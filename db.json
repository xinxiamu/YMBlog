{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon-1.ico","path":"favicon-1.ico","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"source/about/index/a.png","path":"about/index/a.png","modified":1,"renderable":0},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1560695914099},{"_id":"themes/BlueLake/README.en.md","hash":"6cc6e346635bf26dd71030b9c3c6443507cd4108","modified":1560695914100},{"_id":"themes/BlueLake/README.md","hash":"66c3ef7a779b6d65bad90daa2e03bcb7a1bb742f","modified":1560695914100},{"_id":"themes/BlueLake/_config.yml","hash":"470122c6ca9081ed0b5fd5be821f477491b38aa3","modified":1566702647943},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1560695914117},{"_id":"source/about/index.md","hash":"57df7860368f7ef928574c367758944a951c7c4d","modified":1560695914097},{"_id":"source/_posts/Keepalived-LVS-Nginx.md","hash":"58e4f6a4616d9762e74834dfb7ead98430cff2ae","modified":1560695913313},{"_id":"source/_posts/angular-component-interaction.md","hash":"f0ffc02d7c1c8fe622527c86dd56215f80effdd8","modified":1590838103357},{"_id":"source/_posts/angular-cli-command.md","hash":"dc3a2d4dd4a6dbd259a0079faf241bfecb5fe720","modified":1573354321656},{"_id":"source/_posts/angular-environment.md","hash":"80d499065e25f83cc7044212a03176620c73a2da","modified":1590838103357},{"_id":"source/_posts/angular-issue-collect.md","hash":"236cdbb67dc8cb0917be58f327afeb110585e8c6","modified":1590838103358},{"_id":"source/_posts/angular-router.md","hash":"41a110a489cc61d16dba6a05425b46293b278dfa","modified":1573387362805},{"_id":"source/_posts/angular-start-quick.md","hash":"e31c4a098e2954079f454f81a3705ee301f7665a","modified":1573353415862},{"_id":"source/_posts/angular-start.md","hash":"01f7bb775d9a062b7697f2154c4051f5628dfc79","modified":1573885176236},{"_id":"source/_posts/api-version.md","hash":"baf5901cede3dd8b1eb7b0d1358a4251b04a1a58","modified":1560695913315},{"_id":"source/_posts/apidoc-java.md","hash":"3275ea6be4e1be2434129de9ca159bca92af2ea2","modified":1560695913320},{"_id":"source/_posts/aws-server.md","hash":"e8d810674fede4573beb3431c22c2648e0cd8202","modified":1560695913322},{"_id":"source/_posts/blockchain-hash.md","hash":"e1531180b5ff30d39cecf59ac479decd9034a690","modified":1560695913323},{"_id":"source/_posts/blockchain-paxos.md","hash":"27ea113f23cb10b74deb9ecec0f5a54975001155","modified":1560695913323},{"_id":"source/_posts/centos-jdk8-install.md","hash":"e563c23d5ba2f32d0bb949a240afeb64ca0bf080","modified":1560695913324},{"_id":"source/_posts/centos-login-without-pwd.md","hash":"b75428d5c95beef4080f39cedc29cc9b136b76c5","modified":1560695913324},{"_id":"source/_posts/centos-maven-nexus.md","hash":"e5ad5ecee061e95faf3a8747f11adeb37b901eb5","modified":1560695913324},{"_id":"source/_posts/centos-mysql-install.md","hash":"e312419eab275f84d8b241768923a5960ff7cbb1","modified":1560695913336},{"_id":"source/_posts/centos6-kernel-update.md","hash":"f4516c15b2cd54587a0898bbe56f86ff7d8395d3","modified":1560695913336},{"_id":"source/_posts/concourse-tutorial.md","hash":"dccc7d12ac1d94b39da2b9624228fbd24d0b5cb7","modified":1560695913337},{"_id":"source/_posts/cron-grammar.md","hash":"43df2e7a675be94786f7de770cd26ab474161a2d","modified":1573396070788},{"_id":"source/_posts/distributed-difficulty.md","hash":"94f3141fa01fb1e10f2deface91ea0f4c11f39c4","modified":1560695913338},{"_id":"source/_posts/distributed-id-snowflake.md","hash":"bc0fcf9cb5d5cb67f40e8ddb36ba83e1fcdffbae","modified":1560695913338},{"_id":"source/_posts/distributed-lock.md","hash":"8fb96262a30385c378f8920f598e62a8bd7912d3","modified":1566742586145},{"_id":"source/_posts/docker-app-install.md","hash":"5dda2ec69687b11194925e72b2b78665bac3f5a5","modified":1590838103358},{"_id":"source/_posts/docker-commond-collect.md","hash":"cb283ac003d80e33a434fd4976c3e8bf69d2539f","modified":1573396070789},{"_id":"source/_posts/docker-compose-command.md","hash":"98fed868e4fdb128b743194617dc2b8281705c9a","modified":1568305104844},{"_id":"source/_posts/docker-compose-template-command.md","hash":"8557a5d3459239c6c011c96e760bc8a2e8f077bf","modified":1569113787039},{"_id":"source/_posts/docker-container-add-port.md","hash":"833423cc6c3896f1c5a39714bc0662f3b44c42c9","modified":1560695913341},{"_id":"source/_posts/docker-erro-show.md","hash":"ccb2037e1467db59013555527385c9853659f0d1","modified":1560695913341},{"_id":"source/_posts/docker-install-centos6.md","hash":"9117a2666c05e197c70649412f5e95bf06cc9c48","modified":1560695913342},{"_id":"source/_posts/docker-install-centos7.md","hash":"ce0fc41db9ddf244104c1a9cb0a5818079a9c854","modified":1560695913342},{"_id":"source/_posts/docker-install-ubuntu16.md","hash":"51965be6399f656a93d94deb32551cf104d87815","modified":1560695913344},{"_id":"source/_posts/docker-lesson2.md","hash":"bbdae0019ef38d8455906853c2c17e63259cca91","modified":1560695913346},{"_id":"source/_posts/docker-lesson1.md","hash":"ba3453f67da1ad1df6264a68994b22e87886a85d","modified":1560695913346},{"_id":"source/_posts/docker-lesson3-images.md","hash":"6adebaf17a333e18fe6beca712a31010d3d4da17","modified":1561197810041},{"_id":"source/_posts/docker-lesson5-dv.md","hash":"5b27da0ee0881679383d5a734284bf1dfec73c0e","modified":1560695913351},{"_id":"source/_posts/docker-lesson4-container.md","hash":"57a6f492d6033f67e189c1057602949e7f552a7c","modified":1560695913350},{"_id":"source/_posts/docker-lesson6-net.md","hash":"caafe0942b9f182e9df3fffe348b99e81026296f","modified":1560695913351},{"_id":"source/_posts/docker-lesson7-compose.md","hash":"b2df63179d9eb56b86937cbfe443016c8fb30959","modified":1568305104852},{"_id":"source/_posts/docker-maven-nexus.md","hash":"3b760c9786a148e033b6dac595f6951a15e0d58f","modified":1560695913352},{"_id":"source/_posts/docker-register-nexus.md","hash":"e4c51ed5d86b1fa6f13e9a761fb0b1d80f495491","modified":1573396070790},{"_id":"source/_posts/esign-bao-copy.md","hash":"bf5eb3df9f51792e7f7aef386d217d7e5caf503a","modified":1560695913357},{"_id":"source/_posts/fastdfs-start.md","hash":"9db02c276be1214a8f37f5d99ce1246a4682e979","modified":1560695913358},{"_id":"source/_posts/fescar-start.md","hash":"26583e75f2b779633a2047288db8c1ca6a83e45a","modified":1560695913358},{"_id":"source/_posts/flutter-start.md","hash":"17541569384c47ab7c2b40f57d269c052bb72b88","modified":1560695913358},{"_id":"source/_posts/ftp-start.md","hash":"2bab5105de83678be079c7d766ae4368c7914d04","modified":1560695913359},{"_id":"source/_posts/git-branch.md","hash":"cee20d6a9d7a3e3fd098a35b2781796896d29c1c","modified":1560695913360},{"_id":"source/_posts/git-install-in-centos7.md","hash":"1508866cc2ba5b3b3c41bf6d78169252e3576577","modified":1560695913360},{"_id":"source/_posts/git-server-build.md","hash":"60a8320bca9568edd56fee8fb299ae1a44556ad9","modified":1560695913360},{"_id":"source/_posts/git-tag.md","hash":"148c058d5ef94fa1f7a83d3273e659fa0356e1df","modified":1560695913361},{"_id":"source/_posts/git-use.md","hash":"9c39ba2a04168e4cd1d1b4f3cd601696e5ea6133","modified":1590838103359},{"_id":"source/_posts/github-fork-repo-update.md","hash":"307a47abe89bac62b0ce2b6347832481049898ad","modified":1560695913362},{"_id":"source/_posts/github-mnv-jar.md","hash":"20372f5a2db7a4de933cab3a84d084b2c7558c87","modified":1560695913363},{"_id":"source/_posts/gitlab-start.md","hash":"86e9f54002bd59763de742db29671d2b3d09f4f2","modified":1564848741307},{"_id":"source/_posts/glusterfs-start-install.md","hash":"9dd420b4f12e99a2cde4f6d547ff5ef3f29f7a5d","modified":1560695913365},{"_id":"source/_posts/hashicorp-vault.md","hash":"9174738ccc5a18381ed89e0e775168e2622f0ae9","modified":1560695913365},{"_id":"source/_posts/hibernate-relation-mapping.md","hash":"f5afc163cf2e5269217320c41d43eda3c4e9a836","modified":1560695913367},{"_id":"source/_posts/http-protocol-overview.md","hash":"a6c6882fb2c1ab271401a482fc3b6177b3552888","modified":1560695913367},{"_id":"source/_posts/idea-XRebel.md","hash":"76b9127411ff62c6d8df099c830f63439f596000","modified":1590838103359},{"_id":"source/_posts/idea-file-template.md","hash":"ada409768c61f39579fc4516e6a9c300a59754ad","modified":1590838103360},{"_id":"source/_posts/idea-good-plug.md","hash":"69fc0b83474cfc507958f30c0017bdc9a9c3e72a","modified":1590838103361},{"_id":"source/_posts/idea-use-ofen.md","hash":"4b9f7c8d0e9838b932166bbd1361e22d9c0a7216","modified":1590838103361},{"_id":"source/_posts/istio-start.md","hash":"4f8fde313d1df050bbbf530f4f9908b05e2517da","modified":1560695913380},{"_id":"source/_posts/jackson-show-time.md","hash":"f83b7c2899b17d623137555968f6ec3f017f4bf6","modified":1560695913381},{"_id":"source/_posts/java-bit.md","hash":"0491687a22a3902239ae71cec82fb7d386db2d36","modified":1560695913381},{"_id":"source/_posts/java-charset.md","hash":"d86b62b9edd3181381837f52ae9352886495b867","modified":1560695913382},{"_id":"source/_posts/java-checkstyle.md","hash":"0dc7fad0f1f06f8de06e509a19444e1746420d25","modified":1560695913382},{"_id":"source/_posts/java-code-optimization.md","hash":"820cefb44f0cb419899ec284d6374ee9aa9a15dc","modified":1569113786574},{"_id":"source/_posts/java-core-io-buffered.md","hash":"82c859951ae68491f5e72cefac5a44f514869428","modified":1573885176236},{"_id":"source/_posts/java-core-io-byte-stream.md","hash":"0f0070fbf1f0565192e03552bf79d6d994b1fac9","modified":1590838103362},{"_id":"source/_posts/java-core-io-data-stream6.md","hash":"f322c495f8032496bb3ebd42647ffb43693ed965","modified":1590838103363},{"_id":"source/_posts/java-core-io-character-stream.md","hash":"b4295a38a2901bfb00bee45fd4511811534943a4","modified":1590838103362},{"_id":"source/_posts/java-core-io-scanner.md","hash":"d6710012d4aca9ae98cd402fce929d6c2ab07179","modified":1590838103363},{"_id":"source/_posts/java-core-io-start.md","hash":"cc01fd1c4237386c584ebff2c25f5474152137c5","modified":1590838103364},{"_id":"source/_posts/java-core-io-system.md","hash":"e7b66161eb04dd54fb0eab8a453c423e136c7288","modified":1590851713154},{"_id":"source/_posts/java-core-nio-buffer.md","hash":"13ccbacda7d19fc53be18ea94659059e9458544b","modified":1590838103365},{"_id":"source/_posts/java-core-often.md","hash":"1bcbbd577fd616c0ee3942697224eda12ae90ee5","modified":1573396070805},{"_id":"source/_posts/javase-cglib.md","hash":"36d206936281ba5365b47510244c489d200cc0c5","modified":1560695913385},{"_id":"source/_posts/javapoet-apt-annotation.md","hash":"80c183d82fbde10d5fe08a194f7ff272ae13a8d0","modified":1560695913383},{"_id":"source/_posts/jenkins-java-maven.md","hash":"3b3ce34a5c474d85bb16af47c13499bc20f57ea3","modified":1560695913386},{"_id":"source/_posts/jvm-gc.md","hash":"50d8908e1924d2d9699d0c5eeefae4005f5d1d12","modified":1560695913405},{"_id":"source/_posts/jvm-look-tools.md","hash":"f3cf120a60f85ecabb87410bb7957965c8c56c52","modified":1560695913406},{"_id":"source/_posts/jwt-study.md","hash":"7906251037530b9ad6deb9f5b0885b19f47f7286","modified":1560695913406},{"_id":"source/_posts/k8s-start.md","hash":"407816e36d590bd127a37a218b04f6623e8873e3","modified":1560695913408},{"_id":"source/_posts/linux-centos-command.md","hash":"a849f2062223a098cc9e5814795441f04f6c4d59","modified":1569116637581},{"_id":"source/_posts/linux-command-use.md","hash":"b63007d8b4771e88e2a13907d809caffce2b4fef","modified":1560695913408},{"_id":"source/_posts/linux-ubuntu-commom.md","hash":"a739cb134211484543262d3159b1a70e299fc3d2","modified":1560695913410},{"_id":"source/_posts/linux-ubuntu-navicat.md","hash":"dc556823af05811bad81068a612966f9420efa0d","modified":1560695913411},{"_id":"source/_posts/maven-nexus-jar.md","hash":"16e54ecabc5ecc1f84e0124da113ecc7524f9ff4","modified":1560695913411},{"_id":"source/_posts/maven-ofen.md","hash":"20510460ae1cfa1735c97bf09ae1ef606250fc2f","modified":1560695913417},{"_id":"source/_posts/maven-pwd-encryption.md","hash":"088a53fc4937d9eec8246d6b384122ab39c33e33","modified":1560695913420},{"_id":"source/_posts/maven-use-error-collect.md","hash":"1dc0e66221ae0ba38361831e83600b3817c0a88e","modified":1560695913420},{"_id":"source/_posts/metrics-influxdata-grafana.md","hash":"9891b922fe0c55447f7cb9d1dc1b161214165ca0","modified":1560695913421},{"_id":"source/_posts/metrics-start.md","hash":"efc7dbbc1e0cb02d8db71d0e67d28e8f9a9f13ce","modified":1560695913421},{"_id":"source/_posts/microservice-think.md","hash":"857847b7b3953ddea45418c6383d2dc095b104fd","modified":1560695913422},{"_id":"source/_posts/mysql-copy-delay.md","hash":"8f4c8fe200d81c8ae8452b735b1b4c6846de2fb3","modified":1590838103365},{"_id":"source/_posts/mysql-copy.md","hash":"7c86388f71f74ac589ee2494fbdbe64de1f2f0de","modified":1560695913423},{"_id":"source/_posts/mysql-create.md","hash":"5699b0784010a2265148fc5e058bd9a0d6f7122c","modified":1560695913426},{"_id":"source/_posts/mysql-explain.md","hash":"d1c9629c03331300a29fd1aa0a4555d37f83fd0b","modified":1560695913426},{"_id":"source/_posts/mysql-practice.md","hash":"994339c08fd4603bc3440ddee178228eb9362ff6","modified":1590838103366},{"_id":"source/_posts/nginx-study.md","hash":"def94d014d3cada2a7afd971291e9c72d52699b2","modified":1560695913427},{"_id":"source/_posts/nginx-use-issue.md","hash":"5eee6e008d42001df8550fa98d87460798c34d8c","modified":1560695913428},{"_id":"source/_posts/ngrok-start.md","hash":"b0b59ff1dc970a66387265152e4a3366eca91543","modified":1560695913428},{"_id":"source/_posts/npm-use.md","hash":"bee6dbc4bd7594333301be6f3e78a786ca6a9820","modified":1560695913428},{"_id":"source/_posts/pivotal-web-service-start.md","hash":"b49bff609df5b2995516d5a81048282229f84d96","modified":1560695913429},{"_id":"source/_posts/pulsar-start.md","hash":"a34b5ef73a0f38757fb6c99f3d66e0b210bbe675","modified":1569113787040},{"_id":"source/_posts/rabbitmq-action.md","hash":"c96a3c2968aee4c595eab543668ac91ef35429fe","modified":1590838103367},{"_id":"source/_posts/rabbitmq-basic.md","hash":"58f88a2439b7b3361e983a408688f106916ff3e4","modified":1590838103367},{"_id":"source/_posts/rabbitmq-exchange.md","hash":"77a6c91d65f532e58c2fa647a2b74996d8ba78a3","modified":1590838103373},{"_id":"source/_posts/rabbitmq-install.md","hash":"0bb2cc78f0e37d3601ed9937fdd369e6d1777cbc","modified":1560695913436},{"_id":"source/_posts/rabbitmq-messages.md","hash":"f81c480709bb954466a7202fb19cd9f6253e1948","modified":1590838103376},{"_id":"source/_posts/redis-common.md","hash":"d7b10e651f5f4f7b6e5ac5425a54be3238d83fea","modified":1560695913438},{"_id":"source/_posts/redis-cluster-centos.md","hash":"8b4ccbb05fdf6d26f62aea1e574cfd951c401d72","modified":1560695913437},{"_id":"source/_posts/redis-distributed-lock.md","hash":"932fcec3a16bbf8bf24662d0555cf57810323824","modified":1560695913439},{"_id":"source/_posts/redis-conf.md","hash":"db4b21dc750f90f6ba3a1577492726ffc7e6a193","modified":1560695913439},{"_id":"source/_posts/redis-install.md","hash":"353cea7d9f2daa0a3f1d9b90fc83f4abb0bd9514","modified":1560695913440},{"_id":"source/_posts/redis-pub-sub.md","hash":"e94d9a58e89f4eb45828e9416a6311f52b6aa395","modified":1560695913440},{"_id":"source/_posts/redis-sentinel.md","hash":"4831e2355b3badf79e10b83934482b4568265e5c","modified":1560695913440},{"_id":"source/_posts/redmine-mongrel-nginx.md","hash":"5e0d19373bf084132ae4c44b415cf32cd9ed8146","modified":1560695913441},{"_id":"source/_posts/redmine-plugins.md","hash":"5faf7c4f88cad64b99f1fff536a12e8b0892a5d6","modified":1560695913441},{"_id":"source/_posts/redmine-start.md","hash":"e30c722953c0282d92fb66935b11e365d730a03a","modified":1560695913444},{"_id":"source/_posts/redmine-use-record.md","hash":"74a17d349de14dc3ce3d47210ca9a8e6a4e317c2","modified":1560695913448},{"_id":"source/_posts/restful-api-dev.md","hash":"2801e8a7e037d0b3992adc795ca8b1b11fcb8b21","modified":1560695913449},{"_id":"source/_posts/rocketmq-start.md","hash":"d1bcd1a37c4121a0f6972ed815e21439bf1cb32e","modified":1560695913450},{"_id":"source/_posts/sboot-change-contextpath.md","hash":"6c9153ebaac81b554dd7086f80b744e5e022438d","modified":1560695913450},{"_id":"source/_posts/scloud-config-server-encrypt-decrypt.md","hash":"64fe1338b6e5e4d58d9fa81349c3ca8101020acc","modified":1560695913452},{"_id":"source/_posts/scloud-elk.md","hash":"903de15bed6e86d277bf3066ee36de19c66624a3","modified":1567907249841},{"_id":"source/_posts/scloud-feign-anyquestion.md","hash":"97cccd89fe7a037ac6d9a680492371cf25ea4323","modified":1560695913452},{"_id":"source/_posts/scloud-feign-config.md","hash":"aafb8ae5facfd7154face2197fa7242646fd2b2c","modified":1560695913454},{"_id":"source/_posts/scloud-hystrix-dashboard.md","hash":"50bb75b4018555ea3c2d155f51ea8837e1eaabc9","modified":1560695913454},{"_id":"source/_posts/scloud-hystrix.md","hash":"b93a44ca9970fd7d3abc8a562979bdad31c3504f","modified":1560695913454},{"_id":"source/_posts/scloud-issu-record.md","hash":"f15112974d7c88a813f24ceb3f5ac2dd9c1fff44","modified":1590838103379},{"_id":"source/_posts/scloud-zuul-exception.md","hash":"338d5bdac28f1b324b0fbb4e60ccfd9861bf8f49","modified":1560695913458},{"_id":"source/_posts/scloud-properties-refresh.md","hash":"259ffb4b8c58d0e84ba0cc4a3725dd670ce2e36b","modified":1560695913455},{"_id":"source/_posts/scloud-zuul-filters.md","hash":"519299e5a981ecdfaa17930051f0511d7025165f","modified":1560695913459},{"_id":"source/_posts/scloud-zuul-start.md","hash":"b5c62dc5de4f85a221caffef1c258d4e996755c4","modified":1560695913461},{"_id":"source/_posts/session-start.md","hash":"031930013728b00121a40ea746f3465551162ef6","modified":1560695913463},{"_id":"source/_posts/shadowsocks-go.md","hash":"04ce2041e2142ba57879b38b5b6482e3d4ffceda","modified":1564848741317},{"_id":"source/_posts/shiro-jwt.md","hash":"b8fe504012d80b1c9daee5de813661c5f3df4e4b","modified":1560695913964},{"_id":"source/_posts/shiro-start.md","hash":"e945e47ab3947e0f241ffebfba81473607381dfd","modified":1560695913965},{"_id":"source/_posts/spinnaker-start.md","hash":"3d7bbeba71eb3f99a5bf1bc24ad601b6cf80572b","modified":1560695913969},{"_id":"source/_posts/spring-boot-async.md","hash":"66637910cd5cc592a1bf0eebdc649d486aa2dd06","modified":1560695913970},{"_id":"source/_posts/spring-boot-cache.md","hash":"fa2a229e3e0e238373a4fb0e056761f654d96782","modified":1560695913970},{"_id":"source/_posts/spring-boot-cors.md","hash":"ee83eea66c28a323f2979cec00340dba10e88297","modified":1560695913970},{"_id":"source/_posts/spring-boot-dataway.md","hash":"08aeeebdf56100d22912fdc078e172a795948e75","modified":1590854397865},{"_id":"source/_posts/spring-boot-dev-error-show.md","hash":"c569b57058b450e963caf3eb26ac1f34c83247d0","modified":1560695913971},{"_id":"source/_posts/spring-boot-docker.md","hash":"6d4ef32fe3c4fb20e9cdf85721aa533d96f89eb2","modified":1560695913972},{"_id":"source/_posts/spring-boot-exception.md","hash":"01f5938389e94015ae00d483cc8b2d148aac0342","modified":1560695913973},{"_id":"source/_posts/spring-boot-filter.md","hash":"d2e76899ae13f0f8ed636553e26e7b6ad8cd3a65","modified":1560695913973},{"_id":"source/_posts/spring-boot-jar.md","hash":"ae0aa90ffdcb158055a351e203fd639dd8f83c88","modified":1560695913975},{"_id":"source/_posts/spring-boot-messages.md","hash":"6fb63bd705e0a19c30802a8cce594aef87304e7b","modified":1560695913976},{"_id":"source/_posts/spring-boot-record.md","hash":"b4a48c1b3bf689064201e86d39573757541a1506","modified":1573396070806},{"_id":"source/_posts/spring-jpa-multiple-datasource.md","hash":"bb6d61d0d3af82505a37fa2a08141847b34dd17d","modified":1560695913977},{"_id":"source/_posts/teamcity-use-start.md","hash":"78c25c1da41ec9d3087a036ef3204447f768fb32","modified":1560695913977},{"_id":"source/_posts/tslang-study-one.md","hash":"b81c8d6bdde2067462944f49647bbd6e00246e5d","modified":1560695913978},{"_id":"source/_posts/vagrant-Xshell.md","hash":"31eddd1a06bfb324b328b46755505c20994c47ef","modified":1560695913978},{"_id":"source/_posts/vagrant-cli.md","hash":"9ba68c8f7b3c4fdf11ec8cd9ba85ca3c2b6b7139","modified":1560695913982},{"_id":"source/_posts/vagrant-start.md","hash":"63035120d10c77580e6d1f622888fae3a155de3e","modified":1560787588279},{"_id":"source/_posts/vagrant-vagrantfile.md","hash":"a1cdcbbffdc2f2f2309320af3818b525a33c9f32","modified":1560695913989},{"_id":"source/_posts/vault-study.md","hash":"98bf7f67c4b8a0aa0619a0348dee3c9025603dc2","modified":1560695913989},{"_id":"source/_posts/website-high-performance.md","hash":"f94d8e78434734bcf3e8e270cae6af3b74fe5bc1","modified":1560695913990},{"_id":"source/_posts/wkhtmltopdf.md","hash":"aa076b74de0e096db9fb565e369a53d12a6b77a0","modified":1560695913991},{"_id":"source/_posts/zookeeper-curator.md","hash":"8ec9e2f31247ee2be67bf80a7c07014088270780","modified":1560695914096},{"_id":"source/_posts/zookeeper-start.md","hash":"c4576fbc6aadefc40390e2accb3ab135fd58620a","modified":1560695914097},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"a127deb32d1df69bbe50a3824a5f90472513c9c3","modified":1560695914101},{"_id":"themes/BlueLake/languages/en.yml","hash":"95bac2c366505d016b5defc47370679b9f5f3c4b","modified":1560695914102},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"baa68725feeec6643f875a532a9d55ba8aacdb2c","modified":1560695914102},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"bd97d5e4b39d30da1644b90256dfc4e6b1d76988","modified":1560695914102},{"_id":"themes/BlueLake/languages/ko.yml","hash":"fc8826724f570136d9a2d3ec2705b7b7000e0f14","modified":1560695914103},{"_id":"themes/BlueLake/languages/tr.yml","hash":"5f13d55fdd5bdd1115075736e3e26a1ea1dd1dea","modified":1560695914103},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1560695914104},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"d4d587ba81864910715c0c3879605cc6a9362e09","modified":1560695914104},{"_id":"themes/BlueLake/layout/base.jade","hash":"fcf7557c37fca5836bd3a486e394e4603bf28bf5","modified":1590857186067},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1560695914115},{"_id":"themes/BlueLake/layout/index.jade","hash":"dd81d9f7a6b388de2ab731b17b3ba55f70df4a5f","modified":1560695914115},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1560695914114},{"_id":"themes/BlueLake/layout/post.jade","hash":"0305258c33e4d02f977ee1aaf7f2429b993fda17","modified":1560695914116},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1560695914115},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1560695914116},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1560695914118},{"_id":"themes/BlueLake/source/favicon-1.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1560695914119},{"_id":"themes/BlueLake/source/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1560695914120},{"_id":"source/about/index/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695914098},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","hash":"e91f2139090c702ae554fa2a62f492bc2e175941","modified":1560695913315},{"_id":"source/_posts/api-version/a.png","hash":"a20c7a7f6a7ff592a425625fc54d16f438c55e4e","modified":1560695913317},{"_id":"source/_posts/api-version/b.png","hash":"8571a75e4e87d975781b9e3ee105e89684b0e207","modified":1560695913317},{"_id":"source/_posts/api-version/c.png","hash":"c82a2265f368c807f4c215c1a77db2cb3d755013","modified":1560695913318},{"_id":"source/_posts/api-version/e.png","hash":"bb846b7dea9e424afad7c3bf245416f03f2407f6","modified":1560695913319},{"_id":"source/_posts/api-version/d.png","hash":"1e3b87d4365ce11477d699a2af6ce5522c07950e","modified":1560695913319},{"_id":"source/_posts/apidoc-java/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913321},{"_id":"source/_posts/architect-awesome.md","hash":"25b214b72f18894fa2397fff0b2b600936f64941","modified":1560695913322},{"_id":"source/_posts/centos-maven-nexus/a.png","hash":"5ae80ce14b4f22a0c5f4d79e1189800e1d98d85d","modified":1560695913325},{"_id":"source/_posts/distributed-id-snowflake/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913339},{"_id":"source/_posts/docker-app-install/redis.conf","hash":"b60c83be43af835f0db3b2a5596b9465f1eca7a6","modified":1564848741306},{"_id":"source/_posts/docker-install-centos7/a.png","hash":"53319885ee2b62298a8dd0bbf97e66e075d63c33","modified":1560695913343},{"_id":"source/_posts/docker-install-ubuntu16/a.png","hash":"c0c863a0be8921034af76f51a76c0d908735ed9d","modified":1560695913345},{"_id":"source/_posts/docker-lesson3-images/a.png","hash":"127496e0d28b06a73bc5a0947c0cfc91dfb35bcd","modified":1560695913347},{"_id":"source/_posts/docker-lesson3-images/b-1.png","hash":"dc7d88028c907468e4c0e3de1d4b8e0cf9eaa155","modified":1561197810042},{"_id":"source/_posts/docker-lesson3-images/b-2.png","hash":"1eeaee9651426d9f7f524d7ac3568ef9cc14152b","modified":1561197810043},{"_id":"source/_posts/docker-lesson3-images/b.png","hash":"b8e0f05db2ca87f59e5b3b4360639abf6d595768","modified":1560695913348},{"_id":"source/_posts/docker-lesson3-images/yy.png","hash":"45afb92a7893aa9b8b1ae07254eb253d5c008957","modified":1560695913350},{"_id":"source/_posts/docker-maven-nexus/a-1.png","hash":"30009c15b2a0ea884f886c0dfbb541f6ee13a482","modified":1560695913353},{"_id":"source/_posts/docker-register-nexus/a-1.png","hash":"8c6ef1fc714fb25650178a92fb1fca1b64c484b8","modified":1560695913355},{"_id":"source/_posts/docker-register-nexus/a-3.png","hash":"f37ceb7da9aedcc920789a95779da42363a6e1ef","modified":1560695913357},{"_id":"source/_posts/docker-register-nexus/j-1.png","hash":"d2e73b4e1e22b538295678656ebc91bc29ed1b22","modified":1573396070791},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1560695913362},{"_id":"source/_posts/gitlab-start/a-1.png","hash":"91e89abce57f1afcf41167519a2786ecb798b35a","modified":1560695913364},{"_id":"source/_posts/hashicorp-vault/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913366},{"_id":"source/_posts/http-protocol-overview/a.png","hash":"cdc1232c447bc61a7c3df4fd8ecf4c7947b7c739","modified":1560695913369},{"_id":"source/_posts/http-protocol-overview/b.png","hash":"d2158e4cc7c3129a86163fc087f3fdc70cc3f570","modified":1560695913369},{"_id":"source/_posts/idea-file-template/d.png","hash":"297c07f9361f15c4a75c2b0ff2d6f8ea35b76827","modified":1560695913375},{"_id":"source/_posts/idea-file-template/j.png","hash":"81739226bb3fe7555e03210d8fe15790ba896376","modified":1560695913380},{"_id":"source/_posts/idea-good-plug/c-1.png","hash":"eb62bb867d4db4c2a9a965f9921d036eecebb093","modified":1564848741308},{"_id":"source/_posts/idea-good-plug/c-2.png","hash":"5545433c0fc1058d2fa220cf7f291f051dbf362a","modified":1564848741309},{"_id":"source/_posts/idea-good-plug/c-3.png","hash":"bcbb6e60c9d82647cf48a64ba5911eefdfbadc25","modified":1564848741317},{"_id":"source/_posts/java-core-io-buffered/a-1.png","hash":"bd48946896163e00e65f45c4e43a923898f19369","modified":1573396070793},{"_id":"source/_posts/java-core-io-byte-stream/b-1.png","hash":"4a7d8a00988dde36c2c6a5cf119fa493f45a565b","modified":1573396070796},{"_id":"source/_posts/java-core-io-byte-stream/b-2.png","hash":"153580a28d3a3e3c199e3e8e2fdf1fbb810f2437","modified":1573396070796},{"_id":"source/_posts/java-core-io-byte-stream/c-1.png","hash":"451d2d9f9756bd01b29775a0a45789d0faec228c","modified":1573396070797},{"_id":"source/_posts/java-core-io-byte-stream/c-2.png","hash":"6c7e04166a3cdbc96525fe45f44bb75641a7a2a7","modified":1573396070798},{"_id":"source/_posts/java-core-io-start/a-1.png","hash":"9b9211612c0b7efecb5387adc30f561cd1f8c166","modified":1573396070800},{"_id":"source/_posts/java-core-io-start/a-2.png","hash":"c0c87c873716798df350bceff6ec0eb50c44ce32","modified":1573396070801},{"_id":"source/_posts/java-core-io-start/a-3.png","hash":"c3e1a04268d1480f54f316a467e4af093d2815ea","modified":1573396070802},{"_id":"source/_posts/java-core-io-start/b-1.png","hash":"0d5da5e96f5018cbf2297346325d5a98a7e9e946","modified":1573396070803},{"_id":"source/_posts/java-core-io-start/b-2.png","hash":"697f8b731c4e52e44eaa29729cf05ba1a06257eb","modified":1573396070804},{"_id":"source/_posts/javapoet-apt-annotation/a.png","hash":"7a3629a2c00c64293346769a80fd3f2b4882eb33","modified":1560695913384},{"_id":"source/_posts/javapoet-apt-annotation/b.png","hash":"1f0698b9282cca313661656e1bfd9263f3d09bac","modified":1560695913384},{"_id":"source/_posts/jenkins-java-maven/1.png","hash":"c89c3f8f039bb7e3c7b1c8ba19aa421ae5857aba","modified":1560695913387},{"_id":"source/_posts/jenkins-java-maven/11.png","hash":"3d4d301aeb6a173b5681f47dbdefde4f3d91fc38","modified":1560695913389},{"_id":"source/_posts/jenkins-java-maven/13.png","hash":"17b95987316f24f5a4aaa69703b05fbfb52b3872","modified":1560695913390},{"_id":"source/_posts/jenkins-java-maven/14.png","hash":"5eb1accc639b0941b54e6e1c2ec81bcd4133b873","modified":1560695913391},{"_id":"source/_posts/jenkins-java-maven/15.png","hash":"9bdbf1d30b1e1f50df5148d71c69f78a584b522a","modified":1560695913392},{"_id":"source/_posts/jenkins-java-maven/4.png","hash":"7476872c0a08be7fbeda0ae5a52ebde940cfc0f6","modified":1560695913395},{"_id":"source/_posts/jenkins-java-maven/5.png","hash":"64a8107a2748e6ac2fe9d1a42287b53a7dafd314","modified":1560695913395},{"_id":"source/_posts/jenkins-java-maven/6.png","hash":"00ff2355e8986eb0014b5894230b6fd79462eeeb","modified":1560695913396},{"_id":"source/_posts/jenkins-java-maven/7.png","hash":"e16f5020b6038b856ea2a01301f03f305e5a5399","modified":1560695913397},{"_id":"source/_posts/jenkins-java-maven/8.png","hash":"08b0b19249e2c677b6fc774655b586cbd8be8664","modified":1560695913397},{"_id":"source/_posts/jenkins-java-maven/8_1.png","hash":"3b6647cdf713816d9f60deced0a25f59a55798e5","modified":1560695913398},{"_id":"source/_posts/jenkins-java-maven/9.png","hash":"dc3d500c3de6fc1c7c0d17c05628042f244c264b","modified":1560695913398},{"_id":"source/_posts/jenkins-java-maven/b.png","hash":"4dd65c11f708e2e1feaf1c84b2f2a97c6baffb58","modified":1560695913400},{"_id":"source/_posts/jenkins-java-maven/e.png","hash":"038c511df2eaaf6a578ed59860a4fba5f99c560f","modified":1560695913402},{"_id":"source/_posts/jenkins-java-maven/f.png","hash":"bcdfa5c4be7b749d533d2f78aeba07576a33e010","modified":1560695913402},{"_id":"source/_posts/jenkins-java-maven/g.png","hash":"e8b5ab0bc4de16515059f0d854fca3455713aa40","modified":1560695913403},{"_id":"source/_posts/jwt-study/a-1.png","hash":"50b2574c98af103a884fd3f86d8ad31550952f60","modified":1560695913407},{"_id":"source/_posts/linux-command-use/a.png","hash":"dc9aa307fe9221d90f71dfa95841ea3acbab18cc","modified":1560695913409},{"_id":"source/_posts/linux-command-use/b.png","hash":"12fb8951ab9e7361d775a1b0ceb7546cfae5c7fe","modified":1560695913410},{"_id":"source/_posts/maven-nexus-jar/a-2.png","hash":"abd98d169875c8d719ddb29fceb442ddadb37dbd","modified":1560695913413},{"_id":"source/_posts/maven-nexus-jar/a-3.png","hash":"39028cf01f0942993a3b0489841106cf32ea18b1","modified":1560695913414},{"_id":"source/_posts/maven-nexus-jar/a-4.png","hash":"86499d28d09608d86fe45c90fd7dd720176bb0cb","modified":1560695913415},{"_id":"source/_posts/maven-nexus-jar/a-5.png","hash":"b296f511647a938cdccadfb673a3232392e88a7e","modified":1560695913415},{"_id":"source/_posts/maven-nexus-jar/a-6.png","hash":"a4e8321deaeda8a4e388c357a85b494295fd61cf","modified":1560695913416},{"_id":"source/_posts/maven-ofen/a-1.png","hash":"a269042283286715c55e0d76f51abf2574542a72","modified":1560695913418},{"_id":"source/_posts/maven-ofen/a.jpg","hash":"636125fa0cc1f01d7f341619c5822cdc1b420bb2","modified":1560695913418},{"_id":"source/_posts/microservice-think/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913423},{"_id":"source/_posts/mysql-copy/a-2.png","hash":"d573689f35e311e958e516046e02809ed37a96ff","modified":1560695913425},{"_id":"source/_posts/mysql-copy/a-3.png","hash":"853cb8871e6c93fa66149a05cef598bcfc09dab8","modified":1560695913426},{"_id":"source/_posts/pivotal-web-service-start/d.png","hash":"70fedd27e98b3d0b83af6ad4f9538a3fc8a83c05","modified":1560695913436},{"_id":"source/_posts/rabbitmq-exchange/a-1.png","hash":"14866c5ca29c97c3aedbced9b3e812a1814d5c96","modified":1590838103374},{"_id":"source/_posts/rabbitmq-exchange/a-2.png","hash":"2551873cba7a41ab7694a6116fd8314eff073ac5","modified":1590838103374},{"_id":"source/_posts/rabbitmq-exchange/a-3.png","hash":"9424c0bc031a966571b0310afef92389f457abfc","modified":1590838103375},{"_id":"source/_posts/rabbitmq-messages/b-1.png","hash":"3b76beca5cbf49042825a7af4ff0fda1efa4fc9a","modified":1590838103376},{"_id":"source/_posts/rabbitmq-messages/b-2.png","hash":"1a6e3f9e83bf6da5ce91e8f0d3d13ce9ca198a94","modified":1590838103377},{"_id":"source/_posts/rabbitmq-messages/b-3.png","hash":"3117712d25f2b2f9b5ea63d0226536782e97407c","modified":1590838103377},{"_id":"source/_posts/rabbitmq-messages/b-4.png","hash":"5ee51b8063c0179fd62acbaa12f5176215961d7d","modified":1590838103378},{"_id":"source/_posts/rabbitmq-messages/b-5.png","hash":"5c3f21db994444c4dbb723ed5ddfcde168c4ccd4","modified":1590838103378},{"_id":"source/_posts/redmine-plugins/a-1.png","hash":"4dd40fad8f6176efc1e8f73eff291c9d90e22c00","modified":1560695913442},{"_id":"source/_posts/redmine-plugins/b-1.png","hash":"079594e74a18609475a9847b50c4e037f7c52732","modified":1560695913444},{"_id":"source/_posts/redmine-start/a.png","hash":"5e5759cf527bda7aacb0972daf9e6a38fce9b3e8","modified":1560695913445},{"_id":"source/_posts/redmine-start/d.png","hash":"5b09d3b1399d1a4c93277ef40179ae51c88323c8","modified":1560695913448},{"_id":"source/_posts/restful-api-dev/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913449},{"_id":"source/_posts/sboot-change-contextpath/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913451},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913453},{"_id":"source/_posts/scloud-properties-refresh/a-1.png","hash":"540d46abe27f52eb16ba6d1da798962c4ca70cfa","modified":1560695913456},{"_id":"source/_posts/scloud-properties-refresh/a-2.png","hash":"4433b46fff403efac49fb668f35fb4d2a054aee9","modified":1560695913457},{"_id":"source/_posts/scloud-properties-refresh/b-1.png","hash":"48ecc70142257ea6c582a597855050e0f52ea8dc","modified":1560695913457},{"_id":"source/_posts/scloud-zuul-exception/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913459},{"_id":"source/_posts/shadowsocks-go/a.png","hash":"85d77fc8a4bcd6f9bb73eaaaed4a69fbc171b1fa","modified":1560695913514},{"_id":"source/_posts/shiro-start/shiro-01.png","hash":"f1b5d1f08ae296adc08858f1e50382963636ea68","modified":1560695913966},{"_id":"source/_posts/shiro-start/shiro-02.png","hash":"05b764effd7132edb13b1780f71870bd1513b56c","modified":1560695913966},{"_id":"source/_posts/shiro-start/shiro-04.png","hash":"8260317b692da93a2d846bf07bcfbfc542749d47","modified":1560695913968},{"_id":"source/_posts/spring-boot-dev-error-show/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913972},{"_id":"source/_posts/spring-boot-filter/a.png","hash":"96b8176f66bf1e15643484e17f2228c42ef6c572","modified":1560695913974},{"_id":"source/_posts/spring-boot-filter/b.png","hash":"07c9a6bba01baf00436ccb1414ba15c0a1ca570c","modified":1560695913975},{"_id":"source/_posts/vagrant-Xshell/a-1.png","hash":"058a5b9eedc81d3786795f17daa7b4dd1154ef10","modified":1560695913980},{"_id":"source/_posts/vagrant-Xshell/a-2.png","hash":"9e569992ffe988850057aebbbde603d9c807e3c9","modified":1560695913980},{"_id":"source/_posts/vagrant-Xshell/a-3.png","hash":"38bfdfd74aaf0c787c8ee0c8a15072e0895e3011","modified":1560695913981},{"_id":"source/_posts/vagrant-Xshell/b-1.png","hash":"1ed72d83fe9207c871f5ccf5014f4cd2278d67ac","modified":1560695913981},{"_id":"source/_posts/vagrant-Xshell/b-2.png","hash":"17930c0a8f61045a1a1981d1021f7ae4e7cc2a10","modified":1560695913982},{"_id":"source/_posts/website-high-performance/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1560695913990},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"0e9d4d6ad530919a29f3d420ea9420c73f980300","modified":1590852787103},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1560695914106},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"d970c81b5cdbd7c0348ee28e93bcbb006d613b6d","modified":1560695914106},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"c1f1955d12aee22a931a3f4ad9d0e9a408e80f3c","modified":1560695914106},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"e0aa5d7adc1218a324a484abe3513e9545f89067","modified":1560695914107},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1560695914108},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1560695914108},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1560695914107},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1560695914108},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1560695914109},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1560695914109},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"ba0839518db2cb9dafee67ca5e471219bfba2e90","modified":1560695914110},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1560695914110},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1560695914110},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1560695914111},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1560695914111},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1560695914112},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1560695914112},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1560695914113},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1560695914112},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1560695914113},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1560695914118},{"_id":"themes/BlueLake/source/css/style.styl","hash":"45776bc176bc8ed0d664e953e23d6a0a9a030929","modified":1560695914119},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1560695914121},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1560695914121},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1560695914122},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1560695914122},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1560695914126},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1560695914126},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1560695914127},{"_id":"source/_posts/angular-start-quick/a-1.png","hash":"20de5923131b0b1df7245017c7e12f01e5ad2baa","modified":1567909055113},{"_id":"source/_posts/centos-maven-nexus/c.png","hash":"0721cae59a5622f3dfcb6259c018f433598ae858","modified":1560695913328},{"_id":"source/_posts/centos-maven-nexus/d.png","hash":"4837ba62f9c498d52f0d516c33555909ff890419","modified":1560695913329},{"_id":"source/_posts/centos-maven-nexus/e.png","hash":"42bf2cfd4787980d2fd0105ad3dd89afc0cf36fb","modified":1560695913330},{"_id":"source/_posts/centos-maven-nexus/f.png","hash":"696a68fdcf708980f808d0e09b604a71b774a37f","modified":1560695913331},{"_id":"source/_posts/centos-maven-nexus/g.png","hash":"c0177448d5f462df7e3d759f29d14c3faf75eb1b","modified":1560695913332},{"_id":"source/_posts/centos-maven-nexus/h.png","hash":"119b973e074ab4069e934112e6daa5557023b704","modified":1560695913333},{"_id":"source/_posts/centos-maven-nexus/i.png","hash":"47e4f15afff60b872071c95fb23eaf5452e6329a","modified":1560695913334},{"_id":"source/_posts/centos-maven-nexus/j.png","hash":"4c3771a7c674c70043a68f478bce1bdb18cb1844","modified":1560695913335},{"_id":"source/_posts/docker-lesson3-images/c.png","hash":"2f3aa0341cfe8ff2c49a8cbca20e5f67a9c4f599","modified":1560695913349},{"_id":"source/_posts/docker-register-nexus/a-2.png","hash":"39d6522484f01a5ff84bee977bd64926666d2d65","modified":1560695913356},{"_id":"source/_posts/idea-file-template/c.png","hash":"510c42e232b3106a1b7628610d617f906887bcd0","modified":1560695913374},{"_id":"source/_posts/idea-file-template/b.png","hash":"4d04d3e6dd87ba18162986e3a96d2c998f00338e","modified":1560695913373},{"_id":"source/_posts/idea-file-template/f.png","hash":"0cf06ae696464acdbf9def1691e2343111879d9a","modified":1560695913378},{"_id":"source/_posts/idea-file-template/e.png","hash":"c2e2b2c5c2e00052157cca5cce8790bd9a867b03","modified":1560695913376},{"_id":"source/_posts/jenkins-java-maven/10.png","hash":"29788dae623aaa45c8b30658d1c56bdab7fb0279","modified":1560695913388},{"_id":"source/_posts/jenkins-java-maven/12.png","hash":"d6626668fc9a71cf602657cd5170b17f6ad8d85e","modified":1560695913390},{"_id":"source/_posts/jenkins-java-maven/2.png","hash":"90cfb0af72732942f35b3455716b6ddd939f636a","modified":1560695913393},{"_id":"source/_posts/jenkins-java-maven/3.png","hash":"6070bc84371a9ef3d9dbfc50767e9c47759815b3","modified":1560695913394},{"_id":"source/_posts/jenkins-java-maven/a.png","hash":"4aedb54123fd8918579a04102486d34a85762a0b","modified":1560695913400},{"_id":"source/_posts/jenkins-java-maven/c.png","hash":"c0c740a0b1e6cd4cad1e8aa96cef96eabac51fcc","modified":1560695913401},{"_id":"source/_posts/jenkins-java-maven/h.png","hash":"c6a10c564bcd131aa20b15cfd5c46411e3a42ceb","modified":1560695913404},{"_id":"source/_posts/jenkins-java-maven/i.png","hash":"1cd3776d2fe4e8a2782c71895bff5254cfb3296b","modified":1560695913405},{"_id":"source/_posts/maven-nexus-jar/a-1.png","hash":"072c2c6ab165da9004d19199b94982b4735df654","modified":1560695913412},{"_id":"source/_posts/maven-ofen/b.jpg","hash":"dabd4b5d5703c961214903633009a9a02ebc758e","modified":1560695913420},{"_id":"source/_posts/mysql-copy/a-1.png","hash":"9d6eaaf54844b0292a395fc0aa988e313a6a63f9","modified":1560695913425},{"_id":"source/_posts/pivotal-web-service-start/a.png","hash":"d6731486aa76a72a980706fda1735e5b7bc05942","modified":1560695913430},{"_id":"source/_posts/rabbitmq-basic/a.png","hash":"597cf0f9e4ac4090bd45121ec9404a6adb1c04ed","modified":1590838103373},{"_id":"source/_posts/redis-cluster-centos/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1560695913438},{"_id":"source/_posts/redmine-plugins/a.png","hash":"4931a50b80f1def71a168e8df2d0caaa16844503","modified":1560695913443},{"_id":"source/_posts/redmine-start/b.png","hash":"2550346d9f3763d8d78fdc753c5323c5189e476b","modified":1560695913446},{"_id":"source/_posts/redmine-start/c.png","hash":"7d5cb64ba37fcdf576e91671ff4afc9efbffe667","modified":1560695913447},{"_id":"source/_posts/scloud-zuul-filters/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1560695913461},{"_id":"source/_posts/scloud-zuul-start/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1560695913462},{"_id":"source/_posts/shadowsocks-go/b.png","hash":"a0dac0425805a400c38eeb20cdd920fb806d4fa0","modified":1560695913514},{"_id":"source/_posts/shiro-start/shiro-03.png","hash":"48c404db45c431da3166c8a2de72909868d27cd8","modified":1560695913967},{"_id":"source/_posts/shiro-start/shiro-05.png","hash":"553c65b1bc8529ff242c39791c8b4b22f4d480f7","modified":1560695913969},{"_id":"source/_posts/vagrant-start/a.png","hash":"c6c5faf834c1b1639632c1eada1ae5914054b0e0","modified":1560695913984},{"_id":"source/_posts/vagrant-start/b.png","hash":"d840feedffece97290c93ce061561d0b42506664","modified":1560695913985},{"_id":"source/_posts/vagrant-start/c.png","hash":"c060bb440446ba2ee026cadf9dc0b936e8d81c29","modified":1560695913986},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1560695914125},{"_id":"source/_posts/centos-maven-nexus/b.png","hash":"b83a6edfb7e719a3f530c544111dcd93914a648b","modified":1560695913327},{"_id":"source/_posts/idea-file-template/a.png","hash":"1031c609ecca3600cab439e781daf45df27702c6","modified":1560695913372},{"_id":"source/_posts/idea-file-template/g.png","hash":"fc51c847dee563fca8425db6147670c8335551c2","modified":1560695913379},{"_id":"source/_posts/java-core-io-byte-stream/a-1.png","hash":"c2d3ba6de67b58e767e7d186166e3e3eaa59e5a5","modified":1573396070795},{"_id":"source/_posts/pivotal-web-service-start/c.png","hash":"222f2f53d4d37628d4d926c5da817e3a76f14458","modified":1560695913435},{"_id":"source/_posts/vagrant-start/d.png","hash":"facf633ba8edaa1c06039fbcee79a96fdd4aa841","modified":1560695913987},{"_id":"source/_posts/vagrant-start/e.png","hash":"af1562c4e634e97f6529a56e9d08873e4145dafd","modified":1560695913988},{"_id":"source/_posts/pivotal-web-service-start/b.png","hash":"2e35d944a620506caa3ab18f337d71c92fd391e0","modified":1560695913433},{"_id":"source/_posts/scloud-elk/kibana1.png","hash":"453c5a291b843f19e9652d9de8aba77ac690a52d","modified":1567907249854},{"_id":"source/_posts/scloud-elk/kibana2.png","hash":"7c598e0fd2aa7f593eafc88a900b1ba1c91a248f","modified":1567907249861},{"_id":"source/_posts/shadowsocks-go/server.tar.gz","hash":"5cc6db5fa8f70dad1c7e3ca4fd95d120357c5ac4","modified":1560695913964},{"_id":"source/_posts/shadowsocks-go/Shadowsocks-4.0.6.zip","hash":"bde73f5175fe3eb5127651e4602f78dbd5a5aed9","modified":1560695913469},{"_id":"source/_posts/shadowsocks-go/client.tar.gz","hash":"96035ed9ab98329f6b95f13f214c8a35ead5987a","modified":1560695913521},{"_id":"source/_posts/scloud-elk/kibana3.png","hash":"2474636856ed2da6003880c266e460d94aced887","modified":1567907249870},{"_id":"source/_posts/wkhtmltopdf/Arial.zip","hash":"f96dc4f283e8a2c67256f69c95d18c3c4816f5d1","modified":1560695913999},{"_id":"source/_posts/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk","hash":"08466b927332819300796822ab861c779eaf3af9","modified":1560695913512},{"_id":"source/_posts/wkhtmltopdf/simsun.ttc","hash":"56a1a93bebf5f8468bea1a9eac5393206b08cfd6","modified":1560695914095},{"_id":"source/_posts/shadowsocks-go/go1.9.2.linux-amd64.tar.gz","hash":"94c889e039e3d2e94ed95e8f8cb747c5bc1c2b58","modified":1560695913941}],"Category":[{"name":"Nginx","_id":"ckatvaq9q0003g4vak9r2bz69"},{"name":"angular","_id":"ckatvaq9x0008g4va26qzylq2"},{"name":"api-manage","_id":"ckatvaqaj000tg4vatp0wzgha"},{"name":"aws","_id":"ckatvaqao0015g4vas5z2vqvi"},{"name":"区块链","_id":"ckatvaqar001cg4va7q9t2w8f"},{"name":"CentOs","_id":"ckatvaqaw001ng4vae7arq0ry"},{"name":"maven","_id":"ckatvaqb0001ug4varoihxjif"},{"name":"持续集成","_id":"ckatvaqb7002ag4va8u586yh1"},{"name":"java","_id":"ckatvaqbc002lg4va4gz0gl3i"},{"name":"分布式系统","_id":"ckatvaqbf002tg4vaka18w9uu"},{"name":"docker","_id":"ckatvaqbo003ag4va6jg9rcaz"},{"name":"文件存储系统","_id":"ckatvaqd60068g4vavopu0xos"},{"name":"flutter","_id":"ckatvaqda006gg4vaih6s9ysx"},{"name":"git","_id":"ckatvaqdg006ug4vargqm4978"},{"name":"github","_id":"ckatvaqdy007rg4vasl81mj8j"},{"name":"gitlab","_id":"ckatvaqe40083g4va8laeuht0"},{"name":"security","_id":"ckatvaqea008gg4vay7j265o9"},{"name":"http协议","_id":"ckatvaqee008og4vaayt33tzy"},{"name":"idea","_id":"ckatvaqeh008ug4va20l75opr"},{"name":"jpa/hibernate","_id":"ckatvaqel0094g4va0zi64xf8"},{"name":"json","_id":"ckatvaqeu009mg4vahghvn82o"},{"name":"服务网格","_id":"ckatvaqey009ug4vati8ilfih"},{"name":"java-io","_id":"ckatvaqf100a0g4vadpssuttp"},{"name":"java-nio","_id":"ckatvaqfm00b5g4vafkm2nzik"},{"name":"javapoet","_id":"ckatvaqfp00bcg4varhywgit3"},{"name":"jvm","_id":"ckatvaqfs00bkg4vaqv5m0pau"},{"name":"Kubernetes","_id":"ckatvaqfw00bug4vavhplrdwf"},{"name":"jwt","_id":"ckatvaqfz00c1g4vaav6xq9vz"},{"name":"ubuntu","_id":"ckatvaqg100c7g4va8sfrc6jt"},{"name":"linux","_id":"ckatvaqg600cjg4va9lwxa60u"},{"name":"监控","_id":"ckatvaqg900cqg4vak5cs4n9u"},{"name":"micro-service","_id":"ckatvaqge00d1g4va1y6hsdqv"},{"name":"mysql","_id":"ckatvaqgg00d6g4va2fsxit2l"},{"name":"nginx","_id":"ckatvaqgm00dog4vapo84epkv"},{"name":"npm","_id":"ckatvaqgn00dtg4vatj5w040d"},{"name":"ngrok","_id":"ckatvaqgo00dxg4vadi700su5"},{"name":"Pivotal Web Service","_id":"ckatvaqgp00e1g4vabn66dydd"},{"name":"rabbitmq","_id":"ckatvaqgq00e5g4valngb96ep"},{"name":"redis","_id":"ckatvaqgw00eng4vap8ix9iju"},{"name":"redmine","_id":"ckatvaqh300fcg4vavl4o1p5y"},{"name":"rocketmq","_id":"ckatvaqh600fkg4vagdh6z4b9"},{"name":"spring-boot","_id":"ckatvaqh700fng4vavxzoin6s"},{"name":"spring-cloud","_id":"ckatvaqh700fpg4vagcx2qjae"},{"name":"servlet","_id":"ckatvaqhe00gag4vacepbwbiu"},{"name":"shadowsocks","_id":"ckatvaqhf00gdg4valyprt4dl"},{"name":"shiro","_id":"ckatvaqhg00ggg4vabfeogxt6"},{"name":"teamcity","_id":"ckatvaqhq00h6g4vaave4y0f8"},{"name":"TypeScript","_id":"ckatvaqhq00h9g4vas6l6zvzv"},{"name":"vagrant","_id":"ckatvaqhr00hbg4vaod99a3pe"},{"name":"密码","_id":"ckatvaqht00hig4vapqprpjae"},{"name":"架构","_id":"ckatvaqhv00hlg4va0fgzeohc"},{"name":"pdf","_id":"ckatvaqhv00hng4vadf4avb07"},{"name":"zookeeper","_id":"ckatvaqhw00hpg4va1jtxz3in"}],"Data":[],"Page":[{"title":"关于","date":"2017-09-20T03:52:09.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-09-20 11:52:09\n---\n","updated":"2019-06-16T14:38:34.097Z","path":"about/index.html","comments":1,"layout":"page","_id":"ckatvaq9j0000g4vamgo5fskq","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Keepalived+LVS+Nginx负载均衡之高可用","date":"2017-09-23T01:48:19.000Z","_content":"### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","source":"_posts/Keepalived-LVS-Nginx.md","raw":"---\ntitle: Keepalived+LVS+Nginx负载均衡之高可用\ndate: 2017-09-23 09:48:19\ncategories: Nginx\ntags: nginx负载均衡\n---\n### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","slug":"Keepalived-LVS-Nginx","published":1,"updated":"2019-06-16T14:38:33.313Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaq9k0001g4vaz2oig465","content":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"noopener\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"noopener\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>"},{"title":"Angular 组件之间的交互","date":"2019-12-06T02:55:38.000Z","_content":"\n参考：https://angular.cn/guide/component-interaction\n","source":"_posts/angular-component-interaction.md","raw":"---\ntitle: Angular 组件之间的交互\ndate: 2019-12-06 10:55:38\ncategories: angular\ntags:\n---\n\n参考：https://angular.cn/guide/component-interaction\n","slug":"angular-component-interaction","published":1,"updated":"2020-05-30T11:28:23.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaq9o0002g4vaphnfw9ei","content":"<p>参考：<a href=\"https://angular.cn/guide/component-interaction\" target=\"_blank\" rel=\"noopener\">https://angular.cn/guide/component-interaction</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://angular.cn/guide/component-interaction\" target=\"_blank\" rel=\"noopener\">https://angular.cn/guide/component-interaction</a></p>\n"},{"title":"angular常用命令","date":"2019-11-10T02:37:48.000Z","_content":"\n本章介绍angular项目开发过程中经常用到的angular-cli命令。对这些常用命令要有个基本的认识以及基本的使用能力。\n\n## 创建项目\n\n    ng new project-name\n    \n该命令会在当前目录下，按照angular项目脚手架创建一个angular初始化项目。\n\n## 运行应用\n\n    cd project-name\n    ng serve --open 或者 ng serve -o\n\n执行以上命令，将会编译项目并启动，启动完自动跳到浏览器打开（命令参数`--open`）。   \n \n默认的端口是`4200`,你也可以指定运行端口。`ng serve --port 4222 --open`。 \n\n## 添加模块组件\n\n    ng generate componet 组件名称\n    \n会在项目app目录中添加一个组件模块。包括四个文件。css样式文件，html模板文件，ts脚本文件，还有一个spec.ts的测试文件。\n\n## 添加服务组件\n\n\n             ","source":"_posts/angular-cli-command.md","raw":"---\ntitle: angular常用命令\ndate: 2019-11-10 10:37:48\ncategories: angular\ntags:\n---\n\n本章介绍angular项目开发过程中经常用到的angular-cli命令。对这些常用命令要有个基本的认识以及基本的使用能力。\n\n## 创建项目\n\n    ng new project-name\n    \n该命令会在当前目录下，按照angular项目脚手架创建一个angular初始化项目。\n\n## 运行应用\n\n    cd project-name\n    ng serve --open 或者 ng serve -o\n\n执行以上命令，将会编译项目并启动，启动完自动跳到浏览器打开（命令参数`--open`）。   \n \n默认的端口是`4200`,你也可以指定运行端口。`ng serve --port 4222 --open`。 \n\n## 添加模块组件\n\n    ng generate componet 组件名称\n    \n会在项目app目录中添加一个组件模块。包括四个文件。css样式文件，html模板文件，ts脚本文件，还有一个spec.ts的测试文件。\n\n## 添加服务组件\n\n\n             ","slug":"angular-cli-command","published":1,"updated":"2019-11-10T02:52:01.656Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaq9s0005g4vayw1npwtj","content":"<p>本章介绍angular项目开发过程中经常用到的angular-cli命令。对这些常用命令要有个基本的认识以及基本的使用能力。</p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><pre><code>ng new project-name\n</code></pre><p>该命令会在当前目录下，按照angular项目脚手架创建一个angular初始化项目。</p>\n<h2 id=\"运行应用\"><a href=\"#运行应用\" class=\"headerlink\" title=\"运行应用\"></a>运行应用</h2><pre><code>cd project-name\nng serve --open 或者 ng serve -o\n</code></pre><p>执行以上命令，将会编译项目并启动，启动完自动跳到浏览器打开（命令参数<code>--open</code>）。   </p>\n<p>默认的端口是<code>4200</code>,你也可以指定运行端口。<code>ng serve --port 4222 --open</code>。 </p>\n<h2 id=\"添加模块组件\"><a href=\"#添加模块组件\" class=\"headerlink\" title=\"添加模块组件\"></a>添加模块组件</h2><pre><code>ng generate componet 组件名称\n</code></pre><p>会在项目app目录中添加一个组件模块。包括四个文件。css样式文件，html模板文件，ts脚本文件，还有一个spec.ts的测试文件。</p>\n<h2 id=\"添加服务组件\"><a href=\"#添加服务组件\" class=\"headerlink\" title=\"添加服务组件\"></a>添加服务组件</h2>","site":{"data":{}},"excerpt":"","more":"<p>本章介绍angular项目开发过程中经常用到的angular-cli命令。对这些常用命令要有个基本的认识以及基本的使用能力。</p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><pre><code>ng new project-name\n</code></pre><p>该命令会在当前目录下，按照angular项目脚手架创建一个angular初始化项目。</p>\n<h2 id=\"运行应用\"><a href=\"#运行应用\" class=\"headerlink\" title=\"运行应用\"></a>运行应用</h2><pre><code>cd project-name\nng serve --open 或者 ng serve -o\n</code></pre><p>执行以上命令，将会编译项目并启动，启动完自动跳到浏览器打开（命令参数<code>--open</code>）。   </p>\n<p>默认的端口是<code>4200</code>,你也可以指定运行端口。<code>ng serve --port 4222 --open</code>。 </p>\n<h2 id=\"添加模块组件\"><a href=\"#添加模块组件\" class=\"headerlink\" title=\"添加模块组件\"></a>添加模块组件</h2><pre><code>ng generate componet 组件名称\n</code></pre><p>会在项目app目录中添加一个组件模块。包括四个文件。css样式文件，html模板文件，ts脚本文件，还有一个spec.ts的测试文件。</p>\n<h2 id=\"添加服务组件\"><a href=\"#添加服务组件\" class=\"headerlink\" title=\"添加服务组件\"></a>添加服务组件</h2>"},{"title":"angular快速上手","date":"2019-09-01T13:51:09.000Z","_content":"\n## 创建应用\n\n打开某个需要存放项目的目录。在命令窗口执行：\n\n    ng new angular-quick\n    \n用idea工具打开项目：\n\n{% asset_img a-1.png %}  \n\n## 创建组件模块\n\n命令：`ng generate component 模块名称`\n\n    E:\\angular\\study\\angular-quick>ng generate component product-list\n    \n    E:\\angular\\study\\angular-quick>\"node\"  \"E:\\angular\\study\\angular-quick\\node_modules\\.bin\\\\..\\_@angular_cli@8.0.6@@angular\\cli\\bin\\ng\" generate component product-list\n    CREATE src/app/product-list/product-list.component.html (27 bytes)\n    CREATE src/app/product-list/product-list.component.spec.ts (664 bytes)\n    CREATE src/app/product-list/product-list.component.ts (292 bytes)\n    CREATE src/app/product-list/product-list.component.css (0 bytes)\n    UPDATE src/app/app.module.ts (497 bytes)\n    \n    E:\\angular\\study\\angular-quick>ng generate component top-bar\n\n## 运行应用\n\n    cd my-app\n    ng serve --open\n    \nng serve 命令会启动开发服务器、监视文件，并在这些文件发生更改时重建应用。\n\n--open（或者只用 -o 缩写）选项会自动打开你的浏览器，并访问 http://localhost:4200/。    \n\n\n\n    \n    ","source":"_posts/angular-start-quick.md","raw":"---\ntitle: angular快速上手\ndate: 2019-09-01 21:51:09\ncategories: angular\ntags:\n---\n\n## 创建应用\n\n打开某个需要存放项目的目录。在命令窗口执行：\n\n    ng new angular-quick\n    \n用idea工具打开项目：\n\n{% asset_img a-1.png %}  \n\n## 创建组件模块\n\n命令：`ng generate component 模块名称`\n\n    E:\\angular\\study\\angular-quick>ng generate component product-list\n    \n    E:\\angular\\study\\angular-quick>\"node\"  \"E:\\angular\\study\\angular-quick\\node_modules\\.bin\\\\..\\_@angular_cli@8.0.6@@angular\\cli\\bin\\ng\" generate component product-list\n    CREATE src/app/product-list/product-list.component.html (27 bytes)\n    CREATE src/app/product-list/product-list.component.spec.ts (664 bytes)\n    CREATE src/app/product-list/product-list.component.ts (292 bytes)\n    CREATE src/app/product-list/product-list.component.css (0 bytes)\n    UPDATE src/app/app.module.ts (497 bytes)\n    \n    E:\\angular\\study\\angular-quick>ng generate component top-bar\n\n## 运行应用\n\n    cd my-app\n    ng serve --open\n    \nng serve 命令会启动开发服务器、监视文件，并在这些文件发生更改时重建应用。\n\n--open（或者只用 -o 缩写）选项会自动打开你的浏览器，并访问 http://localhost:4200/。    \n\n\n\n    \n    ","slug":"angular-start-quick","published":1,"updated":"2019-11-10T02:36:55.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaq9t0006g4vavv4o5ks2","content":"<h2 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h2><p>打开某个需要存放项目的目录。在命令窗口执行：</p>\n<pre><code>ng new angular-quick\n</code></pre><p>用idea工具打开项目：</p>\n<img src=\"/2019/09/01/angular-start-quick/a-1.png\">  \n<h2 id=\"创建组件模块\"><a href=\"#创建组件模块\" class=\"headerlink\" title=\"创建组件模块\"></a>创建组件模块</h2><p>命令：<code>ng generate component 模块名称</code></p>\n<pre><code>E:\\angular\\study\\angular-quick&gt;ng generate component product-list\n\nE:\\angular\\study\\angular-quick&gt;&quot;node&quot;  &quot;E:\\angular\\study\\angular-quick\\node_modules\\.bin\\\\..\\_@angular_cli@8.0.6@@angular\\cli\\bin\\ng&quot; generate component product-list\nCREATE src/app/product-list/product-list.component.html (27 bytes)\nCREATE src/app/product-list/product-list.component.spec.ts (664 bytes)\nCREATE src/app/product-list/product-list.component.ts (292 bytes)\nCREATE src/app/product-list/product-list.component.css (0 bytes)\nUPDATE src/app/app.module.ts (497 bytes)\n\nE:\\angular\\study\\angular-quick&gt;ng generate component top-bar\n</code></pre><h2 id=\"运行应用\"><a href=\"#运行应用\" class=\"headerlink\" title=\"运行应用\"></a>运行应用</h2><pre><code>cd my-app\nng serve --open\n</code></pre><p>ng serve 命令会启动开发服务器、监视文件，并在这些文件发生更改时重建应用。</p>\n<p>–open（或者只用 -o 缩写）选项会自动打开你的浏览器，并访问 <a href=\"http://localhost:4200/。\" target=\"_blank\" rel=\"noopener\">http://localhost:4200/。</a>    </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建应用\"><a href=\"#创建应用\" class=\"headerlink\" title=\"创建应用\"></a>创建应用</h2><p>打开某个需要存放项目的目录。在命令窗口执行：</p>\n<pre><code>ng new angular-quick\n</code></pre><p>用idea工具打开项目：</p>\n<img src=\"/2019/09/01/angular-start-quick/a-1.png\">  \n<h2 id=\"创建组件模块\"><a href=\"#创建组件模块\" class=\"headerlink\" title=\"创建组件模块\"></a>创建组件模块</h2><p>命令：<code>ng generate component 模块名称</code></p>\n<pre><code>E:\\angular\\study\\angular-quick&gt;ng generate component product-list\n\nE:\\angular\\study\\angular-quick&gt;&quot;node&quot;  &quot;E:\\angular\\study\\angular-quick\\node_modules\\.bin\\\\..\\_@angular_cli@8.0.6@@angular\\cli\\bin\\ng&quot; generate component product-list\nCREATE src/app/product-list/product-list.component.html (27 bytes)\nCREATE src/app/product-list/product-list.component.spec.ts (664 bytes)\nCREATE src/app/product-list/product-list.component.ts (292 bytes)\nCREATE src/app/product-list/product-list.component.css (0 bytes)\nUPDATE src/app/app.module.ts (497 bytes)\n\nE:\\angular\\study\\angular-quick&gt;ng generate component top-bar\n</code></pre><h2 id=\"运行应用\"><a href=\"#运行应用\" class=\"headerlink\" title=\"运行应用\"></a>运行应用</h2><pre><code>cd my-app\nng serve --open\n</code></pre><p>ng serve 命令会启动开发服务器、监视文件，并在这些文件发生更改时重建应用。</p>\n<p>–open（或者只用 -o 缩写）选项会自动打开你的浏览器，并访问 <a href=\"http://localhost:4200/。\" target=\"_blank\" rel=\"noopener\">http://localhost:4200/。</a>    </p>\n"},{"title":"Angular多环境运行、构建发布","date":"2019-11-26T09:28:38.000Z","_content":"\n类似spring boot，多环境构建的构建，避免频繁改变配置，极大提高运行和构建应用的效率。\n\n[构建与运行](https://angular.cn/guide/build)\n","source":"_posts/angular-environment.md","raw":"---\ntitle: Angular多环境运行、构建发布\ndate: 2019-11-26 17:28:38\ncategories: angular\ntags:\n---\n\n类似spring boot，多环境构建的构建，避免频繁改变配置，极大提高运行和构建应用的效率。\n\n[构建与运行](https://angular.cn/guide/build)\n","slug":"angular-environment","published":1,"updated":"2020-05-30T11:28:23.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaq9w0007g4vaxaxv2kro","content":"<p>类似spring boot，多环境构建的构建，避免频繁改变配置，极大提高运行和构建应用的效率。</p>\n<p><a href=\"https://angular.cn/guide/build\" target=\"_blank\" rel=\"noopener\">构建与运行</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>类似spring boot，多环境构建的构建，避免频繁改变配置，极大提高运行和构建应用的效率。</p>\n<p><a href=\"https://angular.cn/guide/build\" target=\"_blank\" rel=\"noopener\">构建与运行</a></p>\n"},{"title":"Angular使用问题收集","date":"2019-12-01T10:05:10.000Z","_content":"\n## 问题一\n\n问题描述：\n\n引入第三方依赖包，如“buffer”，使用报错如下：\n\n    core.js:6014 ERROR Error: Uncaught (in promise): ReferenceError: global is not defined\n    ReferenceError: global is not defined\n        at Object../node_modules/_buffer@4.9.2@buffer/index.js (index.js:43)\n        at __webpack_require__ (bootstrap:84)\n        at Module../src/app/pages/login/login.component.ts (pages-pages-module.js:108766)\n        at __webpack_require__ (bootstrap:84)\n        at Module../src/app/pages/pages-routing.module.ts (login.component.ts:14)\n        at __webpack_require__ (bootstrap:84)\n        at Module../src/app/pages/pages.module.ts (pages-routing.module.ts:36)\n        at __webpack_require__ (bootstrap:84)\n        at $_lazy_route_resource lazy namespace object:22\n        at ZoneDelegate.invoke (zone-evergreen.js:359)\n        at resolvePromise (zone-evergreen.js:797)\n        at resolvePromise (zone-evergreen.js:754)\n        at zone-evergreen.js:858\n        at ZoneDelegate.invokeTask (zone-evergreen.js:391)\n        at Object.onInvokeTask (core.js:39680)\n        at ZoneDelegate.invokeTask (zone-evergreen.js:390)\n        at Zone.runTask (zone-evergreen.js:168)\n        at drainMicroTaskQueue (zone-evergreen.js:559)\n\n\n解决：\n\n在文件`src/polyfills.ts`中，添加一行`(window as any).global = window;`\n\n如下：\n\n    /**\n     * This file includes polyfills needed by Angular and is loaded before the app.\n     * You can add your own extra polyfills to this file.\n     *\n     * This file is divided into 2 sections:\n     *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.\n     *   2. Application imports. Files imported after ZoneJS that should be loaded before your main\n     *      file.\n     *\n     * The current setup is for so-called \"evergreen\" browsers; the last versions of browsers that\n     * automatically update themselves. This includes Safari >= 10, Chrome >= 55 (including Opera),\n     * Edge >= 13 on the desktop, and iOS 10 and Chrome on mobile.\n     *\n     * Learn more in https://angular.io/guide/browser-support\n     */\n    \n    /***************************************************************************************************\n     * BROWSER POLYFILLS\n     */\n    \n    /** IE10 and IE11 requires the following for NgClass support on SVG elements */\n    // import 'classlist.js';  // Run `npm install --save classlist.js`.\n    \n    /**\n     * Web Animations `@angular/platform-browser/animations`\n     * Only required if AnimationBuilder is used within the application and using IE/Edge or Safari.\n     * Standard animation support in Angular DOES NOT require any polyfills (as of Angular 6.0).\n     */\n    // import 'web-animations-js';  // Run `npm install --save web-animations-js`.\n    \n    /**\n     * By default, zone.js will patch all possible macroTask and DomEvents\n     * user can disable parts of macroTask/DomEvents patch by setting following flags\n     * because those flags need to be set before `zone.js` being loaded, and webpack\n     * will put import in the top of bundle, so user need to create a separate file\n     * in this directory (for example: zone-flags.ts), and put the following flags\n     * into that file, and then add the following code before importing zone.js.\n     * import './zone-flags.ts';\n     *\n     * The flags allowed in zone-flags.ts are listed here.\n     *\n     * The following flags will work for all browsers.\n     *\n     * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame\n     * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick\n     * (window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames\n     *\n     *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js\n     *  with the following flag, it will bypass `zone.js` patch for IE/Edge\n     *\n     *  (window as any).__Zone_enable_cross_context_check = true;\n     *\n     */\n    (window as any).global = window;\n    \n    /***************************************************************************************************\n     * Zone JS is required by default for Angular itself.\n     */\n    import 'zone.js/dist/zone';  // Included with Angular CLI.\n    \n    \n    /***************************************************************************************************\n     * APPLICATION IMPORTS\n     */\n\n","source":"_posts/angular-issue-collect.md","raw":"---\ntitle: Angular使用问题收集\ndate: 2019-12-01 18:05:10\ncategories: angular\ntags:\n---\n\n## 问题一\n\n问题描述：\n\n引入第三方依赖包，如“buffer”，使用报错如下：\n\n    core.js:6014 ERROR Error: Uncaught (in promise): ReferenceError: global is not defined\n    ReferenceError: global is not defined\n        at Object../node_modules/_buffer@4.9.2@buffer/index.js (index.js:43)\n        at __webpack_require__ (bootstrap:84)\n        at Module../src/app/pages/login/login.component.ts (pages-pages-module.js:108766)\n        at __webpack_require__ (bootstrap:84)\n        at Module../src/app/pages/pages-routing.module.ts (login.component.ts:14)\n        at __webpack_require__ (bootstrap:84)\n        at Module../src/app/pages/pages.module.ts (pages-routing.module.ts:36)\n        at __webpack_require__ (bootstrap:84)\n        at $_lazy_route_resource lazy namespace object:22\n        at ZoneDelegate.invoke (zone-evergreen.js:359)\n        at resolvePromise (zone-evergreen.js:797)\n        at resolvePromise (zone-evergreen.js:754)\n        at zone-evergreen.js:858\n        at ZoneDelegate.invokeTask (zone-evergreen.js:391)\n        at Object.onInvokeTask (core.js:39680)\n        at ZoneDelegate.invokeTask (zone-evergreen.js:390)\n        at Zone.runTask (zone-evergreen.js:168)\n        at drainMicroTaskQueue (zone-evergreen.js:559)\n\n\n解决：\n\n在文件`src/polyfills.ts`中，添加一行`(window as any).global = window;`\n\n如下：\n\n    /**\n     * This file includes polyfills needed by Angular and is loaded before the app.\n     * You can add your own extra polyfills to this file.\n     *\n     * This file is divided into 2 sections:\n     *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.\n     *   2. Application imports. Files imported after ZoneJS that should be loaded before your main\n     *      file.\n     *\n     * The current setup is for so-called \"evergreen\" browsers; the last versions of browsers that\n     * automatically update themselves. This includes Safari >= 10, Chrome >= 55 (including Opera),\n     * Edge >= 13 on the desktop, and iOS 10 and Chrome on mobile.\n     *\n     * Learn more in https://angular.io/guide/browser-support\n     */\n    \n    /***************************************************************************************************\n     * BROWSER POLYFILLS\n     */\n    \n    /** IE10 and IE11 requires the following for NgClass support on SVG elements */\n    // import 'classlist.js';  // Run `npm install --save classlist.js`.\n    \n    /**\n     * Web Animations `@angular/platform-browser/animations`\n     * Only required if AnimationBuilder is used within the application and using IE/Edge or Safari.\n     * Standard animation support in Angular DOES NOT require any polyfills (as of Angular 6.0).\n     */\n    // import 'web-animations-js';  // Run `npm install --save web-animations-js`.\n    \n    /**\n     * By default, zone.js will patch all possible macroTask and DomEvents\n     * user can disable parts of macroTask/DomEvents patch by setting following flags\n     * because those flags need to be set before `zone.js` being loaded, and webpack\n     * will put import in the top of bundle, so user need to create a separate file\n     * in this directory (for example: zone-flags.ts), and put the following flags\n     * into that file, and then add the following code before importing zone.js.\n     * import './zone-flags.ts';\n     *\n     * The flags allowed in zone-flags.ts are listed here.\n     *\n     * The following flags will work for all browsers.\n     *\n     * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame\n     * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick\n     * (window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames\n     *\n     *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js\n     *  with the following flag, it will bypass `zone.js` patch for IE/Edge\n     *\n     *  (window as any).__Zone_enable_cross_context_check = true;\n     *\n     */\n    (window as any).global = window;\n    \n    /***************************************************************************************************\n     * Zone JS is required by default for Angular itself.\n     */\n    import 'zone.js/dist/zone';  // Included with Angular CLI.\n    \n    \n    /***************************************************************************************************\n     * APPLICATION IMPORTS\n     */\n\n","slug":"angular-issue-collect","published":1,"updated":"2020-05-30T11:28:23.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqa0000ag4vawkq4ylqg","content":"<h2 id=\"问题一\"><a href=\"#问题一\" class=\"headerlink\" title=\"问题一\"></a>问题一</h2><p>问题描述：</p>\n<p>引入第三方依赖包，如“buffer”，使用报错如下：</p>\n<pre><code>core.js:6014 ERROR Error: Uncaught (in promise): ReferenceError: global is not defined\nReferenceError: global is not defined\n    at Object../node_modules/_buffer@4.9.2@buffer/index.js (index.js:43)\n    at __webpack_require__ (bootstrap:84)\n    at Module../src/app/pages/login/login.component.ts (pages-pages-module.js:108766)\n    at __webpack_require__ (bootstrap:84)\n    at Module../src/app/pages/pages-routing.module.ts (login.component.ts:14)\n    at __webpack_require__ (bootstrap:84)\n    at Module../src/app/pages/pages.module.ts (pages-routing.module.ts:36)\n    at __webpack_require__ (bootstrap:84)\n    at $_lazy_route_resource lazy namespace object:22\n    at ZoneDelegate.invoke (zone-evergreen.js:359)\n    at resolvePromise (zone-evergreen.js:797)\n    at resolvePromise (zone-evergreen.js:754)\n    at zone-evergreen.js:858\n    at ZoneDelegate.invokeTask (zone-evergreen.js:391)\n    at Object.onInvokeTask (core.js:39680)\n    at ZoneDelegate.invokeTask (zone-evergreen.js:390)\n    at Zone.runTask (zone-evergreen.js:168)\n    at drainMicroTaskQueue (zone-evergreen.js:559)\n</code></pre><p>解决：</p>\n<p>在文件<code>src/polyfills.ts</code>中，添加一行<code>(window as any).global = window;</code></p>\n<p>如下：</p>\n<pre><code>/**\n * This file includes polyfills needed by Angular and is loaded before the app.\n * You can add your own extra polyfills to this file.\n *\n * This file is divided into 2 sections:\n *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.\n *   2. Application imports. Files imported after ZoneJS that should be loaded before your main\n *      file.\n *\n * The current setup is for so-called &quot;evergreen&quot; browsers; the last versions of browsers that\n * automatically update themselves. This includes Safari &gt;= 10, Chrome &gt;= 55 (including Opera),\n * Edge &gt;= 13 on the desktop, and iOS 10 and Chrome on mobile.\n *\n * Learn more in https://angular.io/guide/browser-support\n */\n\n/***************************************************************************************************\n * BROWSER POLYFILLS\n */\n\n/** IE10 and IE11 requires the following for NgClass support on SVG elements */\n// import &apos;classlist.js&apos;;  // Run `npm install --save classlist.js`.\n\n/**\n * Web Animations `@angular/platform-browser/animations`\n * Only required if AnimationBuilder is used within the application and using IE/Edge or Safari.\n * Standard animation support in Angular DOES NOT require any polyfills (as of Angular 6.0).\n */\n// import &apos;web-animations-js&apos;;  // Run `npm install --save web-animations-js`.\n\n/**\n * By default, zone.js will patch all possible macroTask and DomEvents\n * user can disable parts of macroTask/DomEvents patch by setting following flags\n * because those flags need to be set before `zone.js` being loaded, and webpack\n * will put import in the top of bundle, so user need to create a separate file\n * in this directory (for example: zone-flags.ts), and put the following flags\n * into that file, and then add the following code before importing zone.js.\n * import &apos;./zone-flags.ts&apos;;\n *\n * The flags allowed in zone-flags.ts are listed here.\n *\n * The following flags will work for all browsers.\n *\n * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame\n * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick\n * (window as any).__zone_symbol__UNPATCHED_EVENTS = [&apos;scroll&apos;, &apos;mousemove&apos;]; // disable patch specified eventNames\n *\n *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js\n *  with the following flag, it will bypass `zone.js` patch for IE/Edge\n *\n *  (window as any).__Zone_enable_cross_context_check = true;\n *\n */\n(window as any).global = window;\n\n/***************************************************************************************************\n * Zone JS is required by default for Angular itself.\n */\nimport &apos;zone.js/dist/zone&apos;;  // Included with Angular CLI.\n\n\n/***************************************************************************************************\n * APPLICATION IMPORTS\n */\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"问题一\"><a href=\"#问题一\" class=\"headerlink\" title=\"问题一\"></a>问题一</h2><p>问题描述：</p>\n<p>引入第三方依赖包，如“buffer”，使用报错如下：</p>\n<pre><code>core.js:6014 ERROR Error: Uncaught (in promise): ReferenceError: global is not defined\nReferenceError: global is not defined\n    at Object../node_modules/_buffer@4.9.2@buffer/index.js (index.js:43)\n    at __webpack_require__ (bootstrap:84)\n    at Module../src/app/pages/login/login.component.ts (pages-pages-module.js:108766)\n    at __webpack_require__ (bootstrap:84)\n    at Module../src/app/pages/pages-routing.module.ts (login.component.ts:14)\n    at __webpack_require__ (bootstrap:84)\n    at Module../src/app/pages/pages.module.ts (pages-routing.module.ts:36)\n    at __webpack_require__ (bootstrap:84)\n    at $_lazy_route_resource lazy namespace object:22\n    at ZoneDelegate.invoke (zone-evergreen.js:359)\n    at resolvePromise (zone-evergreen.js:797)\n    at resolvePromise (zone-evergreen.js:754)\n    at zone-evergreen.js:858\n    at ZoneDelegate.invokeTask (zone-evergreen.js:391)\n    at Object.onInvokeTask (core.js:39680)\n    at ZoneDelegate.invokeTask (zone-evergreen.js:390)\n    at Zone.runTask (zone-evergreen.js:168)\n    at drainMicroTaskQueue (zone-evergreen.js:559)\n</code></pre><p>解决：</p>\n<p>在文件<code>src/polyfills.ts</code>中，添加一行<code>(window as any).global = window;</code></p>\n<p>如下：</p>\n<pre><code>/**\n * This file includes polyfills needed by Angular and is loaded before the app.\n * You can add your own extra polyfills to this file.\n *\n * This file is divided into 2 sections:\n *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.\n *   2. Application imports. Files imported after ZoneJS that should be loaded before your main\n *      file.\n *\n * The current setup is for so-called &quot;evergreen&quot; browsers; the last versions of browsers that\n * automatically update themselves. This includes Safari &gt;= 10, Chrome &gt;= 55 (including Opera),\n * Edge &gt;= 13 on the desktop, and iOS 10 and Chrome on mobile.\n *\n * Learn more in https://angular.io/guide/browser-support\n */\n\n/***************************************************************************************************\n * BROWSER POLYFILLS\n */\n\n/** IE10 and IE11 requires the following for NgClass support on SVG elements */\n// import &apos;classlist.js&apos;;  // Run `npm install --save classlist.js`.\n\n/**\n * Web Animations `@angular/platform-browser/animations`\n * Only required if AnimationBuilder is used within the application and using IE/Edge or Safari.\n * Standard animation support in Angular DOES NOT require any polyfills (as of Angular 6.0).\n */\n// import &apos;web-animations-js&apos;;  // Run `npm install --save web-animations-js`.\n\n/**\n * By default, zone.js will patch all possible macroTask and DomEvents\n * user can disable parts of macroTask/DomEvents patch by setting following flags\n * because those flags need to be set before `zone.js` being loaded, and webpack\n * will put import in the top of bundle, so user need to create a separate file\n * in this directory (for example: zone-flags.ts), and put the following flags\n * into that file, and then add the following code before importing zone.js.\n * import &apos;./zone-flags.ts&apos;;\n *\n * The flags allowed in zone-flags.ts are listed here.\n *\n * The following flags will work for all browsers.\n *\n * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame\n * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick\n * (window as any).__zone_symbol__UNPATCHED_EVENTS = [&apos;scroll&apos;, &apos;mousemove&apos;]; // disable patch specified eventNames\n *\n *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js\n *  with the following flag, it will bypass `zone.js` patch for IE/Edge\n *\n *  (window as any).__Zone_enable_cross_context_check = true;\n *\n */\n(window as any).global = window;\n\n/***************************************************************************************************\n * Zone JS is required by default for Angular itself.\n */\nimport &apos;zone.js/dist/zone&apos;;  // Included with Angular CLI.\n\n\n/***************************************************************************************************\n * APPLICATION IMPORTS\n */\n</code></pre>"},{"title":"angular入门","date":"2018-06-23T02:32:10.000Z","_content":"\n本文介绍如何搭建angular开发环境……\n\n[中文官网](https://angular.cn)\n[英文官网](https://angular.io)\n\n## 环境安装\n\n### ubuntu下\n\n_nodejs、npm环境_\n\n下载：https://nodejs.org/en/download/\n\n`nodejs`自带`npm`。\n\n- 现在二进制包，解压到相关目录。\n- 配置`nodejs`环境变量。\n    \n    \n    export NODE_HOME=~/Desktop/work/tools/node\n    export PATH=${NODE_HOME}/bin:$PATH\n    \n- 检查安装是否成功\n\n\n    zmt@zmt-Lenovo:~$ node -v\n    v10.4.1\n    zmt@zmt-Lenovo:~$ npm -v\n    6.1.0\n\n- 安装`npm`淘宝镜像\n\n`npm install -g cnpm --registry=https://registry.npm.taobao.org`  \n\n- 设置npm的镜像地址\n\n1.查看默认\n\n    > npm get registry\n    \n    http://registry.npmjs.org \n    \n2.设置\n\n    npm set registry https://registry.npm.taobao.org\n    \n3.再次查看\n    \n    > npm get registry\n    \n    https://registry.npm.taobao.org/        \n\n可以看到，已经设置成淘宝的npm镜像了。这样，后面使用ng-cli的时候，默认的npm就是从淘宝镜像获取依赖了。\n\n_angular-cli_ 安装\n\n全局安装\n\n`cnpm install -g @angular/cli`\n\n### Windows环境下\n\n直接下载nodejs的可执行文件，运行安装即可。安装成功后，打开命令行窗口检查是否安装成功。\n\n`node -v`       \n`npm -v`    \n\n显示安装的版本号，则表明正常安装。\n\n后面步骤同上……\n\n## 跑起angular项目\n\n1. 创建新项目\n\n    `ng new my-app`\n\n2. 启动服务器\n\n    `cd my-app`\n    \n    `ng serve --open` 或者 `ng serve -o`\n    \n如果一切顺利，会自动打开浏览器显示网页。至此，一个`hello wold`项目完成了。    \n\n\n## 卸载并安装指定版本Angular CLI\n\n1.卸载之前的版本\n\nnpm uninstall -g @angular/cli\n\n2.清除缓存，确保卸载干净\n\nnpm cache clean --force\n\n3.检查是否卸载干净\n\n输入命令\n\nng -v\n\n若显示command not found则卸载干净\n\n4.安装指定版本\n\nnpm install -g @angular/cli@1.6.3\n\n5.检查版本号\n\nng version\n\n\n","source":"_posts/angular-start.md","raw":"---\ntitle: angular入门\ndate: 2018-06-23 10:32:10\ncategories: angular\ntags:\n---\n\n本文介绍如何搭建angular开发环境……\n\n[中文官网](https://angular.cn)\n[英文官网](https://angular.io)\n\n## 环境安装\n\n### ubuntu下\n\n_nodejs、npm环境_\n\n下载：https://nodejs.org/en/download/\n\n`nodejs`自带`npm`。\n\n- 现在二进制包，解压到相关目录。\n- 配置`nodejs`环境变量。\n    \n    \n    export NODE_HOME=~/Desktop/work/tools/node\n    export PATH=${NODE_HOME}/bin:$PATH\n    \n- 检查安装是否成功\n\n\n    zmt@zmt-Lenovo:~$ node -v\n    v10.4.1\n    zmt@zmt-Lenovo:~$ npm -v\n    6.1.0\n\n- 安装`npm`淘宝镜像\n\n`npm install -g cnpm --registry=https://registry.npm.taobao.org`  \n\n- 设置npm的镜像地址\n\n1.查看默认\n\n    > npm get registry\n    \n    http://registry.npmjs.org \n    \n2.设置\n\n    npm set registry https://registry.npm.taobao.org\n    \n3.再次查看\n    \n    > npm get registry\n    \n    https://registry.npm.taobao.org/        \n\n可以看到，已经设置成淘宝的npm镜像了。这样，后面使用ng-cli的时候，默认的npm就是从淘宝镜像获取依赖了。\n\n_angular-cli_ 安装\n\n全局安装\n\n`cnpm install -g @angular/cli`\n\n### Windows环境下\n\n直接下载nodejs的可执行文件，运行安装即可。安装成功后，打开命令行窗口检查是否安装成功。\n\n`node -v`       \n`npm -v`    \n\n显示安装的版本号，则表明正常安装。\n\n后面步骤同上……\n\n## 跑起angular项目\n\n1. 创建新项目\n\n    `ng new my-app`\n\n2. 启动服务器\n\n    `cd my-app`\n    \n    `ng serve --open` 或者 `ng serve -o`\n    \n如果一切顺利，会自动打开浏览器显示网页。至此，一个`hello wold`项目完成了。    \n\n\n## 卸载并安装指定版本Angular CLI\n\n1.卸载之前的版本\n\nnpm uninstall -g @angular/cli\n\n2.清除缓存，确保卸载干净\n\nnpm cache clean --force\n\n3.检查是否卸载干净\n\n输入命令\n\nng -v\n\n若显示command not found则卸载干净\n\n4.安装指定版本\n\nnpm install -g @angular/cli@1.6.3\n\n5.检查版本号\n\nng version\n\n\n","slug":"angular-start","published":1,"updated":"2019-11-16T06:19:36.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqa4000bg4vazs5cqr9j","content":"<p>本文介绍如何搭建angular开发环境……</p>\n<p><a href=\"https://angular.cn\" target=\"_blank\" rel=\"noopener\">中文官网</a><br><a href=\"https://angular.io\" target=\"_blank\" rel=\"noopener\">英文官网</a></p>\n<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><h3 id=\"ubuntu下\"><a href=\"#ubuntu下\" class=\"headerlink\" title=\"ubuntu下\"></a>ubuntu下</h3><p><em>nodejs、npm环境</em></p>\n<p>下载：<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/download/</a></p>\n<p><code>nodejs</code>自带<code>npm</code>。</p>\n<ul>\n<li>现在二进制包，解压到相关目录。</li>\n<li>配置<code>nodejs</code>环境变量。</li>\n</ul>\n<pre><code>export NODE_HOME=~/Desktop/work/tools/node\nexport PATH=${NODE_HOME}/bin:$PATH\n</code></pre><ul>\n<li>检查安装是否成功</li>\n</ul>\n<pre><code>zmt@zmt-Lenovo:~$ node -v\nv10.4.1\nzmt@zmt-Lenovo:~$ npm -v\n6.1.0\n</code></pre><ul>\n<li>安装<code>npm</code>淘宝镜像</li>\n</ul>\n<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>  </p>\n<ul>\n<li>设置npm的镜像地址</li>\n</ul>\n<p>1.查看默认</p>\n<pre><code>&gt; npm get registry\n\nhttp://registry.npmjs.org \n</code></pre><p>2.设置</p>\n<pre><code>npm set registry https://registry.npm.taobao.org\n</code></pre><p>3.再次查看</p>\n<pre><code>&gt; npm get registry\n\nhttps://registry.npm.taobao.org/        \n</code></pre><p>可以看到，已经设置成淘宝的npm镜像了。这样，后面使用ng-cli的时候，默认的npm就是从淘宝镜像获取依赖了。</p>\n<p><em>angular-cli</em> 安装</p>\n<p>全局安装</p>\n<p><code>cnpm install -g @angular/cli</code></p>\n<h3 id=\"Windows环境下\"><a href=\"#Windows环境下\" class=\"headerlink\" title=\"Windows环境下\"></a>Windows环境下</h3><p>直接下载nodejs的可执行文件，运行安装即可。安装成功后，打开命令行窗口检查是否安装成功。</p>\n<p><code>node -v</code><br><code>npm -v</code>    </p>\n<p>显示安装的版本号，则表明正常安装。</p>\n<p>后面步骤同上……</p>\n<h2 id=\"跑起angular项目\"><a href=\"#跑起angular项目\" class=\"headerlink\" title=\"跑起angular项目\"></a>跑起angular项目</h2><ol>\n<li><p>创建新项目</p>\n<p> <code>ng new my-app</code></p>\n</li>\n<li><p>启动服务器</p>\n<p> <code>cd my-app</code></p>\n<p> <code>ng serve --open</code> 或者 <code>ng serve -o</code></p>\n</li>\n</ol>\n<p>如果一切顺利，会自动打开浏览器显示网页。至此，一个<code>hello wold</code>项目完成了。    </p>\n<h2 id=\"卸载并安装指定版本Angular-CLI\"><a href=\"#卸载并安装指定版本Angular-CLI\" class=\"headerlink\" title=\"卸载并安装指定版本Angular CLI\"></a>卸载并安装指定版本Angular CLI</h2><p>1.卸载之前的版本</p>\n<p>npm uninstall -g @angular/cli</p>\n<p>2.清除缓存，确保卸载干净</p>\n<p>npm cache clean –force</p>\n<p>3.检查是否卸载干净</p>\n<p>输入命令</p>\n<p>ng -v</p>\n<p>若显示command not found则卸载干净</p>\n<p>4.安装指定版本</p>\n<p>npm install -g @<a href=\"mailto:angular/cli@1.6.3\" target=\"_blank\" rel=\"noopener\">angular/cli@1.6.3</a></p>\n<p>5.检查版本号</p>\n<p>ng version</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍如何搭建angular开发环境……</p>\n<p><a href=\"https://angular.cn\" target=\"_blank\" rel=\"noopener\">中文官网</a><br><a href=\"https://angular.io\" target=\"_blank\" rel=\"noopener\">英文官网</a></p>\n<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><h3 id=\"ubuntu下\"><a href=\"#ubuntu下\" class=\"headerlink\" title=\"ubuntu下\"></a>ubuntu下</h3><p><em>nodejs、npm环境</em></p>\n<p>下载：<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/download/</a></p>\n<p><code>nodejs</code>自带<code>npm</code>。</p>\n<ul>\n<li>现在二进制包，解压到相关目录。</li>\n<li>配置<code>nodejs</code>环境变量。</li>\n</ul>\n<pre><code>export NODE_HOME=~/Desktop/work/tools/node\nexport PATH=${NODE_HOME}/bin:$PATH\n</code></pre><ul>\n<li>检查安装是否成功</li>\n</ul>\n<pre><code>zmt@zmt-Lenovo:~$ node -v\nv10.4.1\nzmt@zmt-Lenovo:~$ npm -v\n6.1.0\n</code></pre><ul>\n<li>安装<code>npm</code>淘宝镜像</li>\n</ul>\n<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>  </p>\n<ul>\n<li>设置npm的镜像地址</li>\n</ul>\n<p>1.查看默认</p>\n<pre><code>&gt; npm get registry\n\nhttp://registry.npmjs.org \n</code></pre><p>2.设置</p>\n<pre><code>npm set registry https://registry.npm.taobao.org\n</code></pre><p>3.再次查看</p>\n<pre><code>&gt; npm get registry\n\nhttps://registry.npm.taobao.org/        \n</code></pre><p>可以看到，已经设置成淘宝的npm镜像了。这样，后面使用ng-cli的时候，默认的npm就是从淘宝镜像获取依赖了。</p>\n<p><em>angular-cli</em> 安装</p>\n<p>全局安装</p>\n<p><code>cnpm install -g @angular/cli</code></p>\n<h3 id=\"Windows环境下\"><a href=\"#Windows环境下\" class=\"headerlink\" title=\"Windows环境下\"></a>Windows环境下</h3><p>直接下载nodejs的可执行文件，运行安装即可。安装成功后，打开命令行窗口检查是否安装成功。</p>\n<p><code>node -v</code><br><code>npm -v</code>    </p>\n<p>显示安装的版本号，则表明正常安装。</p>\n<p>后面步骤同上……</p>\n<h2 id=\"跑起angular项目\"><a href=\"#跑起angular项目\" class=\"headerlink\" title=\"跑起angular项目\"></a>跑起angular项目</h2><ol>\n<li><p>创建新项目</p>\n<p> <code>ng new my-app</code></p>\n</li>\n<li><p>启动服务器</p>\n<p> <code>cd my-app</code></p>\n<p> <code>ng serve --open</code> 或者 <code>ng serve -o</code></p>\n</li>\n</ol>\n<p>如果一切顺利，会自动打开浏览器显示网页。至此，一个<code>hello wold</code>项目完成了。    </p>\n<h2 id=\"卸载并安装指定版本Angular-CLI\"><a href=\"#卸载并安装指定版本Angular-CLI\" class=\"headerlink\" title=\"卸载并安装指定版本Angular CLI\"></a>卸载并安装指定版本Angular CLI</h2><p>1.卸载之前的版本</p>\n<p>npm uninstall -g @angular/cli</p>\n<p>2.清除缓存，确保卸载干净</p>\n<p>npm cache clean –force</p>\n<p>3.检查是否卸载干净</p>\n<p>输入命令</p>\n<p>ng -v</p>\n<p>若显示command not found则卸载干净</p>\n<p>4.安装指定版本</p>\n<p>npm install -g @<a href=\"mailto:angular/cli@1.6.3\" target=\"_blank\" rel=\"noopener\">angular/cli@1.6.3</a></p>\n<p>5.检查版本号</p>\n<p>ng version</p>\n"},{"title":"angular路由与导航","date":"2019-11-10T03:03:49.000Z","_content":"\n在用户使用应用程序时，Angular 的路由器能让用户从一个视图导航到另一个视图。   \n浏览器具有熟悉的导航模式：\n\n- 在地址栏输入 URL，浏览器就会导航到相应的页面。\n- 在页面中点击链接，浏览器就会导航到一个新页面。\n- 点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。\n\n\n## 基础知识\n\n#### <base href> 元素\n\n大多数带路由的应用都要在index.html的 <head> 标签下先添加一个 <base> 元素，来告诉路由器该如何合成导航用的 URL。\n\n设置src/index.html (base-href)\n\n     <!DOCTYPE html>\n     <html lang=\"en\">\n       <head>\n         <!-- Set the base href -->\n         <base href=\"/\">\n         <title>Angular Router</title>\n         <meta charset=\"UTF-8\">\n         <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n       </head>\n     \n       <body>\n         <app-root></app-root>\n       </body>\n     \n     </html>\n     \n#### 导入路由模块\n\n在src/app/app-routing.module.ts 导入路由模块\n\n    import { RouterModule, Routes } from '@angular/router';\n    \n#### 配置路由\n\n在src/app/app-routing.module.ts (excerpt)中配置路由：\n\n    const appRoutes: Routes = [\n      { path: 'crisis-center', component: CrisisListComponent },\n      { path: 'hero/:id',      component: HeroDetailComponent },\n      {\n        path: 'heroes',\n        component: HeroListComponent,\n        data: { title: 'Heroes List' }\n      },\n      { path: '',\n        redirectTo: '/heroes',\n        pathMatch: 'full'\n      },\n      { path: '**', component: PageNotFoundComponent }\n    ];\n    \n    @NgModule({\n      imports: [\n        RouterModule.forRoot(\n          appRoutes,\n          { enableTracing: true } // 测试环境才打开\n        )\n        // other imports here\n      ],\n      ...\n    })\n    export class AppModule { }\n    \n以上定义一个路由器数组，里面五个路由信息。并用 RouterModule.forRoot() 方法来配置路由器， 并把它的返回值添加到 AppModule 的 imports 数组中。 \n\n这里的路由数组 appRoutes 描述如何进行导航。 把它传给 RouterModule.forRoot() 方法并传给本模块的 imports 数组就可以配置路由器。    \n\n每个路由都会把一个URL的path映射到一个具体的组件。注意，path不能以`斜杆`开头。 路由器会为解析和构建最终的 URL，这样当你在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。\n\n第二个路由中的:id是一个路由参数，后面章节会有更多介绍。\n\n第三个路由中的 data 属性用来存放于每个具体路由有关的任意信息。该数据可以被任何一个激活路由访问，并能用来保存诸如 页标题、面包屑以及其它静态只读数据。如何获取这些存放的信息，后面介绍。 \n\n第四个路由中的空路径（''）表示应用的默认路径，当 URL 为空时就会访问那里，因此它通常会作为起点。 这个默认路由会重定向到 URL /heroes。\n\n最后一个路由中的 ** 路径是一个通配符。当所请求的 URL 不匹配前面定义的路由表中的任何路径时，路由器就会选择此路由。 这个特性可用于显示“404 - Not Found”页，或自动重定向到其它路由。\n\n这些路由的定义顺序是刻意如此设计的。路由器使用先匹配者优先的策略来匹配路由，所以，具体路由应该放在通用路由的前面。在上面的配置中，带静态路径的路由被放在了前面，后面是空路径路由，因此它会作为默认路由。而通配符路由被放在最后面，这是因为它能匹配上每一个 URL，因此应该只有在前面找不到其它能匹配的路由时才匹配它。\n\n如果你想要看到在导航的生命周期中发生过哪些事件，可以使用路由器默认配置中的 enableTracing 选项。它会把每个导航生命周期中的事件输出到浏览器的控制台。 这应该只用于调试。你只需要把 enableTracing: true 选项作为第二个参数传给 RouterModule.forRoot() 方法就可以了。\n\n#### 路由出口\n\nRouterOutlet是一个来自路由模块的一个指令，用法类似组件。它扮演一个占位符的角色，用于在模板中标出一个位置，路由将会把要显示在这个出口处的组件显示在这里。\n\n    <router-outlet></router-outlet>\n    <!-- Routed components go here -->\n    \n有了这份配置，当本应用在浏览器中的 URL 变为 /heroes 时，路由器就会匹配到 path 为 heroes 的 Route，并在宿主视图中的RouterOutlet之后显示 HeroListComponent 组件。\n\n   \n#### 路由器链接\n\n在地址栏输入对应路由，能导航到相应页面。但多数时候，路由导航是用户操作的结果，查看下面例子：\n\n    <h1>Angular Router</h1>\n    <nav>\n      <a routerLink=\"/crisis-center\" routerLinkActive=\"active\">Crisis Center</a>\n      <a routerLink=\"/heroes\" routerLinkActive=\"active\">Heroes</a>\n    </nav>\n    <router-outlet></router-outlet>\n    \na 标签上的 RouterLink 指令让路由器得以控制这个 a 元素。 这里的导航路径是固定的，因此可以把一个字符串赋给 routerLink（“一次性”绑定）。\n\n#### 路由链接的激活状态\n\nRouterLinkActive 指令会基于当前的 RouterState 为活动的 RouterLink 切换所绑定的 css 类。\n\n#### 路由器状态\n\n在导航时的每个生命周期成功完成时，路由器会构建出一个 ActivatedRoute 组成的树，它表示路由器的当前状态。 你可以在应用中的任何地方用 Router 服务及其 routerState 属性来访问当前的 RouterState 值。\n\nRouterState 中的每个 ActivatedRoute 都提供了从任意激活路由开始向上或向下遍历路由树的一种方式，以获得关于父、子、兄弟路由的信息。\n\n#### 激活的路由\n\n该路由的路径和参数可以通过注入进来的一个名叫ActivatedRoute的路由服务来获取。\n\n#### 路由事件\n\n在每次导航中，Router 都会通过 Router.events 属性发布一些导航事件。这些事件的范围涵盖了从开始导航到结束导航之间的很多时间点。下表中列出了全部导航事件：\n\n#### 总结\n\n该应用有一个配置过的路由器。 外壳组件中有一个 RouterOutlet，它能显示路由器所生成的视图。 它还有一些 RouterLink，用户可以点击它们，来通过路由器进行导航。\n\n下面是一些路由器中的关键词汇及其含义：\n\n|  路由器部件   | 含义 |\n| :------: |:-----:|\n| Router（路由器） | 为激活的 URL 显示应用组件。管理从一个组件到另一个组件的导航 |\n|RouterModule | 一个独立的 NgModule，用于提供所需的服务提供商，以及用来在应用视图之间进行导航的指令。 |\n| Routes（路由数组） | 定义了一个路由数组，每一个都会把一个 URL 路径映射到一个组件。 |\n| Route（路由） | 定义路由器该如何根据 URL 模式（pattern）来导航到组件。大多数路由都由路径和组件类构成。 |\n| RouterOutlet（路由出口） | 该指令（<router-outlet>）用来标记出路由器该在哪里显示视图。 |\n|RouterLink（路由链接）|这个指令把可点击的 HTML 元素绑定到某个路由。点击带有 routerLink 指令（绑定到字符串或链接参数数组）的元素时就会触发一次导航。|\n|RouterLinkActive（活动路由链接）|当 HTML 元素上或元素内的routerLink变为激活或非激活状态时，该指令为这个 HTML 元素添加或移除 CSS 类。|\n|ActivatedRoute（激活的路由）|为每个路由组件提供提供的一个服务，它包含特定于路由的信息，比如路由参数、静态数据、解析数据、全局查询参数和全局碎片（fragment）。|\n|RouterState（路由器状态）|路由器的当前状态包含了一棵由程序中激活的路由构成的树。它包含一些用于遍历路由树的快捷方法。|\n|链接参数数组|这个数组会被路由器解释成一个路由操作指南。你可以把一个RouterLink绑定到该数组，或者把它作为参数传给Router.navigate方法。|\n|路由组件|一个带有RouterOutlet的 Angular 组件，它根据路由器的导航来显示相应的视图。|\n\n## 范例应用\n\n下面讲解如何开发一个带路由的多页面小应用。涉及到下面一些决策：\n\n- 把应用的各个特性组织成模块。\n- 导航到组件（Heroes 链接到“英雄列表”组件）。\n- 包含一个路由参数（当路由到“英雄详情”时，把该英雄的 id 传进去）。\n- 子路由（危机中心特性有一组自己的路由）。\n- CanActivate 守卫（检查路由的访问权限）。\n- CanActivateChild 守卫（检查子路由的访问权限）。\n- CanDeactivate 守卫（询问是否丢弃未保存的更改）。\n- Resolve 守卫（预先获取路由数据）。\n- 惰性加载特性模块。\n- CanLoad 守卫（在加载特性模块之前进行检查）。\n\n\n学习参考：\n\n- https://angular.cn/guide/router#base-href\n    \n\n     \n    \n    ","source":"_posts/angular-router.md","raw":"---\ntitle: angular路由与导航\ndate: 2019-11-10 11:03:49\ncategories: angular\ntags:\n---\n\n在用户使用应用程序时，Angular 的路由器能让用户从一个视图导航到另一个视图。   \n浏览器具有熟悉的导航模式：\n\n- 在地址栏输入 URL，浏览器就会导航到相应的页面。\n- 在页面中点击链接，浏览器就会导航到一个新页面。\n- 点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。\n\n\n## 基础知识\n\n#### <base href> 元素\n\n大多数带路由的应用都要在index.html的 <head> 标签下先添加一个 <base> 元素，来告诉路由器该如何合成导航用的 URL。\n\n设置src/index.html (base-href)\n\n     <!DOCTYPE html>\n     <html lang=\"en\">\n       <head>\n         <!-- Set the base href -->\n         <base href=\"/\">\n         <title>Angular Router</title>\n         <meta charset=\"UTF-8\">\n         <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n       </head>\n     \n       <body>\n         <app-root></app-root>\n       </body>\n     \n     </html>\n     \n#### 导入路由模块\n\n在src/app/app-routing.module.ts 导入路由模块\n\n    import { RouterModule, Routes } from '@angular/router';\n    \n#### 配置路由\n\n在src/app/app-routing.module.ts (excerpt)中配置路由：\n\n    const appRoutes: Routes = [\n      { path: 'crisis-center', component: CrisisListComponent },\n      { path: 'hero/:id',      component: HeroDetailComponent },\n      {\n        path: 'heroes',\n        component: HeroListComponent,\n        data: { title: 'Heroes List' }\n      },\n      { path: '',\n        redirectTo: '/heroes',\n        pathMatch: 'full'\n      },\n      { path: '**', component: PageNotFoundComponent }\n    ];\n    \n    @NgModule({\n      imports: [\n        RouterModule.forRoot(\n          appRoutes,\n          { enableTracing: true } // 测试环境才打开\n        )\n        // other imports here\n      ],\n      ...\n    })\n    export class AppModule { }\n    \n以上定义一个路由器数组，里面五个路由信息。并用 RouterModule.forRoot() 方法来配置路由器， 并把它的返回值添加到 AppModule 的 imports 数组中。 \n\n这里的路由数组 appRoutes 描述如何进行导航。 把它传给 RouterModule.forRoot() 方法并传给本模块的 imports 数组就可以配置路由器。    \n\n每个路由都会把一个URL的path映射到一个具体的组件。注意，path不能以`斜杆`开头。 路由器会为解析和构建最终的 URL，这样当你在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。\n\n第二个路由中的:id是一个路由参数，后面章节会有更多介绍。\n\n第三个路由中的 data 属性用来存放于每个具体路由有关的任意信息。该数据可以被任何一个激活路由访问，并能用来保存诸如 页标题、面包屑以及其它静态只读数据。如何获取这些存放的信息，后面介绍。 \n\n第四个路由中的空路径（''）表示应用的默认路径，当 URL 为空时就会访问那里，因此它通常会作为起点。 这个默认路由会重定向到 URL /heroes。\n\n最后一个路由中的 ** 路径是一个通配符。当所请求的 URL 不匹配前面定义的路由表中的任何路径时，路由器就会选择此路由。 这个特性可用于显示“404 - Not Found”页，或自动重定向到其它路由。\n\n这些路由的定义顺序是刻意如此设计的。路由器使用先匹配者优先的策略来匹配路由，所以，具体路由应该放在通用路由的前面。在上面的配置中，带静态路径的路由被放在了前面，后面是空路径路由，因此它会作为默认路由。而通配符路由被放在最后面，这是因为它能匹配上每一个 URL，因此应该只有在前面找不到其它能匹配的路由时才匹配它。\n\n如果你想要看到在导航的生命周期中发生过哪些事件，可以使用路由器默认配置中的 enableTracing 选项。它会把每个导航生命周期中的事件输出到浏览器的控制台。 这应该只用于调试。你只需要把 enableTracing: true 选项作为第二个参数传给 RouterModule.forRoot() 方法就可以了。\n\n#### 路由出口\n\nRouterOutlet是一个来自路由模块的一个指令，用法类似组件。它扮演一个占位符的角色，用于在模板中标出一个位置，路由将会把要显示在这个出口处的组件显示在这里。\n\n    <router-outlet></router-outlet>\n    <!-- Routed components go here -->\n    \n有了这份配置，当本应用在浏览器中的 URL 变为 /heroes 时，路由器就会匹配到 path 为 heroes 的 Route，并在宿主视图中的RouterOutlet之后显示 HeroListComponent 组件。\n\n   \n#### 路由器链接\n\n在地址栏输入对应路由，能导航到相应页面。但多数时候，路由导航是用户操作的结果，查看下面例子：\n\n    <h1>Angular Router</h1>\n    <nav>\n      <a routerLink=\"/crisis-center\" routerLinkActive=\"active\">Crisis Center</a>\n      <a routerLink=\"/heroes\" routerLinkActive=\"active\">Heroes</a>\n    </nav>\n    <router-outlet></router-outlet>\n    \na 标签上的 RouterLink 指令让路由器得以控制这个 a 元素。 这里的导航路径是固定的，因此可以把一个字符串赋给 routerLink（“一次性”绑定）。\n\n#### 路由链接的激活状态\n\nRouterLinkActive 指令会基于当前的 RouterState 为活动的 RouterLink 切换所绑定的 css 类。\n\n#### 路由器状态\n\n在导航时的每个生命周期成功完成时，路由器会构建出一个 ActivatedRoute 组成的树，它表示路由器的当前状态。 你可以在应用中的任何地方用 Router 服务及其 routerState 属性来访问当前的 RouterState 值。\n\nRouterState 中的每个 ActivatedRoute 都提供了从任意激活路由开始向上或向下遍历路由树的一种方式，以获得关于父、子、兄弟路由的信息。\n\n#### 激活的路由\n\n该路由的路径和参数可以通过注入进来的一个名叫ActivatedRoute的路由服务来获取。\n\n#### 路由事件\n\n在每次导航中，Router 都会通过 Router.events 属性发布一些导航事件。这些事件的范围涵盖了从开始导航到结束导航之间的很多时间点。下表中列出了全部导航事件：\n\n#### 总结\n\n该应用有一个配置过的路由器。 外壳组件中有一个 RouterOutlet，它能显示路由器所生成的视图。 它还有一些 RouterLink，用户可以点击它们，来通过路由器进行导航。\n\n下面是一些路由器中的关键词汇及其含义：\n\n|  路由器部件   | 含义 |\n| :------: |:-----:|\n| Router（路由器） | 为激活的 URL 显示应用组件。管理从一个组件到另一个组件的导航 |\n|RouterModule | 一个独立的 NgModule，用于提供所需的服务提供商，以及用来在应用视图之间进行导航的指令。 |\n| Routes（路由数组） | 定义了一个路由数组，每一个都会把一个 URL 路径映射到一个组件。 |\n| Route（路由） | 定义路由器该如何根据 URL 模式（pattern）来导航到组件。大多数路由都由路径和组件类构成。 |\n| RouterOutlet（路由出口） | 该指令（<router-outlet>）用来标记出路由器该在哪里显示视图。 |\n|RouterLink（路由链接）|这个指令把可点击的 HTML 元素绑定到某个路由。点击带有 routerLink 指令（绑定到字符串或链接参数数组）的元素时就会触发一次导航。|\n|RouterLinkActive（活动路由链接）|当 HTML 元素上或元素内的routerLink变为激活或非激活状态时，该指令为这个 HTML 元素添加或移除 CSS 类。|\n|ActivatedRoute（激活的路由）|为每个路由组件提供提供的一个服务，它包含特定于路由的信息，比如路由参数、静态数据、解析数据、全局查询参数和全局碎片（fragment）。|\n|RouterState（路由器状态）|路由器的当前状态包含了一棵由程序中激活的路由构成的树。它包含一些用于遍历路由树的快捷方法。|\n|链接参数数组|这个数组会被路由器解释成一个路由操作指南。你可以把一个RouterLink绑定到该数组，或者把它作为参数传给Router.navigate方法。|\n|路由组件|一个带有RouterOutlet的 Angular 组件，它根据路由器的导航来显示相应的视图。|\n\n## 范例应用\n\n下面讲解如何开发一个带路由的多页面小应用。涉及到下面一些决策：\n\n- 把应用的各个特性组织成模块。\n- 导航到组件（Heroes 链接到“英雄列表”组件）。\n- 包含一个路由参数（当路由到“英雄详情”时，把该英雄的 id 传进去）。\n- 子路由（危机中心特性有一组自己的路由）。\n- CanActivate 守卫（检查路由的访问权限）。\n- CanActivateChild 守卫（检查子路由的访问权限）。\n- CanDeactivate 守卫（询问是否丢弃未保存的更改）。\n- Resolve 守卫（预先获取路由数据）。\n- 惰性加载特性模块。\n- CanLoad 守卫（在加载特性模块之前进行检查）。\n\n\n学习参考：\n\n- https://angular.cn/guide/router#base-href\n    \n\n     \n    \n    ","slug":"angular-router","published":1,"updated":"2019-11-10T12:02:42.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqa7000eg4vanaodg0ew","content":"<p>在用户使用应用程序时，Angular 的路由器能让用户从一个视图导航到另一个视图。<br>浏览器具有熟悉的导航模式：</p>\n<ul>\n<li>在地址栏输入 URL，浏览器就会导航到相应的页面。</li>\n<li>在页面中点击链接，浏览器就会导航到一个新页面。</li>\n<li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li>\n</ul>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h4 id=\"元素\"><a href=\"#元素\" class=\"headerlink\" title=\" 元素\"></a><base href=\"\"> 元素</h4><p>大多数带路由的应用都要在index.html的 <head><meta name=\"generator\" content=\"Hexo 3.8.0\"> 标签下先添加一个 <base> 元素，来告诉路由器该如何合成导航用的 URL。</head></p>\n<p>设置src/index.html (base-href)</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;!-- Set the base href --&gt;\n    &lt;base href=&quot;/&quot;&gt;\n    &lt;title&gt;Angular Router&lt;/title&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;app-root&gt;&lt;/app-root&gt;\n  &lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre><h4 id=\"导入路由模块\"><a href=\"#导入路由模块\" class=\"headerlink\" title=\"导入路由模块\"></a>导入路由模块</h4><p>在src/app/app-routing.module.ts 导入路由模块</p>\n<pre><code>import { RouterModule, Routes } from &apos;@angular/router&apos;;\n</code></pre><h4 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h4><p>在src/app/app-routing.module.ts (excerpt)中配置路由：</p>\n<pre><code>const appRoutes: Routes = [\n  { path: &apos;crisis-center&apos;, component: CrisisListComponent },\n  { path: &apos;hero/:id&apos;,      component: HeroDetailComponent },\n  {\n    path: &apos;heroes&apos;,\n    component: HeroListComponent,\n    data: { title: &apos;Heroes List&apos; }\n  },\n  { path: &apos;&apos;,\n    redirectTo: &apos;/heroes&apos;,\n    pathMatch: &apos;full&apos;\n  },\n  { path: &apos;**&apos;, component: PageNotFoundComponent }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // 测试环境才打开\n    )\n    // other imports here\n  ],\n  ...\n})\nexport class AppModule { }\n</code></pre><p>以上定义一个路由器数组，里面五个路由信息。并用 RouterModule.forRoot() 方法来配置路由器， 并把它的返回值添加到 AppModule 的 imports 数组中。 </p>\n<p>这里的路由数组 appRoutes 描述如何进行导航。 把它传给 RouterModule.forRoot() 方法并传给本模块的 imports 数组就可以配置路由器。    </p>\n<p>每个路由都会把一个URL的path映射到一个具体的组件。注意，path不能以<code>斜杆</code>开头。 路由器会为解析和构建最终的 URL，这样当你在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。</p>\n<p>第二个路由中的:id是一个路由参数，后面章节会有更多介绍。</p>\n<p>第三个路由中的 data 属性用来存放于每个具体路由有关的任意信息。该数据可以被任何一个激活路由访问，并能用来保存诸如 页标题、面包屑以及其它静态只读数据。如何获取这些存放的信息，后面介绍。 </p>\n<p>第四个路由中的空路径（’’）表示应用的默认路径，当 URL 为空时就会访问那里，因此它通常会作为起点。 这个默认路由会重定向到 URL /heroes。</p>\n<p>最后一个路由中的 ** 路径是一个通配符。当所请求的 URL 不匹配前面定义的路由表中的任何路径时，路由器就会选择此路由。 这个特性可用于显示“404 - Not Found”页，或自动重定向到其它路由。</p>\n<p>这些路由的定义顺序是刻意如此设计的。路由器使用先匹配者优先的策略来匹配路由，所以，具体路由应该放在通用路由的前面。在上面的配置中，带静态路径的路由被放在了前面，后面是空路径路由，因此它会作为默认路由。而通配符路由被放在最后面，这是因为它能匹配上每一个 URL，因此应该只有在前面找不到其它能匹配的路由时才匹配它。</p>\n<p>如果你想要看到在导航的生命周期中发生过哪些事件，可以使用路由器默认配置中的 enableTracing 选项。它会把每个导航生命周期中的事件输出到浏览器的控制台。 这应该只用于调试。你只需要把 enableTracing: true 选项作为第二个参数传给 RouterModule.forRoot() 方法就可以了。</p>\n<h4 id=\"路由出口\"><a href=\"#路由出口\" class=\"headerlink\" title=\"路由出口\"></a>路由出口</h4><p>RouterOutlet是一个来自路由模块的一个指令，用法类似组件。它扮演一个占位符的角色，用于在模板中标出一个位置，路由将会把要显示在这个出口处的组件显示在这里。</p>\n<pre><code>&lt;router-outlet&gt;&lt;/router-outlet&gt;\n&lt;!-- Routed components go here --&gt;\n</code></pre><p>有了这份配置，当本应用在浏览器中的 URL 变为 /heroes 时，路由器就会匹配到 path 为 heroes 的 Route，并在宿主视图中的RouterOutlet之后显示 HeroListComponent 组件。</p>\n<h4 id=\"路由器链接\"><a href=\"#路由器链接\" class=\"headerlink\" title=\"路由器链接\"></a>路由器链接</h4><p>在地址栏输入对应路由，能导航到相应页面。但多数时候，路由导航是用户操作的结果，查看下面例子：</p>\n<pre><code>&lt;h1&gt;Angular Router&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;\n  &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n</code></pre><p>a 标签上的 RouterLink 指令让路由器得以控制这个 a 元素。 这里的导航路径是固定的，因此可以把一个字符串赋给 routerLink（“一次性”绑定）。</p>\n<h4 id=\"路由链接的激活状态\"><a href=\"#路由链接的激活状态\" class=\"headerlink\" title=\"路由链接的激活状态\"></a>路由链接的激活状态</h4><p>RouterLinkActive 指令会基于当前的 RouterState 为活动的 RouterLink 切换所绑定的 css 类。</p>\n<h4 id=\"路由器状态\"><a href=\"#路由器状态\" class=\"headerlink\" title=\"路由器状态\"></a>路由器状态</h4><p>在导航时的每个生命周期成功完成时，路由器会构建出一个 ActivatedRoute 组成的树，它表示路由器的当前状态。 你可以在应用中的任何地方用 Router 服务及其 routerState 属性来访问当前的 RouterState 值。</p>\n<p>RouterState 中的每个 ActivatedRoute 都提供了从任意激活路由开始向上或向下遍历路由树的一种方式，以获得关于父、子、兄弟路由的信息。</p>\n<h4 id=\"激活的路由\"><a href=\"#激活的路由\" class=\"headerlink\" title=\"激活的路由\"></a>激活的路由</h4><p>该路由的路径和参数可以通过注入进来的一个名叫ActivatedRoute的路由服务来获取。</p>\n<h4 id=\"路由事件\"><a href=\"#路由事件\" class=\"headerlink\" title=\"路由事件\"></a>路由事件</h4><p>在每次导航中，Router 都会通过 Router.events 属性发布一些导航事件。这些事件的范围涵盖了从开始导航到结束导航之间的很多时间点。下表中列出了全部导航事件：</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>该应用有一个配置过的路由器。 外壳组件中有一个 RouterOutlet，它能显示路由器所生成的视图。 它还有一些 RouterLink，用户可以点击它们，来通过路由器进行导航。</p>\n<p>下面是一些路由器中的关键词汇及其含义：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">路由器部件</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Router（路由器）</td>\n<td style=\"text-align:center\">为激活的 URL 显示应用组件。管理从一个组件到另一个组件的导航</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterModule</td>\n<td style=\"text-align:center\">一个独立的 NgModule，用于提供所需的服务提供商，以及用来在应用视图之间进行导航的指令。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Routes（路由数组）</td>\n<td style=\"text-align:center\">定义了一个路由数组，每一个都会把一个 URL 路径映射到一个组件。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Route（路由）</td>\n<td style=\"text-align:center\">定义路由器该如何根据 URL 模式（pattern）来导航到组件。大多数路由都由路径和组件类构成。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterOutlet（路由出口）</td>\n<td style=\"text-align:center\">该指令（<router-outlet>）用来标记出路由器该在哪里显示视图。</router-outlet></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterLink（路由链接）</td>\n<td style=\"text-align:center\">这个指令把可点击的 HTML 元素绑定到某个路由。点击带有 routerLink 指令（绑定到字符串或链接参数数组）的元素时就会触发一次导航。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterLinkActive（活动路由链接）</td>\n<td style=\"text-align:center\">当 HTML 元素上或元素内的routerLink变为激活或非激活状态时，该指令为这个 HTML 元素添加或移除 CSS 类。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ActivatedRoute（激活的路由）</td>\n<td style=\"text-align:center\">为每个路由组件提供提供的一个服务，它包含特定于路由的信息，比如路由参数、静态数据、解析数据、全局查询参数和全局碎片（fragment）。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterState（路由器状态）</td>\n<td style=\"text-align:center\">路由器的当前状态包含了一棵由程序中激活的路由构成的树。它包含一些用于遍历路由树的快捷方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">链接参数数组</td>\n<td style=\"text-align:center\">这个数组会被路由器解释成一个路由操作指南。你可以把一个RouterLink绑定到该数组，或者把它作为参数传给Router.navigate方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">路由组件</td>\n<td style=\"text-align:center\">一个带有RouterOutlet的 Angular 组件，它根据路由器的导航来显示相应的视图。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"范例应用\"><a href=\"#范例应用\" class=\"headerlink\" title=\"范例应用\"></a>范例应用</h2><p>下面讲解如何开发一个带路由的多页面小应用。涉及到下面一些决策：</p>\n<ul>\n<li>把应用的各个特性组织成模块。</li>\n<li>导航到组件（Heroes 链接到“英雄列表”组件）。</li>\n<li>包含一个路由参数（当路由到“英雄详情”时，把该英雄的 id 传进去）。</li>\n<li>子路由（危机中心特性有一组自己的路由）。</li>\n<li>CanActivate 守卫（检查路由的访问权限）。</li>\n<li>CanActivateChild 守卫（检查子路由的访问权限）。</li>\n<li>CanDeactivate 守卫（询问是否丢弃未保存的更改）。</li>\n<li>Resolve 守卫（预先获取路由数据）。</li>\n<li>惰性加载特性模块。</li>\n<li>CanLoad 守卫（在加载特性模块之前进行检查）。</li>\n</ul>\n<p>学习参考：</p>\n<ul>\n<li><a href=\"https://angular.cn/guide/router#base-href\" target=\"_blank\" rel=\"noopener\">https://angular.cn/guide/router#base-href</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>在用户使用应用程序时，Angular 的路由器能让用户从一个视图导航到另一个视图。<br>浏览器具有熟悉的导航模式：</p>\n<ul>\n<li>在地址栏输入 URL，浏览器就会导航到相应的页面。</li>\n<li>在页面中点击链接，浏览器就会导航到一个新页面。</li>\n<li>点击浏览器的前进和后退按钮，浏览器就会在你的浏览历史中向前或向后导航。</li>\n</ul>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h4 id=\"元素\"><a href=\"#元素\" class=\"headerlink\" title=\" 元素\"></a><base href=\"\"> 元素</h4><p>大多数带路由的应用都要在index.html的 <head><meta name=\"generator\" content=\"Hexo 3.8.0\"> 标签下先添加一个 <base> 元素，来告诉路由器该如何合成导航用的 URL。</head></p>\n<p>设置src/index.html (base-href)</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n  &lt;head&gt;\n    &lt;!-- Set the base href --&gt;\n    &lt;base href=&quot;/&quot;&gt;\n    &lt;title&gt;Angular Router&lt;/title&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;\n  &lt;/head&gt;\n\n  &lt;body&gt;\n    &lt;app-root&gt;&lt;/app-root&gt;\n  &lt;/body&gt;\n\n&lt;/html&gt;\n</code></pre><h4 id=\"导入路由模块\"><a href=\"#导入路由模块\" class=\"headerlink\" title=\"导入路由模块\"></a>导入路由模块</h4><p>在src/app/app-routing.module.ts 导入路由模块</p>\n<pre><code>import { RouterModule, Routes } from &apos;@angular/router&apos;;\n</code></pre><h4 id=\"配置路由\"><a href=\"#配置路由\" class=\"headerlink\" title=\"配置路由\"></a>配置路由</h4><p>在src/app/app-routing.module.ts (excerpt)中配置路由：</p>\n<pre><code>const appRoutes: Routes = [\n  { path: &apos;crisis-center&apos;, component: CrisisListComponent },\n  { path: &apos;hero/:id&apos;,      component: HeroDetailComponent },\n  {\n    path: &apos;heroes&apos;,\n    component: HeroListComponent,\n    data: { title: &apos;Heroes List&apos; }\n  },\n  { path: &apos;&apos;,\n    redirectTo: &apos;/heroes&apos;,\n    pathMatch: &apos;full&apos;\n  },\n  { path: &apos;**&apos;, component: PageNotFoundComponent }\n];\n\n@NgModule({\n  imports: [\n    RouterModule.forRoot(\n      appRoutes,\n      { enableTracing: true } // 测试环境才打开\n    )\n    // other imports here\n  ],\n  ...\n})\nexport class AppModule { }\n</code></pre><p>以上定义一个路由器数组，里面五个路由信息。并用 RouterModule.forRoot() 方法来配置路由器， 并把它的返回值添加到 AppModule 的 imports 数组中。 </p>\n<p>这里的路由数组 appRoutes 描述如何进行导航。 把它传给 RouterModule.forRoot() 方法并传给本模块的 imports 数组就可以配置路由器。    </p>\n<p>每个路由都会把一个URL的path映射到一个具体的组件。注意，path不能以<code>斜杆</code>开头。 路由器会为解析和构建最终的 URL，这样当你在应用的多个视图之间导航时，可以任意使用相对路径和绝对路径。</p>\n<p>第二个路由中的:id是一个路由参数，后面章节会有更多介绍。</p>\n<p>第三个路由中的 data 属性用来存放于每个具体路由有关的任意信息。该数据可以被任何一个激活路由访问，并能用来保存诸如 页标题、面包屑以及其它静态只读数据。如何获取这些存放的信息，后面介绍。 </p>\n<p>第四个路由中的空路径（’’）表示应用的默认路径，当 URL 为空时就会访问那里，因此它通常会作为起点。 这个默认路由会重定向到 URL /heroes。</p>\n<p>最后一个路由中的 ** 路径是一个通配符。当所请求的 URL 不匹配前面定义的路由表中的任何路径时，路由器就会选择此路由。 这个特性可用于显示“404 - Not Found”页，或自动重定向到其它路由。</p>\n<p>这些路由的定义顺序是刻意如此设计的。路由器使用先匹配者优先的策略来匹配路由，所以，具体路由应该放在通用路由的前面。在上面的配置中，带静态路径的路由被放在了前面，后面是空路径路由，因此它会作为默认路由。而通配符路由被放在最后面，这是因为它能匹配上每一个 URL，因此应该只有在前面找不到其它能匹配的路由时才匹配它。</p>\n<p>如果你想要看到在导航的生命周期中发生过哪些事件，可以使用路由器默认配置中的 enableTracing 选项。它会把每个导航生命周期中的事件输出到浏览器的控制台。 这应该只用于调试。你只需要把 enableTracing: true 选项作为第二个参数传给 RouterModule.forRoot() 方法就可以了。</p>\n<h4 id=\"路由出口\"><a href=\"#路由出口\" class=\"headerlink\" title=\"路由出口\"></a>路由出口</h4><p>RouterOutlet是一个来自路由模块的一个指令，用法类似组件。它扮演一个占位符的角色，用于在模板中标出一个位置，路由将会把要显示在这个出口处的组件显示在这里。</p>\n<pre><code>&lt;router-outlet&gt;&lt;/router-outlet&gt;\n&lt;!-- Routed components go here --&gt;\n</code></pre><p>有了这份配置，当本应用在浏览器中的 URL 变为 /heroes 时，路由器就会匹配到 path 为 heroes 的 Route，并在宿主视图中的RouterOutlet之后显示 HeroListComponent 组件。</p>\n<h4 id=\"路由器链接\"><a href=\"#路由器链接\" class=\"headerlink\" title=\"路由器链接\"></a>路由器链接</h4><p>在地址栏输入对应路由，能导航到相应页面。但多数时候，路由导航是用户操作的结果，查看下面例子：</p>\n<pre><code>&lt;h1&gt;Angular Router&lt;/h1&gt;\n&lt;nav&gt;\n  &lt;a routerLink=&quot;/crisis-center&quot; routerLinkActive=&quot;active&quot;&gt;Crisis Center&lt;/a&gt;\n  &lt;a routerLink=&quot;/heroes&quot; routerLinkActive=&quot;active&quot;&gt;Heroes&lt;/a&gt;\n&lt;/nav&gt;\n&lt;router-outlet&gt;&lt;/router-outlet&gt;\n</code></pre><p>a 标签上的 RouterLink 指令让路由器得以控制这个 a 元素。 这里的导航路径是固定的，因此可以把一个字符串赋给 routerLink（“一次性”绑定）。</p>\n<h4 id=\"路由链接的激活状态\"><a href=\"#路由链接的激活状态\" class=\"headerlink\" title=\"路由链接的激活状态\"></a>路由链接的激活状态</h4><p>RouterLinkActive 指令会基于当前的 RouterState 为活动的 RouterLink 切换所绑定的 css 类。</p>\n<h4 id=\"路由器状态\"><a href=\"#路由器状态\" class=\"headerlink\" title=\"路由器状态\"></a>路由器状态</h4><p>在导航时的每个生命周期成功完成时，路由器会构建出一个 ActivatedRoute 组成的树，它表示路由器的当前状态。 你可以在应用中的任何地方用 Router 服务及其 routerState 属性来访问当前的 RouterState 值。</p>\n<p>RouterState 中的每个 ActivatedRoute 都提供了从任意激活路由开始向上或向下遍历路由树的一种方式，以获得关于父、子、兄弟路由的信息。</p>\n<h4 id=\"激活的路由\"><a href=\"#激活的路由\" class=\"headerlink\" title=\"激活的路由\"></a>激活的路由</h4><p>该路由的路径和参数可以通过注入进来的一个名叫ActivatedRoute的路由服务来获取。</p>\n<h4 id=\"路由事件\"><a href=\"#路由事件\" class=\"headerlink\" title=\"路由事件\"></a>路由事件</h4><p>在每次导航中，Router 都会通过 Router.events 属性发布一些导航事件。这些事件的范围涵盖了从开始导航到结束导航之间的很多时间点。下表中列出了全部导航事件：</p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>该应用有一个配置过的路由器。 外壳组件中有一个 RouterOutlet，它能显示路由器所生成的视图。 它还有一些 RouterLink，用户可以点击它们，来通过路由器进行导航。</p>\n<p>下面是一些路由器中的关键词汇及其含义：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">路由器部件</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Router（路由器）</td>\n<td style=\"text-align:center\">为激活的 URL 显示应用组件。管理从一个组件到另一个组件的导航</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterModule</td>\n<td style=\"text-align:center\">一个独立的 NgModule，用于提供所需的服务提供商，以及用来在应用视图之间进行导航的指令。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Routes（路由数组）</td>\n<td style=\"text-align:center\">定义了一个路由数组，每一个都会把一个 URL 路径映射到一个组件。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Route（路由）</td>\n<td style=\"text-align:center\">定义路由器该如何根据 URL 模式（pattern）来导航到组件。大多数路由都由路径和组件类构成。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterOutlet（路由出口）</td>\n<td style=\"text-align:center\">该指令（<router-outlet>）用来标记出路由器该在哪里显示视图。</router-outlet></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterLink（路由链接）</td>\n<td style=\"text-align:center\">这个指令把可点击的 HTML 元素绑定到某个路由。点击带有 routerLink 指令（绑定到字符串或链接参数数组）的元素时就会触发一次导航。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterLinkActive（活动路由链接）</td>\n<td style=\"text-align:center\">当 HTML 元素上或元素内的routerLink变为激活或非激活状态时，该指令为这个 HTML 元素添加或移除 CSS 类。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">ActivatedRoute（激活的路由）</td>\n<td style=\"text-align:center\">为每个路由组件提供提供的一个服务，它包含特定于路由的信息，比如路由参数、静态数据、解析数据、全局查询参数和全局碎片（fragment）。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">RouterState（路由器状态）</td>\n<td style=\"text-align:center\">路由器的当前状态包含了一棵由程序中激活的路由构成的树。它包含一些用于遍历路由树的快捷方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">链接参数数组</td>\n<td style=\"text-align:center\">这个数组会被路由器解释成一个路由操作指南。你可以把一个RouterLink绑定到该数组，或者把它作为参数传给Router.navigate方法。</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">路由组件</td>\n<td style=\"text-align:center\">一个带有RouterOutlet的 Angular 组件，它根据路由器的导航来显示相应的视图。</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"范例应用\"><a href=\"#范例应用\" class=\"headerlink\" title=\"范例应用\"></a>范例应用</h2><p>下面讲解如何开发一个带路由的多页面小应用。涉及到下面一些决策：</p>\n<ul>\n<li>把应用的各个特性组织成模块。</li>\n<li>导航到组件（Heroes 链接到“英雄列表”组件）。</li>\n<li>包含一个路由参数（当路由到“英雄详情”时，把该英雄的 id 传进去）。</li>\n<li>子路由（危机中心特性有一组自己的路由）。</li>\n<li>CanActivate 守卫（检查路由的访问权限）。</li>\n<li>CanActivateChild 守卫（检查子路由的访问权限）。</li>\n<li>CanDeactivate 守卫（询问是否丢弃未保存的更改）。</li>\n<li>Resolve 守卫（预先获取路由数据）。</li>\n<li>惰性加载特性模块。</li>\n<li>CanLoad 守卫（在加载特性模块之前进行检查）。</li>\n</ul>\n<p>学习参考：</p>\n<ul>\n<li><a href=\"https://angular.cn/guide/router#base-href\" target=\"_blank\" rel=\"noopener\">https://angular.cn/guide/router#base-href</a></li>\n</ul>\n"},{"title":"apidoc在spring-mvc中实践","date":"2017-09-24T15:01:49.000Z","_content":"\n官网：http://apidocjs.com/\n","source":"_posts/apidoc-java.md","raw":"---\ntitle: apidoc在spring-mvc中实践\ndate: 2017-09-24 23:01:49\ncategories: api-manage\ntags: apidoc\n---\n\n官网：http://apidocjs.com/\n","slug":"apidoc-java","published":1,"updated":"2019-06-16T14:38:33.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqaa000fg4va4bpcrxt0","content":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"noopener\">http://apidocjs.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"noopener\">http://apidocjs.com/</a></p>\n"},{"title":"rest-api版本迭代管理实践","date":"2017-09-26T06:23:44.000Z","_content":"\n在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。  \n因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  \n\n通常，restful-api的版本迭代实现方式主要又两种：\n\n- 在url中显示设置，如：`https://api.example.com/v1/`。\n- 在http请求头中添加，如：\n        \n        设置请求头：\n        Content-Version: 1\n        \n        请求:\n        https://api.example.com\n \n-------------------------------------------------------------\n \n首先，建立spring-boot-web项目：\n\n{% asset_img a.png %}\n \n        \n## 在请求头中设置\n\n1.创建注解类ApiVersion\n在controller中添加注解标志api版本\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.bind.annotation.Mapping;\n    \n    import java.lang.annotation.*;\n    \n    /**\n     * \n     * 接口版本标识注解\n     *\n     */\n    @Target({ElementType.METHOD, ElementType.TYPE})\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @Mapping\n    public @interface ApiVersion {\n        int value();\n    }\n\n2.创建处理类ApiVersionCondition\n继承RequestCondition，每次url请求都会首先进入该方法。\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import java.util.regex.Pattern;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        private int apiVersion;\n    \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n    \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        \tString path = request.getServletPath();\n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n    \t\tString contentVersion = request.getHeader(\"Content-Version\"); //在http请求头中定义api版本，而不是在url中\n            if (null == contentVersion || \"\".equals(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version非null非空\");\n            }\n            if (!isInteger(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version必须为整数\");\n            }\n    \n            int version = Integer.valueOf(contentVersion).intValue();\n            if(version >= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n        /**\n         * 判断字符串是否为整数。\n         * @param str\n         * @return\n         */\n        private boolean isInteger(String str) {\n            Pattern pattern = Pattern.compile(\"^[-\\\\+]?[\\\\d]*$\");\n            return pattern.matcher(str).matches();\n        }\n    \n    }\n    \n3.自定义url注册回调类CustomRequestMappingHandlerMapping\nurl注解回调句柄类。继承RequestMappingHandlerMapping。\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 类。\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        /**\n         * 方法\n         * @param method\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n    \n\n4.创建web配置类并编辑内容：WebConfig\n配置自定义类RequestMappingHandlerMapping。\n    \n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    @Configuration\n    public class WebConfig extends WebMvcConfigurationSupport{\n    \n        @Override\n        @Bean\n        public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n            RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n            handlerMapping.setOrder(0);\n            handlerMapping.setInterceptors(getInterceptors()); \n            return handlerMapping;\n        }\n        \n    }\n\n5.创建演示类HelloController\n\n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.ApiVersion;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    import org.springframework.web.bind.annotation.RequestMethod;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    @RestController\n    @RequestMapping\n    public class HelloController {\n    \t\n    \t//---------------- api版本管理 demo start ------------------//\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        public String hello0(HttpServletRequest request){\n            print(request);\n            return \"hello\";\n        }\n    \n    \t@RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(1)\n        public String hello1(HttpServletRequest request){\n            print(request);\n            return \"hello:v1\";\n        }\n    \n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(5)\n        public String hello5(HttpServletRequest request){\n            print(request);\n            return \"hello:v5\";\n        }\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(2)\n        public String hello2(HttpServletRequest request){\n            print(request);\n            return \"hello:v2\";\n        }\n    \n        private void print(HttpServletRequest request) {\n            System.out.println(\"version:\" + request.getHeader(\"Content-Version\"));\n        }\n        \n    }    \n\n6.演示：\n\n{% asset_img b.png %}\n\n------------------------------\n\n{% asset_img c.png %}\n    \n\n## 在url中显示设置\n\n在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 \n\n1.修改CustomRequestMappingHandlerMapping类。\n只需要重写方法：\n\n    /**\n     * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set<String> s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(\"\");\n            if (s != null && !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!\"/error\".equals(str)) {\n                        pathNew.append(\"/{version}\");\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n        \n    -----------------------------------------------------\n        \n    完整代码如下：    \n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.RequestMappingInfo;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    import java.util.Set;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n         * 不用在每个类或方法的@RequestMapping中加。\n         * @param method\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n            RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n            if (requestMappingInfo != null) {\n                PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n                Set<String> s = pcOri.getPatterns();\n                StringBuilder pathNew = new StringBuilder(\"\");\n                if (s != null && !s.isEmpty()) {\n                    for (String str: s ) {\n                        if (!\"/error\".equals(str)) {\n                            pathNew.append(\"/{version}\");\n                            pathNew.append(str);\n                        } else {\n                            pathNew.append(str);\n                        }\n                    }\n                }\n    \n                PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n    \n                RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n    \n                return requestMappingInfoNew;\n    \n            }\n            return requestMappingInfo;\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n\n2.修改类ApiVersionCondition。\n主要修改方法：getMatchingCondition\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n    \n    -----------------------------------------------------------\n    \n    完整代码如下：\n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import java.util.regex.Matcher;\n    import java.util.regex.Pattern;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n        private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(\"v(\\\\d+)/\");\n        \n        private int apiVersion;\n        \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n        \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        \tString path = request.getServletPath(); \n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n            Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n            if(m.find()){\n                Integer version = Integer.valueOf(m.group(1));\n                if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                    return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n    }\n\n3.演示：\n\n{%asset_img d.png%}\n\n--------------------------------------\n\n{%asset_img e.png%}\n\n   ","source":"_posts/api-version.md","raw":"---\ntitle: rest-api版本迭代管理实践\ndate: 2017-09-26 14:23:44\ncategories: api-manage\ntags: api-version-manage,spring-boot中API版本迭代管理\n---\n\n在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。  \n因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  \n\n通常，restful-api的版本迭代实现方式主要又两种：\n\n- 在url中显示设置，如：`https://api.example.com/v1/`。\n- 在http请求头中添加，如：\n        \n        设置请求头：\n        Content-Version: 1\n        \n        请求:\n        https://api.example.com\n \n-------------------------------------------------------------\n \n首先，建立spring-boot-web项目：\n\n{% asset_img a.png %}\n \n        \n## 在请求头中设置\n\n1.创建注解类ApiVersion\n在controller中添加注解标志api版本\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.bind.annotation.Mapping;\n    \n    import java.lang.annotation.*;\n    \n    /**\n     * \n     * 接口版本标识注解\n     *\n     */\n    @Target({ElementType.METHOD, ElementType.TYPE})\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @Mapping\n    public @interface ApiVersion {\n        int value();\n    }\n\n2.创建处理类ApiVersionCondition\n继承RequestCondition，每次url请求都会首先进入该方法。\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import java.util.regex.Pattern;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        private int apiVersion;\n    \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n    \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        \tString path = request.getServletPath();\n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n    \t\tString contentVersion = request.getHeader(\"Content-Version\"); //在http请求头中定义api版本，而不是在url中\n            if (null == contentVersion || \"\".equals(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version非null非空\");\n            }\n            if (!isInteger(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version必须为整数\");\n            }\n    \n            int version = Integer.valueOf(contentVersion).intValue();\n            if(version >= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n        /**\n         * 判断字符串是否为整数。\n         * @param str\n         * @return\n         */\n        private boolean isInteger(String str) {\n            Pattern pattern = Pattern.compile(\"^[-\\\\+]?[\\\\d]*$\");\n            return pattern.matcher(str).matches();\n        }\n    \n    }\n    \n3.自定义url注册回调类CustomRequestMappingHandlerMapping\nurl注解回调句柄类。继承RequestMappingHandlerMapping。\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 类。\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        /**\n         * 方法\n         * @param method\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n    \n\n4.创建web配置类并编辑内容：WebConfig\n配置自定义类RequestMappingHandlerMapping。\n    \n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    @Configuration\n    public class WebConfig extends WebMvcConfigurationSupport{\n    \n        @Override\n        @Bean\n        public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n            RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n            handlerMapping.setOrder(0);\n            handlerMapping.setInterceptors(getInterceptors()); \n            return handlerMapping;\n        }\n        \n    }\n\n5.创建演示类HelloController\n\n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.ApiVersion;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    import org.springframework.web.bind.annotation.RequestMethod;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    @RestController\n    @RequestMapping\n    public class HelloController {\n    \t\n    \t//---------------- api版本管理 demo start ------------------//\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        public String hello0(HttpServletRequest request){\n            print(request);\n            return \"hello\";\n        }\n    \n    \t@RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(1)\n        public String hello1(HttpServletRequest request){\n            print(request);\n            return \"hello:v1\";\n        }\n    \n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(5)\n        public String hello5(HttpServletRequest request){\n            print(request);\n            return \"hello:v5\";\n        }\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(2)\n        public String hello2(HttpServletRequest request){\n            print(request);\n            return \"hello:v2\";\n        }\n    \n        private void print(HttpServletRequest request) {\n            System.out.println(\"version:\" + request.getHeader(\"Content-Version\"));\n        }\n        \n    }    \n\n6.演示：\n\n{% asset_img b.png %}\n\n------------------------------\n\n{% asset_img c.png %}\n    \n\n## 在url中显示设置\n\n在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 \n\n1.修改CustomRequestMappingHandlerMapping类。\n只需要重写方法：\n\n    /**\n     * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set<String> s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(\"\");\n            if (s != null && !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!\"/error\".equals(str)) {\n                        pathNew.append(\"/{version}\");\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n        \n    -----------------------------------------------------\n        \n    完整代码如下：    \n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.RequestMappingInfo;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    import java.util.Set;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n         * 不用在每个类或方法的@RequestMapping中加。\n         * @param method\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n            RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n            if (requestMappingInfo != null) {\n                PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n                Set<String> s = pcOri.getPatterns();\n                StringBuilder pathNew = new StringBuilder(\"\");\n                if (s != null && !s.isEmpty()) {\n                    for (String str: s ) {\n                        if (!\"/error\".equals(str)) {\n                            pathNew.append(\"/{version}\");\n                            pathNew.append(str);\n                        } else {\n                            pathNew.append(str);\n                        }\n                    }\n                }\n    \n                PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n    \n                RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n    \n                return requestMappingInfoNew;\n    \n            }\n            return requestMappingInfo;\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n\n2.修改类ApiVersionCondition。\n主要修改方法：getMatchingCondition\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n    \n    -----------------------------------------------------------\n    \n    完整代码如下：\n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import java.util.regex.Matcher;\n    import java.util.regex.Pattern;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n        private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(\"v(\\\\d+)/\");\n        \n        private int apiVersion;\n        \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n        \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        \tString path = request.getServletPath(); \n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n            Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n            if(m.find()){\n                Integer version = Integer.valueOf(m.group(1));\n                if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                    return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n    }\n\n3.演示：\n\n{%asset_img d.png%}\n\n--------------------------------------\n\n{%asset_img e.png%}\n\n   ","slug":"api-version","published":1,"updated":"2019-06-16T14:38:33.315Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqad000ig4va2mq4o4ph","content":"<p>在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。<br>因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  </p>\n<p>通常，restful-api的版本迭代实现方式主要又两种：</p>\n<ul>\n<li>在url中显示设置，如：<code>https://api.example.com/v1/</code>。</li>\n<li><p>在http请求头中添加，如：</p>\n<pre><code>设置请求头：\nContent-Version: 1\n\n请求:\nhttps://api.example.com\n</code></pre></li>\n</ul>\n<hr>\n<p>首先，建立spring-boot-web项目：</p>\n<img src=\"/2017/09/26/api-version/a.png\">\n<h2 id=\"在请求头中设置\"><a href=\"#在请求头中设置\" class=\"headerlink\" title=\"在请求头中设置\"></a>在请求头中设置</h2><p>1.创建注解类ApiVersion<br>在controller中添加注解标志api版本</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.bind.annotation.Mapping;\n\nimport java.lang.annotation.*;\n\n/**\n * \n * 接口版本标识注解\n *\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Mapping\npublic @interface ApiVersion {\n    int value();\n}\n</code></pre><p>2.创建处理类ApiVersionCondition<br>继承RequestCondition，每次url请求都会首先进入该方法。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.regex.Pattern;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        String path = request.getServletPath();\n        if (path == null) {\n            return null;\n        }\n        String contentVersion = request.getHeader(&quot;Content-Version&quot;); //在http请求头中定义api版本，而不是在url中\n        if (null == contentVersion || &quot;&quot;.equals(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version非null非空&quot;);\n        }\n        if (!isInteger(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version必须为整数&quot;);\n        }\n\n        int version = Integer.valueOf(contentVersion).intValue();\n        if(version &gt;= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n    /**\n     * 判断字符串是否为整数。\n     * @param str\n     * @return\n     */\n    private boolean isInteger(String str) {\n        Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[\\\\d]*$&quot;);\n        return pattern.matcher(str).matches();\n    }\n\n}\n</code></pre><p>3.自定义url注册回调类CustomRequestMappingHandlerMapping<br>url注解回调句柄类。继承RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 类。\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    /**\n     * 方法\n     * @param method\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>4.创建web配置类并编辑内容：WebConfig<br>配置自定义类RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\n@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport{\n\n    @Override\n    @Bean\n    public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n        RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n        handlerMapping.setOrder(0);\n        handlerMapping.setInterceptors(getInterceptors()); \n        return handlerMapping;\n    }\n\n}\n</code></pre><p>5.创建演示类HelloController</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.ApiVersion;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@RestController\n@RequestMapping\npublic class HelloController {\n\n    //---------------- api版本管理 demo start ------------------//\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    public String hello0(HttpServletRequest request){\n        print(request);\n        return &quot;hello&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(1)\n    public String hello1(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v1&quot;;\n    }\n\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(5)\n    public String hello5(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v5&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(2)\n    public String hello2(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v2&quot;;\n    }\n\n    private void print(HttpServletRequest request) {\n        System.out.println(&quot;version:&quot; + request.getHeader(&quot;Content-Version&quot;));\n    }\n\n}    \n</code></pre><p>6.演示：</p>\n<img src=\"/2017/09/26/api-version/b.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/c.png\">\n<h2 id=\"在url中显示设置\"><a href=\"#在url中显示设置\" class=\"headerlink\" title=\"在url中显示设置\"></a>在url中显示设置</h2><p>在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 </p>\n<p>1.修改CustomRequestMappingHandlerMapping类。<br>只需要重写方法：</p>\n<pre><code>/**\n * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n * 不用在每个类或方法的@RequestMapping中加。\n * @param method\n * @param handlerType\n * @return\n */\n@Override\nprotected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n    RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n    if (requestMappingInfo != null) {\n        PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n        Set&lt;String&gt; s = pcOri.getPatterns();\n        StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n        if (s != null &amp;&amp; !s.isEmpty()) {\n            for (String str: s ) {\n                if (!&quot;/error&quot;.equals(str)) {\n                    pathNew.append(&quot;/{version}&quot;);\n                    pathNew.append(str);\n                } else {\n                    pathNew.append(str);\n                }\n            }\n        }\n\n        PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n        RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n        return requestMappingInfoNew;\n\n    }\n    return requestMappingInfo;\n}\n\n-----------------------------------------------------\n\n完整代码如下：    \n\npackage com.ymu.framework.spring.mvc.api;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\nimport java.util.Set;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set&lt;String&gt; s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n            if (s != null &amp;&amp; !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!&quot;/error&quot;.equals(str)) {\n                        pathNew.append(&quot;/{version}&quot;);\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>2.修改类ApiVersionCondition。<br>主要修改方法：getMatchingCondition</p>\n<pre><code>public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n    String path = request.getServletPath(); \n    if (path == null) {\n        return null;\n    }\n    Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n    if(m.find()){\n        Integer version = Integer.valueOf(m.group(1));\n        if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n    }\n    return null;\n}\n\n-----------------------------------------------------------\n\n完整代码如下：\n\npackage com.ymu.framework.spring.mvc.api;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n    private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(&quot;v(\\\\d+)/&quot;);\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n}\n</code></pre><p>3.演示：</p>\n<img src=\"/2017/09/26/api-version/d.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/e.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。<br>因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  </p>\n<p>通常，restful-api的版本迭代实现方式主要又两种：</p>\n<ul>\n<li>在url中显示设置，如：<code>https://api.example.com/v1/</code>。</li>\n<li><p>在http请求头中添加，如：</p>\n<pre><code>设置请求头：\nContent-Version: 1\n\n请求:\nhttps://api.example.com\n</code></pre></li>\n</ul>\n<hr>\n<p>首先，建立spring-boot-web项目：</p>\n<img src=\"/2017/09/26/api-version/a.png\">\n<h2 id=\"在请求头中设置\"><a href=\"#在请求头中设置\" class=\"headerlink\" title=\"在请求头中设置\"></a>在请求头中设置</h2><p>1.创建注解类ApiVersion<br>在controller中添加注解标志api版本</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.bind.annotation.Mapping;\n\nimport java.lang.annotation.*;\n\n/**\n * \n * 接口版本标识注解\n *\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Mapping\npublic @interface ApiVersion {\n    int value();\n}\n</code></pre><p>2.创建处理类ApiVersionCondition<br>继承RequestCondition，每次url请求都会首先进入该方法。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.regex.Pattern;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        String path = request.getServletPath();\n        if (path == null) {\n            return null;\n        }\n        String contentVersion = request.getHeader(&quot;Content-Version&quot;); //在http请求头中定义api版本，而不是在url中\n        if (null == contentVersion || &quot;&quot;.equals(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version非null非空&quot;);\n        }\n        if (!isInteger(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version必须为整数&quot;);\n        }\n\n        int version = Integer.valueOf(contentVersion).intValue();\n        if(version &gt;= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n    /**\n     * 判断字符串是否为整数。\n     * @param str\n     * @return\n     */\n    private boolean isInteger(String str) {\n        Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[\\\\d]*$&quot;);\n        return pattern.matcher(str).matches();\n    }\n\n}\n</code></pre><p>3.自定义url注册回调类CustomRequestMappingHandlerMapping<br>url注解回调句柄类。继承RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 类。\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    /**\n     * 方法\n     * @param method\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>4.创建web配置类并编辑内容：WebConfig<br>配置自定义类RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\n@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport{\n\n    @Override\n    @Bean\n    public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n        RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n        handlerMapping.setOrder(0);\n        handlerMapping.setInterceptors(getInterceptors()); \n        return handlerMapping;\n    }\n\n}\n</code></pre><p>5.创建演示类HelloController</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.ApiVersion;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@RestController\n@RequestMapping\npublic class HelloController {\n\n    //---------------- api版本管理 demo start ------------------//\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    public String hello0(HttpServletRequest request){\n        print(request);\n        return &quot;hello&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(1)\n    public String hello1(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v1&quot;;\n    }\n\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(5)\n    public String hello5(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v5&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(2)\n    public String hello2(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v2&quot;;\n    }\n\n    private void print(HttpServletRequest request) {\n        System.out.println(&quot;version:&quot; + request.getHeader(&quot;Content-Version&quot;));\n    }\n\n}    \n</code></pre><p>6.演示：</p>\n<img src=\"/2017/09/26/api-version/b.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/c.png\">\n<h2 id=\"在url中显示设置\"><a href=\"#在url中显示设置\" class=\"headerlink\" title=\"在url中显示设置\"></a>在url中显示设置</h2><p>在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 </p>\n<p>1.修改CustomRequestMappingHandlerMapping类。<br>只需要重写方法：</p>\n<pre><code>/**\n * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n * 不用在每个类或方法的@RequestMapping中加。\n * @param method\n * @param handlerType\n * @return\n */\n@Override\nprotected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n    RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n    if (requestMappingInfo != null) {\n        PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n        Set&lt;String&gt; s = pcOri.getPatterns();\n        StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n        if (s != null &amp;&amp; !s.isEmpty()) {\n            for (String str: s ) {\n                if (!&quot;/error&quot;.equals(str)) {\n                    pathNew.append(&quot;/{version}&quot;);\n                    pathNew.append(str);\n                } else {\n                    pathNew.append(str);\n                }\n            }\n        }\n\n        PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n        RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n        return requestMappingInfoNew;\n\n    }\n    return requestMappingInfo;\n}\n\n-----------------------------------------------------\n\n完整代码如下：    \n\npackage com.ymu.framework.spring.mvc.api;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\nimport java.util.Set;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set&lt;String&gt; s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n            if (s != null &amp;&amp; !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!&quot;/error&quot;.equals(str)) {\n                        pathNew.append(&quot;/{version}&quot;);\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>2.修改类ApiVersionCondition。<br>主要修改方法：getMatchingCondition</p>\n<pre><code>public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n    String path = request.getServletPath(); \n    if (path == null) {\n        return null;\n    }\n    Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n    if(m.find()){\n        Integer version = Integer.valueOf(m.group(1));\n        if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n    }\n    return null;\n}\n\n-----------------------------------------------------------\n\n完整代码如下：\n\npackage com.ymu.framework.spring.mvc.api;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n    private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(&quot;v(\\\\d+)/&quot;);\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n}\n</code></pre><p>3.演示：</p>\n<img src=\"/2017/09/26/api-version/d.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/e.png\">\n"},{"title":"aws云服务器使用","date":"2018-06-21T06:22:55.000Z","_content":"\n本文记录在使用亚马逊云服务器aws过程中遇到的一些问题……\n\n### 1.登录到aws云服务器\n\n- 下载私钥`*.pem`,放到指定目录下。\n-  给予私钥权限。`chmod 400 .pem`\n- ssh登录。`ssh -i ~/aws-server-key/Seoul-Server-Key.pem ubuntu@13.209.47.139`\n\n### 2.在安全组开放端口\n\n### 3.上传文件aws服务器\n\n- IPv4：\n\n        # chmod 400 /path/my-key-pair.pem\n        # scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~\n        \n- (仅限 IPv6) 或者,您可以使用实例的 IPv6 地址传输文件。IPv6 地址必须用方括号 ([]) 括起,方括号必\n  须转义 (\\)。\n  \n        scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@\n        \\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~\n\n                \n\n_小提示_:  \n对于 Amazon Linux,用户名为 ec2-user。对于 RHEL,用户名称是 ec2-user 或 root。\n对于 Ubuntu,用户名称是 ubuntu 或 root。对于 Centos,用户名称是 centos。对于\nFedora,用户名称是 ec2-user。对于 SUSE,用户名称是 ec2-user 或 root。另外,如果\nec2-user 和 root 无法使用,请与您的 AMI 供应商核实。\n\n### 4.下载文件到本机\n\n- IPv4：\n\n        scp -i /path/my-key-pair.pem ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~/\n        SampleFile.txt ~/SampleFile2.txt\n\n\n- (仅限 IPv6) 或者,您可以使用实例的 IPv6 地址反方向传输文件。\n\n        scp -i /path/my-key-pair.pem ec2-user@\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~/\n        SampleFile.txt ~/SampleFile2.txt\n","source":"_posts/aws-server.md","raw":"---\ntitle: aws云服务器使用\ndate: 2018-06-21 14:22:55\ncategories: aws\ntags: aws云服务器\n---\n\n本文记录在使用亚马逊云服务器aws过程中遇到的一些问题……\n\n### 1.登录到aws云服务器\n\n- 下载私钥`*.pem`,放到指定目录下。\n-  给予私钥权限。`chmod 400 .pem`\n- ssh登录。`ssh -i ~/aws-server-key/Seoul-Server-Key.pem ubuntu@13.209.47.139`\n\n### 2.在安全组开放端口\n\n### 3.上传文件aws服务器\n\n- IPv4：\n\n        # chmod 400 /path/my-key-pair.pem\n        # scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~\n        \n- (仅限 IPv6) 或者,您可以使用实例的 IPv6 地址传输文件。IPv6 地址必须用方括号 ([]) 括起,方括号必\n  须转义 (\\)。\n  \n        scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@\n        \\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~\n\n                \n\n_小提示_:  \n对于 Amazon Linux,用户名为 ec2-user。对于 RHEL,用户名称是 ec2-user 或 root。\n对于 Ubuntu,用户名称是 ubuntu 或 root。对于 Centos,用户名称是 centos。对于\nFedora,用户名称是 ec2-user。对于 SUSE,用户名称是 ec2-user 或 root。另外,如果\nec2-user 和 root 无法使用,请与您的 AMI 供应商核实。\n\n### 4.下载文件到本机\n\n- IPv4：\n\n        scp -i /path/my-key-pair.pem ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~/\n        SampleFile.txt ~/SampleFile2.txt\n\n\n- (仅限 IPv6) 或者,您可以使用实例的 IPv6 地址反方向传输文件。\n\n        scp -i /path/my-key-pair.pem ec2-user@\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~/\n        SampleFile.txt ~/SampleFile2.txt\n","slug":"aws-server","published":1,"updated":"2019-06-16T14:38:33.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqaf000lg4vawfirv1wq","content":"<p>本文记录在使用亚马逊云服务器aws过程中遇到的一些问题……</p>\n<h3 id=\"1-登录到aws云服务器\"><a href=\"#1-登录到aws云服务器\" class=\"headerlink\" title=\"1.登录到aws云服务器\"></a>1.登录到aws云服务器</h3><ul>\n<li>下载私钥<code>*.pem</code>,放到指定目录下。</li>\n<li>给予私钥权限。<code>chmod 400 .pem</code></li>\n<li>ssh登录。<code>ssh -i ~/aws-server-key/Seoul-Server-Key.pem ubuntu@13.209.47.139</code></li>\n</ul>\n<h3 id=\"2-在安全组开放端口\"><a href=\"#2-在安全组开放端口\" class=\"headerlink\" title=\"2.在安全组开放端口\"></a>2.在安全组开放端口</h3><h3 id=\"3-上传文件aws服务器\"><a href=\"#3-上传文件aws服务器\" class=\"headerlink\" title=\"3.上传文件aws服务器\"></a>3.上传文件aws服务器</h3><ul>\n<li><p>IPv4：</p>\n<pre><code># chmod 400 /path/my-key-pair.pem\n# scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~\n</code></pre></li>\n<li><p>(仅限 IPv6) 或者,您可以使用实例的 IPv6 地址传输文件。IPv6 地址必须用方括号 ([]) 括起,方括号必<br>须转义 ()。</p>\n<pre><code>scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@\n\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~\n</code></pre></li>\n</ul>\n<p><em>小提示</em>:<br>对于 Amazon Linux,用户名为 ec2-user。对于 RHEL,用户名称是 ec2-user 或 root。<br>对于 Ubuntu,用户名称是 ubuntu 或 root。对于 Centos,用户名称是 centos。对于<br>Fedora,用户名称是 ec2-user。对于 SUSE,用户名称是 ec2-user 或 root。另外,如果<br>ec2-user 和 root 无法使用,请与您的 AMI 供应商核实。</p>\n<h3 id=\"4-下载文件到本机\"><a href=\"#4-下载文件到本机\" class=\"headerlink\" title=\"4.下载文件到本机\"></a>4.下载文件到本机</h3><ul>\n<li><p>IPv4：</p>\n<pre><code>scp -i /path/my-key-pair.pem ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~/\nSampleFile.txt ~/SampleFile2.txt\n</code></pre></li>\n</ul>\n<ul>\n<li><p>(仅限 IPv6) 或者,您可以使用实例的 IPv6 地址反方向传输文件。</p>\n<pre><code>scp -i /path/my-key-pair.pem ec2-user@\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~/\nSampleFile.txt ~/SampleFile2.txt\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录在使用亚马逊云服务器aws过程中遇到的一些问题……</p>\n<h3 id=\"1-登录到aws云服务器\"><a href=\"#1-登录到aws云服务器\" class=\"headerlink\" title=\"1.登录到aws云服务器\"></a>1.登录到aws云服务器</h3><ul>\n<li>下载私钥<code>*.pem</code>,放到指定目录下。</li>\n<li>给予私钥权限。<code>chmod 400 .pem</code></li>\n<li>ssh登录。<code>ssh -i ~/aws-server-key/Seoul-Server-Key.pem ubuntu@13.209.47.139</code></li>\n</ul>\n<h3 id=\"2-在安全组开放端口\"><a href=\"#2-在安全组开放端口\" class=\"headerlink\" title=\"2.在安全组开放端口\"></a>2.在安全组开放端口</h3><h3 id=\"3-上传文件aws服务器\"><a href=\"#3-上传文件aws服务器\" class=\"headerlink\" title=\"3.上传文件aws服务器\"></a>3.上传文件aws服务器</h3><ul>\n<li><p>IPv4：</p>\n<pre><code># chmod 400 /path/my-key-pair.pem\n# scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~\n</code></pre></li>\n<li><p>(仅限 IPv6) 或者,您可以使用实例的 IPv6 地址传输文件。IPv6 地址必须用方括号 ([]) 括起,方括号必<br>须转义 ()。</p>\n<pre><code>scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@\n\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~\n</code></pre></li>\n</ul>\n<p><em>小提示</em>:<br>对于 Amazon Linux,用户名为 ec2-user。对于 RHEL,用户名称是 ec2-user 或 root。<br>对于 Ubuntu,用户名称是 ubuntu 或 root。对于 Centos,用户名称是 centos。对于<br>Fedora,用户名称是 ec2-user。对于 SUSE,用户名称是 ec2-user 或 root。另外,如果<br>ec2-user 和 root 无法使用,请与您的 AMI 供应商核实。</p>\n<h3 id=\"4-下载文件到本机\"><a href=\"#4-下载文件到本机\" class=\"headerlink\" title=\"4.下载文件到本机\"></a>4.下载文件到本机</h3><ul>\n<li><p>IPv4：</p>\n<pre><code>scp -i /path/my-key-pair.pem ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~/\nSampleFile.txt ~/SampleFile2.txt\n</code></pre></li>\n</ul>\n<ul>\n<li><p>(仅限 IPv6) 或者,您可以使用实例的 IPv6 地址反方向传输文件。</p>\n<pre><code>scp -i /path/my-key-pair.pem ec2-user@\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~/\nSampleFile.txt ~/SampleFile2.txt\n</code></pre></li>\n</ul>\n"},{"title":"区块链-密码学之哈希函数","date":"2018-07-25T06:45:45.000Z","_content":"\n本文介绍哈希……\n","source":"_posts/blockchain-hash.md","raw":"---\ntitle: 区块链-密码学之哈希函数\ndate: 2018-07-25 14:45:45\ncategories: 区块链\ntags: \n---\n\n本文介绍哈希……\n","slug":"blockchain-hash","published":1,"updated":"2019-06-16T14:38:33.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqah000og4vai4yghsf8","content":"<p>本文介绍哈希……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍哈希……</p>\n"},{"title":"区块链-Paxos共识算法介绍","date":"2018-12-26T02:21:43.000Z","_content":"","source":"_posts/blockchain-paxos.md","raw":"---\ntitle: 区块链-Paxos共识算法介绍\ndate: 2018-12-26 10:21:43\ncategories: 区块链\ntags:\n---\n","slug":"blockchain-paxos","published":1,"updated":"2019-06-16T14:38:33.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqai000qg4va0xq4hjzc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"centos7下jdk8安装","date":"2017-11-12T06:32:34.000Z","_content":"1、下载jdk(在官网找)\n如果还没安装axel，先安装axel：> yum -y install axel\n\n    > axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n\n2、新建安装目录\n\n    >  mkdir /usr/lib/jvm\n\n3、解压jdk到安装目录下\n\n    > tar xf jdk-8u131-linux-x64.tar.gz\n    > cd /usr/lib/jvm\n    > mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n    > mv jdk1.8.0_131/ jdk8 #更改名字\n\n4、配置环境变量\n\n    > vim /etc/profile\n    \n键盘按a键进入编辑模式，在末尾添加：\n#jdk\nexport JAVA_HOME=/usr/lib/jvm/jdk8\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH\n\n按Esc退出编辑模式\n按Shift+:,然后输入wq保存退出。\n\n5、使环境变量生效\n\n    > source /etc/profile\n\n6、验证安装是否成功\n\n    > java -version\n\n如果安装成功会看到：\n\n    java version \"1.8.0_131\"\n    Java(TM) SE Runtime Environment (build 1.8.0_131-b11)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)","source":"_posts/centos-jdk8-install.md","raw":"---\ntitle: centos7下jdk8安装\ndate: 2017-11-12 14:32:34\ncategories: CentOs\ntags: centos-jdk8-install\n---\n1、下载jdk(在官网找)\n如果还没安装axel，先安装axel：> yum -y install axel\n\n    > axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n\n2、新建安装目录\n\n    >  mkdir /usr/lib/jvm\n\n3、解压jdk到安装目录下\n\n    > tar xf jdk-8u131-linux-x64.tar.gz\n    > cd /usr/lib/jvm\n    > mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n    > mv jdk1.8.0_131/ jdk8 #更改名字\n\n4、配置环境变量\n\n    > vim /etc/profile\n    \n键盘按a键进入编辑模式，在末尾添加：\n#jdk\nexport JAVA_HOME=/usr/lib/jvm/jdk8\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH\n\n按Esc退出编辑模式\n按Shift+:,然后输入wq保存退出。\n\n5、使环境变量生效\n\n    > source /etc/profile\n\n6、验证安装是否成功\n\n    > java -version\n\n如果安装成功会看到：\n\n    java version \"1.8.0_131\"\n    Java(TM) SE Runtime Environment (build 1.8.0_131-b11)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)","slug":"centos-jdk8-install","published":1,"updated":"2019-06-16T14:38:33.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqaj000vg4vagai0n5e0","content":"<p>1、下载jdk(在官网找)<br>如果还没安装axel，先安装axel：&gt; yum -y install axel</p>\n<pre><code>&gt; axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n</code></pre><p>2、新建安装目录</p>\n<pre><code>&gt;  mkdir /usr/lib/jvm\n</code></pre><p>3、解压jdk到安装目录下</p>\n<pre><code>&gt; tar xf jdk-8u131-linux-x64.tar.gz\n&gt; cd /usr/lib/jvm\n&gt; mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n&gt; mv jdk1.8.0_131/ jdk8 #更改名字\n</code></pre><p>4、配置环境变量</p>\n<pre><code>&gt; vim /etc/profile\n</code></pre><p>键盘按a键进入编辑模式，在末尾添加：</p>\n<p>#jdk<br>export JAVA_HOME=/usr/lib/jvm/jdk8<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>\n<p>按Esc退出编辑模式<br>按Shift+:,然后输入wq保存退出。</p>\n<p>5、使环境变量生效</p>\n<pre><code>&gt; source /etc/profile\n</code></pre><p>6、验证安装是否成功</p>\n<pre><code>&gt; java -version\n</code></pre><p>如果安装成功会看到：</p>\n<pre><code>java version &quot;1.8.0_131&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1、下载jdk(在官网找)<br>如果还没安装axel，先安装axel：&gt; yum -y install axel</p>\n<pre><code>&gt; axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n</code></pre><p>2、新建安装目录</p>\n<pre><code>&gt;  mkdir /usr/lib/jvm\n</code></pre><p>3、解压jdk到安装目录下</p>\n<pre><code>&gt; tar xf jdk-8u131-linux-x64.tar.gz\n&gt; cd /usr/lib/jvm\n&gt; mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n&gt; mv jdk1.8.0_131/ jdk8 #更改名字\n</code></pre><p>4、配置环境变量</p>\n<pre><code>&gt; vim /etc/profile\n</code></pre><p>键盘按a键进入编辑模式，在末尾添加：</p>\n<p>#jdk<br>export JAVA_HOME=/usr/lib/jvm/jdk8<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>\n<p>按Esc退出编辑模式<br>按Shift+:,然后输入wq保存退出。</p>\n<p>5、使环境变量生效</p>\n<pre><code>&gt; source /etc/profile\n</code></pre><p>6、验证安装是否成功</p>\n<pre><code>&gt; java -version\n</code></pre><p>如果安装成功会看到：</p>\n<pre><code>java version &quot;1.8.0_131&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n</code></pre>"},{"title":"centos7下搭建maven私仓Nexus","date":"2017-11-12T06:47:38.000Z","_content":"\n项目组件化，共用jar包，统一获取墙外jar包…… \n\n官方文档 [sonatype](https://www.sonatype.com/)\n\n## 安装jdk\n参考其他文章……\n\n\n## 下载Nexus Repository OSS\n> 下载地址：http://www.sonatype.com/download-oss-sonatype\n\n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n\n解压：\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n    \n## 启动\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n    [root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n\n如果启动成功，可以看到：\n\n > Started Sonatype Nexus OSS 3.6.0-02\n\n防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。\n\n在浏览器访问：http://47.52.236.72:8081/\n可以看到：\n\n{% asset_img a.png %}\n\n## 配置为Linux Service\n\n1. 编辑`bin/nexus.rc`：\n\n`[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc`\n\n添加： \n> run_as_user=\"root\"\n\n2. 在`/etc/init.d`放nexus软连接\n\n` ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus`\n\n3. 设置服务随系统自启\n命令：*chkconfig*\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n    [root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n\n5. 启动\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\n    WARNING: ************************************************************\n    WARNING: Detected execution as \"root\" user.  This is NOT recommended!\n    WARNING: ************************************************************\n    Starting nexus\n\n## 界面操作\n\n*1. 登录*\n\n默认账号密码：\nusername: admin\npwd: admin123\n\n{% asset_img b.png %} \n\n*2. 修改admin密码*\n\n{% asset_img c.png %}\n\n点击`More`\n\n{% asset_img d.png %}\n    \n## 创建maven仓库\n\n{% asset_img e.png %}\n\n简单介绍下几种repository的类型:\n\n> - hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。\n> - proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。\n> - group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。\n\n这里我们选择创建本地仓库：\n{% asset_img f.png %}\n\n填写内容：\n{% asset_img g.png %}\n\n> version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。\n\n创建成功：\n{% asset_img h.png %}\n\n添加到maven-public仓库组：\n{% asset_img j.png %}\n\n## 查看仓库\n如果上传了项目，在Nexus用户界面，选择components -> xiaoming-host\n\n{% asset_img i.png %}\n\n\n\n\n    \n","source":"_posts/centos-maven-nexus.md","raw":"---\ntitle: centos7下搭建maven私仓Nexus\ndate: 2017-11-12 14:47:38\ncategories: maven\ntags: \n---\n\n项目组件化，共用jar包，统一获取墙外jar包…… \n\n官方文档 [sonatype](https://www.sonatype.com/)\n\n## 安装jdk\n参考其他文章……\n\n\n## 下载Nexus Repository OSS\n> 下载地址：http://www.sonatype.com/download-oss-sonatype\n\n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n\n解压：\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n    \n## 启动\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n    [root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n\n如果启动成功，可以看到：\n\n > Started Sonatype Nexus OSS 3.6.0-02\n\n防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。\n\n在浏览器访问：http://47.52.236.72:8081/\n可以看到：\n\n{% asset_img a.png %}\n\n## 配置为Linux Service\n\n1. 编辑`bin/nexus.rc`：\n\n`[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc`\n\n添加： \n> run_as_user=\"root\"\n\n2. 在`/etc/init.d`放nexus软连接\n\n` ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus`\n\n3. 设置服务随系统自启\n命令：*chkconfig*\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n    [root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n\n5. 启动\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\n    WARNING: ************************************************************\n    WARNING: Detected execution as \"root\" user.  This is NOT recommended!\n    WARNING: ************************************************************\n    Starting nexus\n\n## 界面操作\n\n*1. 登录*\n\n默认账号密码：\nusername: admin\npwd: admin123\n\n{% asset_img b.png %} \n\n*2. 修改admin密码*\n\n{% asset_img c.png %}\n\n点击`More`\n\n{% asset_img d.png %}\n    \n## 创建maven仓库\n\n{% asset_img e.png %}\n\n简单介绍下几种repository的类型:\n\n> - hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。\n> - proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。\n> - group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。\n\n这里我们选择创建本地仓库：\n{% asset_img f.png %}\n\n填写内容：\n{% asset_img g.png %}\n\n> version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。\n\n创建成功：\n{% asset_img h.png %}\n\n添加到maven-public仓库组：\n{% asset_img j.png %}\n\n## 查看仓库\n如果上传了项目，在Nexus用户界面，选择components -> xiaoming-host\n\n{% asset_img i.png %}\n\n\n\n\n    \n","slug":"centos-maven-nexus","published":1,"updated":"2019-06-16T14:38:33.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqak000xg4vab8wfpway","content":"<p>项目组件化，共用jar包，统一获取墙外jar包…… </p>\n<p>官方文档 <a href=\"https://www.sonatype.com/\" target=\"_blank\" rel=\"noopener\">sonatype</a></p>\n<h2 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h2><p>参考其他文章……</p>\n<h2 id=\"下载Nexus-Repository-OSS\"><a href=\"#下载Nexus-Repository-OSS\" class=\"headerlink\" title=\"下载Nexus Repository OSS\"></a>下载Nexus Repository OSS</h2><blockquote>\n<p>下载地址：<a href=\"http://www.sonatype.com/download-oss-sonatype\" target=\"_blank\" rel=\"noopener\">http://www.sonatype.com/download-oss-sonatype</a></p>\n</blockquote>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n</code></pre><p>解压：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n[root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n</code></pre><p>如果启动成功，可以看到：</p>\n<blockquote>\n<p>Started Sonatype Nexus OSS 3.6.0-02</p>\n</blockquote>\n<p>防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。</p>\n<p>在浏览器访问：<a href=\"http://47.52.236.72:8081/\" target=\"_blank\" rel=\"noopener\">http://47.52.236.72:8081/</a><br>可以看到：</p>\n<img src=\"/2017/11/12/centos-maven-nexus/a.png\">\n<h2 id=\"配置为Linux-Service\"><a href=\"#配置为Linux-Service\" class=\"headerlink\" title=\"配置为Linux Service\"></a>配置为Linux Service</h2><ol>\n<li>编辑<code>bin/nexus.rc</code>：</li>\n</ol>\n<p><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc</code></p>\n<p>添加： </p>\n<blockquote>\n<p>run_as_user=”root”</p>\n</blockquote>\n<ol start=\"2\">\n<li>在<code>/etc/init.d</code>放nexus软连接</li>\n</ol>\n<p><code>ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus</code></p>\n<ol start=\"3\">\n<li>设置服务随系统自启<br>命令：<em>chkconfig</em></li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n[root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n</code></pre><ol start=\"5\">\n<li>启动</li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\nWARNING: ************************************************************\nWARNING: Detected execution as &quot;root&quot; user.  This is NOT recommended!\nWARNING: ************************************************************\nStarting nexus\n</code></pre><h2 id=\"界面操作\"><a href=\"#界面操作\" class=\"headerlink\" title=\"界面操作\"></a>界面操作</h2><p><em>1. 登录</em></p>\n<p>默认账号密码：<br>username: admin<br>pwd: admin123</p>\n<img src=\"/2017/11/12/centos-maven-nexus/b.png\"> \n<p><em>2. 修改admin密码</em></p>\n<img src=\"/2017/11/12/centos-maven-nexus/c.png\">\n<p>点击<code>More</code></p>\n<img src=\"/2017/11/12/centos-maven-nexus/d.png\">\n<h2 id=\"创建maven仓库\"><a href=\"#创建maven仓库\" class=\"headerlink\" title=\"创建maven仓库\"></a>创建maven仓库</h2><img src=\"/2017/11/12/centos-maven-nexus/e.png\">\n<p>简单介绍下几种repository的类型:</p>\n<blockquote>\n<ul>\n<li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li>\n<li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li>\n<li>group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li>\n</ul>\n</blockquote>\n<p>这里我们选择创建本地仓库：<br><img src=\"/2017/11/12/centos-maven-nexus/f.png\"></p>\n<p>填写内容：<br><img src=\"/2017/11/12/centos-maven-nexus/g.png\"></p>\n<blockquote>\n<p>version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。</p>\n</blockquote>\n<p>创建成功：<br><img src=\"/2017/11/12/centos-maven-nexus/h.png\"></p>\n<p>添加到maven-public仓库组：<br><img src=\"/2017/11/12/centos-maven-nexus/j.png\"></p>\n<h2 id=\"查看仓库\"><a href=\"#查看仓库\" class=\"headerlink\" title=\"查看仓库\"></a>查看仓库</h2><p>如果上传了项目，在Nexus用户界面，选择components -&gt; xiaoming-host</p>\n<img src=\"/2017/11/12/centos-maven-nexus/i.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>项目组件化，共用jar包，统一获取墙外jar包…… </p>\n<p>官方文档 <a href=\"https://www.sonatype.com/\" target=\"_blank\" rel=\"noopener\">sonatype</a></p>\n<h2 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h2><p>参考其他文章……</p>\n<h2 id=\"下载Nexus-Repository-OSS\"><a href=\"#下载Nexus-Repository-OSS\" class=\"headerlink\" title=\"下载Nexus Repository OSS\"></a>下载Nexus Repository OSS</h2><blockquote>\n<p>下载地址：<a href=\"http://www.sonatype.com/download-oss-sonatype\" target=\"_blank\" rel=\"noopener\">http://www.sonatype.com/download-oss-sonatype</a></p>\n</blockquote>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n</code></pre><p>解压：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n[root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n</code></pre><p>如果启动成功，可以看到：</p>\n<blockquote>\n<p>Started Sonatype Nexus OSS 3.6.0-02</p>\n</blockquote>\n<p>防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。</p>\n<p>在浏览器访问：<a href=\"http://47.52.236.72:8081/\" target=\"_blank\" rel=\"noopener\">http://47.52.236.72:8081/</a><br>可以看到：</p>\n<img src=\"/2017/11/12/centos-maven-nexus/a.png\">\n<h2 id=\"配置为Linux-Service\"><a href=\"#配置为Linux-Service\" class=\"headerlink\" title=\"配置为Linux Service\"></a>配置为Linux Service</h2><ol>\n<li>编辑<code>bin/nexus.rc</code>：</li>\n</ol>\n<p><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc</code></p>\n<p>添加： </p>\n<blockquote>\n<p>run_as_user=”root”</p>\n</blockquote>\n<ol start=\"2\">\n<li>在<code>/etc/init.d</code>放nexus软连接</li>\n</ol>\n<p><code>ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus</code></p>\n<ol start=\"3\">\n<li>设置服务随系统自启<br>命令：<em>chkconfig</em></li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n[root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n</code></pre><ol start=\"5\">\n<li>启动</li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\nWARNING: ************************************************************\nWARNING: Detected execution as &quot;root&quot; user.  This is NOT recommended!\nWARNING: ************************************************************\nStarting nexus\n</code></pre><h2 id=\"界面操作\"><a href=\"#界面操作\" class=\"headerlink\" title=\"界面操作\"></a>界面操作</h2><p><em>1. 登录</em></p>\n<p>默认账号密码：<br>username: admin<br>pwd: admin123</p>\n<img src=\"/2017/11/12/centos-maven-nexus/b.png\"> \n<p><em>2. 修改admin密码</em></p>\n<img src=\"/2017/11/12/centos-maven-nexus/c.png\">\n<p>点击<code>More</code></p>\n<img src=\"/2017/11/12/centos-maven-nexus/d.png\">\n<h2 id=\"创建maven仓库\"><a href=\"#创建maven仓库\" class=\"headerlink\" title=\"创建maven仓库\"></a>创建maven仓库</h2><img src=\"/2017/11/12/centos-maven-nexus/e.png\">\n<p>简单介绍下几种repository的类型:</p>\n<blockquote>\n<ul>\n<li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li>\n<li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li>\n<li>group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li>\n</ul>\n</blockquote>\n<p>这里我们选择创建本地仓库：<br><img src=\"/2017/11/12/centos-maven-nexus/f.png\"></p>\n<p>填写内容：<br><img src=\"/2017/11/12/centos-maven-nexus/g.png\"></p>\n<blockquote>\n<p>version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。</p>\n</blockquote>\n<p>创建成功：<br><img src=\"/2017/11/12/centos-maven-nexus/h.png\"></p>\n<p>添加到maven-public仓库组：<br><img src=\"/2017/11/12/centos-maven-nexus/j.png\"></p>\n<h2 id=\"查看仓库\"><a href=\"#查看仓库\" class=\"headerlink\" title=\"查看仓库\"></a>查看仓库</h2><p>如果上传了项目，在Nexus用户界面，选择components -&gt; xiaoming-host</p>\n<img src=\"/2017/11/12/centos-maven-nexus/i.png\">\n"},{"title":"centos免密码登录","date":"2017-11-30T06:53:47.000Z","_content":"\n配置免密码登录服务器。不用每次都要输入密码。\n\n## 环境说明\n\n客户机:Mac OS X\n服务器:CentOS 7\n客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.\n\n## 客户机配置\n\n1. 查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  \n2. 生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.\n\n## 服务器配置\n\n1.修改sshd配置文件(/etc/ssh/sshd_config).  \n找到以下内容，并去掉注释符”#“\n\n> RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)\nPubkeyAuthentication yes\nAuthorizedKeysFile  .ssh/authorized_keys\n\n2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:\n\n    cat ~/.ssh/id_rsa.pub | ssh user@host “cat - >> ~/.ssh/authorized_keys”\n    \n>注意:\n1 .ssh目录的权限必须是700\n2 .ssh/authorized_keys文件权限必须是600\n\n重启ssh： service sshd restart   \n然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.\n\n-----------------------------------------------------------\n## 更简单方式\n\n1、执行命令：ssh-keygen -t rsa -C \"xx@qq.com\"(随便编个字符串，一般用邮箱）\n2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；\n3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件\n\n\n\nyutao@localhost ~]$ ssh-copy-id yutao@192.168.161.132 #把秘钥拷贝到远程服务器\n","source":"_posts/centos-login-without-pwd.md","raw":"---\ntitle: centos免密码登录\ndate: 2017-11-30 14:53:47\ncategories: CentOs\ntags: centos登录\n---\n\n配置免密码登录服务器。不用每次都要输入密码。\n\n## 环境说明\n\n客户机:Mac OS X\n服务器:CentOS 7\n客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.\n\n## 客户机配置\n\n1. 查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  \n2. 生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.\n\n## 服务器配置\n\n1.修改sshd配置文件(/etc/ssh/sshd_config).  \n找到以下内容，并去掉注释符”#“\n\n> RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)\nPubkeyAuthentication yes\nAuthorizedKeysFile  .ssh/authorized_keys\n\n2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:\n\n    cat ~/.ssh/id_rsa.pub | ssh user@host “cat - >> ~/.ssh/authorized_keys”\n    \n>注意:\n1 .ssh目录的权限必须是700\n2 .ssh/authorized_keys文件权限必须是600\n\n重启ssh： service sshd restart   \n然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.\n\n-----------------------------------------------------------\n## 更简单方式\n\n1、执行命令：ssh-keygen -t rsa -C \"xx@qq.com\"(随便编个字符串，一般用邮箱）\n2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；\n3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件\n\n\n\nyutao@localhost ~]$ ssh-copy-id yutao@192.168.161.132 #把秘钥拷贝到远程服务器\n","slug":"centos-login-without-pwd","published":1,"updated":"2019-06-16T14:38:33.324Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqam0011g4vax5ztk8xw","content":"<p>配置免密码登录服务器。不用每次都要输入密码。</p>\n<h2 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h2><p>客户机:Mac OS X<br>服务器:CentOS 7<br>客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.</p>\n<h2 id=\"客户机配置\"><a href=\"#客户机配置\" class=\"headerlink\" title=\"客户机配置\"></a>客户机配置</h2><ol>\n<li>查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  </li>\n<li>生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.</li>\n</ol>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><p>1.修改sshd配置文件(/etc/ssh/sshd_config).<br>找到以下内容，并去掉注释符”#“</p>\n<blockquote>\n<p>RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile  .ssh/authorized_keys</p>\n</blockquote>\n<p>2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:</p>\n<pre><code>cat ~/.ssh/id_rsa.pub | ssh user@host “cat - &gt;&gt; ~/.ssh/authorized_keys”\n</code></pre><blockquote>\n<p>注意:<br>1 .ssh目录的权限必须是700<br>2 .ssh/authorized_keys文件权限必须是600</p>\n</blockquote>\n<p>重启ssh： service sshd restart<br>然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.</p>\n<hr>\n<h2 id=\"更简单方式\"><a href=\"#更简单方式\" class=\"headerlink\" title=\"更简单方式\"></a>更简单方式</h2><p>1、执行命令：ssh-keygen -t rsa -C “<a href=\"mailto:xx@qq.com\" target=\"_blank\" rel=\"noopener\">xx@qq.com</a>“(随便编个字符串，一般用邮箱）<br>2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；<br>3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件</p>\n<p>yutao@localhost ~]$ ssh-copy-id <a href=\"mailto:yutao@192.168.161.132\" target=\"_blank\" rel=\"noopener\">yutao@192.168.161.132</a> #把秘钥拷贝到远程服务器</p>\n","site":{"data":{}},"excerpt":"","more":"<p>配置免密码登录服务器。不用每次都要输入密码。</p>\n<h2 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h2><p>客户机:Mac OS X<br>服务器:CentOS 7<br>客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.</p>\n<h2 id=\"客户机配置\"><a href=\"#客户机配置\" class=\"headerlink\" title=\"客户机配置\"></a>客户机配置</h2><ol>\n<li>查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  </li>\n<li>生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.</li>\n</ol>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><p>1.修改sshd配置文件(/etc/ssh/sshd_config).<br>找到以下内容，并去掉注释符”#“</p>\n<blockquote>\n<p>RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile  .ssh/authorized_keys</p>\n</blockquote>\n<p>2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:</p>\n<pre><code>cat ~/.ssh/id_rsa.pub | ssh user@host “cat - &gt;&gt; ~/.ssh/authorized_keys”\n</code></pre><blockquote>\n<p>注意:<br>1 .ssh目录的权限必须是700<br>2 .ssh/authorized_keys文件权限必须是600</p>\n</blockquote>\n<p>重启ssh： service sshd restart<br>然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.</p>\n<hr>\n<h2 id=\"更简单方式\"><a href=\"#更简单方式\" class=\"headerlink\" title=\"更简单方式\"></a>更简单方式</h2><p>1、执行命令：ssh-keygen -t rsa -C “<a href=\"mailto:xx@qq.com\" target=\"_blank\" rel=\"noopener\">xx@qq.com</a>“(随便编个字符串，一般用邮箱）<br>2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；<br>3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件</p>\n<p>yutao@localhost ~]$ ssh-copy-id <a href=\"mailto:yutao@192.168.161.132\" target=\"_blank\" rel=\"noopener\">yutao@192.168.161.132</a> #把秘钥拷贝到远程服务器</p>\n"},{"title":"centos6升级内核","date":"2018-12-18T07:26:21.000Z","_content":"\n本章介绍linux系统升级内核的方法，在centos6环境下实验通过，并安装docker成功。     \n如果不升级内核，安装docker，性能会收到影响。   \n\n1.查看当前内核版本： \n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -a\n    Linux iZwz9b0bqrkbhqd5lu2pwhZ 2.6.32-696.10.1.el6.x86_64 #1 SMP Tue Aug 22 18:51:35 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /proc/version\n    Linux version 2.6.32-696.10.1.el6.x86_64 (mockbuild@c1bl.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC) ) #1 SMP Tue Aug 22 18:51:35 UTC 2017\n    \n    -----------------------------------------------------------------\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# lsb_release -a\n    LSB Version:\t:base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch\n    Distributor ID:\tCentOS\n    Description:\tCentOS release 6.9 (Final)\n    Release:\t6.9\n    Codename:\tFinal\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /proc/version\n    Linux version 2.6.32-696.10.1.el6.x86_64 (mockbuild@c1bl.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC\n    \n2.导入public key    \n\n     rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n     \n3.安装ELRepo到CentOS \n\n可以去http://elrepo.org/tiki/tiki-index.php 选择要安装的ELRepo \n\n一般会安装到最新版内核\n\n    rpm -Uvh https://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm\n    \n4.安装 kernel-lt（lt=long-term）\n\n    [root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-lt -y\n    \n或者 安装kernel-ml（ml=mainline）\n \n    [root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-ml -y    \n \n \n5.编辑grub.conf文件，修改Grub引导顺序     \n\n    [root@localhost ~]# vim /etc/grub.conf\n    \n因为一般新安装的内核在第一个位置，所以设置default=0，表示启动新内核    \n\n\n6.重启 \n\n查看最新内核：\n\n     [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -a\n     Linux iZwz9b0bqrkbhqd5lu2pwhZ 4.4.167-1.el6.elrepo.x86_64 #1 SMP Thu Dec 13 11:35:54 EST 2018 x86_64 x86_64 x86_64 GNU/Linux\n     [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -r\n     4.4.167-1.el6.elrepo.x86_64\n     \n成功！      ","source":"_posts/centos6-kernel-update.md","raw":"---\ntitle: centos6升级内核\ndate: 2018-12-18 15:26:21\ncategories: CentOs\ntags:\n---\n\n本章介绍linux系统升级内核的方法，在centos6环境下实验通过，并安装docker成功。     \n如果不升级内核，安装docker，性能会收到影响。   \n\n1.查看当前内核版本： \n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -a\n    Linux iZwz9b0bqrkbhqd5lu2pwhZ 2.6.32-696.10.1.el6.x86_64 #1 SMP Tue Aug 22 18:51:35 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /proc/version\n    Linux version 2.6.32-696.10.1.el6.x86_64 (mockbuild@c1bl.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC) ) #1 SMP Tue Aug 22 18:51:35 UTC 2017\n    \n    -----------------------------------------------------------------\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# lsb_release -a\n    LSB Version:\t:base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch\n    Distributor ID:\tCentOS\n    Description:\tCentOS release 6.9 (Final)\n    Release:\t6.9\n    Codename:\tFinal\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /proc/version\n    Linux version 2.6.32-696.10.1.el6.x86_64 (mockbuild@c1bl.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC\n    \n2.导入public key    \n\n     rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n     \n3.安装ELRepo到CentOS \n\n可以去http://elrepo.org/tiki/tiki-index.php 选择要安装的ELRepo \n\n一般会安装到最新版内核\n\n    rpm -Uvh https://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm\n    \n4.安装 kernel-lt（lt=long-term）\n\n    [root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-lt -y\n    \n或者 安装kernel-ml（ml=mainline）\n \n    [root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-ml -y    \n \n \n5.编辑grub.conf文件，修改Grub引导顺序     \n\n    [root@localhost ~]# vim /etc/grub.conf\n    \n因为一般新安装的内核在第一个位置，所以设置default=0，表示启动新内核    \n\n\n6.重启 \n\n查看最新内核：\n\n     [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -a\n     Linux iZwz9b0bqrkbhqd5lu2pwhZ 4.4.167-1.el6.elrepo.x86_64 #1 SMP Thu Dec 13 11:35:54 EST 2018 x86_64 x86_64 x86_64 GNU/Linux\n     [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -r\n     4.4.167-1.el6.elrepo.x86_64\n     \n成功！      ","slug":"centos6-kernel-update","published":1,"updated":"2019-06-16T14:38:33.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqan0013g4va7fig6dbd","content":"<p>本章介绍linux系统升级内核的方法，在centos6环境下实验通过，并安装docker成功。<br>如果不升级内核，安装docker，性能会收到影响。   </p>\n<p>1.查看当前内核版本： </p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -a\nLinux iZwz9b0bqrkbhqd5lu2pwhZ 2.6.32-696.10.1.el6.x86_64 #1 SMP Tue Aug 22 18:51:35 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /proc/version\nLinux version 2.6.32-696.10.1.el6.x86_64 (mockbuild@c1bl.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC) ) #1 SMP Tue Aug 22 18:51:35 UTC 2017\n\n-----------------------------------------------------------------\n[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# lsb_release -a\nLSB Version:    :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch\nDistributor ID:    CentOS\nDescription:    CentOS release 6.9 (Final)\nRelease:    6.9\nCodename:    Final\n[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /proc/version\nLinux version 2.6.32-696.10.1.el6.x86_64 (mockbuild@c1bl.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC\n</code></pre><p>2.导入public key    </p>\n<pre><code>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n</code></pre><p>3.安装ELRepo到CentOS </p>\n<p>可以去<a href=\"http://elrepo.org/tiki/tiki-index.php\" target=\"_blank\" rel=\"noopener\">http://elrepo.org/tiki/tiki-index.php</a> 选择要安装的ELRepo </p>\n<p>一般会安装到最新版内核</p>\n<pre><code>rpm -Uvh https://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm\n</code></pre><p>4.安装 kernel-lt（lt=long-term）</p>\n<pre><code>[root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-lt -y\n</code></pre><p>或者 安装kernel-ml（ml=mainline）</p>\n<pre><code>[root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-ml -y    \n</code></pre><p>5.编辑grub.conf文件，修改Grub引导顺序     </p>\n<pre><code>[root@localhost ~]# vim /etc/grub.conf\n</code></pre><p>因为一般新安装的内核在第一个位置，所以设置default=0，表示启动新内核    </p>\n<p>6.重启 </p>\n<p>查看最新内核：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -a\nLinux iZwz9b0bqrkbhqd5lu2pwhZ 4.4.167-1.el6.elrepo.x86_64 #1 SMP Thu Dec 13 11:35:54 EST 2018 x86_64 x86_64 x86_64 GNU/Linux\n[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -r\n4.4.167-1.el6.elrepo.x86_64\n</code></pre><p>成功！      </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本章介绍linux系统升级内核的方法，在centos6环境下实验通过，并安装docker成功。<br>如果不升级内核，安装docker，性能会收到影响。   </p>\n<p>1.查看当前内核版本： </p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -a\nLinux iZwz9b0bqrkbhqd5lu2pwhZ 2.6.32-696.10.1.el6.x86_64 #1 SMP Tue Aug 22 18:51:35 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux\n[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /proc/version\nLinux version 2.6.32-696.10.1.el6.x86_64 (mockbuild@c1bl.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC) ) #1 SMP Tue Aug 22 18:51:35 UTC 2017\n\n-----------------------------------------------------------------\n[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# lsb_release -a\nLSB Version:    :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch\nDistributor ID:    CentOS\nDescription:    CentOS release 6.9 (Final)\nRelease:    6.9\nCodename:    Final\n[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /proc/version\nLinux version 2.6.32-696.10.1.el6.x86_64 (mockbuild@c1bl.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC\n</code></pre><p>2.导入public key    </p>\n<pre><code>rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org\n</code></pre><p>3.安装ELRepo到CentOS </p>\n<p>可以去<a href=\"http://elrepo.org/tiki/tiki-index.php\" target=\"_blank\" rel=\"noopener\">http://elrepo.org/tiki/tiki-index.php</a> 选择要安装的ELRepo </p>\n<p>一般会安装到最新版内核</p>\n<pre><code>rpm -Uvh https://www.elrepo.org/elrepo-release-6-8.el6.elrepo.noarch.rpm\n</code></pre><p>4.安装 kernel-lt（lt=long-term）</p>\n<pre><code>[root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-lt -y\n</code></pre><p>或者 安装kernel-ml（ml=mainline）</p>\n<pre><code>[root@localhost ~]# yum --enablerepo=elrepo-kernel install kernel-ml -y    \n</code></pre><p>5.编辑grub.conf文件，修改Grub引导顺序     </p>\n<pre><code>[root@localhost ~]# vim /etc/grub.conf\n</code></pre><p>因为一般新安装的内核在第一个位置，所以设置default=0，表示启动新内核    </p>\n<p>6.重启 </p>\n<p>查看最新内核：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -a\nLinux iZwz9b0bqrkbhqd5lu2pwhZ 4.4.167-1.el6.elrepo.x86_64 #1 SMP Thu Dec 13 11:35:54 EST 2018 x86_64 x86_64 x86_64 GNU/Linux\n[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# uname -r\n4.4.167-1.el6.elrepo.x86_64\n</code></pre><p>成功！      </p>\n"},{"title":"concourse持续集成使用教程","date":"2018-02-10T02:35:22.000Z","_content":"\n官网：https://concourse.ci/","source":"_posts/concourse-tutorial.md","raw":"---\ntitle: concourse持续集成使用教程\ndate: 2018-02-10 10:35:22\ncategories: 持续集成\ntags: concourse\n---\n\n官网：https://concourse.ci/","slug":"concourse-tutorial","published":1,"updated":"2019-06-16T14:38:33.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqao0017g4val9uj25jo","content":"<p>官网：<a href=\"https://concourse.ci/\" target=\"_blank\" rel=\"noopener\">https://concourse.ci/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"https://concourse.ci/\" target=\"_blank\" rel=\"noopener\">https://concourse.ci/</a></p>\n"},{"title":"centos7下安装mysql8","date":"2018-07-27T14:57:16.000Z","_content":"\n本文介绍在centos7.4下源码编译安装msyql8的步骤……\n\n参考：https://www.linuxidc.com/Linux/2018-04/152010.htm\n\n## 源码编译安装\n\n### 安装前清理\n\n1. 清理旧的mysql\n\n        rpm -pa | grep mysql\n        \n        yum remove mysql-xxx-xxx-\n        \n2. 删除旧的mysql配置文件，卸载不会自动删除。\n\n        find / -name mysql\n     \n显示： \n\n    /etc/logrotate.d/mysql\n    /etc/selinux/targeted/active/modules/100/mysql\n    /etc/selinux/targeted/tmp/modules/100/mysql\n    /var/lib/mysql\n    /var/lib/mysql/mysql\n    /usr/bin/mysql\n    /usr/lib64/mysql\n    /usr/local/mysql\n\n根据需求使用以下命令 依次 对配置文件进行删除\n\n    rm -rf /var/lib/mysql\n    \n3. 卸载当前系统中已安装的mariadb。centos7中默认安装，会和mysql冲突。\n\n\n    rpm -qa | grep mariadb  （查找）\n    \n    rpm -e mysql*/mariadb*\n    \n    rpm -e --nodeps mysql*/mariadb*  （强制删除）\n    \n    ----------------------\n    [root@ymu ~]# rpm -qa | grep mariadb\n    mariadb-libs-5.5.56-2.el7.x86_64\n    [root@ymu ~]# rpm -e mysql*/mariadb*\n    error: package mysql*/mariadb* is not installed\n    [root@ymu ~]# rpm -e --nodeps mysql*/mariadb*  \n    error: package mysql*/mariadb* is not installed\n    [root@ymu ~]# rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64\n              \n\n### 准备工作\n\n1.安装依赖\n\n    yum -y install wget  cmake gcc gcc-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel\n        \n2.下载源码包\n\n下载网址： https://dev.mysql.com\n\n    wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz      (此版本带有boost)\n     \n         \n3.创建mysql用户\n\n    groupadd mysql\n    useradd -r -g mysql -s /bin/false mysql\n    \n   \n4.创建安装目录和数据目录\n\n    mkdir -p /server/mysql\n    mkdir -p /server/data/mysql\n    \n### 安装mysql\n\n1.解压源码包\n\n    [root@ymu tools]# tar -zxvf mysql-boost-8.0.11.tar.gz \n    \n2.编译&安装\n\n    [root@ymu tools]# cd mysql-8.0.11/\n    [root@ymu mysql-8.0.11]# cmake .  -DCMAKE_INSTALL_PREFIX=/server/mysql \\\n    > -DMYSQL_DATADIR=/server/data/mysql/ \\\n    > -DDEFAULT_CHARSET=utf8mb4 \\\n    > -DDEFAULT_COLLATION=utf8mb4_general_ci \\\n    > -DWITH_BOOST=/server/tools/mysql-8.0.11/boost/\n       \n    [root@ymu mysql-8.0.11]# make && make install   \n    \n3.配置my.cnf文件\n\n可能找不到该文件，如果没有，新建一个。 \n\n          cat /etc/my.cnf\n          [mysqld]\n          server-id=1\n          port=3306\n          basedir=/server/mysql8\n          datadir=/server/data/mysql8\n    　　　 ##请根据实际情况添加参数\n    \n更改： \n\n    [client]\n    port = 3307\n    socket = /tmp/mysql.sock\n    default-character-set = utf8mb4\n    \n    [mysqld]\n    port=3307\n    socket=/tmp/mysql.sock\n    \n    [mysql.server]\n    server-id=1\n    basedir=/server/mysql\n    datadir=/server/data/mysql\n    pid-file=/server/data/mysql/mysql.pid\n    \n    character-set-server = utf8mb4\n    \n    slow_query_log=1\n    long_query_time=5\n    slow_query_log_file=/server/data/mysql/mysql-slow.log\n    \n    default_storage_engine=InnoDB\n    innodb_file_per_table = 1\n    innodb_open_files = 500\n    innodb_buffer_pool_size = 64M\n    innodb_write_io_threads = 4\n    innodb_read_io_threads = 4\n    innodb_thread_concurrency = 0\n    innodb_purge_threads = 1\n    innodb_flush_log_at_trx_commit = 2\n    innodb_log_buffer_size = 2M\n    innodb_log_file_size = 32M\n    innodb_log_files_in_group = 3\n    innodb_max_dirty_pages_pct = 90\n    innodb_lock_wait_timeout = 120\n\n    \n\n参考：\n\n    [client]\n    port = 3307\n    socket = ~/tmp/mysql.sock\n    default-character-set = utf8mb4\n    \n    [mysqld]\n    port = 3307\n    socket = /home/mutian/tmp/mysql.sock\n    \n    [mysql.server]\n    basedir = /home/mutian/dev/tools/mysql\n    datadir = /home/mutian/dev/data/mysql\n    pid-file = /home/mutian/dev/data/mysql/mysql.pid\n    user = mysql\n    bind-address = 0.0.0.0\n    server-id = 1\n    \n    init-connect = 'SET NAMES utf8mb4'\n    character-set-server = utf8mb4\n    \n    #skip-name-resolve\n    #skip-networking\n    back_log = 300\n    \n    max_connections = 1000\n    max_connect_errors = 6000\n    open_files_limit = 65535\n    table_open_cache = 128\n    max_allowed_packet = 4M\n    binlog_cache_size = 1M\n    max_heap_table_size = 8M\n    tmp_table_size = 16M\n    \n    read_buffer_size = 2M\n    read_rnd_buffer_size = 8M\n    sort_buffer_size = 8M\n    join_buffer_size = 8M\n    key_buffer_size = 4M\n    \n    thread_cache_size = 8\n    \n    query_cache_type = 1\n    query_cache_size = 8M\n    query_cache_limit = 2M\n    \n    ft_min_word_len = 4\n    \n    log_bin = mysql-bin\n    binlog_format = mixed\n    expire_logs_days = 30\n    \n    slow_query_log = 1\n    long_query_time = 1\n    slow_query_log_file = /home/mutian/dev/data/mysql/mysql-slow.log\n    \n    performance_schema = 0\n    explicit_defaults_for_timestamp\n    \n    #lower_case_table_names = 1\n    \n    skip-external-locking\n    \n    default_storage_engine = InnoDB\n    #default-storage-engine = MyISAM\n    innodb_file_per_table = 1\n    innodb_open_files = 500\n    innodb_buffer_pool_size = 64M\n    innodb_write_io_threads = 4\n    innodb_read_io_threads = 4\n    innodb_thread_concurrency = 0\n    innodb_purge_threads = 1\n    innodb_flush_log_at_trx_commit = 2\n    innodb_log_buffer_size = 2M\n    innodb_log_file_size = 32M\n    innodb_log_files_in_group = 3\n    innodb_max_dirty_pages_pct = 90\n    innodb_lock_wait_timeout = 120\n    \n    bulk_insert_buffer_size = 8M\n    myisam_sort_buffer_size = 8M\n    myisam_max_sort_file_size = 10G\n    myisam_repair_threads = 1\n    \n    interactive_timeout = 28800\n    wait_timeout = 28800\n    \n    [mysqldump]\n    quick\n    max_allowed_packet = 16M\n    \n    [myisamchk]\n    key_buffer_size = 8M\n    sort_buffer_size = 8M\n    read_buffer = 4M\n    write_buffer = 4M\n\n4.目录权限修改\n\n    chown -R mysql:mysql /server/mysql\n    chown -R mysql:mysql /server/data/mysql\n    chmod 755 /server/mysql -R\n    chmod 755 /server/data/mysql -R\n\n5.初始化\n\n    bin/mysqld --initialize --user=mysql\n    bin/mysql_ssl_rsa_setup\n\n6.启动mysql\n\n    bin/mysqld_safe --user=mysql &\n\n7.修改账号密码\n\n- 如果出现错误：\n\n       ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)\n       \n说明服务没启动成功。     \n\n- 错误： \n\n       [root@ymu mysql]# bin/mysql  -uroot -p\n       Enter password: \n       ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)\n\n空密码无法登录。\n\n处理（修改密码）： \n\n    bin/mysqld_safe --user=mysql --skip-grant-tables &\n     \n    mysql -uroot -p     //密码，直接按回车登录\n    use mysql;\n    select host, user, authentication_string, plugin from user; \n    update user set authentication_string='' where user='root';\n    flush privileges;\n    //更更改密码\n    ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    quit;\n    \n    ------------------------------\n    如果执行\n    ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    报错误。\n    \n    按下面处理，执行：flush privileges;然后在执行更改密码语句就ok了：\n    mysql> ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\n    mysql> \n    mysql> flush privileges;\n    Query OK, 0 rows affected (0.01 sec)\n    \n    mysql> ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    Query OK, 0 rows affected (0.06 sec)\n    \n    mysql>   \n    \n    如果报错如下信息：\n    Error: Cannot retrieve repository metadata (repomd.xml) for repository: InstallMedia. Please verify its path and try again\n     You could try using --skip-broken to work around the problem\n     You could try running: rpm -Va --nofiles --nodigest\n    \n    我们只要到/etc/yum.repo.s下面把packetxxxx.repo和redhat.repo两个文件删除掉，再启动就可以了， \n    \n    ------------------------------------------\n    查看密码是否已经重置：\n    mysql> select host, user, authentication_string, plugin from user;\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    | host      | user             | authentication_string                                                  | plugin                |\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    | localhost | mysql.infoschema | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | root             | $A$005$ }DQPo%'\u0004:5\u0006'_\u001d#-QhPn/ZULDCRuo2Xh8w2uhS1.zZ/U.W8d7zWwlmpTB3D5 | caching_sha2_password |\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    4 rows in set (0.00 sec)\n    \n    可以看到root用户的密码已经更改。然后重启mysql登录试试。\n    \n    --------------------------\n    客户端连接报错：客户端连接caching-sha2-password问题。\n    这是因为msyql8对密码加密的规则导致，navicat不支持。所以，需要更改加密规则：\n    \n    在服务器，通过mysql客户端登入：\n    [root@ymu ~]# mysql -uroot -p\n    \n    #修改加密规则  \n    ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; \n    或者：\n    ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; \n    \n    #更新密码（mysql_native_password模式）    \n    ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '{NewPassword}';\n    或者：\n    ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '{NewPassword}';\n\n    实际操作过程：\n    mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'ymu123@' PASSWORD EXPIRE NEVER;\n    ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'localhost'\n    mysql> ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;\n    Query OK, 0 rows affected (0.05 sec)\n    \n    mysql> ALTER USER 'root'@'*' IDENTIFIED WITH mysql_native_password BY 'ymu123@';\n    ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'*'\n    mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'ymu123@';\n    Query OK, 0 rows affected (0.10 sec)\n\n    \n设置密码不能是`123456`这些简单的密码，会通不过。所以设置复杂点`ymu123@`。     \n     \n表格中有以下信息：  \nhost: 允许用户登录的 ip ‘位置’ % 表示可以远程；  \nuser: 当前数据库的用户名；    \nauthentication_string: 用户密码（在mysql 5.7.9以后废弃了password字段和password()函数）；  \nplugin： 密码加密方式；  \n\n然后重启就可以登录了。 \n\n参考： https://blog.csdn.net/xinpengfei521/article/details/80400142    \n     \n8.创建软链接（非必要）\n\n    ln -s /server/mysql/bin/* /usr/local/bin/\n\n9.添加到启动（非必要）\n\n开启自动启动mysql：\n\n    cp support-files/mysql.server /etc/init.d/mysql.server\n    chmod +x /etc/init.d/mysql.server\n    chkconfig --add mysql.server\n    chkconfig mysql.server on\n    \n    ------ 参考来源 ----\n    /bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\n    chmod +x /etc/init.d/mysqld\n    chkconfig --add mysqld\n    chkconfig mysqld on\n    \n10.查看启动状态、启动、停止、重启\n\n`mysql.server`对应上面设置自启动的：`/etc/init.d/mysql.server`\n\n查看状态：\n\n`systemctl status mysql.server.service`  \n\n或者：\n`service mysql.server status`\n\n停止：`service mysql.server stop`\n\n启动：`service mysql.server start`\n\n重新启动：`service mysql.server reload`\n\n  \n    \n## 二进制安装包rpm安装（推荐）    \n                  ","source":"_posts/centos-mysql-install.md","raw":"---\ntitle: centos7下安装mysql8\ndate: 2018-07-27 22:57:16\ncategories: CentOs\ntags: mysql mysql8\n---\n\n本文介绍在centos7.4下源码编译安装msyql8的步骤……\n\n参考：https://www.linuxidc.com/Linux/2018-04/152010.htm\n\n## 源码编译安装\n\n### 安装前清理\n\n1. 清理旧的mysql\n\n        rpm -pa | grep mysql\n        \n        yum remove mysql-xxx-xxx-\n        \n2. 删除旧的mysql配置文件，卸载不会自动删除。\n\n        find / -name mysql\n     \n显示： \n\n    /etc/logrotate.d/mysql\n    /etc/selinux/targeted/active/modules/100/mysql\n    /etc/selinux/targeted/tmp/modules/100/mysql\n    /var/lib/mysql\n    /var/lib/mysql/mysql\n    /usr/bin/mysql\n    /usr/lib64/mysql\n    /usr/local/mysql\n\n根据需求使用以下命令 依次 对配置文件进行删除\n\n    rm -rf /var/lib/mysql\n    \n3. 卸载当前系统中已安装的mariadb。centos7中默认安装，会和mysql冲突。\n\n\n    rpm -qa | grep mariadb  （查找）\n    \n    rpm -e mysql*/mariadb*\n    \n    rpm -e --nodeps mysql*/mariadb*  （强制删除）\n    \n    ----------------------\n    [root@ymu ~]# rpm -qa | grep mariadb\n    mariadb-libs-5.5.56-2.el7.x86_64\n    [root@ymu ~]# rpm -e mysql*/mariadb*\n    error: package mysql*/mariadb* is not installed\n    [root@ymu ~]# rpm -e --nodeps mysql*/mariadb*  \n    error: package mysql*/mariadb* is not installed\n    [root@ymu ~]# rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64\n              \n\n### 准备工作\n\n1.安装依赖\n\n    yum -y install wget  cmake gcc gcc-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel\n        \n2.下载源码包\n\n下载网址： https://dev.mysql.com\n\n    wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz      (此版本带有boost)\n     \n         \n3.创建mysql用户\n\n    groupadd mysql\n    useradd -r -g mysql -s /bin/false mysql\n    \n   \n4.创建安装目录和数据目录\n\n    mkdir -p /server/mysql\n    mkdir -p /server/data/mysql\n    \n### 安装mysql\n\n1.解压源码包\n\n    [root@ymu tools]# tar -zxvf mysql-boost-8.0.11.tar.gz \n    \n2.编译&安装\n\n    [root@ymu tools]# cd mysql-8.0.11/\n    [root@ymu mysql-8.0.11]# cmake .  -DCMAKE_INSTALL_PREFIX=/server/mysql \\\n    > -DMYSQL_DATADIR=/server/data/mysql/ \\\n    > -DDEFAULT_CHARSET=utf8mb4 \\\n    > -DDEFAULT_COLLATION=utf8mb4_general_ci \\\n    > -DWITH_BOOST=/server/tools/mysql-8.0.11/boost/\n       \n    [root@ymu mysql-8.0.11]# make && make install   \n    \n3.配置my.cnf文件\n\n可能找不到该文件，如果没有，新建一个。 \n\n          cat /etc/my.cnf\n          [mysqld]\n          server-id=1\n          port=3306\n          basedir=/server/mysql8\n          datadir=/server/data/mysql8\n    　　　 ##请根据实际情况添加参数\n    \n更改： \n\n    [client]\n    port = 3307\n    socket = /tmp/mysql.sock\n    default-character-set = utf8mb4\n    \n    [mysqld]\n    port=3307\n    socket=/tmp/mysql.sock\n    \n    [mysql.server]\n    server-id=1\n    basedir=/server/mysql\n    datadir=/server/data/mysql\n    pid-file=/server/data/mysql/mysql.pid\n    \n    character-set-server = utf8mb4\n    \n    slow_query_log=1\n    long_query_time=5\n    slow_query_log_file=/server/data/mysql/mysql-slow.log\n    \n    default_storage_engine=InnoDB\n    innodb_file_per_table = 1\n    innodb_open_files = 500\n    innodb_buffer_pool_size = 64M\n    innodb_write_io_threads = 4\n    innodb_read_io_threads = 4\n    innodb_thread_concurrency = 0\n    innodb_purge_threads = 1\n    innodb_flush_log_at_trx_commit = 2\n    innodb_log_buffer_size = 2M\n    innodb_log_file_size = 32M\n    innodb_log_files_in_group = 3\n    innodb_max_dirty_pages_pct = 90\n    innodb_lock_wait_timeout = 120\n\n    \n\n参考：\n\n    [client]\n    port = 3307\n    socket = ~/tmp/mysql.sock\n    default-character-set = utf8mb4\n    \n    [mysqld]\n    port = 3307\n    socket = /home/mutian/tmp/mysql.sock\n    \n    [mysql.server]\n    basedir = /home/mutian/dev/tools/mysql\n    datadir = /home/mutian/dev/data/mysql\n    pid-file = /home/mutian/dev/data/mysql/mysql.pid\n    user = mysql\n    bind-address = 0.0.0.0\n    server-id = 1\n    \n    init-connect = 'SET NAMES utf8mb4'\n    character-set-server = utf8mb4\n    \n    #skip-name-resolve\n    #skip-networking\n    back_log = 300\n    \n    max_connections = 1000\n    max_connect_errors = 6000\n    open_files_limit = 65535\n    table_open_cache = 128\n    max_allowed_packet = 4M\n    binlog_cache_size = 1M\n    max_heap_table_size = 8M\n    tmp_table_size = 16M\n    \n    read_buffer_size = 2M\n    read_rnd_buffer_size = 8M\n    sort_buffer_size = 8M\n    join_buffer_size = 8M\n    key_buffer_size = 4M\n    \n    thread_cache_size = 8\n    \n    query_cache_type = 1\n    query_cache_size = 8M\n    query_cache_limit = 2M\n    \n    ft_min_word_len = 4\n    \n    log_bin = mysql-bin\n    binlog_format = mixed\n    expire_logs_days = 30\n    \n    slow_query_log = 1\n    long_query_time = 1\n    slow_query_log_file = /home/mutian/dev/data/mysql/mysql-slow.log\n    \n    performance_schema = 0\n    explicit_defaults_for_timestamp\n    \n    #lower_case_table_names = 1\n    \n    skip-external-locking\n    \n    default_storage_engine = InnoDB\n    #default-storage-engine = MyISAM\n    innodb_file_per_table = 1\n    innodb_open_files = 500\n    innodb_buffer_pool_size = 64M\n    innodb_write_io_threads = 4\n    innodb_read_io_threads = 4\n    innodb_thread_concurrency = 0\n    innodb_purge_threads = 1\n    innodb_flush_log_at_trx_commit = 2\n    innodb_log_buffer_size = 2M\n    innodb_log_file_size = 32M\n    innodb_log_files_in_group = 3\n    innodb_max_dirty_pages_pct = 90\n    innodb_lock_wait_timeout = 120\n    \n    bulk_insert_buffer_size = 8M\n    myisam_sort_buffer_size = 8M\n    myisam_max_sort_file_size = 10G\n    myisam_repair_threads = 1\n    \n    interactive_timeout = 28800\n    wait_timeout = 28800\n    \n    [mysqldump]\n    quick\n    max_allowed_packet = 16M\n    \n    [myisamchk]\n    key_buffer_size = 8M\n    sort_buffer_size = 8M\n    read_buffer = 4M\n    write_buffer = 4M\n\n4.目录权限修改\n\n    chown -R mysql:mysql /server/mysql\n    chown -R mysql:mysql /server/data/mysql\n    chmod 755 /server/mysql -R\n    chmod 755 /server/data/mysql -R\n\n5.初始化\n\n    bin/mysqld --initialize --user=mysql\n    bin/mysql_ssl_rsa_setup\n\n6.启动mysql\n\n    bin/mysqld_safe --user=mysql &\n\n7.修改账号密码\n\n- 如果出现错误：\n\n       ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)\n       \n说明服务没启动成功。     \n\n- 错误： \n\n       [root@ymu mysql]# bin/mysql  -uroot -p\n       Enter password: \n       ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)\n\n空密码无法登录。\n\n处理（修改密码）： \n\n    bin/mysqld_safe --user=mysql --skip-grant-tables &\n     \n    mysql -uroot -p     //密码，直接按回车登录\n    use mysql;\n    select host, user, authentication_string, plugin from user; \n    update user set authentication_string='' where user='root';\n    flush privileges;\n    //更更改密码\n    ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    quit;\n    \n    ------------------------------\n    如果执行\n    ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    报错误。\n    \n    按下面处理，执行：flush privileges;然后在执行更改密码语句就ok了：\n    mysql> ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\n    mysql> \n    mysql> flush privileges;\n    Query OK, 0 rows affected (0.01 sec)\n    \n    mysql> ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    Query OK, 0 rows affected (0.06 sec)\n    \n    mysql>   \n    \n    如果报错如下信息：\n    Error: Cannot retrieve repository metadata (repomd.xml) for repository: InstallMedia. Please verify its path and try again\n     You could try using --skip-broken to work around the problem\n     You could try running: rpm -Va --nofiles --nodigest\n    \n    我们只要到/etc/yum.repo.s下面把packetxxxx.repo和redhat.repo两个文件删除掉，再启动就可以了， \n    \n    ------------------------------------------\n    查看密码是否已经重置：\n    mysql> select host, user, authentication_string, plugin from user;\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    | host      | user             | authentication_string                                                  | plugin                |\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    | localhost | mysql.infoschema | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | root             | $A$005$ }DQPo%'\u0004:5\u0006'_\u001d#-QhPn/ZULDCRuo2Xh8w2uhS1.zZ/U.W8d7zWwlmpTB3D5 | caching_sha2_password |\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    4 rows in set (0.00 sec)\n    \n    可以看到root用户的密码已经更改。然后重启mysql登录试试。\n    \n    --------------------------\n    客户端连接报错：客户端连接caching-sha2-password问题。\n    这是因为msyql8对密码加密的规则导致，navicat不支持。所以，需要更改加密规则：\n    \n    在服务器，通过mysql客户端登入：\n    [root@ymu ~]# mysql -uroot -p\n    \n    #修改加密规则  \n    ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; \n    或者：\n    ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; \n    \n    #更新密码（mysql_native_password模式）    \n    ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '{NewPassword}';\n    或者：\n    ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '{NewPassword}';\n\n    实际操作过程：\n    mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'ymu123@' PASSWORD EXPIRE NEVER;\n    ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'localhost'\n    mysql> ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;\n    Query OK, 0 rows affected (0.05 sec)\n    \n    mysql> ALTER USER 'root'@'*' IDENTIFIED WITH mysql_native_password BY 'ymu123@';\n    ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'*'\n    mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'ymu123@';\n    Query OK, 0 rows affected (0.10 sec)\n\n    \n设置密码不能是`123456`这些简单的密码，会通不过。所以设置复杂点`ymu123@`。     \n     \n表格中有以下信息：  \nhost: 允许用户登录的 ip ‘位置’ % 表示可以远程；  \nuser: 当前数据库的用户名；    \nauthentication_string: 用户密码（在mysql 5.7.9以后废弃了password字段和password()函数）；  \nplugin： 密码加密方式；  \n\n然后重启就可以登录了。 \n\n参考： https://blog.csdn.net/xinpengfei521/article/details/80400142    \n     \n8.创建软链接（非必要）\n\n    ln -s /server/mysql/bin/* /usr/local/bin/\n\n9.添加到启动（非必要）\n\n开启自动启动mysql：\n\n    cp support-files/mysql.server /etc/init.d/mysql.server\n    chmod +x /etc/init.d/mysql.server\n    chkconfig --add mysql.server\n    chkconfig mysql.server on\n    \n    ------ 参考来源 ----\n    /bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\n    chmod +x /etc/init.d/mysqld\n    chkconfig --add mysqld\n    chkconfig mysqld on\n    \n10.查看启动状态、启动、停止、重启\n\n`mysql.server`对应上面设置自启动的：`/etc/init.d/mysql.server`\n\n查看状态：\n\n`systemctl status mysql.server.service`  \n\n或者：\n`service mysql.server status`\n\n停止：`service mysql.server stop`\n\n启动：`service mysql.server start`\n\n重新启动：`service mysql.server reload`\n\n  \n    \n## 二进制安装包rpm安装（推荐）    \n                  ","slug":"centos-mysql-install","published":1,"updated":"2019-06-16T14:38:33.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqaq0019g4vavkekd1xe","content":"<p>本文介绍在centos7.4下源码编译安装msyql8的步骤……</p>\n<p>参考：<a href=\"https://www.linuxidc.com/Linux/2018-04/152010.htm\" target=\"_blank\" rel=\"noopener\">https://www.linuxidc.com/Linux/2018-04/152010.htm</a></p>\n<h2 id=\"源码编译安装\"><a href=\"#源码编译安装\" class=\"headerlink\" title=\"源码编译安装\"></a>源码编译安装</h2><h3 id=\"安装前清理\"><a href=\"#安装前清理\" class=\"headerlink\" title=\"安装前清理\"></a>安装前清理</h3><ol>\n<li><p>清理旧的mysql</p>\n<pre><code>rpm -pa | grep mysql\n\nyum remove mysql-xxx-xxx-\n</code></pre></li>\n<li><p>删除旧的mysql配置文件，卸载不会自动删除。</p>\n<pre><code>find / -name mysql\n</code></pre></li>\n</ol>\n<p>显示： </p>\n<pre><code>/etc/logrotate.d/mysql\n/etc/selinux/targeted/active/modules/100/mysql\n/etc/selinux/targeted/tmp/modules/100/mysql\n/var/lib/mysql\n/var/lib/mysql/mysql\n/usr/bin/mysql\n/usr/lib64/mysql\n/usr/local/mysql\n</code></pre><p>根据需求使用以下命令 依次 对配置文件进行删除</p>\n<pre><code>rm -rf /var/lib/mysql\n</code></pre><ol start=\"3\">\n<li>卸载当前系统中已安装的mariadb。centos7中默认安装，会和mysql冲突。</li>\n</ol>\n<pre><code>rpm -qa | grep mariadb  （查找）\n\nrpm -e mysql*/mariadb*\n\nrpm -e --nodeps mysql*/mariadb*  （强制删除）\n\n----------------------\n[root@ymu ~]# rpm -qa | grep mariadb\nmariadb-libs-5.5.56-2.el7.x86_64\n[root@ymu ~]# rpm -e mysql*/mariadb*\nerror: package mysql*/mariadb* is not installed\n[root@ymu ~]# rpm -e --nodeps mysql*/mariadb*  \nerror: package mysql*/mariadb* is not installed\n[root@ymu ~]# rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64\n</code></pre><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>1.安装依赖</p>\n<pre><code>yum -y install wget  cmake gcc gcc-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel\n</code></pre><p>2.下载源码包</p>\n<p>下载网址： <a href=\"https://dev.mysql.com\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com</a></p>\n<pre><code>wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz      (此版本带有boost)\n</code></pre><p>3.创建mysql用户</p>\n<pre><code>groupadd mysql\nuseradd -r -g mysql -s /bin/false mysql\n</code></pre><p>4.创建安装目录和数据目录</p>\n<pre><code>mkdir -p /server/mysql\nmkdir -p /server/data/mysql\n</code></pre><h3 id=\"安装mysql\"><a href=\"#安装mysql\" class=\"headerlink\" title=\"安装mysql\"></a>安装mysql</h3><p>1.解压源码包</p>\n<pre><code>[root@ymu tools]# tar -zxvf mysql-boost-8.0.11.tar.gz \n</code></pre><p>2.编译&amp;安装</p>\n<pre><code>[root@ymu tools]# cd mysql-8.0.11/\n[root@ymu mysql-8.0.11]# cmake .  -DCMAKE_INSTALL_PREFIX=/server/mysql \\\n&gt; -DMYSQL_DATADIR=/server/data/mysql/ \\\n&gt; -DDEFAULT_CHARSET=utf8mb4 \\\n&gt; -DDEFAULT_COLLATION=utf8mb4_general_ci \\\n&gt; -DWITH_BOOST=/server/tools/mysql-8.0.11/boost/\n\n[root@ymu mysql-8.0.11]# make &amp;&amp; make install   \n</code></pre><p>3.配置my.cnf文件</p>\n<p>可能找不到该文件，如果没有，新建一个。 </p>\n<pre><code>cat /etc/my.cnf\n[mysqld]\nserver-id=1\nport=3306\nbasedir=/server/mysql8\ndatadir=/server/data/mysql8\n　　　 ##请根据实际情况添加参数\n</code></pre><p>更改： </p>\n<pre><code>[client]\nport = 3307\nsocket = /tmp/mysql.sock\ndefault-character-set = utf8mb4\n\n[mysqld]\nport=3307\nsocket=/tmp/mysql.sock\n\n[mysql.server]\nserver-id=1\nbasedir=/server/mysql\ndatadir=/server/data/mysql\npid-file=/server/data/mysql/mysql.pid\n\ncharacter-set-server = utf8mb4\n\nslow_query_log=1\nlong_query_time=5\nslow_query_log_file=/server/data/mysql/mysql-slow.log\n\ndefault_storage_engine=InnoDB\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\n</code></pre><p>参考：</p>\n<pre><code>[client]\nport = 3307\nsocket = ~/tmp/mysql.sock\ndefault-character-set = utf8mb4\n\n[mysqld]\nport = 3307\nsocket = /home/mutian/tmp/mysql.sock\n\n[mysql.server]\nbasedir = /home/mutian/dev/tools/mysql\ndatadir = /home/mutian/dev/data/mysql\npid-file = /home/mutian/dev/data/mysql/mysql.pid\nuser = mysql\nbind-address = 0.0.0.0\nserver-id = 1\n\ninit-connect = &apos;SET NAMES utf8mb4&apos;\ncharacter-set-server = utf8mb4\n\n#skip-name-resolve\n#skip-networking\nback_log = 300\n\nmax_connections = 1000\nmax_connect_errors = 6000\nopen_files_limit = 65535\ntable_open_cache = 128\nmax_allowed_packet = 4M\nbinlog_cache_size = 1M\nmax_heap_table_size = 8M\ntmp_table_size = 16M\n\nread_buffer_size = 2M\nread_rnd_buffer_size = 8M\nsort_buffer_size = 8M\njoin_buffer_size = 8M\nkey_buffer_size = 4M\n\nthread_cache_size = 8\n\nquery_cache_type = 1\nquery_cache_size = 8M\nquery_cache_limit = 2M\n\nft_min_word_len = 4\n\nlog_bin = mysql-bin\nbinlog_format = mixed\nexpire_logs_days = 30\n\nslow_query_log = 1\nlong_query_time = 1\nslow_query_log_file = /home/mutian/dev/data/mysql/mysql-slow.log\n\nperformance_schema = 0\nexplicit_defaults_for_timestamp\n\n#lower_case_table_names = 1\n\nskip-external-locking\n\ndefault_storage_engine = InnoDB\n#default-storage-engine = MyISAM\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\n\nbulk_insert_buffer_size = 8M\nmyisam_sort_buffer_size = 8M\nmyisam_max_sort_file_size = 10G\nmyisam_repair_threads = 1\n\ninteractive_timeout = 28800\nwait_timeout = 28800\n\n[mysqldump]\nquick\nmax_allowed_packet = 16M\n\n[myisamchk]\nkey_buffer_size = 8M\nsort_buffer_size = 8M\nread_buffer = 4M\nwrite_buffer = 4M\n</code></pre><p>4.目录权限修改</p>\n<pre><code>chown -R mysql:mysql /server/mysql\nchown -R mysql:mysql /server/data/mysql\nchmod 755 /server/mysql -R\nchmod 755 /server/data/mysql -R\n</code></pre><p>5.初始化</p>\n<pre><code>bin/mysqld --initialize --user=mysql\nbin/mysql_ssl_rsa_setup\n</code></pre><p>6.启动mysql</p>\n<pre><code>bin/mysqld_safe --user=mysql &amp;\n</code></pre><p>7.修改账号密码</p>\n<ul>\n<li><p>如果出现错误：</p>\n<pre><code>ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2)\n</code></pre></li>\n</ul>\n<p>说明服务没启动成功。     </p>\n<ul>\n<li><p>错误： </p>\n<pre><code>[root@ymu mysql]# bin/mysql  -uroot -p\nEnter password: \nERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)\n</code></pre></li>\n</ul>\n<p>空密码无法登录。</p>\n<p>处理（修改密码）： </p>\n<pre><code>bin/mysqld_safe --user=mysql --skip-grant-tables &amp;\n\nmysql -uroot -p     //密码，直接按回车登录\nuse mysql;\nselect host, user, authentication_string, plugin from user; \nupdate user set authentication_string=&apos;&apos; where user=&apos;root&apos;;\nflush privileges;\n//更更改密码\nALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nquit;\n\n------------------------------\n如果执行\nALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\n报错误。\n\n按下面处理，执行：flush privileges;然后在执行更改密码语句就ok了：\nmysql&gt; ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\nmysql&gt; \nmysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nQuery OK, 0 rows affected (0.06 sec)\n\nmysql&gt;   \n\n如果报错如下信息：\nError: Cannot retrieve repository metadata (repomd.xml) for repository: InstallMedia. Please verify its path and try again\n You could try using --skip-broken to work around the problem\n You could try running: rpm -Va --nofiles --nodigest\n\n我们只要到/etc/yum.repo.s下面把packetxxxx.repo和redhat.repo两个文件删除掉，再启动就可以了， \n\n------------------------------------------\n查看密码是否已经重置：\nmysql&gt; select host, user, authentication_string, plugin from user;\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n| host      | user             | authentication_string                                                  | plugin                |\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n| localhost | mysql.infoschema | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | root             | $A$005$ }DQPo%&apos;\u0004:5\u0006&apos;_\u001d#-QhPn/ZULDCRuo2Xh8w2uhS1.zZ/U.W8d7zWwlmpTB3D5 | caching_sha2_password |\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n4 rows in set (0.00 sec)\n\n可以看到root用户的密码已经更改。然后重启mysql登录试试。\n\n--------------------------\n客户端连接报错：客户端连接caching-sha2-password问题。\n这是因为msyql8对密码加密的规则导致，navicat不支持。所以，需要更改加密规则：\n\n在服务器，通过mysql客户端登入：\n[root@ymu ~]# mysql -uroot -p\n\n#修改加密规则  \nALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; \n或者：\nALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; \n\n#更新密码（mysql_native_password模式）    \nALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;{NewPassword}&apos;;\n或者：\nALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;{NewPassword}&apos;;\n\n实际操作过程：\nmysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos; PASSWORD EXPIRE NEVER;\nERROR 1396 (HY000): Operation ALTER USER failed for &apos;root&apos;@&apos;localhost&apos;\nmysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER;\nQuery OK, 0 rows affected (0.05 sec)\n\nmysql&gt; ALTER USER &apos;root&apos;@&apos;*&apos; IDENTIFIED WITH mysql_native_password BY &apos;ymu123@&apos;;\nERROR 1396 (HY000): Operation ALTER USER failed for &apos;root&apos;@&apos;*&apos;\nmysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;ymu123@&apos;;\nQuery OK, 0 rows affected (0.10 sec)\n</code></pre><p>设置密码不能是<code>123456</code>这些简单的密码，会通不过。所以设置复杂点<code>ymu123@</code>。     </p>\n<p>表格中有以下信息：<br>host: 允许用户登录的 ip ‘位置’ % 表示可以远程；<br>user: 当前数据库的用户名；<br>authentication_string: 用户密码（在mysql 5.7.9以后废弃了password字段和password()函数）；<br>plugin： 密码加密方式；  </p>\n<p>然后重启就可以登录了。 </p>\n<p>参考： <a href=\"https://blog.csdn.net/xinpengfei521/article/details/80400142\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xinpengfei521/article/details/80400142</a>    </p>\n<p>8.创建软链接（非必要）</p>\n<pre><code>ln -s /server/mysql/bin/* /usr/local/bin/\n</code></pre><p>9.添加到启动（非必要）</p>\n<p>开启自动启动mysql：</p>\n<pre><code>cp support-files/mysql.server /etc/init.d/mysql.server\nchmod +x /etc/init.d/mysql.server\nchkconfig --add mysql.server\nchkconfig mysql.server on\n\n------ 参考来源 ----\n/bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\nchmod +x /etc/init.d/mysqld\nchkconfig --add mysqld\nchkconfig mysqld on\n</code></pre><p>10.查看启动状态、启动、停止、重启</p>\n<p><code>mysql.server</code>对应上面设置自启动的：<code>/etc/init.d/mysql.server</code></p>\n<p>查看状态：</p>\n<p><code>systemctl status mysql.server.service</code>  </p>\n<p>或者：<br><code>service mysql.server status</code></p>\n<p>停止：<code>service mysql.server stop</code></p>\n<p>启动：<code>service mysql.server start</code></p>\n<p>重新启动：<code>service mysql.server reload</code></p>\n<h2 id=\"二进制安装包rpm安装（推荐）\"><a href=\"#二进制安装包rpm安装（推荐）\" class=\"headerlink\" title=\"二进制安装包rpm安装（推荐）\"></a>二进制安装包rpm安装（推荐）</h2>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍在centos7.4下源码编译安装msyql8的步骤……</p>\n<p>参考：<a href=\"https://www.linuxidc.com/Linux/2018-04/152010.htm\" target=\"_blank\" rel=\"noopener\">https://www.linuxidc.com/Linux/2018-04/152010.htm</a></p>\n<h2 id=\"源码编译安装\"><a href=\"#源码编译安装\" class=\"headerlink\" title=\"源码编译安装\"></a>源码编译安装</h2><h3 id=\"安装前清理\"><a href=\"#安装前清理\" class=\"headerlink\" title=\"安装前清理\"></a>安装前清理</h3><ol>\n<li><p>清理旧的mysql</p>\n<pre><code>rpm -pa | grep mysql\n\nyum remove mysql-xxx-xxx-\n</code></pre></li>\n<li><p>删除旧的mysql配置文件，卸载不会自动删除。</p>\n<pre><code>find / -name mysql\n</code></pre></li>\n</ol>\n<p>显示： </p>\n<pre><code>/etc/logrotate.d/mysql\n/etc/selinux/targeted/active/modules/100/mysql\n/etc/selinux/targeted/tmp/modules/100/mysql\n/var/lib/mysql\n/var/lib/mysql/mysql\n/usr/bin/mysql\n/usr/lib64/mysql\n/usr/local/mysql\n</code></pre><p>根据需求使用以下命令 依次 对配置文件进行删除</p>\n<pre><code>rm -rf /var/lib/mysql\n</code></pre><ol start=\"3\">\n<li>卸载当前系统中已安装的mariadb。centos7中默认安装，会和mysql冲突。</li>\n</ol>\n<pre><code>rpm -qa | grep mariadb  （查找）\n\nrpm -e mysql*/mariadb*\n\nrpm -e --nodeps mysql*/mariadb*  （强制删除）\n\n----------------------\n[root@ymu ~]# rpm -qa | grep mariadb\nmariadb-libs-5.5.56-2.el7.x86_64\n[root@ymu ~]# rpm -e mysql*/mariadb*\nerror: package mysql*/mariadb* is not installed\n[root@ymu ~]# rpm -e --nodeps mysql*/mariadb*  \nerror: package mysql*/mariadb* is not installed\n[root@ymu ~]# rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64\n</code></pre><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>1.安装依赖</p>\n<pre><code>yum -y install wget  cmake gcc gcc-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel\n</code></pre><p>2.下载源码包</p>\n<p>下载网址： <a href=\"https://dev.mysql.com\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com</a></p>\n<pre><code>wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz      (此版本带有boost)\n</code></pre><p>3.创建mysql用户</p>\n<pre><code>groupadd mysql\nuseradd -r -g mysql -s /bin/false mysql\n</code></pre><p>4.创建安装目录和数据目录</p>\n<pre><code>mkdir -p /server/mysql\nmkdir -p /server/data/mysql\n</code></pre><h3 id=\"安装mysql\"><a href=\"#安装mysql\" class=\"headerlink\" title=\"安装mysql\"></a>安装mysql</h3><p>1.解压源码包</p>\n<pre><code>[root@ymu tools]# tar -zxvf mysql-boost-8.0.11.tar.gz \n</code></pre><p>2.编译&amp;安装</p>\n<pre><code>[root@ymu tools]# cd mysql-8.0.11/\n[root@ymu mysql-8.0.11]# cmake .  -DCMAKE_INSTALL_PREFIX=/server/mysql \\\n&gt; -DMYSQL_DATADIR=/server/data/mysql/ \\\n&gt; -DDEFAULT_CHARSET=utf8mb4 \\\n&gt; -DDEFAULT_COLLATION=utf8mb4_general_ci \\\n&gt; -DWITH_BOOST=/server/tools/mysql-8.0.11/boost/\n\n[root@ymu mysql-8.0.11]# make &amp;&amp; make install   \n</code></pre><p>3.配置my.cnf文件</p>\n<p>可能找不到该文件，如果没有，新建一个。 </p>\n<pre><code>cat /etc/my.cnf\n[mysqld]\nserver-id=1\nport=3306\nbasedir=/server/mysql8\ndatadir=/server/data/mysql8\n　　　 ##请根据实际情况添加参数\n</code></pre><p>更改： </p>\n<pre><code>[client]\nport = 3307\nsocket = /tmp/mysql.sock\ndefault-character-set = utf8mb4\n\n[mysqld]\nport=3307\nsocket=/tmp/mysql.sock\n\n[mysql.server]\nserver-id=1\nbasedir=/server/mysql\ndatadir=/server/data/mysql\npid-file=/server/data/mysql/mysql.pid\n\ncharacter-set-server = utf8mb4\n\nslow_query_log=1\nlong_query_time=5\nslow_query_log_file=/server/data/mysql/mysql-slow.log\n\ndefault_storage_engine=InnoDB\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\n</code></pre><p>参考：</p>\n<pre><code>[client]\nport = 3307\nsocket = ~/tmp/mysql.sock\ndefault-character-set = utf8mb4\n\n[mysqld]\nport = 3307\nsocket = /home/mutian/tmp/mysql.sock\n\n[mysql.server]\nbasedir = /home/mutian/dev/tools/mysql\ndatadir = /home/mutian/dev/data/mysql\npid-file = /home/mutian/dev/data/mysql/mysql.pid\nuser = mysql\nbind-address = 0.0.0.0\nserver-id = 1\n\ninit-connect = &apos;SET NAMES utf8mb4&apos;\ncharacter-set-server = utf8mb4\n\n#skip-name-resolve\n#skip-networking\nback_log = 300\n\nmax_connections = 1000\nmax_connect_errors = 6000\nopen_files_limit = 65535\ntable_open_cache = 128\nmax_allowed_packet = 4M\nbinlog_cache_size = 1M\nmax_heap_table_size = 8M\ntmp_table_size = 16M\n\nread_buffer_size = 2M\nread_rnd_buffer_size = 8M\nsort_buffer_size = 8M\njoin_buffer_size = 8M\nkey_buffer_size = 4M\n\nthread_cache_size = 8\n\nquery_cache_type = 1\nquery_cache_size = 8M\nquery_cache_limit = 2M\n\nft_min_word_len = 4\n\nlog_bin = mysql-bin\nbinlog_format = mixed\nexpire_logs_days = 30\n\nslow_query_log = 1\nlong_query_time = 1\nslow_query_log_file = /home/mutian/dev/data/mysql/mysql-slow.log\n\nperformance_schema = 0\nexplicit_defaults_for_timestamp\n\n#lower_case_table_names = 1\n\nskip-external-locking\n\ndefault_storage_engine = InnoDB\n#default-storage-engine = MyISAM\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\n\nbulk_insert_buffer_size = 8M\nmyisam_sort_buffer_size = 8M\nmyisam_max_sort_file_size = 10G\nmyisam_repair_threads = 1\n\ninteractive_timeout = 28800\nwait_timeout = 28800\n\n[mysqldump]\nquick\nmax_allowed_packet = 16M\n\n[myisamchk]\nkey_buffer_size = 8M\nsort_buffer_size = 8M\nread_buffer = 4M\nwrite_buffer = 4M\n</code></pre><p>4.目录权限修改</p>\n<pre><code>chown -R mysql:mysql /server/mysql\nchown -R mysql:mysql /server/data/mysql\nchmod 755 /server/mysql -R\nchmod 755 /server/data/mysql -R\n</code></pre><p>5.初始化</p>\n<pre><code>bin/mysqld --initialize --user=mysql\nbin/mysql_ssl_rsa_setup\n</code></pre><p>6.启动mysql</p>\n<pre><code>bin/mysqld_safe --user=mysql &amp;\n</code></pre><p>7.修改账号密码</p>\n<ul>\n<li><p>如果出现错误：</p>\n<pre><code>ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2)\n</code></pre></li>\n</ul>\n<p>说明服务没启动成功。     </p>\n<ul>\n<li><p>错误： </p>\n<pre><code>[root@ymu mysql]# bin/mysql  -uroot -p\nEnter password: \nERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)\n</code></pre></li>\n</ul>\n<p>空密码无法登录。</p>\n<p>处理（修改密码）： </p>\n<pre><code>bin/mysqld_safe --user=mysql --skip-grant-tables &amp;\n\nmysql -uroot -p     //密码，直接按回车登录\nuse mysql;\nselect host, user, authentication_string, plugin from user; \nupdate user set authentication_string=&apos;&apos; where user=&apos;root&apos;;\nflush privileges;\n//更更改密码\nALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nquit;\n\n------------------------------\n如果执行\nALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\n报错误。\n\n按下面处理，执行：flush privileges;然后在执行更改密码语句就ok了：\nmysql&gt; ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\nmysql&gt; \nmysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nQuery OK, 0 rows affected (0.06 sec)\n\nmysql&gt;   \n\n如果报错如下信息：\nError: Cannot retrieve repository metadata (repomd.xml) for repository: InstallMedia. Please verify its path and try again\n You could try using --skip-broken to work around the problem\n You could try running: rpm -Va --nofiles --nodigest\n\n我们只要到/etc/yum.repo.s下面把packetxxxx.repo和redhat.repo两个文件删除掉，再启动就可以了， \n\n------------------------------------------\n查看密码是否已经重置：\nmysql&gt; select host, user, authentication_string, plugin from user;\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n| host      | user             | authentication_string                                                  | plugin                |\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n| localhost | mysql.infoschema | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | root             | $A$005$ }DQPo%&apos;\u0004:5\u0006&apos;_\u001d#-QhPn/ZULDCRuo2Xh8w2uhS1.zZ/U.W8d7zWwlmpTB3D5 | caching_sha2_password |\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n4 rows in set (0.00 sec)\n\n可以看到root用户的密码已经更改。然后重启mysql登录试试。\n\n--------------------------\n客户端连接报错：客户端连接caching-sha2-password问题。\n这是因为msyql8对密码加密的规则导致，navicat不支持。所以，需要更改加密规则：\n\n在服务器，通过mysql客户端登入：\n[root@ymu ~]# mysql -uroot -p\n\n#修改加密规则  \nALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; \n或者：\nALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; \n\n#更新密码（mysql_native_password模式）    \nALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;{NewPassword}&apos;;\n或者：\nALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;{NewPassword}&apos;;\n\n实际操作过程：\nmysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos; PASSWORD EXPIRE NEVER;\nERROR 1396 (HY000): Operation ALTER USER failed for &apos;root&apos;@&apos;localhost&apos;\nmysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER;\nQuery OK, 0 rows affected (0.05 sec)\n\nmysql&gt; ALTER USER &apos;root&apos;@&apos;*&apos; IDENTIFIED WITH mysql_native_password BY &apos;ymu123@&apos;;\nERROR 1396 (HY000): Operation ALTER USER failed for &apos;root&apos;@&apos;*&apos;\nmysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;ymu123@&apos;;\nQuery OK, 0 rows affected (0.10 sec)\n</code></pre><p>设置密码不能是<code>123456</code>这些简单的密码，会通不过。所以设置复杂点<code>ymu123@</code>。     </p>\n<p>表格中有以下信息：<br>host: 允许用户登录的 ip ‘位置’ % 表示可以远程；<br>user: 当前数据库的用户名；<br>authentication_string: 用户密码（在mysql 5.7.9以后废弃了password字段和password()函数）；<br>plugin： 密码加密方式；  </p>\n<p>然后重启就可以登录了。 </p>\n<p>参考： <a href=\"https://blog.csdn.net/xinpengfei521/article/details/80400142\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xinpengfei521/article/details/80400142</a>    </p>\n<p>8.创建软链接（非必要）</p>\n<pre><code>ln -s /server/mysql/bin/* /usr/local/bin/\n</code></pre><p>9.添加到启动（非必要）</p>\n<p>开启自动启动mysql：</p>\n<pre><code>cp support-files/mysql.server /etc/init.d/mysql.server\nchmod +x /etc/init.d/mysql.server\nchkconfig --add mysql.server\nchkconfig mysql.server on\n\n------ 参考来源 ----\n/bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\nchmod +x /etc/init.d/mysqld\nchkconfig --add mysqld\nchkconfig mysqld on\n</code></pre><p>10.查看启动状态、启动、停止、重启</p>\n<p><code>mysql.server</code>对应上面设置自启动的：<code>/etc/init.d/mysql.server</code></p>\n<p>查看状态：</p>\n<p><code>systemctl status mysql.server.service</code>  </p>\n<p>或者：<br><code>service mysql.server status</code></p>\n<p>停止：<code>service mysql.server stop</code></p>\n<p>启动：<code>service mysql.server start</code></p>\n<p>重新启动：<code>service mysql.server reload</code></p>\n<h2 id=\"二进制安装包rpm安装（推荐）\"><a href=\"#二进制安装包rpm安装（推荐）\" class=\"headerlink\" title=\"二进制安装包rpm安装（推荐）\"></a>二进制安装包rpm安装（推荐）</h2>"},{"title":"Cron 语法","date":"2017-10-24T02:23:19.000Z","_content":"\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]   \ncron语法主要用在定时任务上。linux系统有个类似的crontab。\n\n|   序号   |\t说明\t|是否必填|\t允许填写的值\t|允许的符号|\n|:---|:---|:---|:---|:---|\n|1\t|秒   |是\t|0－59\t|, - * /|\n |2\t|分\t    |是 |0－59\t|, - * /|\n |3\t|小时   |是\t |0－23 |\t, - * / |\n |4\t|日\t    |是\t |1－31\t|, - * ? / L W |\n |5\t|月\t    |是\t |1－12 or JAN-DEC\t|, - * /|\n |6\t|星期\t|是\t |1-7 or SUN-SAT\t|, - * ? / L #  |\n |7\t|年\t     |否\t|1970-2099\t|, - * / |\n \n> 其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。\n\n_详细说明_\n\n“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。 \n“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。 \n“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。\n\n`*`表示所有值. 如在“分”上设置“`*`”，表示每分钟触发。 \n“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”\n\n“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同\n\n“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。 \n“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。 \n如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四\n\n> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n\nW表示离指定日期的最近那个工作日(周一至周五). \n例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。 \n如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。 \n如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。 \n如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。\n\n> 小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；\n\n_常用示例_\n\n0 0 12 * * ? 每天12点触发\n\n0 15 10 ? * * 每天10点15分触发\n\n0 15 10 * * ? 每天10点15分触发\n\n0 15 10 * * ? * 每天10点15分触发\n\n0 15 10 * * ? 2005 2005年每天10点15分触发\n\n0 * 14 * * ? 每天14点到14点59分之间，每分钟触发一次\n\n0 0/5 14 * * ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）\n\n0 0/5 14，18 * * ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）\n\n0 0-5 14 * * ? 每天14点到14点05分之间，每分钟触发\n\n0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发\n\n0 15 10 ? * MON-FRI 周一到周五每天10点15分触发\n\n0 15 10 15 * ? 每月15号10点15分触发\n\n0 15 10 L * ? 每月最后一天的10点15分触发\n\n0 15 10 ? * 6L 每月最后一个周五的10点15分触发\n\n0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发\n\n0 15 10 ? * 6#3 每月第三个周五的10点15分触发\n\n0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次\n\n------------------------------\n\n资料：\n\n1.cron表达式生成器：http://cron.qqe2.com/\n\n\n\n","source":"_posts/cron-grammar.md","raw":"---\ntitle:  Cron 语法\ndate: 2017-10-24 10:23:19\ncategories: java\ntags: cron-grammar\n---\n\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]   \ncron语法主要用在定时任务上。linux系统有个类似的crontab。\n\n|   序号   |\t说明\t|是否必填|\t允许填写的值\t|允许的符号|\n|:---|:---|:---|:---|:---|\n|1\t|秒   |是\t|0－59\t|, - * /|\n |2\t|分\t    |是 |0－59\t|, - * /|\n |3\t|小时   |是\t |0－23 |\t, - * / |\n |4\t|日\t    |是\t |1－31\t|, - * ? / L W |\n |5\t|月\t    |是\t |1－12 or JAN-DEC\t|, - * /|\n |6\t|星期\t|是\t |1-7 or SUN-SAT\t|, - * ? / L #  |\n |7\t|年\t     |否\t|1970-2099\t|, - * / |\n \n> 其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。\n\n_详细说明_\n\n“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。 \n“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。 \n“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。\n\n`*`表示所有值. 如在“分”上设置“`*`”，表示每分钟触发。 \n“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”\n\n“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同\n\n“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。 \n“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。 \n如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四\n\n> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n\nW表示离指定日期的最近那个工作日(周一至周五). \n例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。 \n如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。 \n如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。 \n如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。\n\n> 小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；\n\n_常用示例_\n\n0 0 12 * * ? 每天12点触发\n\n0 15 10 ? * * 每天10点15分触发\n\n0 15 10 * * ? 每天10点15分触发\n\n0 15 10 * * ? * 每天10点15分触发\n\n0 15 10 * * ? 2005 2005年每天10点15分触发\n\n0 * 14 * * ? 每天14点到14点59分之间，每分钟触发一次\n\n0 0/5 14 * * ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）\n\n0 0/5 14，18 * * ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）\n\n0 0-5 14 * * ? 每天14点到14点05分之间，每分钟触发\n\n0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发\n\n0 15 10 ? * MON-FRI 周一到周五每天10点15分触发\n\n0 15 10 15 * ? 每月15号10点15分触发\n\n0 15 10 L * ? 每月最后一天的10点15分触发\n\n0 15 10 ? * 6L 每月最后一个周五的10点15分触发\n\n0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发\n\n0 15 10 ? * 6#3 每月第三个周五的10点15分触发\n\n0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次\n\n------------------------------\n\n资料：\n\n1.cron表达式生成器：http://cron.qqe2.com/\n\n\n\n","slug":"cron-grammar","published":1,"updated":"2019-11-10T14:27:50.788Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqar001dg4va14t85gpf","content":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]<br>cron语法主要用在定时任务上。linux系统有个类似的crontab。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">允许填写的值</th>\n<th style=\"text-align:left\">允许的符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">秒</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">分</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">小时</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－23</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">日</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－31</td>\n<td style=\"text-align:left\">, - * ? / L W</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">月</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－12 or JAN-DEC</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">星期</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1-7 or SUN-SAT</td>\n<td style=\"text-align:left\">, - * ? / L #</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">1970-2099</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。</p>\n</blockquote>\n<p><em>详细说明</em></p>\n<p>“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。<br>“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。<br>“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。</p>\n<p><code>*</code>表示所有值. 如在“分”上设置“<code>*</code>”，表示每分钟触发。<br>“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”</p>\n<p>“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同</p>\n<p>“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。<br>“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。<br>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四</p>\n<blockquote>\n<p>注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>\n</blockquote>\n<p>W表示离指定日期的最近那个工作日(周一至周五).<br>例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。<br>如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。<br>如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。<br>如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。</p>\n<blockquote>\n<p>小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；</p>\n</blockquote>\n<p><em>常用示例</em></p>\n<p>0 0 12 <em> </em> ? 每天12点触发</p>\n<p>0 15 10 ? <em> </em> 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? * 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 2005 2005年每天10点15分触发</p>\n<p>0 <em> 14 </em> * ? 每天14点到14点59分之间，每分钟触发一次</p>\n<p>0 0/5 14 <em> </em> ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）</p>\n<p>0 0/5 14，18 <em> </em> ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）</p>\n<p>0 0-5 14 <em> </em> ? 每天14点到14点05分之间，每分钟触发</p>\n<p>0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发</p>\n<p>0 15 10 ? * MON-FRI 周一到周五每天10点15分触发</p>\n<p>0 15 10 15 * ? 每月15号10点15分触发</p>\n<p>0 15 10 L * ? 每月最后一天的10点15分触发</p>\n<p>0 15 10 ? * 6L 每月最后一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6#3 每月第三个周五的10点15分触发</p>\n<p>0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次</p>\n<hr>\n<p>资料：</p>\n<p>1.cron表达式生成器：<a href=\"http://cron.qqe2.com/\" target=\"_blank\" rel=\"noopener\">http://cron.qqe2.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]<br>cron语法主要用在定时任务上。linux系统有个类似的crontab。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">允许填写的值</th>\n<th style=\"text-align:left\">允许的符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">秒</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">分</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">小时</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－23</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">日</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－31</td>\n<td style=\"text-align:left\">, - * ? / L W</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">月</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－12 or JAN-DEC</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">星期</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1-7 or SUN-SAT</td>\n<td style=\"text-align:left\">, - * ? / L #</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">1970-2099</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。</p>\n</blockquote>\n<p><em>详细说明</em></p>\n<p>“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。<br>“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。<br>“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。</p>\n<p><code>*</code>表示所有值. 如在“分”上设置“<code>*</code>”，表示每分钟触发。<br>“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”</p>\n<p>“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同</p>\n<p>“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。<br>“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。<br>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四</p>\n<blockquote>\n<p>注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>\n</blockquote>\n<p>W表示离指定日期的最近那个工作日(周一至周五).<br>例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。<br>如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。<br>如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。<br>如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。</p>\n<blockquote>\n<p>小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；</p>\n</blockquote>\n<p><em>常用示例</em></p>\n<p>0 0 12 <em> </em> ? 每天12点触发</p>\n<p>0 15 10 ? <em> </em> 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? * 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 2005 2005年每天10点15分触发</p>\n<p>0 <em> 14 </em> * ? 每天14点到14点59分之间，每分钟触发一次</p>\n<p>0 0/5 14 <em> </em> ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）</p>\n<p>0 0/5 14，18 <em> </em> ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）</p>\n<p>0 0-5 14 <em> </em> ? 每天14点到14点05分之间，每分钟触发</p>\n<p>0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发</p>\n<p>0 15 10 ? * MON-FRI 周一到周五每天10点15分触发</p>\n<p>0 15 10 15 * ? 每月15号10点15分触发</p>\n<p>0 15 10 L * ? 每月最后一天的10点15分触发</p>\n<p>0 15 10 ? * 6L 每月最后一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6#3 每月第三个周五的10点15分触发</p>\n<p>0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次</p>\n<hr>\n<p>资料：</p>\n<p>1.cron表达式生成器：<a href=\"http://cron.qqe2.com/\" target=\"_blank\" rel=\"noopener\">http://cron.qqe2.com/</a></p>\n"},{"title":"分布式系统几大难点","date":"2017-11-08T06:57:10.000Z","_content":"\n## 1. 分布式ID\n\n## 2. 分布式事务\n\n## 3. 分布式缓存以及缓存与数据库的同步\n\n## 4. 数据库集群同步延迟问题\n\n## 5. 分布式跨库连表查询\n\n## 6. 分布式定时任务\n\n## 7.分布式锁","source":"_posts/distributed-difficulty.md","raw":"---\ntitle: 分布式系统几大难点\ndate: 2017-11-08 14:57:10\ncategories: 分布式系统\ntags:\n---\n\n## 1. 分布式ID\n\n## 2. 分布式事务\n\n## 3. 分布式缓存以及缓存与数据库的同步\n\n## 4. 数据库集群同步延迟问题\n\n## 5. 分布式跨库连表查询\n\n## 6. 分布式定时任务\n\n## 7.分布式锁","slug":"distributed-difficulty","published":1,"updated":"2019-06-16T14:38:33.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqas001fg4vaaz23w0c4","content":"<h2 id=\"1-分布式ID\"><a href=\"#1-分布式ID\" class=\"headerlink\" title=\"1. 分布式ID\"></a>1. 分布式ID</h2><h2 id=\"2-分布式事务\"><a href=\"#2-分布式事务\" class=\"headerlink\" title=\"2. 分布式事务\"></a>2. 分布式事务</h2><h2 id=\"3-分布式缓存以及缓存与数据库的同步\"><a href=\"#3-分布式缓存以及缓存与数据库的同步\" class=\"headerlink\" title=\"3. 分布式缓存以及缓存与数据库的同步\"></a>3. 分布式缓存以及缓存与数据库的同步</h2><h2 id=\"4-数据库集群同步延迟问题\"><a href=\"#4-数据库集群同步延迟问题\" class=\"headerlink\" title=\"4. 数据库集群同步延迟问题\"></a>4. 数据库集群同步延迟问题</h2><h2 id=\"5-分布式跨库连表查询\"><a href=\"#5-分布式跨库连表查询\" class=\"headerlink\" title=\"5. 分布式跨库连表查询\"></a>5. 分布式跨库连表查询</h2><h2 id=\"6-分布式定时任务\"><a href=\"#6-分布式定时任务\" class=\"headerlink\" title=\"6. 分布式定时任务\"></a>6. 分布式定时任务</h2><h2 id=\"7-分布式锁\"><a href=\"#7-分布式锁\" class=\"headerlink\" title=\"7.分布式锁\"></a>7.分布式锁</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-分布式ID\"><a href=\"#1-分布式ID\" class=\"headerlink\" title=\"1. 分布式ID\"></a>1. 分布式ID</h2><h2 id=\"2-分布式事务\"><a href=\"#2-分布式事务\" class=\"headerlink\" title=\"2. 分布式事务\"></a>2. 分布式事务</h2><h2 id=\"3-分布式缓存以及缓存与数据库的同步\"><a href=\"#3-分布式缓存以及缓存与数据库的同步\" class=\"headerlink\" title=\"3. 分布式缓存以及缓存与数据库的同步\"></a>3. 分布式缓存以及缓存与数据库的同步</h2><h2 id=\"4-数据库集群同步延迟问题\"><a href=\"#4-数据库集群同步延迟问题\" class=\"headerlink\" title=\"4. 数据库集群同步延迟问题\"></a>4. 数据库集群同步延迟问题</h2><h2 id=\"5-分布式跨库连表查询\"><a href=\"#5-分布式跨库连表查询\" class=\"headerlink\" title=\"5. 分布式跨库连表查询\"></a>5. 分布式跨库连表查询</h2><h2 id=\"6-分布式定时任务\"><a href=\"#6-分布式定时任务\" class=\"headerlink\" title=\"6. 分布式定时任务\"></a>6. 分布式定时任务</h2><h2 id=\"7-分布式锁\"><a href=\"#7-分布式锁\" class=\"headerlink\" title=\"7.分布式锁\"></a>7.分布式锁</h2>"},{"title":"分布式ID生成-snowflake算法","date":"2017-09-20T03:06:57.000Z","_content":"## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","source":"_posts/distributed-id-snowflake.md","raw":"---\ntitle: 分布式ID生成-snowflake算法\ndate: 2017-09-20 11:06:57\ncategories: 分布式系统\ntags: snowflake算法\n---\n## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","slug":"distributed-id-snowflake","published":1,"updated":"2019-06-16T14:38:33.338Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqat001hg4vambkq5x55","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>"},{"title":"分布式锁","date":"2019-05-10T14:35:22.000Z","_content":"\n## 为什么要使用分布式锁\n\n对共享变量或者数据（数据库数据）多线程操作的时候，为了避免在同一个时刻多线程操作导致数据的混乱，我们可以通过线程的互斥等来控制某个时刻只有一个线程执行，但这只是再单机应用下。\n\n但是，随着业务的发展，架构随之发展，就需要做集群，负载均衡，这样子，同一个方法或者变量就会以多线程的方式且再不同的物理机也就是不同的jvm上同时执行，这显然是不对的，我们想要的是在某个时刻，该方法或者共享数据只在一个线程中执行，也就是只在某一台物理机子上执行，其余的排斥。这时，分布式锁就派上用场了，它就是做这么一件事的。\n\n## 分布式锁应该具备哪些条件\n\n在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：\n\n>1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； \n2、高可用的获取锁与释放锁； \n3、高性能的获取锁与释放锁； \n4、具备可重入特性； \n5、具备锁失效机制，防止死锁； \n6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败\n\n## 常用分布式锁实现方式\n\n>基于数据库实现分布式锁； \n基于缓存（Redis等）实现分布式锁； \n基于Zookeeper实现分布式锁；\n\n### 1.基于Redis缓存实现分布式锁\n\n#### Spring Boot使用RedLock实现分布式锁\n\n\n\n\n### 2.基于Zookeeper实现分布式锁\n\n\n### 3.基于数据库实现分布式锁\n\n\nhttps://www.cnblogs.com/seesun2012/p/9214653.html","source":"_posts/distributed-lock.md","raw":"---\ntitle: 分布式锁\ndate: 2019-05-10 22:35:22\ncategories: 分布式系统\ntags:\n---\n\n## 为什么要使用分布式锁\n\n对共享变量或者数据（数据库数据）多线程操作的时候，为了避免在同一个时刻多线程操作导致数据的混乱，我们可以通过线程的互斥等来控制某个时刻只有一个线程执行，但这只是再单机应用下。\n\n但是，随着业务的发展，架构随之发展，就需要做集群，负载均衡，这样子，同一个方法或者变量就会以多线程的方式且再不同的物理机也就是不同的jvm上同时执行，这显然是不对的，我们想要的是在某个时刻，该方法或者共享数据只在一个线程中执行，也就是只在某一台物理机子上执行，其余的排斥。这时，分布式锁就派上用场了，它就是做这么一件事的。\n\n## 分布式锁应该具备哪些条件\n\n在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：\n\n>1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； \n2、高可用的获取锁与释放锁； \n3、高性能的获取锁与释放锁； \n4、具备可重入特性； \n5、具备锁失效机制，防止死锁； \n6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败\n\n## 常用分布式锁实现方式\n\n>基于数据库实现分布式锁； \n基于缓存（Redis等）实现分布式锁； \n基于Zookeeper实现分布式锁；\n\n### 1.基于Redis缓存实现分布式锁\n\n#### Spring Boot使用RedLock实现分布式锁\n\n\n\n\n### 2.基于Zookeeper实现分布式锁\n\n\n### 3.基于数据库实现分布式锁\n\n\nhttps://www.cnblogs.com/seesun2012/p/9214653.html","slug":"distributed-lock","published":1,"updated":"2019-08-25T14:16:26.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqav001lg4vaxa64leng","content":"<h2 id=\"为什么要使用分布式锁\"><a href=\"#为什么要使用分布式锁\" class=\"headerlink\" title=\"为什么要使用分布式锁\"></a>为什么要使用分布式锁</h2><p>对共享变量或者数据（数据库数据）多线程操作的时候，为了避免在同一个时刻多线程操作导致数据的混乱，我们可以通过线程的互斥等来控制某个时刻只有一个线程执行，但这只是再单机应用下。</p>\n<p>但是，随着业务的发展，架构随之发展，就需要做集群，负载均衡，这样子，同一个方法或者变量就会以多线程的方式且再不同的物理机也就是不同的jvm上同时执行，这显然是不对的，我们想要的是在某个时刻，该方法或者共享数据只在一个线程中执行，也就是只在某一台物理机子上执行，其余的排斥。这时，分布式锁就派上用场了，它就是做这么一件事的。</p>\n<h2 id=\"分布式锁应该具备哪些条件\"><a href=\"#分布式锁应该具备哪些条件\" class=\"headerlink\" title=\"分布式锁应该具备哪些条件\"></a>分布式锁应该具备哪些条件</h2><p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：</p>\n<blockquote>\n<p>1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；<br>2、高可用的获取锁与释放锁；<br>3、高性能的获取锁与释放锁；<br>4、具备可重入特性；<br>5、具备锁失效机制，防止死锁；<br>6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</p>\n</blockquote>\n<h2 id=\"常用分布式锁实现方式\"><a href=\"#常用分布式锁实现方式\" class=\"headerlink\" title=\"常用分布式锁实现方式\"></a>常用分布式锁实现方式</h2><blockquote>\n<p>基于数据库实现分布式锁；<br>基于缓存（Redis等）实现分布式锁；<br>基于Zookeeper实现分布式锁；</p>\n</blockquote>\n<h3 id=\"1-基于Redis缓存实现分布式锁\"><a href=\"#1-基于Redis缓存实现分布式锁\" class=\"headerlink\" title=\"1.基于Redis缓存实现分布式锁\"></a>1.基于Redis缓存实现分布式锁</h3><h4 id=\"Spring-Boot使用RedLock实现分布式锁\"><a href=\"#Spring-Boot使用RedLock实现分布式锁\" class=\"headerlink\" title=\"Spring Boot使用RedLock实现分布式锁\"></a>Spring Boot使用RedLock实现分布式锁</h4><h3 id=\"2-基于Zookeeper实现分布式锁\"><a href=\"#2-基于Zookeeper实现分布式锁\" class=\"headerlink\" title=\"2.基于Zookeeper实现分布式锁\"></a>2.基于Zookeeper实现分布式锁</h3><h3 id=\"3-基于数据库实现分布式锁\"><a href=\"#3-基于数据库实现分布式锁\" class=\"headerlink\" title=\"3.基于数据库实现分布式锁\"></a>3.基于数据库实现分布式锁</h3><p><a href=\"https://www.cnblogs.com/seesun2012/p/9214653.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/seesun2012/p/9214653.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么要使用分布式锁\"><a href=\"#为什么要使用分布式锁\" class=\"headerlink\" title=\"为什么要使用分布式锁\"></a>为什么要使用分布式锁</h2><p>对共享变量或者数据（数据库数据）多线程操作的时候，为了避免在同一个时刻多线程操作导致数据的混乱，我们可以通过线程的互斥等来控制某个时刻只有一个线程执行，但这只是再单机应用下。</p>\n<p>但是，随着业务的发展，架构随之发展，就需要做集群，负载均衡，这样子，同一个方法或者变量就会以多线程的方式且再不同的物理机也就是不同的jvm上同时执行，这显然是不对的，我们想要的是在某个时刻，该方法或者共享数据只在一个线程中执行，也就是只在某一台物理机子上执行，其余的排斥。这时，分布式锁就派上用场了，它就是做这么一件事的。</p>\n<h2 id=\"分布式锁应该具备哪些条件\"><a href=\"#分布式锁应该具备哪些条件\" class=\"headerlink\" title=\"分布式锁应该具备哪些条件\"></a>分布式锁应该具备哪些条件</h2><p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：</p>\n<blockquote>\n<p>1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；<br>2、高可用的获取锁与释放锁；<br>3、高性能的获取锁与释放锁；<br>4、具备可重入特性；<br>5、具备锁失效机制，防止死锁；<br>6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败</p>\n</blockquote>\n<h2 id=\"常用分布式锁实现方式\"><a href=\"#常用分布式锁实现方式\" class=\"headerlink\" title=\"常用分布式锁实现方式\"></a>常用分布式锁实现方式</h2><blockquote>\n<p>基于数据库实现分布式锁；<br>基于缓存（Redis等）实现分布式锁；<br>基于Zookeeper实现分布式锁；</p>\n</blockquote>\n<h3 id=\"1-基于Redis缓存实现分布式锁\"><a href=\"#1-基于Redis缓存实现分布式锁\" class=\"headerlink\" title=\"1.基于Redis缓存实现分布式锁\"></a>1.基于Redis缓存实现分布式锁</h3><h4 id=\"Spring-Boot使用RedLock实现分布式锁\"><a href=\"#Spring-Boot使用RedLock实现分布式锁\" class=\"headerlink\" title=\"Spring Boot使用RedLock实现分布式锁\"></a>Spring Boot使用RedLock实现分布式锁</h4><h3 id=\"2-基于Zookeeper实现分布式锁\"><a href=\"#2-基于Zookeeper实现分布式锁\" class=\"headerlink\" title=\"2.基于Zookeeper实现分布式锁\"></a>2.基于Zookeeper实现分布式锁</h3><h3 id=\"3-基于数据库实现分布式锁\"><a href=\"#3-基于数据库实现分布式锁\" class=\"headerlink\" title=\"3.基于数据库实现分布式锁\"></a>3.基于数据库实现分布式锁</h3><p><a href=\"https://www.cnblogs.com/seesun2012/p/9214653.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/seesun2012/p/9214653.html</a></p>\n"},{"title":"docker安装各种常用开发应用软件","date":"2018-07-19T07:49:39.000Z","_content":"\n本文记录在docker各种应用程序的安装以及使用……\n\ndocker仓库： [hub repo](https://hub.docker.com/)\n\n## 安装nginx\n\n参考：\n- https://hub.docker.com/_/nginx\n\n1.新建要映射的卷\n\n    # mkdir -p /server/data/nginx/{cache,conf,conf.d,html,logs,pid}\n    # chown 1000 /server/data/nginx/* -R\n    # chmod 755 /server/data/nginx/* -R\n\n查看\n\n    [root@sqjr-client-demo-server1-hn nginx]# pwd\n    /server/data/nginx\n    [root@sqjr-client-demo-server1-hn nginx]# ls\n    cache  conf  conf.d  html  logs  pid    \n\n2.拉取nginx最新镜像\n\n    docker pull nginx\n    \n2.配置nginx.conf\n\n- 可以从从启动的容器中把该文件拷贝出来。\n\n\n    $ docker run --name tmp-nginx-container -d nginx\n    $ docker cp tmp-nginx-container:/etc/nginx/nginx.conf /server/data/nginx/conf/nginx.conf\n    $ docker rm -f tmp-nginx-container\n\n- 或者进入`/server/data/nginx/conf`,新建文件`touch nginx.conf`\n\n然后编辑nginx.conf文件：\n\n    user  nginx;\n    worker_processes  1;\n    \n    error_log  /var/log/nginx/error.log warn;\n    pid        /var/run/nginx.pid;\n    \n    \n    events {\n        worker_connections  1024;\n    }\n    \n    \n    http {\n        include       /etc/nginx/mime.types;\n        default_type  application/octet-stream;\n    \n        log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                          '$status $body_bytes_sent \"$http_referer\" '\n                          '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    \n        access_log  /var/log/nginx/access.log  main;\n    \n        sendfile        on;\n        #tcp_nopush     on;\n    \n        keepalive_timeout  65;\n    \n        #gzip  on;\n    \n        server {\n            listen       80;\n            server_name  localhost;\n    \tcharset utf-8;\n    \n            #charset koi8-r;\n    \n            #access_log  logs/host.access.log  main;\n    \n            location / {\n                root   /usr/share/nginx/html;\n                #root /server/wwwroot;\n                index  index.html index.htm;\n            }\n    \n            #error_page  404              /404.html;\n    \n            # redirect server error pages to the static page /50x.html\n            #\n            error_page   500 502 503 504  /50x.html;\n            location = /50x.html {\n                root   html;\n            }\n    \n            # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n            #\n            #location ~ \\.php$ {\n            #    proxy_pass   http://127.0.0.1;\n            #}\n    \n            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n            #\n            #location ~ \\.php$ {\n            #    root           html;\n            #    fastcgi_pass   127.0.0.1:9000;\n            #    fastcgi_index  index.php;\n            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n            #    include        fastcgi_params;\n            #}\n    \n            # deny access to .htaccess files, if Apache's document root\n            # concurs with nginx's one\n            #\n            #location ~ /\\.ht {\n            #    deny  all;\n            #}\n        }\n    \n        include /etc/nginx/conf.d/*.conf;\n    }\n\n3.新建欢迎页面\n\n进入目录`server/data/nginx/html`下，新建文件`index.html`并随便编写内容测试。\n\n4.启动nginx容器\n\n    docker run --name nginx -d -p 80:80 -v /server/data/nginx/html:/usr/share/nginx/html:ro -v /server/data/nginx/logs:/var/log/nginx -v /server/data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro -v /server/data/nginx/conf.d:/etc/nginx/conf.d -v /server/data/nginx/cache:/var/cache/nginx -v /server/data/nginx/pid:/var/run -d nginx\n    \n成功启动后，就可以打开浏览器测试：http://ip或者http://域名\n\n5.中文乱码问题\n\n如果发现中文乱码，修改server的配置内容，增加一行：charset utf-8;  \n\n      upstream you.domainName.com {\n         server 127.0.0.1:8081;\n      }\n     \n      server {\n            listen      80;\n            server_name  you.domainName.com;\n            charset utf-8;\n       \n            location /examples {\n                return 403;\n              }   \n       }\n      \n然后重启nginx。最后，在浏览器上Ctrl+F5，刷新，一切正常！\n\n6.反向代理失败问题\n\n    upstream abs-demo.xcsqjr.com{\n        ip_hash;\n        server localhost:8084;\n        #server 192.168.0.36:8084;\n        #server 192.168.0.196:8011;\n        #server 192.168.0.197:8011;\n    }\n    \n这里不成功，包404错误。8084的应用也是跑在docker上的。实际上并不是因为跑在docker上就失败。  \n成功配置：    \n    \n    upstream abs-demo.xcsqjr.com{\n            ip_hash;\n            #server localhost:8084;\n            server 192.168.0.36:8084;\n            #server 192.168.0.196:8011;\n            #server 192.168.0.197:8011;\n    }\n    \n不能用`localhost`或者`127.0.0.1`,要用内网ip。查询内网ip，执行命令：`ifconfig`。\n\n## 安装redis\n\n参考：\n- http://www.runoob.com/docker/docker-install-redis.html\n\n### 使用redis镜像\n\n#### 不使用自定义配置文件：\n \n \n    docker run -p 6379:6379 --name redis-6379 --restart=always -v /server/data/redis-6379/data:/data  -d redis:5.0.3 redis-server --appendonly yes --requirepass \"a1234567\"\n\n```text\n命令说明：\n-p 6379:6379 : 将容器的6379端口映射到主机的6379端口\n-v /server/data/redis-6379/data:/data : 将主机中/server/data/redis-6379目录下的data挂载到容器的/data\nredis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 \n--requirepass \"a1234567\" : 设置认证密码 \n--restart=always ： 随docker启动而启动\n```\n\n通过客户端连接进入redis-ci：\n\n    [root@sqjr-client-demo-server1-hn ~]# docker exec -it redis-6379 redis-cli -a a1234567\n    Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.\n    127.0.0.1:6379> set username zmt\n\n在宿主机查看redis进程：\n\n    [root@sqjr-client-demo-server1-hn ~]# ps -ef|grep redis\n    polkitd  29683 29651  0 14:27 ?        00:00:01 redis-server *:6379\n    root     29935 29453  0 14:51 pts/1    00:00:00 grep --color=auto redis\n\n只能本机127.0.0.1连接，不能远程连接。默认是保护模式，不允许远程连接。\n\n#### 使用自定义配置文件（推荐）\n\n\n     docker run --name redis-6380 -p 6380:6380 --restart=always -v /server/data/redis-6380/data:/data -v /server/data/redis-6380/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server  /usr/local/etc/redis/redis.conf --appendonly yes\n     \nredis.conf配置文件基本内容，自由添加：\n    \n    # 指定Redis监听端口，默认端口为6379\n    # 如果指定0端口，表示Redis不监听TCP连接\n    port 6380\n    \n    #设置密码\n    requirepass a1234567\n    \n    #### 生产环境要开启保护模式\n    # 绑定的主机地址\n    # 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接\n    # bind 127.0.0.1\n    \n    #protected-mode yes #关闭，不要保护模式，远程可连接\n    \n    # 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\n    timeout 0\n    \n    #一定要打开，否则无法启动\n    #daemonize yes\n    \n    # 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n    pidfile /var/run/redis.pid\n    \n    # 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n    # debug (很多信息, 对开发／测试比较有用)\n    # verbose (many rarely useful info, but not a mess like the debug level)\n    # notice (moderately verbose, what you want in production probably)\n    # warning (only very important / critical messages are logged)\n    loglevel verbose\n    \n    # 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null\n    logfile stdout\n    \n    # 设置数据库的数量，默认数据库为0，可以使用select <dbid>命令在连接上指定数据库id\n    # dbid是从0到‘databases’-1的数目\n    databases 16\n    \n    ################################ SNAPSHOTTING  #################################\n    # 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n    # Save the DB on disk:\n    #\n    #   save <seconds> <changes>\n    #\n    #   Will save the DB if both the given number of seconds and the given\n    #   number of write operations against the DB occurred.\n    #\n    #   满足以下条件将会同步数据:\n    #   900秒（15分钟）内有1个更改\n    #   300秒（5分钟）内有10个更改\n    #   60秒内有10000个更改\n    #   Note: 可以把所有“save”行注释掉，这样就取消同步操作了\n    \n    save 900 1\n    save 300 10\n    save 60 10000\n    \n    # 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n    rdbcompression yes\n    \n    # 指定本地数据库文件名，默认值为dump.rdb\n    dbfilename dump.rdb         \n    \n*注意*:   \n切记注释掉：#daemonize yes 否则无法启动容器\n重要话说三遍：注释掉#daemonize yes，注释掉#daemonize yes，注释掉#daemonize yes\n\n配置文件：{% asset_link redis.conf %}\n\n## 安装mysql-server\n\n仓库：https://hub.docker.com/r/library/mysql/\n\n#### 拉取镜像：\n\n    docker pull mysql:8.0.13  # 8.0.13为标签tag\n    \n#### 使用mysql镜像\n\n- 自定义配置文件\n\n\n    docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.13    \n\n    ------------------------------------\n    docker run --name mysql-3910 -p 3910:3910 --restart always --privileged=true -v /server/data/mysql-3910/conf:/etc/mysql/conf.d -v /server/data/mysql-3910/logs:/logs -v /server/data/mysql-3910/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --default-authentication-plugin=mysql_native_password -d mysql:8.0.13 \n\n\nmy.cnf内容\n\n    [mysqld] \n    port = 3910\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    # 一下三个配置，解决too manay connection问题。\n    max_connections=1000 # 最大连接数，默认100\n    wait_timeout = 300 #\n    interactive_timeout = 500\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n\n_注意_:   \n\n- 远程连接可能报错误：\n\n\n    2019-01-03T07:41:43.260661Z 8 [Warning] [MY-010055] [Server] IP address '172.17.0.1' could not be resolved: Name or service not known\n\n- 原因：    \n在网上查了些资料简单点说就是反向解析造成的，具体原因是因为“MYSQL Server在本地内存中维护了一个非本地的Client TCP cache，这个cache中包含了远程Client的登录信息，比如IP地址，hostname等信息。如果Client连接到服务器后，Mysql首先会在本地TCP池中根据IP地址解析客户端的hostname或者反解析，如果解析不到，就会去DNS中进行解析，如果还是解析失败就在error log中写入这样的警告信息。”。 \n    \n- 解决办法：        \n在配置文件新增一句`skip-name-resolve`： \n \n\n    [mysqld] \n    port = 3910\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    skip-name-resolve\n    wait_timeout = 100\n    interactive_timeout = 100\n\n然后重启mysql服务再试。\n        \n    \n命令说明：\n\n- -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。\n- -v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。看下面补充内容说明。\n- -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。\n- -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。\n- -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。\n- --default-authentication-plugin=mysql_native_password  加上这个客户端才能登录上。在配置文件加了，命令中可以不加。\n-  --privileged=true 提升root在docker中的权限，否则只是普通用户\n- –restart always：开机启动\n\n```text\n补充：     \nMySQL默认配置文件是 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /etc/mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。     \n具体操作：   \n首先需要创建将要映射到容器中的目录以及.cnf文件，然后再创建容器\n\n    # pwd\n    /opt\n    # mkdir -p docker_v/mysql/conf\n    # cd docker_v/mysql/conf\n    # touch my.cnf\n    # docker run -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d imageID\n    4ec4f56455ea2d6d7251a05b7f308e314051fdad2c26bf3d0f27a9b0c0a71414\n    \n-p 3306:3306：将容器的3306端口映射到主机的3306端口\n-v /opt/docker_v/mysql/conf:/etc/mysql/conf.d：将主机/opt/docker_v/mysql/conf目录挂载到容器的/etc/mysql/conf.d\n-e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码\n-d: 后台运行容器，并返回容器ID\nimageID: mysql镜像ID\n```\n- 不使用conf配置文件\n\n参考：https://hub.docker.com/r/library/mysql/\n\n创建容器mysql实例，端口为：3306\n\n    docker run --name mysql-3306 -p 3306:3306 -v /server/mysql-3306/logs:/logs -v /server/mysql-3306/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.13 --port=3306  --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n    \n查看配置参数列表：\n\n    docker run -it --rm mysql:tag --verbose --help    \n\n#### 查看容器启动情况\n\n    [root@xr-server ~]# docker ps\n    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n    415c0167fb5a        mysql:8.0.13        \"docker-entrypoint.s…\"   5 minutes ago       Up 5 minutes        0.0.0.0:3306->3306/tcp, 33060/tcp   mymysql\n\n#### 进入mysql镜像\n\n参考容器章节……\n\n`docker exec -it 415c0167fb5a /bin/bash 或者 docker exec -it 415c0167fb5a bash`\n\n`415c0167fb5a`为容器id\n\n```text\n[root@xr-server ~]# clear\n[root@xr-server ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n415c0167fb5a        mysql:8.0.13        \"docker-entrypoint.s…\"   17 hours ago        Up 6 minutes        0.0.0.0:3306->3306/tcp, 33060/tcp   mymysql\n[root@xr-server ~]# docker exec -it 415c0167fb5a /bin/bash 或者 docker exec -it 415c0167fb5a bash\nroot@415c0167fb5a:/# ls\nbin   docker-entrypoint-initdb.d  home\t logs\topt   run   sys  var\nboot  entrypoint.sh\t\t  lib\t media\tproc  sbin  tmp\ndev   etc\t\t\t  lib64  mnt\troot  srv   usr\nroot@415c0167fb5a:/# \n```\n    \n## 安装zabbix\n\n#### 启动一个mysql服务器实例\n\n    docker run --name zabbix-mysql-server  \\\n    -e MYSQL_ROOT_PASSWORD=\"123456\" \\\n    -e MYSQL_USER=\"zabbix\" \\\n    -e MYSQL_PASSWORD=\"123456\" \\\n    -e MYSQL_DATABASE=\"zabbix\" \\\n    -p 3306:3306  \\\n    -v /server/dockers/zabbix/mysql/logs:/logs \\\n    -v /server/dockers/zabbix/mysql/data:/var/lib/mysql \\\n    -d mysql:5.7 \\\n    --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n       \n#### 启动Zabbix server实例，并关联这个实例到已创建的MySQL服务器实例\n\n    docker run  --name zabbix-server-mysql --hostname zabbix-server-mysql \\\n    --link zabbix-mysql-server:mysql \\\n    -e DB_SERVER_HOST=\"mysql\" \\\n    -e MYSQL_USER=\"zabbix\" \\\n    -e MYSQL_DATABASE=\"zabbix\" \\\n    -e MYSQL_PASSWORD=\"123456\" \\\n    -e MYSQL_ROOT_PASSWORD=\"123456\" \\\n    -v /etc/localtime:/etc/localtime:ro \\\n    -v /server/dockers/zabbix/zabbix-server/alertscripts:/usr/lib/zabbix/alertscripts \\\n    -v /server/dockers/zabbix/zabbix-server/externalscripts:/usr/lib/zabbix/externalscripts \\\n    -p 10051:10051 \\\n    -p 10050:10050 \\\n    -d zabbix/zabbix-server-mysql:centos-4.0.2\n    \n    ------------------------------ 查看启动日志 ---------------\n    docker logs zabbix-server-mysql\n   \n\n_注意_：必须加上属性` -e MYSQL_ROOT_PASSWORD=\"123456\"`,否则mysql的`zabbix`用户没有操作mysql数据库的权限。    \n\n>`--link`属性说明：   \ndocker run --link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。\n--link的格式：\n--link <name or id>:alias\n其中，name和id是源容器的name和id，alias是源容器在link下的别名。    \n\n#### 启动Zabbix web 接口，并将它与MySQL服务器实例和Zabbix server实例关联\n\n    docker run --name zabbix-web-nginx-mysql --hostname zabbix-web-nginx-mysql \\\n    --link zabbix-mysql-server:mysql \\\n    --link zabbix-server-mysql:zabbix-server \\\n    -e DB_SERVER_HOST=\"mysql\" \\\n    -e MYSQL_ROOT_PASSWORD=\"123456\" \\\n    -e MYSQL_USER=\"zabbix\" \\\n    -e MYSQL_PASSWORD=\"123456\" \\\n    -e MYSQL_DATABASE=\"zabbix\" \\\n    -e ZBX_SERVER_HOST=\"zabbix-server\" \\\n    -e PHP_TZ=\"Asia/Shanghai\" \\\n    -p 8083:80 \\\n    -d zabbix/zabbix-web-nginx-mysql:centos-4.0.2\n    \n    ------------------------------ 查看启动日志 ---------------\n    docker logs zabbix-web-nginx-mysql\n\n```text\n浏览器访问ip:8083查看\n默认登录\nusername:Admin\npassword:zabbix\n```\n  \n _注意_ ：生产环境要做数据卷映射。以防止数据丢失。必须加上属性` -e MYSQL_ROOT_PASSWORD=\"123456\"`,否则mysql的`zabbix`用户没有操作mysql数据库的权限。\n \n_界面无法选择中文显示的问题_：\n\n打开系统，在用户资料中，可以选择语言，但是无法选择中文。这是由于docker容器没有安装中文字符集，不支持中文。   \n因此，要进入容器，安装中文字符集合： \n\n查看系统当前字符集： `# locale`；     \n查看系统可用字符集： `#locale -a`;     \n安装中文字符集：  \n`yum install kde-l10n-Chinese -y `\n`yum -y -q reinstall glibc-common`\n \n\n修改`vim /etc/locale.conf`, LANG=zh_CN.UTF-8;\n\n重新启动容器。再次进入容器，查看系统当前字符集，发现上面修改无效。坑爹……\n\n那是因为centos默认镜像的 /etc/yum.conf 里面有一句`override_install_langs=en_US.utf8`，    \n删除这句话，然后重新运行：`yum -y -q reinstall glibc-common`，再重启容器，查看系统当前字符集，可以看到是中文的了。\n \n \n       \n#### 启动zabbix-agent\n\n\n\n    docker run --name zabbix-agent --link zabbix-server-mysql:zabbix-server -d zabbix/zabbix-agent:centos-4.0.2 \n    \n最后需要在web端将，zabbix-agent添加到zabbix-server的host列表里面。    \n\n\n\n####  启动Zabbix Java gateway实例,并关联到zabbix-server  \n\n用于监控jvm/tomcat性能。   \nZabbix监控Java应用程序的关键点在于：配置Zabbix-JavaGateway、让Zabbix-Server能够连接Zabbix-JavaGateway、Tomcat开启JVM远程监控功能等。\n\n    docker run --name zabbix-java-gateway --link zabbix-server-mysql:zabbix-server -d zabbix/zabbix-java-gateway:latest\n    \n\n## 安装Jenkins\n\n####　配置日志：   \n\n    [root@ymu /]# mkdir -p /server/data/jenkins\n    [root@ymu /]# cd /server/data/jenkins\n    [root@ymu jenkins]# touch log.properties\n    [root@ymu jenkins]# cat > log.properties <<EOF\n    > handlers=java.util.logging.ConsoleHandler\n    > jenkins.level=FINEST\n    > java.util.logging.ConsoleHandler.level=FINEST\n    > EOF\n\n\n#### 启动jenkins服务\n\n参考：https://github.com/jenkinsci/docker/blob/master/README.md\n\n首先，要对文件夹赋予权限：   \n查看文件夹权限：`\n\n    [root@xr-server jenkins]# ls -l /server/data/jenkins/\n    total 4\n    -rw-r--r--. 1 root root 109 Dec 17 00:55 log.properties\n    \n赋予文件夹权限：    \n\n    chown -R 1000:1000 /server/data/jenkins/    \n\n启动容器：\n\n    docker run --name ymu-jenkins -p 3001:8080 -p 50000:50000 --env JAVA_OPTS=\"-Djava.util.logging.config.file=/var/jenkins_home/log.properties\" -v /server/data/jenkins:/var/jenkins_home -d jenkins/jenkins:lts\n\nlts：长期支持版本    \n以上启动的容器安装Locale插件后，也只能部分中文，原因：未知……\n    \n说明： \n- -v 会把容器目录`/var/jenkins_home`映射到主机`/server/data/jenkins` \n\n\n#### 测试是否安装成功\n\n打开浏览器输入：local:3001\n\n如果看到要求获取登录密码的界面，则成功。恭喜……\n\n获取登录初始密码：   \n\n    [root@ymu secrets]# pwd\n    /server/data/jenkins/secrets\n    [root@ymu secrets]# cat initialAdminPassword \n    8ccac67d98dd4c77a2c09870e8246e5d\n    [root@ymu secrets]#\n\n其它的如和maven的集成等，参考以前文档。  \n\n#### 使用Nginx做方向代理\n\n坑，坑，坑……\n\n一开始按一般的nginx方向代理配置，负载均衡配置，都不行，页面打开异常的慢……\n\n各种百度，不行。还好，想起了google大神……结果找到了：  \n\nhttps://wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx\n\n还是官方文档有用，以后遇到这种问题，都先到官方wiki上找答案才对。  \n重新配置：\n\n    upstream jenkins {\n      keepalive 32; # keepalive connections\n      server 127.0.0.1:9000; # jenkins ip and port\n    }\n     \n    server {\n      listen          80;       # Listen on port 80 for IPv4 requests\n    \n      server_name     ci.xcsqjr.com;\n    \n      #this is the jenkins web root directory (mentioned in the /etc/default/jenkins file)\n      root            /server/data/jenkins/war;\n    \n      access_log      /server/java/nginx/logs/ci.xcsqjr.com.access.log;\n      error_log       /server/java/nginx/logs/ci.xcsqjr.com.error.log;\n      ignore_invalid_headers off; #pass through headers from Jenkins which are considered invalid by Nginx server.\n    \n      location ~ \"^/static/[0-9a-fA-F]{8}\\/(.*)$\" {\n        #rewrite all static files into requests to the root\n        #E.g /static/12345678/css/something.css will become /css/something.css\n        rewrite \"^/static/[0-9a-fA-F]{8}\\/(.*)\" /$1 last;\n      }\n    \n      location /userContent {\n        #have nginx handle all the static requests to the userContent folder files\n        #note : This is the $JENKINS_HOME dir\n        root /server/data/jenkins/war;\n        if (!-f $request_filename){\n          #this file does not exist, might be a directory or a /**view** url\n          rewrite (.*) /$1 last;\n    \t  break;\n        }\n    \tsendfile on;\n      }\n    \n      location / {\n          sendfile off;\n          proxy_pass         http://jenkins;\n          proxy_redirect     default;\n          proxy_http_version 1.1;\n    \n          proxy_set_header   Host              $host;\n          proxy_set_header   X-Real-IP         $remote_addr;\n          proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;\n          proxy_set_header   X-Forwarded-Proto $scheme;\n          proxy_max_temp_file_size 0;\n    \n          #this is the maximum upload size\n          client_max_body_size       10m;\n          client_body_buffer_size    128k;\n    \n          proxy_connect_timeout      90;\n          proxy_send_timeout         90;\n          proxy_read_timeout         90;\n          proxy_buffering            off;\n          #proxy_request_buffering    off; # Required for HTTP CLI commands in Jenkins > 2.54\n          proxy_set_header Connection \"\"; # Clear for keepalive\n      }\n    \n    }\n\n注意：按上面docker安装jenkins的时候，映射了数据卷，所以可以知道：`server/data/jenkins/war` 为jenkins的web根目录。注意配置好。\n\n## 安装gitlab\n\n参考网址：https://docs.gitlab.com/omnibus/docker/\n\n## 安装sonatype/nexus\n\n参考网址：   \nhttps://hub.docker.com/r/sonatype/nexus \n\n1.初始持久化数据目录\n\n    # mkdir /server/data/nexus/data && chown -R 200 /server/data/nexus/data\n    \n    # docker run -d -p 8084:8081 --name nexus -e MAX_HEAP=768m  -v /server/data/nexus/data:/sonatype-work sonatype/nexus    \n    \n2.查看启动日志\n\n    docker logs -f nexus\n    \n3.默认账号密码：\n\n    admin / admin123        \n\n4.浏览器浏览：\n\n    http://ip:8084/nexus\n\n### 安装sonatype/nexus3,兼容maven依赖和docker register（推荐生产使用）\n\n网址：https://github.com/sonatype/docker-nexus3\n\n1.创建映射卷并启动实例\n\n    # mkdir -p /server/data/nexus3-data && chown -R 200 /server/data/nexus3-data\n    \n    # docker run  -p 8085:8081 -p 8082:8082 -p 8083:8083 --name nexus3 --restart=always -v /server/data/nexus3-data:/nexus-data  -d sonatype/nexus3\n\n2.查看启动日志：\n\n    docker logs -f nexus    \n    \n3.测试是否安装成功：\n\n    curl -u admin:admin123 http://localhost:8085/service/metrics/ping  \n    \n4.打开浏览器浏览：\n\n 网址：http://ip:8085\n \n 默认账号密码：admin admin123\n \n","source":"_posts/docker-app-install.md","raw":"---\ntitle: docker安装各种常用开发应用软件\ndate: 2018-07-19 15:49:39\ncategories: docker\ntags: \n---\n\n本文记录在docker各种应用程序的安装以及使用……\n\ndocker仓库： [hub repo](https://hub.docker.com/)\n\n## 安装nginx\n\n参考：\n- https://hub.docker.com/_/nginx\n\n1.新建要映射的卷\n\n    # mkdir -p /server/data/nginx/{cache,conf,conf.d,html,logs,pid}\n    # chown 1000 /server/data/nginx/* -R\n    # chmod 755 /server/data/nginx/* -R\n\n查看\n\n    [root@sqjr-client-demo-server1-hn nginx]# pwd\n    /server/data/nginx\n    [root@sqjr-client-demo-server1-hn nginx]# ls\n    cache  conf  conf.d  html  logs  pid    \n\n2.拉取nginx最新镜像\n\n    docker pull nginx\n    \n2.配置nginx.conf\n\n- 可以从从启动的容器中把该文件拷贝出来。\n\n\n    $ docker run --name tmp-nginx-container -d nginx\n    $ docker cp tmp-nginx-container:/etc/nginx/nginx.conf /server/data/nginx/conf/nginx.conf\n    $ docker rm -f tmp-nginx-container\n\n- 或者进入`/server/data/nginx/conf`,新建文件`touch nginx.conf`\n\n然后编辑nginx.conf文件：\n\n    user  nginx;\n    worker_processes  1;\n    \n    error_log  /var/log/nginx/error.log warn;\n    pid        /var/run/nginx.pid;\n    \n    \n    events {\n        worker_connections  1024;\n    }\n    \n    \n    http {\n        include       /etc/nginx/mime.types;\n        default_type  application/octet-stream;\n    \n        log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                          '$status $body_bytes_sent \"$http_referer\" '\n                          '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n    \n        access_log  /var/log/nginx/access.log  main;\n    \n        sendfile        on;\n        #tcp_nopush     on;\n    \n        keepalive_timeout  65;\n    \n        #gzip  on;\n    \n        server {\n            listen       80;\n            server_name  localhost;\n    \tcharset utf-8;\n    \n            #charset koi8-r;\n    \n            #access_log  logs/host.access.log  main;\n    \n            location / {\n                root   /usr/share/nginx/html;\n                #root /server/wwwroot;\n                index  index.html index.htm;\n            }\n    \n            #error_page  404              /404.html;\n    \n            # redirect server error pages to the static page /50x.html\n            #\n            error_page   500 502 503 504  /50x.html;\n            location = /50x.html {\n                root   html;\n            }\n    \n            # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n            #\n            #location ~ \\.php$ {\n            #    proxy_pass   http://127.0.0.1;\n            #}\n    \n            # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n            #\n            #location ~ \\.php$ {\n            #    root           html;\n            #    fastcgi_pass   127.0.0.1:9000;\n            #    fastcgi_index  index.php;\n            #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n            #    include        fastcgi_params;\n            #}\n    \n            # deny access to .htaccess files, if Apache's document root\n            # concurs with nginx's one\n            #\n            #location ~ /\\.ht {\n            #    deny  all;\n            #}\n        }\n    \n        include /etc/nginx/conf.d/*.conf;\n    }\n\n3.新建欢迎页面\n\n进入目录`server/data/nginx/html`下，新建文件`index.html`并随便编写内容测试。\n\n4.启动nginx容器\n\n    docker run --name nginx -d -p 80:80 -v /server/data/nginx/html:/usr/share/nginx/html:ro -v /server/data/nginx/logs:/var/log/nginx -v /server/data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro -v /server/data/nginx/conf.d:/etc/nginx/conf.d -v /server/data/nginx/cache:/var/cache/nginx -v /server/data/nginx/pid:/var/run -d nginx\n    \n成功启动后，就可以打开浏览器测试：http://ip或者http://域名\n\n5.中文乱码问题\n\n如果发现中文乱码，修改server的配置内容，增加一行：charset utf-8;  \n\n      upstream you.domainName.com {\n         server 127.0.0.1:8081;\n      }\n     \n      server {\n            listen      80;\n            server_name  you.domainName.com;\n            charset utf-8;\n       \n            location /examples {\n                return 403;\n              }   \n       }\n      \n然后重启nginx。最后，在浏览器上Ctrl+F5，刷新，一切正常！\n\n6.反向代理失败问题\n\n    upstream abs-demo.xcsqjr.com{\n        ip_hash;\n        server localhost:8084;\n        #server 192.168.0.36:8084;\n        #server 192.168.0.196:8011;\n        #server 192.168.0.197:8011;\n    }\n    \n这里不成功，包404错误。8084的应用也是跑在docker上的。实际上并不是因为跑在docker上就失败。  \n成功配置：    \n    \n    upstream abs-demo.xcsqjr.com{\n            ip_hash;\n            #server localhost:8084;\n            server 192.168.0.36:8084;\n            #server 192.168.0.196:8011;\n            #server 192.168.0.197:8011;\n    }\n    \n不能用`localhost`或者`127.0.0.1`,要用内网ip。查询内网ip，执行命令：`ifconfig`。\n\n## 安装redis\n\n参考：\n- http://www.runoob.com/docker/docker-install-redis.html\n\n### 使用redis镜像\n\n#### 不使用自定义配置文件：\n \n \n    docker run -p 6379:6379 --name redis-6379 --restart=always -v /server/data/redis-6379/data:/data  -d redis:5.0.3 redis-server --appendonly yes --requirepass \"a1234567\"\n\n```text\n命令说明：\n-p 6379:6379 : 将容器的6379端口映射到主机的6379端口\n-v /server/data/redis-6379/data:/data : 将主机中/server/data/redis-6379目录下的data挂载到容器的/data\nredis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 \n--requirepass \"a1234567\" : 设置认证密码 \n--restart=always ： 随docker启动而启动\n```\n\n通过客户端连接进入redis-ci：\n\n    [root@sqjr-client-demo-server1-hn ~]# docker exec -it redis-6379 redis-cli -a a1234567\n    Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.\n    127.0.0.1:6379> set username zmt\n\n在宿主机查看redis进程：\n\n    [root@sqjr-client-demo-server1-hn ~]# ps -ef|grep redis\n    polkitd  29683 29651  0 14:27 ?        00:00:01 redis-server *:6379\n    root     29935 29453  0 14:51 pts/1    00:00:00 grep --color=auto redis\n\n只能本机127.0.0.1连接，不能远程连接。默认是保护模式，不允许远程连接。\n\n#### 使用自定义配置文件（推荐）\n\n\n     docker run --name redis-6380 -p 6380:6380 --restart=always -v /server/data/redis-6380/data:/data -v /server/data/redis-6380/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server  /usr/local/etc/redis/redis.conf --appendonly yes\n     \nredis.conf配置文件基本内容，自由添加：\n    \n    # 指定Redis监听端口，默认端口为6379\n    # 如果指定0端口，表示Redis不监听TCP连接\n    port 6380\n    \n    #设置密码\n    requirepass a1234567\n    \n    #### 生产环境要开启保护模式\n    # 绑定的主机地址\n    # 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接\n    # bind 127.0.0.1\n    \n    #protected-mode yes #关闭，不要保护模式，远程可连接\n    \n    # 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\n    timeout 0\n    \n    #一定要打开，否则无法启动\n    #daemonize yes\n    \n    # 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\n    pidfile /var/run/redis.pid\n    \n    # 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n    # debug (很多信息, 对开发／测试比较有用)\n    # verbose (many rarely useful info, but not a mess like the debug level)\n    # notice (moderately verbose, what you want in production probably)\n    # warning (only very important / critical messages are logged)\n    loglevel verbose\n    \n    # 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null\n    logfile stdout\n    \n    # 设置数据库的数量，默认数据库为0，可以使用select <dbid>命令在连接上指定数据库id\n    # dbid是从0到‘databases’-1的数目\n    databases 16\n    \n    ################################ SNAPSHOTTING  #################################\n    # 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n    # Save the DB on disk:\n    #\n    #   save <seconds> <changes>\n    #\n    #   Will save the DB if both the given number of seconds and the given\n    #   number of write operations against the DB occurred.\n    #\n    #   满足以下条件将会同步数据:\n    #   900秒（15分钟）内有1个更改\n    #   300秒（5分钟）内有10个更改\n    #   60秒内有10000个更改\n    #   Note: 可以把所有“save”行注释掉，这样就取消同步操作了\n    \n    save 900 1\n    save 300 10\n    save 60 10000\n    \n    # 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\n    rdbcompression yes\n    \n    # 指定本地数据库文件名，默认值为dump.rdb\n    dbfilename dump.rdb         \n    \n*注意*:   \n切记注释掉：#daemonize yes 否则无法启动容器\n重要话说三遍：注释掉#daemonize yes，注释掉#daemonize yes，注释掉#daemonize yes\n\n配置文件：{% asset_link redis.conf %}\n\n## 安装mysql-server\n\n仓库：https://hub.docker.com/r/library/mysql/\n\n#### 拉取镜像：\n\n    docker pull mysql:8.0.13  # 8.0.13为标签tag\n    \n#### 使用mysql镜像\n\n- 自定义配置文件\n\n\n    docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.13    \n\n    ------------------------------------\n    docker run --name mysql-3910 -p 3910:3910 --restart always --privileged=true -v /server/data/mysql-3910/conf:/etc/mysql/conf.d -v /server/data/mysql-3910/logs:/logs -v /server/data/mysql-3910/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --default-authentication-plugin=mysql_native_password -d mysql:8.0.13 \n\n\nmy.cnf内容\n\n    [mysqld] \n    port = 3910\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    # 一下三个配置，解决too manay connection问题。\n    max_connections=1000 # 最大连接数，默认100\n    wait_timeout = 300 #\n    interactive_timeout = 500\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n\n_注意_:   \n\n- 远程连接可能报错误：\n\n\n    2019-01-03T07:41:43.260661Z 8 [Warning] [MY-010055] [Server] IP address '172.17.0.1' could not be resolved: Name or service not known\n\n- 原因：    \n在网上查了些资料简单点说就是反向解析造成的，具体原因是因为“MYSQL Server在本地内存中维护了一个非本地的Client TCP cache，这个cache中包含了远程Client的登录信息，比如IP地址，hostname等信息。如果Client连接到服务器后，Mysql首先会在本地TCP池中根据IP地址解析客户端的hostname或者反解析，如果解析不到，就会去DNS中进行解析，如果还是解析失败就在error log中写入这样的警告信息。”。 \n    \n- 解决办法：        \n在配置文件新增一句`skip-name-resolve`： \n \n\n    [mysqld] \n    port = 3910\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    skip-name-resolve\n    wait_timeout = 100\n    interactive_timeout = 100\n\n然后重启mysql服务再试。\n        \n    \n命令说明：\n\n- -p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。\n- -v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。看下面补充内容说明。\n- -v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。\n- -v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。\n- -e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。\n- --default-authentication-plugin=mysql_native_password  加上这个客户端才能登录上。在配置文件加了，命令中可以不加。\n-  --privileged=true 提升root在docker中的权限，否则只是普通用户\n- –restart always：开机启动\n\n```text\n补充：     \nMySQL默认配置文件是 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /etc/mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。     \n具体操作：   \n首先需要创建将要映射到容器中的目录以及.cnf文件，然后再创建容器\n\n    # pwd\n    /opt\n    # mkdir -p docker_v/mysql/conf\n    # cd docker_v/mysql/conf\n    # touch my.cnf\n    # docker run -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d imageID\n    4ec4f56455ea2d6d7251a05b7f308e314051fdad2c26bf3d0f27a9b0c0a71414\n    \n-p 3306:3306：将容器的3306端口映射到主机的3306端口\n-v /opt/docker_v/mysql/conf:/etc/mysql/conf.d：将主机/opt/docker_v/mysql/conf目录挂载到容器的/etc/mysql/conf.d\n-e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码\n-d: 后台运行容器，并返回容器ID\nimageID: mysql镜像ID\n```\n- 不使用conf配置文件\n\n参考：https://hub.docker.com/r/library/mysql/\n\n创建容器mysql实例，端口为：3306\n\n    docker run --name mysql-3306 -p 3306:3306 -v /server/mysql-3306/logs:/logs -v /server/mysql-3306/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.13 --port=3306  --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n    \n查看配置参数列表：\n\n    docker run -it --rm mysql:tag --verbose --help    \n\n#### 查看容器启动情况\n\n    [root@xr-server ~]# docker ps\n    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n    415c0167fb5a        mysql:8.0.13        \"docker-entrypoint.s…\"   5 minutes ago       Up 5 minutes        0.0.0.0:3306->3306/tcp, 33060/tcp   mymysql\n\n#### 进入mysql镜像\n\n参考容器章节……\n\n`docker exec -it 415c0167fb5a /bin/bash 或者 docker exec -it 415c0167fb5a bash`\n\n`415c0167fb5a`为容器id\n\n```text\n[root@xr-server ~]# clear\n[root@xr-server ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n415c0167fb5a        mysql:8.0.13        \"docker-entrypoint.s…\"   17 hours ago        Up 6 minutes        0.0.0.0:3306->3306/tcp, 33060/tcp   mymysql\n[root@xr-server ~]# docker exec -it 415c0167fb5a /bin/bash 或者 docker exec -it 415c0167fb5a bash\nroot@415c0167fb5a:/# ls\nbin   docker-entrypoint-initdb.d  home\t logs\topt   run   sys  var\nboot  entrypoint.sh\t\t  lib\t media\tproc  sbin  tmp\ndev   etc\t\t\t  lib64  mnt\troot  srv   usr\nroot@415c0167fb5a:/# \n```\n    \n## 安装zabbix\n\n#### 启动一个mysql服务器实例\n\n    docker run --name zabbix-mysql-server  \\\n    -e MYSQL_ROOT_PASSWORD=\"123456\" \\\n    -e MYSQL_USER=\"zabbix\" \\\n    -e MYSQL_PASSWORD=\"123456\" \\\n    -e MYSQL_DATABASE=\"zabbix\" \\\n    -p 3306:3306  \\\n    -v /server/dockers/zabbix/mysql/logs:/logs \\\n    -v /server/dockers/zabbix/mysql/data:/var/lib/mysql \\\n    -d mysql:5.7 \\\n    --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n       \n#### 启动Zabbix server实例，并关联这个实例到已创建的MySQL服务器实例\n\n    docker run  --name zabbix-server-mysql --hostname zabbix-server-mysql \\\n    --link zabbix-mysql-server:mysql \\\n    -e DB_SERVER_HOST=\"mysql\" \\\n    -e MYSQL_USER=\"zabbix\" \\\n    -e MYSQL_DATABASE=\"zabbix\" \\\n    -e MYSQL_PASSWORD=\"123456\" \\\n    -e MYSQL_ROOT_PASSWORD=\"123456\" \\\n    -v /etc/localtime:/etc/localtime:ro \\\n    -v /server/dockers/zabbix/zabbix-server/alertscripts:/usr/lib/zabbix/alertscripts \\\n    -v /server/dockers/zabbix/zabbix-server/externalscripts:/usr/lib/zabbix/externalscripts \\\n    -p 10051:10051 \\\n    -p 10050:10050 \\\n    -d zabbix/zabbix-server-mysql:centos-4.0.2\n    \n    ------------------------------ 查看启动日志 ---------------\n    docker logs zabbix-server-mysql\n   \n\n_注意_：必须加上属性` -e MYSQL_ROOT_PASSWORD=\"123456\"`,否则mysql的`zabbix`用户没有操作mysql数据库的权限。    \n\n>`--link`属性说明：   \ndocker run --link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。\n--link的格式：\n--link <name or id>:alias\n其中，name和id是源容器的name和id，alias是源容器在link下的别名。    \n\n#### 启动Zabbix web 接口，并将它与MySQL服务器实例和Zabbix server实例关联\n\n    docker run --name zabbix-web-nginx-mysql --hostname zabbix-web-nginx-mysql \\\n    --link zabbix-mysql-server:mysql \\\n    --link zabbix-server-mysql:zabbix-server \\\n    -e DB_SERVER_HOST=\"mysql\" \\\n    -e MYSQL_ROOT_PASSWORD=\"123456\" \\\n    -e MYSQL_USER=\"zabbix\" \\\n    -e MYSQL_PASSWORD=\"123456\" \\\n    -e MYSQL_DATABASE=\"zabbix\" \\\n    -e ZBX_SERVER_HOST=\"zabbix-server\" \\\n    -e PHP_TZ=\"Asia/Shanghai\" \\\n    -p 8083:80 \\\n    -d zabbix/zabbix-web-nginx-mysql:centos-4.0.2\n    \n    ------------------------------ 查看启动日志 ---------------\n    docker logs zabbix-web-nginx-mysql\n\n```text\n浏览器访问ip:8083查看\n默认登录\nusername:Admin\npassword:zabbix\n```\n  \n _注意_ ：生产环境要做数据卷映射。以防止数据丢失。必须加上属性` -e MYSQL_ROOT_PASSWORD=\"123456\"`,否则mysql的`zabbix`用户没有操作mysql数据库的权限。\n \n_界面无法选择中文显示的问题_：\n\n打开系统，在用户资料中，可以选择语言，但是无法选择中文。这是由于docker容器没有安装中文字符集，不支持中文。   \n因此，要进入容器，安装中文字符集合： \n\n查看系统当前字符集： `# locale`；     \n查看系统可用字符集： `#locale -a`;     \n安装中文字符集：  \n`yum install kde-l10n-Chinese -y `\n`yum -y -q reinstall glibc-common`\n \n\n修改`vim /etc/locale.conf`, LANG=zh_CN.UTF-8;\n\n重新启动容器。再次进入容器，查看系统当前字符集，发现上面修改无效。坑爹……\n\n那是因为centos默认镜像的 /etc/yum.conf 里面有一句`override_install_langs=en_US.utf8`，    \n删除这句话，然后重新运行：`yum -y -q reinstall glibc-common`，再重启容器，查看系统当前字符集，可以看到是中文的了。\n \n \n       \n#### 启动zabbix-agent\n\n\n\n    docker run --name zabbix-agent --link zabbix-server-mysql:zabbix-server -d zabbix/zabbix-agent:centos-4.0.2 \n    \n最后需要在web端将，zabbix-agent添加到zabbix-server的host列表里面。    \n\n\n\n####  启动Zabbix Java gateway实例,并关联到zabbix-server  \n\n用于监控jvm/tomcat性能。   \nZabbix监控Java应用程序的关键点在于：配置Zabbix-JavaGateway、让Zabbix-Server能够连接Zabbix-JavaGateway、Tomcat开启JVM远程监控功能等。\n\n    docker run --name zabbix-java-gateway --link zabbix-server-mysql:zabbix-server -d zabbix/zabbix-java-gateway:latest\n    \n\n## 安装Jenkins\n\n####　配置日志：   \n\n    [root@ymu /]# mkdir -p /server/data/jenkins\n    [root@ymu /]# cd /server/data/jenkins\n    [root@ymu jenkins]# touch log.properties\n    [root@ymu jenkins]# cat > log.properties <<EOF\n    > handlers=java.util.logging.ConsoleHandler\n    > jenkins.level=FINEST\n    > java.util.logging.ConsoleHandler.level=FINEST\n    > EOF\n\n\n#### 启动jenkins服务\n\n参考：https://github.com/jenkinsci/docker/blob/master/README.md\n\n首先，要对文件夹赋予权限：   \n查看文件夹权限：`\n\n    [root@xr-server jenkins]# ls -l /server/data/jenkins/\n    total 4\n    -rw-r--r--. 1 root root 109 Dec 17 00:55 log.properties\n    \n赋予文件夹权限：    \n\n    chown -R 1000:1000 /server/data/jenkins/    \n\n启动容器：\n\n    docker run --name ymu-jenkins -p 3001:8080 -p 50000:50000 --env JAVA_OPTS=\"-Djava.util.logging.config.file=/var/jenkins_home/log.properties\" -v /server/data/jenkins:/var/jenkins_home -d jenkins/jenkins:lts\n\nlts：长期支持版本    \n以上启动的容器安装Locale插件后，也只能部分中文，原因：未知……\n    \n说明： \n- -v 会把容器目录`/var/jenkins_home`映射到主机`/server/data/jenkins` \n\n\n#### 测试是否安装成功\n\n打开浏览器输入：local:3001\n\n如果看到要求获取登录密码的界面，则成功。恭喜……\n\n获取登录初始密码：   \n\n    [root@ymu secrets]# pwd\n    /server/data/jenkins/secrets\n    [root@ymu secrets]# cat initialAdminPassword \n    8ccac67d98dd4c77a2c09870e8246e5d\n    [root@ymu secrets]#\n\n其它的如和maven的集成等，参考以前文档。  \n\n#### 使用Nginx做方向代理\n\n坑，坑，坑……\n\n一开始按一般的nginx方向代理配置，负载均衡配置，都不行，页面打开异常的慢……\n\n各种百度，不行。还好，想起了google大神……结果找到了：  \n\nhttps://wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx\n\n还是官方文档有用，以后遇到这种问题，都先到官方wiki上找答案才对。  \n重新配置：\n\n    upstream jenkins {\n      keepalive 32; # keepalive connections\n      server 127.0.0.1:9000; # jenkins ip and port\n    }\n     \n    server {\n      listen          80;       # Listen on port 80 for IPv4 requests\n    \n      server_name     ci.xcsqjr.com;\n    \n      #this is the jenkins web root directory (mentioned in the /etc/default/jenkins file)\n      root            /server/data/jenkins/war;\n    \n      access_log      /server/java/nginx/logs/ci.xcsqjr.com.access.log;\n      error_log       /server/java/nginx/logs/ci.xcsqjr.com.error.log;\n      ignore_invalid_headers off; #pass through headers from Jenkins which are considered invalid by Nginx server.\n    \n      location ~ \"^/static/[0-9a-fA-F]{8}\\/(.*)$\" {\n        #rewrite all static files into requests to the root\n        #E.g /static/12345678/css/something.css will become /css/something.css\n        rewrite \"^/static/[0-9a-fA-F]{8}\\/(.*)\" /$1 last;\n      }\n    \n      location /userContent {\n        #have nginx handle all the static requests to the userContent folder files\n        #note : This is the $JENKINS_HOME dir\n        root /server/data/jenkins/war;\n        if (!-f $request_filename){\n          #this file does not exist, might be a directory or a /**view** url\n          rewrite (.*) /$1 last;\n    \t  break;\n        }\n    \tsendfile on;\n      }\n    \n      location / {\n          sendfile off;\n          proxy_pass         http://jenkins;\n          proxy_redirect     default;\n          proxy_http_version 1.1;\n    \n          proxy_set_header   Host              $host;\n          proxy_set_header   X-Real-IP         $remote_addr;\n          proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;\n          proxy_set_header   X-Forwarded-Proto $scheme;\n          proxy_max_temp_file_size 0;\n    \n          #this is the maximum upload size\n          client_max_body_size       10m;\n          client_body_buffer_size    128k;\n    \n          proxy_connect_timeout      90;\n          proxy_send_timeout         90;\n          proxy_read_timeout         90;\n          proxy_buffering            off;\n          #proxy_request_buffering    off; # Required for HTTP CLI commands in Jenkins > 2.54\n          proxy_set_header Connection \"\"; # Clear for keepalive\n      }\n    \n    }\n\n注意：按上面docker安装jenkins的时候，映射了数据卷，所以可以知道：`server/data/jenkins/war` 为jenkins的web根目录。注意配置好。\n\n## 安装gitlab\n\n参考网址：https://docs.gitlab.com/omnibus/docker/\n\n## 安装sonatype/nexus\n\n参考网址：   \nhttps://hub.docker.com/r/sonatype/nexus \n\n1.初始持久化数据目录\n\n    # mkdir /server/data/nexus/data && chown -R 200 /server/data/nexus/data\n    \n    # docker run -d -p 8084:8081 --name nexus -e MAX_HEAP=768m  -v /server/data/nexus/data:/sonatype-work sonatype/nexus    \n    \n2.查看启动日志\n\n    docker logs -f nexus\n    \n3.默认账号密码：\n\n    admin / admin123        \n\n4.浏览器浏览：\n\n    http://ip:8084/nexus\n\n### 安装sonatype/nexus3,兼容maven依赖和docker register（推荐生产使用）\n\n网址：https://github.com/sonatype/docker-nexus3\n\n1.创建映射卷并启动实例\n\n    # mkdir -p /server/data/nexus3-data && chown -R 200 /server/data/nexus3-data\n    \n    # docker run  -p 8085:8081 -p 8082:8082 -p 8083:8083 --name nexus3 --restart=always -v /server/data/nexus3-data:/nexus-data  -d sonatype/nexus3\n\n2.查看启动日志：\n\n    docker logs -f nexus    \n    \n3.测试是否安装成功：\n\n    curl -u admin:admin123 http://localhost:8085/service/metrics/ping  \n    \n4.打开浏览器浏览：\n\n 网址：http://ip:8085\n \n 默认账号密码：admin admin123\n \n","slug":"docker-app-install","published":1,"updated":"2020-05-30T11:28:23.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqaw001mg4vazotto437","content":"<p>本文记录在docker各种应用程序的安装以及使用……</p>\n<p>docker仓库： <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">hub repo</a></p>\n<h2 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h2><p>参考：</p>\n<ul>\n<li><a href=\"https://hub.docker.com/_/nginx\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/nginx</a></li>\n</ul>\n<p>1.新建要映射的卷</p>\n<pre><code># mkdir -p /server/data/nginx/{cache,conf,conf.d,html,logs,pid}\n# chown 1000 /server/data/nginx/* -R\n# chmod 755 /server/data/nginx/* -R\n</code></pre><p>查看</p>\n<pre><code>[root@sqjr-client-demo-server1-hn nginx]# pwd\n/server/data/nginx\n[root@sqjr-client-demo-server1-hn nginx]# ls\ncache  conf  conf.d  html  logs  pid    \n</code></pre><p>2.拉取nginx最新镜像</p>\n<pre><code>docker pull nginx\n</code></pre><p>2.配置nginx.conf</p>\n<ul>\n<li>可以从从启动的容器中把该文件拷贝出来。</li>\n</ul>\n<pre><code>$ docker run --name tmp-nginx-container -d nginx\n$ docker cp tmp-nginx-container:/etc/nginx/nginx.conf /server/data/nginx/conf/nginx.conf\n$ docker rm -f tmp-nginx-container\n</code></pre><ul>\n<li>或者进入<code>/server/data/nginx/conf</code>,新建文件<code>touch nginx.conf</code></li>\n</ul>\n<p>然后编辑nginx.conf文件：</p>\n<pre><code>user  nginx;\nworker_processes  1;\n\nerror_log  /var/log/nginx/error.log warn;\npid        /var/run/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;\n                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;\n                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        listen       80;\n        server_name  localhost;\n    charset utf-8;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   /usr/share/nginx/html;\n            #root /server/wwwroot;\n            index  index.html index.htm;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache&apos;s document root\n        # concurs with nginx&apos;s one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n    include /etc/nginx/conf.d/*.conf;\n}\n</code></pre><p>3.新建欢迎页面</p>\n<p>进入目录<code>server/data/nginx/html</code>下，新建文件<code>index.html</code>并随便编写内容测试。</p>\n<p>4.启动nginx容器</p>\n<pre><code>docker run --name nginx -d -p 80:80 -v /server/data/nginx/html:/usr/share/nginx/html:ro -v /server/data/nginx/logs:/var/log/nginx -v /server/data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro -v /server/data/nginx/conf.d:/etc/nginx/conf.d -v /server/data/nginx/cache:/var/cache/nginx -v /server/data/nginx/pid:/var/run -d nginx\n</code></pre><p>成功启动后，就可以打开浏览器测试：<a href=\"http://ip或者http://域名\" target=\"_blank\" rel=\"noopener\">http://ip或者http://域名</a></p>\n<p>5.中文乱码问题</p>\n<p>如果发现中文乱码，修改server的配置内容，增加一行：charset utf-8;  </p>\n<pre><code>upstream you.domainName.com {\n   server 127.0.0.1:8081;\n}\n\nserver {\n      listen      80;\n      server_name  you.domainName.com;\n      charset utf-8;\n\n      location /examples {\n          return 403;\n        }   \n }\n</code></pre><p>然后重启nginx。最后，在浏览器上Ctrl+F5，刷新，一切正常！</p>\n<p>6.反向代理失败问题</p>\n<pre><code>upstream abs-demo.xcsqjr.com{\n    ip_hash;\n    server localhost:8084;\n    #server 192.168.0.36:8084;\n    #server 192.168.0.196:8011;\n    #server 192.168.0.197:8011;\n}\n</code></pre><p>这里不成功，包404错误。8084的应用也是跑在docker上的。实际上并不是因为跑在docker上就失败。<br>成功配置：    </p>\n<pre><code>upstream abs-demo.xcsqjr.com{\n        ip_hash;\n        #server localhost:8084;\n        server 192.168.0.36:8084;\n        #server 192.168.0.196:8011;\n        #server 192.168.0.197:8011;\n}\n</code></pre><p>不能用<code>localhost</code>或者<code>127.0.0.1</code>,要用内网ip。查询内网ip，执行命令：<code>ifconfig</code>。</p>\n<h2 id=\"安装redis\"><a href=\"#安装redis\" class=\"headerlink\" title=\"安装redis\"></a>安装redis</h2><p>参考：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/docker/docker-install-redis.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-install-redis.html</a></li>\n</ul>\n<h3 id=\"使用redis镜像\"><a href=\"#使用redis镜像\" class=\"headerlink\" title=\"使用redis镜像\"></a>使用redis镜像</h3><h4 id=\"不使用自定义配置文件：\"><a href=\"#不使用自定义配置文件：\" class=\"headerlink\" title=\"不使用自定义配置文件：\"></a>不使用自定义配置文件：</h4><pre><code>docker run -p 6379:6379 --name redis-6379 --restart=always -v /server/data/redis-6379/data:/data  -d redis:5.0.3 redis-server --appendonly yes --requirepass &quot;a1234567&quot;\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令说明：</span><br><span class=\"line\">-p 6379:6379 : 将容器的6379端口映射到主机的6379端口</span><br><span class=\"line\">-v /server/data/redis-6379/data:/data : 将主机中/server/data/redis-6379目录下的data挂载到容器的/data</span><br><span class=\"line\">redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 </span><br><span class=\"line\">--requirepass &quot;a1234567&quot; : 设置认证密码 </span><br><span class=\"line\">--restart=always ： 随docker启动而启动</span><br></pre></td></tr></table></figure>\n<p>通过客户端连接进入redis-ci：</p>\n<pre><code>[root@sqjr-client-demo-server1-hn ~]# docker exec -it redis-6379 redis-cli -a a1234567\nWarning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.\n127.0.0.1:6379&gt; set username zmt\n</code></pre><p>在宿主机查看redis进程：</p>\n<pre><code>[root@sqjr-client-demo-server1-hn ~]# ps -ef|grep redis\npolkitd  29683 29651  0 14:27 ?        00:00:01 redis-server *:6379\nroot     29935 29453  0 14:51 pts/1    00:00:00 grep --color=auto redis\n</code></pre><p>只能本机127.0.0.1连接，不能远程连接。默认是保护模式，不允许远程连接。</p>\n<h4 id=\"使用自定义配置文件（推荐）\"><a href=\"#使用自定义配置文件（推荐）\" class=\"headerlink\" title=\"使用自定义配置文件（推荐）\"></a>使用自定义配置文件（推荐）</h4><pre><code>docker run --name redis-6380 -p 6380:6380 --restart=always -v /server/data/redis-6380/data:/data -v /server/data/redis-6380/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server  /usr/local/etc/redis/redis.conf --appendonly yes\n</code></pre><p>redis.conf配置文件基本内容，自由添加：</p>\n<pre><code># 指定Redis监听端口，默认端口为6379\n# 如果指定0端口，表示Redis不监听TCP连接\nport 6380\n\n#设置密码\nrequirepass a1234567\n\n#### 生产环境要开启保护模式\n# 绑定的主机地址\n# 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接\n# bind 127.0.0.1\n\n#protected-mode yes #关闭，不要保护模式，远程可连接\n\n# 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\ntimeout 0\n\n#一定要打开，否则无法启动\n#daemonize yes\n\n# 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\npidfile /var/run/redis.pid\n\n# 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n# debug (很多信息, 对开发／测试比较有用)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)\n# warning (only very important / critical messages are logged)\nloglevel verbose\n\n# 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null\nlogfile stdout\n\n# 设置数据库的数量，默认数据库为0，可以使用select &lt;dbid&gt;命令在连接上指定数据库id\n# dbid是从0到‘databases’-1的数目\ndatabases 16\n\n################################ SNAPSHOTTING  #################################\n# 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n# Save the DB on disk:\n#\n#   save &lt;seconds&gt; &lt;changes&gt;\n#\n#   Will save the DB if both the given number of seconds and the given\n#   number of write operations against the DB occurred.\n#\n#   满足以下条件将会同步数据:\n#   900秒（15分钟）内有1个更改\n#   300秒（5分钟）内有10个更改\n#   60秒内有10000个更改\n#   Note: 可以把所有“save”行注释掉，这样就取消同步操作了\n\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\nrdbcompression yes\n\n# 指定本地数据库文件名，默认值为dump.rdb\ndbfilename dump.rdb         \n</code></pre><p><em>注意</em>:<br>切记注释掉：#daemonize yes 否则无法启动容器<br>重要话说三遍：注释掉#daemonize yes，注释掉#daemonize yes，注释掉#daemonize yes</p>\n<p>配置文件：<a href=\"/2018/07/19/docker-app-install/redis.conf\" title=\"redis.conf\">redis.conf</a></p>\n<h2 id=\"安装mysql-server\"><a href=\"#安装mysql-server\" class=\"headerlink\" title=\"安装mysql-server\"></a>安装mysql-server</h2><p>仓库：<a href=\"https://hub.docker.com/r/library/mysql/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/r/library/mysql/</a></p>\n<h4 id=\"拉取镜像：\"><a href=\"#拉取镜像：\" class=\"headerlink\" title=\"拉取镜像：\"></a>拉取镜像：</h4><pre><code>docker pull mysql:8.0.13  # 8.0.13为标签tag\n</code></pre><h4 id=\"使用mysql镜像\"><a href=\"#使用mysql镜像\" class=\"headerlink\" title=\"使用mysql镜像\"></a>使用mysql镜像</h4><ul>\n<li>自定义配置文件</li>\n</ul>\n<pre><code>docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.13    \n\n------------------------------------\ndocker run --name mysql-3910 -p 3910:3910 --restart always --privileged=true -v /server/data/mysql-3910/conf:/etc/mysql/conf.d -v /server/data/mysql-3910/logs:/logs -v /server/data/mysql-3910/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --default-authentication-plugin=mysql_native_password -d mysql:8.0.13 \n</code></pre><p>my.cnf内容</p>\n<pre><code>[mysqld] \nport = 3910\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\n# 一下三个配置，解决too manay connection问题。\nmax_connections=1000 # 最大连接数，默认100\nwait_timeout = 300 #\ninteractive_timeout = 500\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><p>_注意_:   </p>\n<ul>\n<li>远程连接可能报错误：</li>\n</ul>\n<pre><code>2019-01-03T07:41:43.260661Z 8 [Warning] [MY-010055] [Server] IP address &apos;172.17.0.1&apos; could not be resolved: Name or service not known\n</code></pre><ul>\n<li><p>原因：<br>在网上查了些资料简单点说就是反向解析造成的，具体原因是因为“MYSQL Server在本地内存中维护了一个非本地的Client TCP cache，这个cache中包含了远程Client的登录信息，比如IP地址，hostname等信息。如果Client连接到服务器后，Mysql首先会在本地TCP池中根据IP地址解析客户端的hostname或者反解析，如果解析不到，就会去DNS中进行解析，如果还是解析失败就在error log中写入这样的警告信息。”。 </p>\n</li>\n<li><p>解决办法：<br>在配置文件新增一句<code>skip-name-resolve</code>： </p>\n</li>\n</ul>\n<pre><code>[mysqld] \nport = 3910\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\nskip-name-resolve\nwait_timeout = 100\ninteractive_timeout = 100\n</code></pre><p>然后重启mysql服务再试。</p>\n<p>命令说明：</p>\n<ul>\n<li>-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。</li>\n<li>-v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。看下面补充内容说明。</li>\n<li>-v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。</li>\n<li>-v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。</li>\n<li>-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。</li>\n<li>–default-authentication-plugin=mysql_native_password  加上这个客户端才能登录上。在配置文件加了，命令中可以不加。</li>\n<li>–privileged=true 提升root在docker中的权限，否则只是普通用户</li>\n<li>–restart always：开机启动</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">补充：     </span><br><span class=\"line\">MySQL默认配置文件是 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /etc/mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。     </span><br><span class=\"line\">具体操作：   </span><br><span class=\"line\">首先需要创建将要映射到容器中的目录以及.cnf文件，然后再创建容器</span><br><span class=\"line\"></span><br><span class=\"line\">    # pwd</span><br><span class=\"line\">    /opt</span><br><span class=\"line\">    # mkdir -p docker_v/mysql/conf</span><br><span class=\"line\">    # cd docker_v/mysql/conf</span><br><span class=\"line\">    # touch my.cnf</span><br><span class=\"line\">    # docker run -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d imageID</span><br><span class=\"line\">    4ec4f56455ea2d6d7251a05b7f308e314051fdad2c26bf3d0f27a9b0c0a71414</span><br><span class=\"line\">    </span><br><span class=\"line\">-p 3306:3306：将容器的3306端口映射到主机的3306端口</span><br><span class=\"line\">-v /opt/docker_v/mysql/conf:/etc/mysql/conf.d：将主机/opt/docker_v/mysql/conf目录挂载到容器的/etc/mysql/conf.d</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码</span><br><span class=\"line\">-d: 后台运行容器，并返回容器ID</span><br><span class=\"line\">imageID: mysql镜像ID</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不使用conf配置文件</li>\n</ul>\n<p>参考：<a href=\"https://hub.docker.com/r/library/mysql/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/r/library/mysql/</a></p>\n<p>创建容器mysql实例，端口为：3306</p>\n<pre><code>docker run --name mysql-3306 -p 3306:3306 -v /server/mysql-3306/logs:/logs -v /server/mysql-3306/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.13 --port=3306  --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n</code></pre><p>查看配置参数列表：</p>\n<pre><code>docker run -it --rm mysql:tag --verbose --help    \n</code></pre><h4 id=\"查看容器启动情况\"><a href=\"#查看容器启动情况\" class=\"headerlink\" title=\"查看容器启动情况\"></a>查看容器启动情况</h4><pre><code>[root@xr-server ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n415c0167fb5a        mysql:8.0.13        &quot;docker-entrypoint.s…&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mymysql\n</code></pre><h4 id=\"进入mysql镜像\"><a href=\"#进入mysql镜像\" class=\"headerlink\" title=\"进入mysql镜像\"></a>进入mysql镜像</h4><p>参考容器章节……</p>\n<p><code>docker exec -it 415c0167fb5a /bin/bash 或者 docker exec -it 415c0167fb5a bash</code></p>\n<p><code>415c0167fb5a</code>为容器id</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xr-server ~]# clear</span><br><span class=\"line\">[root@xr-server ~]# docker ps</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class=\"line\">415c0167fb5a        mysql:8.0.13        &quot;docker-entrypoint.s…&quot;   17 hours ago        Up 6 minutes        0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mymysql</span><br><span class=\"line\">[root@xr-server ~]# docker exec -it 415c0167fb5a /bin/bash 或者 docker exec -it 415c0167fb5a bash</span><br><span class=\"line\">root@415c0167fb5a:/# ls</span><br><span class=\"line\">bin   docker-entrypoint-initdb.d  home\t logs\topt   run   sys  var</span><br><span class=\"line\">boot  entrypoint.sh\t\t  lib\t media\tproc  sbin  tmp</span><br><span class=\"line\">dev   etc\t\t\t  lib64  mnt\troot  srv   usr</span><br><span class=\"line\">root@415c0167fb5a:/#</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装zabbix\"><a href=\"#安装zabbix\" class=\"headerlink\" title=\"安装zabbix\"></a>安装zabbix</h2><h4 id=\"启动一个mysql服务器实例\"><a href=\"#启动一个mysql服务器实例\" class=\"headerlink\" title=\"启动一个mysql服务器实例\"></a>启动一个mysql服务器实例</h4><pre><code>docker run --name zabbix-mysql-server  \\\n-e MYSQL_ROOT_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_USER=&quot;zabbix&quot; \\\n-e MYSQL_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_DATABASE=&quot;zabbix&quot; \\\n-p 3306:3306  \\\n-v /server/dockers/zabbix/mysql/logs:/logs \\\n-v /server/dockers/zabbix/mysql/data:/var/lib/mysql \\\n-d mysql:5.7 \\\n--character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n</code></pre><h4 id=\"启动Zabbix-server实例，并关联这个实例到已创建的MySQL服务器实例\"><a href=\"#启动Zabbix-server实例，并关联这个实例到已创建的MySQL服务器实例\" class=\"headerlink\" title=\"启动Zabbix server实例，并关联这个实例到已创建的MySQL服务器实例\"></a>启动Zabbix server实例，并关联这个实例到已创建的MySQL服务器实例</h4><pre><code>docker run  --name zabbix-server-mysql --hostname zabbix-server-mysql \\\n--link zabbix-mysql-server:mysql \\\n-e DB_SERVER_HOST=&quot;mysql&quot; \\\n-e MYSQL_USER=&quot;zabbix&quot; \\\n-e MYSQL_DATABASE=&quot;zabbix&quot; \\\n-e MYSQL_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_ROOT_PASSWORD=&quot;123456&quot; \\\n-v /etc/localtime:/etc/localtime:ro \\\n-v /server/dockers/zabbix/zabbix-server/alertscripts:/usr/lib/zabbix/alertscripts \\\n-v /server/dockers/zabbix/zabbix-server/externalscripts:/usr/lib/zabbix/externalscripts \\\n-p 10051:10051 \\\n-p 10050:10050 \\\n-d zabbix/zabbix-server-mysql:centos-4.0.2\n\n------------------------------ 查看启动日志 ---------------\ndocker logs zabbix-server-mysql\n</code></pre><p>_注意_：必须加上属性<code>-e MYSQL_ROOT_PASSWORD=&quot;123456&quot;</code>,否则mysql的<code>zabbix</code>用户没有操作mysql数据库的权限。    </p>\n<blockquote>\n<p><code>--link</code>属性说明：<br>docker run –link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。<br>–link的格式：<br>–link <name or=\"\" id=\"\">:alias<br>其中，name和id是源容器的name和id，alias是源容器在link下的别名。    </name></p>\n</blockquote>\n<h4 id=\"启动Zabbix-web-接口，并将它与MySQL服务器实例和Zabbix-server实例关联\"><a href=\"#启动Zabbix-web-接口，并将它与MySQL服务器实例和Zabbix-server实例关联\" class=\"headerlink\" title=\"启动Zabbix web 接口，并将它与MySQL服务器实例和Zabbix server实例关联\"></a>启动Zabbix web 接口，并将它与MySQL服务器实例和Zabbix server实例关联</h4><pre><code>docker run --name zabbix-web-nginx-mysql --hostname zabbix-web-nginx-mysql \\\n--link zabbix-mysql-server:mysql \\\n--link zabbix-server-mysql:zabbix-server \\\n-e DB_SERVER_HOST=&quot;mysql&quot; \\\n-e MYSQL_ROOT_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_USER=&quot;zabbix&quot; \\\n-e MYSQL_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_DATABASE=&quot;zabbix&quot; \\\n-e ZBX_SERVER_HOST=&quot;zabbix-server&quot; \\\n-e PHP_TZ=&quot;Asia/Shanghai&quot; \\\n-p 8083:80 \\\n-d zabbix/zabbix-web-nginx-mysql:centos-4.0.2\n\n------------------------------ 查看启动日志 ---------------\ndocker logs zabbix-web-nginx-mysql\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">浏览器访问ip:8083查看</span><br><span class=\"line\">默认登录</span><br><span class=\"line\">username:Admin</span><br><span class=\"line\">password:zabbix</span><br></pre></td></tr></table></figure>\n<p> _注意_ ：生产环境要做数据卷映射。以防止数据丢失。必须加上属性<code>-e MYSQL_ROOT_PASSWORD=&quot;123456&quot;</code>,否则mysql的<code>zabbix</code>用户没有操作mysql数据库的权限。</p>\n<p><em>界面无法选择中文显示的问题</em>：</p>\n<p>打开系统，在用户资料中，可以选择语言，但是无法选择中文。这是由于docker容器没有安装中文字符集，不支持中文。<br>因此，要进入容器，安装中文字符集合： </p>\n<p>查看系统当前字符集： <code># locale</code>；<br>查看系统可用字符集： <code>#locale -a</code>;<br>安装中文字符集：<br><code>yum install kde-l10n-Chinese -y</code><br><code>yum -y -q reinstall glibc-common</code></p>\n<p>修改<code>vim /etc/locale.conf</code>, LANG=zh_CN.UTF-8;</p>\n<p>重新启动容器。再次进入容器，查看系统当前字符集，发现上面修改无效。坑爹……</p>\n<p>那是因为centos默认镜像的 /etc/yum.conf 里面有一句<code>override_install_langs=en_US.utf8</code>，<br>删除这句话，然后重新运行：<code>yum -y -q reinstall glibc-common</code>，再重启容器，查看系统当前字符集，可以看到是中文的了。</p>\n<h4 id=\"启动zabbix-agent\"><a href=\"#启动zabbix-agent\" class=\"headerlink\" title=\"启动zabbix-agent\"></a>启动zabbix-agent</h4><pre><code>docker run --name zabbix-agent --link zabbix-server-mysql:zabbix-server -d zabbix/zabbix-agent:centos-4.0.2 \n</code></pre><p>最后需要在web端将，zabbix-agent添加到zabbix-server的host列表里面。    </p>\n<h4 id=\"启动Zabbix-Java-gateway实例-并关联到zabbix-server\"><a href=\"#启动Zabbix-Java-gateway实例-并关联到zabbix-server\" class=\"headerlink\" title=\"启动Zabbix Java gateway实例,并关联到zabbix-server\"></a>启动Zabbix Java gateway实例,并关联到zabbix-server</h4><p>用于监控jvm/tomcat性能。<br>Zabbix监控Java应用程序的关键点在于：配置Zabbix-JavaGateway、让Zabbix-Server能够连接Zabbix-JavaGateway、Tomcat开启JVM远程监控功能等。</p>\n<pre><code>docker run --name zabbix-java-gateway --link zabbix-server-mysql:zabbix-server -d zabbix/zabbix-java-gateway:latest\n</code></pre><h2 id=\"安装Jenkins\"><a href=\"#安装Jenkins\" class=\"headerlink\" title=\"安装Jenkins\"></a>安装Jenkins</h2><p>####　配置日志：   </p>\n<pre><code>[root@ymu /]# mkdir -p /server/data/jenkins\n[root@ymu /]# cd /server/data/jenkins\n[root@ymu jenkins]# touch log.properties\n[root@ymu jenkins]# cat &gt; log.properties &lt;&lt;EOF\n&gt; handlers=java.util.logging.ConsoleHandler\n&gt; jenkins.level=FINEST\n&gt; java.util.logging.ConsoleHandler.level=FINEST\n&gt; EOF\n</code></pre><h4 id=\"启动jenkins服务\"><a href=\"#启动jenkins服务\" class=\"headerlink\" title=\"启动jenkins服务\"></a>启动jenkins服务</h4><p>参考：<a href=\"https://github.com/jenkinsci/docker/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/jenkinsci/docker/blob/master/README.md</a></p>\n<p>首先，要对文件夹赋予权限：<br>查看文件夹权限：`</p>\n<pre><code>[root@xr-server jenkins]# ls -l /server/data/jenkins/\ntotal 4\n-rw-r--r--. 1 root root 109 Dec 17 00:55 log.properties\n</code></pre><p>赋予文件夹权限：    </p>\n<pre><code>chown -R 1000:1000 /server/data/jenkins/    \n</code></pre><p>启动容器：</p>\n<pre><code>docker run --name ymu-jenkins -p 3001:8080 -p 50000:50000 --env JAVA_OPTS=&quot;-Djava.util.logging.config.file=/var/jenkins_home/log.properties&quot; -v /server/data/jenkins:/var/jenkins_home -d jenkins/jenkins:lts\n</code></pre><p>lts：长期支持版本<br>以上启动的容器安装Locale插件后，也只能部分中文，原因：未知……</p>\n<p>说明： </p>\n<ul>\n<li>-v 会把容器目录<code>/var/jenkins_home</code>映射到主机<code>/server/data/jenkins</code> </li>\n</ul>\n<h4 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h4><p>打开浏览器输入：local:3001</p>\n<p>如果看到要求获取登录密码的界面，则成功。恭喜……</p>\n<p>获取登录初始密码：   </p>\n<pre><code>[root@ymu secrets]# pwd\n/server/data/jenkins/secrets\n[root@ymu secrets]# cat initialAdminPassword \n8ccac67d98dd4c77a2c09870e8246e5d\n[root@ymu secrets]#\n</code></pre><p>其它的如和maven的集成等，参考以前文档。  </p>\n<h4 id=\"使用Nginx做方向代理\"><a href=\"#使用Nginx做方向代理\" class=\"headerlink\" title=\"使用Nginx做方向代理\"></a>使用Nginx做方向代理</h4><p>坑，坑，坑……</p>\n<p>一开始按一般的nginx方向代理配置，负载均衡配置，都不行，页面打开异常的慢……</p>\n<p>各种百度，不行。还好，想起了google大神……结果找到了：  </p>\n<p><a href=\"https://wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx\" target=\"_blank\" rel=\"noopener\">https://wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx</a></p>\n<p>还是官方文档有用，以后遇到这种问题，都先到官方wiki上找答案才对。<br>重新配置：</p>\n<pre><code>upstream jenkins {\n  keepalive 32; # keepalive connections\n  server 127.0.0.1:9000; # jenkins ip and port\n}\n\nserver {\n  listen          80;       # Listen on port 80 for IPv4 requests\n\n  server_name     ci.xcsqjr.com;\n\n  #this is the jenkins web root directory (mentioned in the /etc/default/jenkins file)\n  root            /server/data/jenkins/war;\n\n  access_log      /server/java/nginx/logs/ci.xcsqjr.com.access.log;\n  error_log       /server/java/nginx/logs/ci.xcsqjr.com.error.log;\n  ignore_invalid_headers off; #pass through headers from Jenkins which are considered invalid by Nginx server.\n\n  location ~ &quot;^/static/[0-9a-fA-F]{8}\\/(.*)$&quot; {\n    #rewrite all static files into requests to the root\n    #E.g /static/12345678/css/something.css will become /css/something.css\n    rewrite &quot;^/static/[0-9a-fA-F]{8}\\/(.*)&quot; /$1 last;\n  }\n\n  location /userContent {\n    #have nginx handle all the static requests to the userContent folder files\n    #note : This is the $JENKINS_HOME dir\n    root /server/data/jenkins/war;\n    if (!-f $request_filename){\n      #this file does not exist, might be a directory or a /**view** url\n      rewrite (.*) /$1 last;\n      break;\n    }\n    sendfile on;\n  }\n\n  location / {\n      sendfile off;\n      proxy_pass         http://jenkins;\n      proxy_redirect     default;\n      proxy_http_version 1.1;\n\n      proxy_set_header   Host              $host;\n      proxy_set_header   X-Real-IP         $remote_addr;\n      proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;\n      proxy_set_header   X-Forwarded-Proto $scheme;\n      proxy_max_temp_file_size 0;\n\n      #this is the maximum upload size\n      client_max_body_size       10m;\n      client_body_buffer_size    128k;\n\n      proxy_connect_timeout      90;\n      proxy_send_timeout         90;\n      proxy_read_timeout         90;\n      proxy_buffering            off;\n      #proxy_request_buffering    off; # Required for HTTP CLI commands in Jenkins &gt; 2.54\n      proxy_set_header Connection &quot;&quot;; # Clear for keepalive\n  }\n\n}\n</code></pre><p>注意：按上面docker安装jenkins的时候，映射了数据卷，所以可以知道：<code>server/data/jenkins/war</code> 为jenkins的web根目录。注意配置好。</p>\n<h2 id=\"安装gitlab\"><a href=\"#安装gitlab\" class=\"headerlink\" title=\"安装gitlab\"></a>安装gitlab</h2><p>参考网址：<a href=\"https://docs.gitlab.com/omnibus/docker/\" target=\"_blank\" rel=\"noopener\">https://docs.gitlab.com/omnibus/docker/</a></p>\n<h2 id=\"安装sonatype-nexus\"><a href=\"#安装sonatype-nexus\" class=\"headerlink\" title=\"安装sonatype/nexus\"></a>安装sonatype/nexus</h2><p>参考网址：<br><a href=\"https://hub.docker.com/r/sonatype/nexus\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/r/sonatype/nexus</a> </p>\n<p>1.初始持久化数据目录</p>\n<pre><code># mkdir /server/data/nexus/data &amp;&amp; chown -R 200 /server/data/nexus/data\n\n# docker run -d -p 8084:8081 --name nexus -e MAX_HEAP=768m  -v /server/data/nexus/data:/sonatype-work sonatype/nexus    \n</code></pre><p>2.查看启动日志</p>\n<pre><code>docker logs -f nexus\n</code></pre><p>3.默认账号密码：</p>\n<pre><code>admin / admin123        \n</code></pre><p>4.浏览器浏览：</p>\n<pre><code>http://ip:8084/nexus\n</code></pre><h3 id=\"安装sonatype-nexus3-兼容maven依赖和docker-register（推荐生产使用）\"><a href=\"#安装sonatype-nexus3-兼容maven依赖和docker-register（推荐生产使用）\" class=\"headerlink\" title=\"安装sonatype/nexus3,兼容maven依赖和docker register（推荐生产使用）\"></a>安装sonatype/nexus3,兼容maven依赖和docker register（推荐生产使用）</h3><p>网址：<a href=\"https://github.com/sonatype/docker-nexus3\" target=\"_blank\" rel=\"noopener\">https://github.com/sonatype/docker-nexus3</a></p>\n<p>1.创建映射卷并启动实例</p>\n<pre><code># mkdir -p /server/data/nexus3-data &amp;&amp; chown -R 200 /server/data/nexus3-data\n\n# docker run  -p 8085:8081 -p 8082:8082 -p 8083:8083 --name nexus3 --restart=always -v /server/data/nexus3-data:/nexus-data  -d sonatype/nexus3\n</code></pre><p>2.查看启动日志：</p>\n<pre><code>docker logs -f nexus    \n</code></pre><p>3.测试是否安装成功：</p>\n<pre><code>curl -u admin:admin123 http://localhost:8085/service/metrics/ping  \n</code></pre><p>4.打开浏览器浏览：</p>\n<p> 网址：<a href=\"http://ip:8085\" target=\"_blank\" rel=\"noopener\">http://ip:8085</a></p>\n<p> 默认账号密码：admin admin123</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录在docker各种应用程序的安装以及使用……</p>\n<p>docker仓库： <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">hub repo</a></p>\n<h2 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h2><p>参考：</p>\n<ul>\n<li><a href=\"https://hub.docker.com/_/nginx\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/nginx</a></li>\n</ul>\n<p>1.新建要映射的卷</p>\n<pre><code># mkdir -p /server/data/nginx/{cache,conf,conf.d,html,logs,pid}\n# chown 1000 /server/data/nginx/* -R\n# chmod 755 /server/data/nginx/* -R\n</code></pre><p>查看</p>\n<pre><code>[root@sqjr-client-demo-server1-hn nginx]# pwd\n/server/data/nginx\n[root@sqjr-client-demo-server1-hn nginx]# ls\ncache  conf  conf.d  html  logs  pid    \n</code></pre><p>2.拉取nginx最新镜像</p>\n<pre><code>docker pull nginx\n</code></pre><p>2.配置nginx.conf</p>\n<ul>\n<li>可以从从启动的容器中把该文件拷贝出来。</li>\n</ul>\n<pre><code>$ docker run --name tmp-nginx-container -d nginx\n$ docker cp tmp-nginx-container:/etc/nginx/nginx.conf /server/data/nginx/conf/nginx.conf\n$ docker rm -f tmp-nginx-container\n</code></pre><ul>\n<li>或者进入<code>/server/data/nginx/conf</code>,新建文件<code>touch nginx.conf</code></li>\n</ul>\n<p>然后编辑nginx.conf文件：</p>\n<pre><code>user  nginx;\nworker_processes  1;\n\nerror_log  /var/log/nginx/error.log warn;\npid        /var/run/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;\n                      &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;\n                      &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;;\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    server {\n        listen       80;\n        server_name  localhost;\n    charset utf-8;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   /usr/share/nginx/html;\n            #root /server/wwwroot;\n            index  index.html index.htm;\n        }\n\n        #error_page  404              /404.html;\n\n        # redirect server error pages to the static page /50x.html\n        #\n        error_page   500 502 503 504  /50x.html;\n        location = /50x.html {\n            root   html;\n        }\n\n        # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n        #\n        #location ~ \\.php$ {\n        #    proxy_pass   http://127.0.0.1;\n        #}\n\n        # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n        #\n        #location ~ \\.php$ {\n        #    root           html;\n        #    fastcgi_pass   127.0.0.1:9000;\n        #    fastcgi_index  index.php;\n        #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;\n        #    include        fastcgi_params;\n        #}\n\n        # deny access to .htaccess files, if Apache&apos;s document root\n        # concurs with nginx&apos;s one\n        #\n        #location ~ /\\.ht {\n        #    deny  all;\n        #}\n    }\n\n    include /etc/nginx/conf.d/*.conf;\n}\n</code></pre><p>3.新建欢迎页面</p>\n<p>进入目录<code>server/data/nginx/html</code>下，新建文件<code>index.html</code>并随便编写内容测试。</p>\n<p>4.启动nginx容器</p>\n<pre><code>docker run --name nginx -d -p 80:80 -v /server/data/nginx/html:/usr/share/nginx/html:ro -v /server/data/nginx/logs:/var/log/nginx -v /server/data/nginx/conf/nginx.conf:/etc/nginx/nginx.conf:ro -v /server/data/nginx/conf.d:/etc/nginx/conf.d -v /server/data/nginx/cache:/var/cache/nginx -v /server/data/nginx/pid:/var/run -d nginx\n</code></pre><p>成功启动后，就可以打开浏览器测试：<a href=\"http://ip或者http://域名\" target=\"_blank\" rel=\"noopener\">http://ip或者http://域名</a></p>\n<p>5.中文乱码问题</p>\n<p>如果发现中文乱码，修改server的配置内容，增加一行：charset utf-8;  </p>\n<pre><code>upstream you.domainName.com {\n   server 127.0.0.1:8081;\n}\n\nserver {\n      listen      80;\n      server_name  you.domainName.com;\n      charset utf-8;\n\n      location /examples {\n          return 403;\n        }   \n }\n</code></pre><p>然后重启nginx。最后，在浏览器上Ctrl+F5，刷新，一切正常！</p>\n<p>6.反向代理失败问题</p>\n<pre><code>upstream abs-demo.xcsqjr.com{\n    ip_hash;\n    server localhost:8084;\n    #server 192.168.0.36:8084;\n    #server 192.168.0.196:8011;\n    #server 192.168.0.197:8011;\n}\n</code></pre><p>这里不成功，包404错误。8084的应用也是跑在docker上的。实际上并不是因为跑在docker上就失败。<br>成功配置：    </p>\n<pre><code>upstream abs-demo.xcsqjr.com{\n        ip_hash;\n        #server localhost:8084;\n        server 192.168.0.36:8084;\n        #server 192.168.0.196:8011;\n        #server 192.168.0.197:8011;\n}\n</code></pre><p>不能用<code>localhost</code>或者<code>127.0.0.1</code>,要用内网ip。查询内网ip，执行命令：<code>ifconfig</code>。</p>\n<h2 id=\"安装redis\"><a href=\"#安装redis\" class=\"headerlink\" title=\"安装redis\"></a>安装redis</h2><p>参考：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/docker/docker-install-redis.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-install-redis.html</a></li>\n</ul>\n<h3 id=\"使用redis镜像\"><a href=\"#使用redis镜像\" class=\"headerlink\" title=\"使用redis镜像\"></a>使用redis镜像</h3><h4 id=\"不使用自定义配置文件：\"><a href=\"#不使用自定义配置文件：\" class=\"headerlink\" title=\"不使用自定义配置文件：\"></a>不使用自定义配置文件：</h4><pre><code>docker run -p 6379:6379 --name redis-6379 --restart=always -v /server/data/redis-6379/data:/data  -d redis:5.0.3 redis-server --appendonly yes --requirepass &quot;a1234567&quot;\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">命令说明：</span><br><span class=\"line\">-p 6379:6379 : 将容器的6379端口映射到主机的6379端口</span><br><span class=\"line\">-v /server/data/redis-6379/data:/data : 将主机中/server/data/redis-6379目录下的data挂载到容器的/data</span><br><span class=\"line\">redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置 </span><br><span class=\"line\">--requirepass &quot;a1234567&quot; : 设置认证密码 </span><br><span class=\"line\">--restart=always ： 随docker启动而启动</span><br></pre></td></tr></table></figure>\n<p>通过客户端连接进入redis-ci：</p>\n<pre><code>[root@sqjr-client-demo-server1-hn ~]# docker exec -it redis-6379 redis-cli -a a1234567\nWarning: Using a password with &apos;-a&apos; or &apos;-u&apos; option on the command line interface may not be safe.\n127.0.0.1:6379&gt; set username zmt\n</code></pre><p>在宿主机查看redis进程：</p>\n<pre><code>[root@sqjr-client-demo-server1-hn ~]# ps -ef|grep redis\npolkitd  29683 29651  0 14:27 ?        00:00:01 redis-server *:6379\nroot     29935 29453  0 14:51 pts/1    00:00:00 grep --color=auto redis\n</code></pre><p>只能本机127.0.0.1连接，不能远程连接。默认是保护模式，不允许远程连接。</p>\n<h4 id=\"使用自定义配置文件（推荐）\"><a href=\"#使用自定义配置文件（推荐）\" class=\"headerlink\" title=\"使用自定义配置文件（推荐）\"></a>使用自定义配置文件（推荐）</h4><pre><code>docker run --name redis-6380 -p 6380:6380 --restart=always -v /server/data/redis-6380/data:/data -v /server/data/redis-6380/conf/redis.conf:/usr/local/etc/redis/redis.conf -d redis redis-server  /usr/local/etc/redis/redis.conf --appendonly yes\n</code></pre><p>redis.conf配置文件基本内容，自由添加：</p>\n<pre><code># 指定Redis监听端口，默认端口为6379\n# 如果指定0端口，表示Redis不监听TCP连接\nport 6380\n\n#设置密码\nrequirepass a1234567\n\n#### 生产环境要开启保护模式\n# 绑定的主机地址\n# 你可以绑定单一接口，如果没有绑定，所有接口都会监听到来的连接\n# bind 127.0.0.1\n\n#protected-mode yes #关闭，不要保护模式，远程可连接\n\n# 当客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能\ntimeout 0\n\n#一定要打开，否则无法启动\n#daemonize yes\n\n# 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定\npidfile /var/run/redis.pid\n\n# 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose\n# debug (很多信息, 对开发／测试比较有用)\n# verbose (many rarely useful info, but not a mess like the debug level)\n# notice (moderately verbose, what you want in production probably)\n# warning (only very important / critical messages are logged)\nloglevel verbose\n\n# 日志记录方式，默认为标准输出，如果配置为redis为守护进程方式运行，而这里又配置为标准输出，则日志将会发送给/dev/null\nlogfile stdout\n\n# 设置数据库的数量，默认数据库为0，可以使用select &lt;dbid&gt;命令在连接上指定数据库id\n# dbid是从0到‘databases’-1的数目\ndatabases 16\n\n################################ SNAPSHOTTING  #################################\n# 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合\n# Save the DB on disk:\n#\n#   save &lt;seconds&gt; &lt;changes&gt;\n#\n#   Will save the DB if both the given number of seconds and the given\n#   number of write operations against the DB occurred.\n#\n#   满足以下条件将会同步数据:\n#   900秒（15分钟）内有1个更改\n#   300秒（5分钟）内有10个更改\n#   60秒内有10000个更改\n#   Note: 可以把所有“save”行注释掉，这样就取消同步操作了\n\nsave 900 1\nsave 300 10\nsave 60 10000\n\n# 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大\nrdbcompression yes\n\n# 指定本地数据库文件名，默认值为dump.rdb\ndbfilename dump.rdb         \n</code></pre><p><em>注意</em>:<br>切记注释掉：#daemonize yes 否则无法启动容器<br>重要话说三遍：注释掉#daemonize yes，注释掉#daemonize yes，注释掉#daemonize yes</p>\n<p>配置文件：<a href=\"/2018/07/19/docker-app-install/redis.conf\" title=\"redis.conf\">redis.conf</a></p>\n<h2 id=\"安装mysql-server\"><a href=\"#安装mysql-server\" class=\"headerlink\" title=\"安装mysql-server\"></a>安装mysql-server</h2><p>仓库：<a href=\"https://hub.docker.com/r/library/mysql/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/r/library/mysql/</a></p>\n<h4 id=\"拉取镜像：\"><a href=\"#拉取镜像：\" class=\"headerlink\" title=\"拉取镜像：\"></a>拉取镜像：</h4><pre><code>docker pull mysql:8.0.13  # 8.0.13为标签tag\n</code></pre><h4 id=\"使用mysql镜像\"><a href=\"#使用mysql镜像\" class=\"headerlink\" title=\"使用mysql镜像\"></a>使用mysql镜像</h4><ul>\n<li>自定义配置文件</li>\n</ul>\n<pre><code>docker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.13    \n\n------------------------------------\ndocker run --name mysql-3910 -p 3910:3910 --restart always --privileged=true -v /server/data/mysql-3910/conf:/etc/mysql/conf.d -v /server/data/mysql-3910/logs:/logs -v /server/data/mysql-3910/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --default-authentication-plugin=mysql_native_password -d mysql:8.0.13 \n</code></pre><p>my.cnf内容</p>\n<pre><code>[mysqld] \nport = 3910\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\n# 一下三个配置，解决too manay connection问题。\nmax_connections=1000 # 最大连接数，默认100\nwait_timeout = 300 #\ninteractive_timeout = 500\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><p>_注意_:   </p>\n<ul>\n<li>远程连接可能报错误：</li>\n</ul>\n<pre><code>2019-01-03T07:41:43.260661Z 8 [Warning] [MY-010055] [Server] IP address &apos;172.17.0.1&apos; could not be resolved: Name or service not known\n</code></pre><ul>\n<li><p>原因：<br>在网上查了些资料简单点说就是反向解析造成的，具体原因是因为“MYSQL Server在本地内存中维护了一个非本地的Client TCP cache，这个cache中包含了远程Client的登录信息，比如IP地址，hostname等信息。如果Client连接到服务器后，Mysql首先会在本地TCP池中根据IP地址解析客户端的hostname或者反解析，如果解析不到，就会去DNS中进行解析，如果还是解析失败就在error log中写入这样的警告信息。”。 </p>\n</li>\n<li><p>解决办法：<br>在配置文件新增一句<code>skip-name-resolve</code>： </p>\n</li>\n</ul>\n<pre><code>[mysqld] \nport = 3910\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\nskip-name-resolve\nwait_timeout = 100\ninteractive_timeout = 100\n</code></pre><p>然后重启mysql服务再试。</p>\n<p>命令说明：</p>\n<ul>\n<li>-p 3306:3306：将容器的 3306 端口映射到主机的 3306 端口。</li>\n<li>-v -v $PWD/conf:/etc/mysql/conf.d：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。看下面补充内容说明。</li>\n<li>-v $PWD/logs:/logs：将主机当前目录下的 logs 目录挂载到容器的 /logs。</li>\n<li>-v $PWD/data:/var/lib/mysql ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。</li>\n<li>-e MYSQL_ROOT_PASSWORD=123456：初始化 root 用户的密码。</li>\n<li>–default-authentication-plugin=mysql_native_password  加上这个客户端才能登录上。在配置文件加了，命令中可以不加。</li>\n<li>–privileged=true 提升root在docker中的权限，否则只是普通用户</li>\n<li>–restart always：开机启动</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">补充：     </span><br><span class=\"line\">MySQL默认配置文件是 /etc/mysql/my.cnf 文件。如果想要自定义配置，建议向 /etc/mysql/conf.d 目录中创建 .cnf 文件。新建的文件可以任意起名，只要保证后缀名是 cnf 即可。新建的文件中的配置项可以覆盖 /etc/mysql/my.cnf 中的配置项。     </span><br><span class=\"line\">具体操作：   </span><br><span class=\"line\">首先需要创建将要映射到容器中的目录以及.cnf文件，然后再创建容器</span><br><span class=\"line\"></span><br><span class=\"line\">    # pwd</span><br><span class=\"line\">    /opt</span><br><span class=\"line\">    # mkdir -p docker_v/mysql/conf</span><br><span class=\"line\">    # cd docker_v/mysql/conf</span><br><span class=\"line\">    # touch my.cnf</span><br><span class=\"line\">    # docker run -p 3306:3306 --name mysql -v /opt/docker_v/mysql/conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d imageID</span><br><span class=\"line\">    4ec4f56455ea2d6d7251a05b7f308e314051fdad2c26bf3d0f27a9b0c0a71414</span><br><span class=\"line\">    </span><br><span class=\"line\">-p 3306:3306：将容器的3306端口映射到主机的3306端口</span><br><span class=\"line\">-v /opt/docker_v/mysql/conf:/etc/mysql/conf.d：将主机/opt/docker_v/mysql/conf目录挂载到容器的/etc/mysql/conf.d</span><br><span class=\"line\">-e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码</span><br><span class=\"line\">-d: 后台运行容器，并返回容器ID</span><br><span class=\"line\">imageID: mysql镜像ID</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不使用conf配置文件</li>\n</ul>\n<p>参考：<a href=\"https://hub.docker.com/r/library/mysql/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/r/library/mysql/</a></p>\n<p>创建容器mysql实例，端口为：3306</p>\n<pre><code>docker run --name mysql-3306 -p 3306:3306 -v /server/mysql-3306/logs:/logs -v /server/mysql-3306/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:8.0.13 --port=3306  --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n</code></pre><p>查看配置参数列表：</p>\n<pre><code>docker run -it --rm mysql:tag --verbose --help    \n</code></pre><h4 id=\"查看容器启动情况\"><a href=\"#查看容器启动情况\" class=\"headerlink\" title=\"查看容器启动情况\"></a>查看容器启动情况</h4><pre><code>[root@xr-server ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES\n415c0167fb5a        mysql:8.0.13        &quot;docker-entrypoint.s…&quot;   5 minutes ago       Up 5 minutes        0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mymysql\n</code></pre><h4 id=\"进入mysql镜像\"><a href=\"#进入mysql镜像\" class=\"headerlink\" title=\"进入mysql镜像\"></a>进入mysql镜像</h4><p>参考容器章节……</p>\n<p><code>docker exec -it 415c0167fb5a /bin/bash 或者 docker exec -it 415c0167fb5a bash</code></p>\n<p><code>415c0167fb5a</code>为容器id</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@xr-server ~]# clear</span><br><span class=\"line\">[root@xr-server ~]# docker ps</span><br><span class=\"line\">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES</span><br><span class=\"line\">415c0167fb5a        mysql:8.0.13        &quot;docker-entrypoint.s…&quot;   17 hours ago        Up 6 minutes        0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mymysql</span><br><span class=\"line\">[root@xr-server ~]# docker exec -it 415c0167fb5a /bin/bash 或者 docker exec -it 415c0167fb5a bash</span><br><span class=\"line\">root@415c0167fb5a:/# ls</span><br><span class=\"line\">bin   docker-entrypoint-initdb.d  home\t logs\topt   run   sys  var</span><br><span class=\"line\">boot  entrypoint.sh\t\t  lib\t media\tproc  sbin  tmp</span><br><span class=\"line\">dev   etc\t\t\t  lib64  mnt\troot  srv   usr</span><br><span class=\"line\">root@415c0167fb5a:/#</span><br></pre></td></tr></table></figure>\n<h2 id=\"安装zabbix\"><a href=\"#安装zabbix\" class=\"headerlink\" title=\"安装zabbix\"></a>安装zabbix</h2><h4 id=\"启动一个mysql服务器实例\"><a href=\"#启动一个mysql服务器实例\" class=\"headerlink\" title=\"启动一个mysql服务器实例\"></a>启动一个mysql服务器实例</h4><pre><code>docker run --name zabbix-mysql-server  \\\n-e MYSQL_ROOT_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_USER=&quot;zabbix&quot; \\\n-e MYSQL_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_DATABASE=&quot;zabbix&quot; \\\n-p 3306:3306  \\\n-v /server/dockers/zabbix/mysql/logs:/logs \\\n-v /server/dockers/zabbix/mysql/data:/var/lib/mysql \\\n-d mysql:5.7 \\\n--character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci\n</code></pre><h4 id=\"启动Zabbix-server实例，并关联这个实例到已创建的MySQL服务器实例\"><a href=\"#启动Zabbix-server实例，并关联这个实例到已创建的MySQL服务器实例\" class=\"headerlink\" title=\"启动Zabbix server实例，并关联这个实例到已创建的MySQL服务器实例\"></a>启动Zabbix server实例，并关联这个实例到已创建的MySQL服务器实例</h4><pre><code>docker run  --name zabbix-server-mysql --hostname zabbix-server-mysql \\\n--link zabbix-mysql-server:mysql \\\n-e DB_SERVER_HOST=&quot;mysql&quot; \\\n-e MYSQL_USER=&quot;zabbix&quot; \\\n-e MYSQL_DATABASE=&quot;zabbix&quot; \\\n-e MYSQL_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_ROOT_PASSWORD=&quot;123456&quot; \\\n-v /etc/localtime:/etc/localtime:ro \\\n-v /server/dockers/zabbix/zabbix-server/alertscripts:/usr/lib/zabbix/alertscripts \\\n-v /server/dockers/zabbix/zabbix-server/externalscripts:/usr/lib/zabbix/externalscripts \\\n-p 10051:10051 \\\n-p 10050:10050 \\\n-d zabbix/zabbix-server-mysql:centos-4.0.2\n\n------------------------------ 查看启动日志 ---------------\ndocker logs zabbix-server-mysql\n</code></pre><p>_注意_：必须加上属性<code>-e MYSQL_ROOT_PASSWORD=&quot;123456&quot;</code>,否则mysql的<code>zabbix</code>用户没有操作mysql数据库的权限。    </p>\n<blockquote>\n<p><code>--link</code>属性说明：<br>docker run –link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据，如源容器的环境变量。<br>–link的格式：<br>–link <name or=\"\" id=\"\">:alias<br>其中，name和id是源容器的name和id，alias是源容器在link下的别名。    </name></p>\n</blockquote>\n<h4 id=\"启动Zabbix-web-接口，并将它与MySQL服务器实例和Zabbix-server实例关联\"><a href=\"#启动Zabbix-web-接口，并将它与MySQL服务器实例和Zabbix-server实例关联\" class=\"headerlink\" title=\"启动Zabbix web 接口，并将它与MySQL服务器实例和Zabbix server实例关联\"></a>启动Zabbix web 接口，并将它与MySQL服务器实例和Zabbix server实例关联</h4><pre><code>docker run --name zabbix-web-nginx-mysql --hostname zabbix-web-nginx-mysql \\\n--link zabbix-mysql-server:mysql \\\n--link zabbix-server-mysql:zabbix-server \\\n-e DB_SERVER_HOST=&quot;mysql&quot; \\\n-e MYSQL_ROOT_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_USER=&quot;zabbix&quot; \\\n-e MYSQL_PASSWORD=&quot;123456&quot; \\\n-e MYSQL_DATABASE=&quot;zabbix&quot; \\\n-e ZBX_SERVER_HOST=&quot;zabbix-server&quot; \\\n-e PHP_TZ=&quot;Asia/Shanghai&quot; \\\n-p 8083:80 \\\n-d zabbix/zabbix-web-nginx-mysql:centos-4.0.2\n\n------------------------------ 查看启动日志 ---------------\ndocker logs zabbix-web-nginx-mysql\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">浏览器访问ip:8083查看</span><br><span class=\"line\">默认登录</span><br><span class=\"line\">username:Admin</span><br><span class=\"line\">password:zabbix</span><br></pre></td></tr></table></figure>\n<p> _注意_ ：生产环境要做数据卷映射。以防止数据丢失。必须加上属性<code>-e MYSQL_ROOT_PASSWORD=&quot;123456&quot;</code>,否则mysql的<code>zabbix</code>用户没有操作mysql数据库的权限。</p>\n<p><em>界面无法选择中文显示的问题</em>：</p>\n<p>打开系统，在用户资料中，可以选择语言，但是无法选择中文。这是由于docker容器没有安装中文字符集，不支持中文。<br>因此，要进入容器，安装中文字符集合： </p>\n<p>查看系统当前字符集： <code># locale</code>；<br>查看系统可用字符集： <code>#locale -a</code>;<br>安装中文字符集：<br><code>yum install kde-l10n-Chinese -y</code><br><code>yum -y -q reinstall glibc-common</code></p>\n<p>修改<code>vim /etc/locale.conf</code>, LANG=zh_CN.UTF-8;</p>\n<p>重新启动容器。再次进入容器，查看系统当前字符集，发现上面修改无效。坑爹……</p>\n<p>那是因为centos默认镜像的 /etc/yum.conf 里面有一句<code>override_install_langs=en_US.utf8</code>，<br>删除这句话，然后重新运行：<code>yum -y -q reinstall glibc-common</code>，再重启容器，查看系统当前字符集，可以看到是中文的了。</p>\n<h4 id=\"启动zabbix-agent\"><a href=\"#启动zabbix-agent\" class=\"headerlink\" title=\"启动zabbix-agent\"></a>启动zabbix-agent</h4><pre><code>docker run --name zabbix-agent --link zabbix-server-mysql:zabbix-server -d zabbix/zabbix-agent:centos-4.0.2 \n</code></pre><p>最后需要在web端将，zabbix-agent添加到zabbix-server的host列表里面。    </p>\n<h4 id=\"启动Zabbix-Java-gateway实例-并关联到zabbix-server\"><a href=\"#启动Zabbix-Java-gateway实例-并关联到zabbix-server\" class=\"headerlink\" title=\"启动Zabbix Java gateway实例,并关联到zabbix-server\"></a>启动Zabbix Java gateway实例,并关联到zabbix-server</h4><p>用于监控jvm/tomcat性能。<br>Zabbix监控Java应用程序的关键点在于：配置Zabbix-JavaGateway、让Zabbix-Server能够连接Zabbix-JavaGateway、Tomcat开启JVM远程监控功能等。</p>\n<pre><code>docker run --name zabbix-java-gateway --link zabbix-server-mysql:zabbix-server -d zabbix/zabbix-java-gateway:latest\n</code></pre><h2 id=\"安装Jenkins\"><a href=\"#安装Jenkins\" class=\"headerlink\" title=\"安装Jenkins\"></a>安装Jenkins</h2><p>####　配置日志：   </p>\n<pre><code>[root@ymu /]# mkdir -p /server/data/jenkins\n[root@ymu /]# cd /server/data/jenkins\n[root@ymu jenkins]# touch log.properties\n[root@ymu jenkins]# cat &gt; log.properties &lt;&lt;EOF\n&gt; handlers=java.util.logging.ConsoleHandler\n&gt; jenkins.level=FINEST\n&gt; java.util.logging.ConsoleHandler.level=FINEST\n&gt; EOF\n</code></pre><h4 id=\"启动jenkins服务\"><a href=\"#启动jenkins服务\" class=\"headerlink\" title=\"启动jenkins服务\"></a>启动jenkins服务</h4><p>参考：<a href=\"https://github.com/jenkinsci/docker/blob/master/README.md\" target=\"_blank\" rel=\"noopener\">https://github.com/jenkinsci/docker/blob/master/README.md</a></p>\n<p>首先，要对文件夹赋予权限：<br>查看文件夹权限：`</p>\n<pre><code>[root@xr-server jenkins]# ls -l /server/data/jenkins/\ntotal 4\n-rw-r--r--. 1 root root 109 Dec 17 00:55 log.properties\n</code></pre><p>赋予文件夹权限：    </p>\n<pre><code>chown -R 1000:1000 /server/data/jenkins/    \n</code></pre><p>启动容器：</p>\n<pre><code>docker run --name ymu-jenkins -p 3001:8080 -p 50000:50000 --env JAVA_OPTS=&quot;-Djava.util.logging.config.file=/var/jenkins_home/log.properties&quot; -v /server/data/jenkins:/var/jenkins_home -d jenkins/jenkins:lts\n</code></pre><p>lts：长期支持版本<br>以上启动的容器安装Locale插件后，也只能部分中文，原因：未知……</p>\n<p>说明： </p>\n<ul>\n<li>-v 会把容器目录<code>/var/jenkins_home</code>映射到主机<code>/server/data/jenkins</code> </li>\n</ul>\n<h4 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h4><p>打开浏览器输入：local:3001</p>\n<p>如果看到要求获取登录密码的界面，则成功。恭喜……</p>\n<p>获取登录初始密码：   </p>\n<pre><code>[root@ymu secrets]# pwd\n/server/data/jenkins/secrets\n[root@ymu secrets]# cat initialAdminPassword \n8ccac67d98dd4c77a2c09870e8246e5d\n[root@ymu secrets]#\n</code></pre><p>其它的如和maven的集成等，参考以前文档。  </p>\n<h4 id=\"使用Nginx做方向代理\"><a href=\"#使用Nginx做方向代理\" class=\"headerlink\" title=\"使用Nginx做方向代理\"></a>使用Nginx做方向代理</h4><p>坑，坑，坑……</p>\n<p>一开始按一般的nginx方向代理配置，负载均衡配置，都不行，页面打开异常的慢……</p>\n<p>各种百度，不行。还好，想起了google大神……结果找到了：  </p>\n<p><a href=\"https://wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx\" target=\"_blank\" rel=\"noopener\">https://wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx</a></p>\n<p>还是官方文档有用，以后遇到这种问题，都先到官方wiki上找答案才对。<br>重新配置：</p>\n<pre><code>upstream jenkins {\n  keepalive 32; # keepalive connections\n  server 127.0.0.1:9000; # jenkins ip and port\n}\n\nserver {\n  listen          80;       # Listen on port 80 for IPv4 requests\n\n  server_name     ci.xcsqjr.com;\n\n  #this is the jenkins web root directory (mentioned in the /etc/default/jenkins file)\n  root            /server/data/jenkins/war;\n\n  access_log      /server/java/nginx/logs/ci.xcsqjr.com.access.log;\n  error_log       /server/java/nginx/logs/ci.xcsqjr.com.error.log;\n  ignore_invalid_headers off; #pass through headers from Jenkins which are considered invalid by Nginx server.\n\n  location ~ &quot;^/static/[0-9a-fA-F]{8}\\/(.*)$&quot; {\n    #rewrite all static files into requests to the root\n    #E.g /static/12345678/css/something.css will become /css/something.css\n    rewrite &quot;^/static/[0-9a-fA-F]{8}\\/(.*)&quot; /$1 last;\n  }\n\n  location /userContent {\n    #have nginx handle all the static requests to the userContent folder files\n    #note : This is the $JENKINS_HOME dir\n    root /server/data/jenkins/war;\n    if (!-f $request_filename){\n      #this file does not exist, might be a directory or a /**view** url\n      rewrite (.*) /$1 last;\n      break;\n    }\n    sendfile on;\n  }\n\n  location / {\n      sendfile off;\n      proxy_pass         http://jenkins;\n      proxy_redirect     default;\n      proxy_http_version 1.1;\n\n      proxy_set_header   Host              $host;\n      proxy_set_header   X-Real-IP         $remote_addr;\n      proxy_set_header   X-Forwarded-For   $proxy_add_x_forwarded_for;\n      proxy_set_header   X-Forwarded-Proto $scheme;\n      proxy_max_temp_file_size 0;\n\n      #this is the maximum upload size\n      client_max_body_size       10m;\n      client_body_buffer_size    128k;\n\n      proxy_connect_timeout      90;\n      proxy_send_timeout         90;\n      proxy_read_timeout         90;\n      proxy_buffering            off;\n      #proxy_request_buffering    off; # Required for HTTP CLI commands in Jenkins &gt; 2.54\n      proxy_set_header Connection &quot;&quot;; # Clear for keepalive\n  }\n\n}\n</code></pre><p>注意：按上面docker安装jenkins的时候，映射了数据卷，所以可以知道：<code>server/data/jenkins/war</code> 为jenkins的web根目录。注意配置好。</p>\n<h2 id=\"安装gitlab\"><a href=\"#安装gitlab\" class=\"headerlink\" title=\"安装gitlab\"></a>安装gitlab</h2><p>参考网址：<a href=\"https://docs.gitlab.com/omnibus/docker/\" target=\"_blank\" rel=\"noopener\">https://docs.gitlab.com/omnibus/docker/</a></p>\n<h2 id=\"安装sonatype-nexus\"><a href=\"#安装sonatype-nexus\" class=\"headerlink\" title=\"安装sonatype/nexus\"></a>安装sonatype/nexus</h2><p>参考网址：<br><a href=\"https://hub.docker.com/r/sonatype/nexus\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/r/sonatype/nexus</a> </p>\n<p>1.初始持久化数据目录</p>\n<pre><code># mkdir /server/data/nexus/data &amp;&amp; chown -R 200 /server/data/nexus/data\n\n# docker run -d -p 8084:8081 --name nexus -e MAX_HEAP=768m  -v /server/data/nexus/data:/sonatype-work sonatype/nexus    \n</code></pre><p>2.查看启动日志</p>\n<pre><code>docker logs -f nexus\n</code></pre><p>3.默认账号密码：</p>\n<pre><code>admin / admin123        \n</code></pre><p>4.浏览器浏览：</p>\n<pre><code>http://ip:8084/nexus\n</code></pre><h3 id=\"安装sonatype-nexus3-兼容maven依赖和docker-register（推荐生产使用）\"><a href=\"#安装sonatype-nexus3-兼容maven依赖和docker-register（推荐生产使用）\" class=\"headerlink\" title=\"安装sonatype/nexus3,兼容maven依赖和docker register（推荐生产使用）\"></a>安装sonatype/nexus3,兼容maven依赖和docker register（推荐生产使用）</h3><p>网址：<a href=\"https://github.com/sonatype/docker-nexus3\" target=\"_blank\" rel=\"noopener\">https://github.com/sonatype/docker-nexus3</a></p>\n<p>1.创建映射卷并启动实例</p>\n<pre><code># mkdir -p /server/data/nexus3-data &amp;&amp; chown -R 200 /server/data/nexus3-data\n\n# docker run  -p 8085:8081 -p 8082:8082 -p 8083:8083 --name nexus3 --restart=always -v /server/data/nexus3-data:/nexus-data  -d sonatype/nexus3\n</code></pre><p>2.查看启动日志：</p>\n<pre><code>docker logs -f nexus    \n</code></pre><p>3.测试是否安装成功：</p>\n<pre><code>curl -u admin:admin123 http://localhost:8085/service/metrics/ping  \n</code></pre><p>4.打开浏览器浏览：</p>\n<p> 网址：<a href=\"http://ip:8085\" target=\"_blank\" rel=\"noopener\">http://ip:8085</a></p>\n<p> 默认账号密码：admin admin123</p>\n"},{"title":"Docker Compose常用命令","date":"2018-08-01T12:33:33.000Z","_content":"\n本节讨论Compose的一些常用命令。\n\n## Compose命令说明\n\n执行`docker-compose [COMMAND] --help` 查看具体某个命令的使用说明。\n\n选项: \n- --verbose 输出更多调试信息。   \n- --version 打印版本并退出。\n- -f, --file FILE 使用特定的 compose 模板文件，默认为 docker-compose.yml 。\n- -p, --project-name NAME 指定项目名称，默认使用目录名称。\n\n## 命令\n\n### build\n\n用于构建或重新构建服务。\n\n服务一旦构建后，将会带上一个标记名，例如 web_db。\n\n可以随时在项目目录下运行 docker-compose build 来重新构建服务。\n        \n### help\n\n获得一个命令的帮助。`docker compose --help`\n\n### kill\n\n通过发送 SIGKILL 信号来强制停止服务容器。支持通过参数来指定发送的信号，例如\n\n    $ docker-compose kill -s SIGINT\n    \n### logs\n\n查看服务的输出。`docker-compose logs`\n\n### port\n\n打印绑定的公共端口。\n\n### ps\n\n列出所有容器。\n\n进入compose工程目录，执行下面命令：\n\n    [root@izwz9guplfsq8ltfk0wnjiz ELK]# docker-compose ps\n           Name                      Command               State                                Ports                              \n    -------------------------------------------------------------------------------------------------------------------------------\n    elk_elasticsearch_1   /usr/local/bin/docker-entr ...   Up      0.0.0.0:9200->9200/tcp, 0.0.0.0:9300->9300/tcp                  \n    elk_kibana_1          /usr/local/bin/dumb-init - ...   Up      0.0.0.0:5601->5601/tcp                                          \n    elk_logstash_1        /usr/local/bin/docker-entr ...   Up      0.0.0.0:5000->5000/tcp, 5044/tcp, 0.0.0.0:8088->8088/tcp,       \n                                                                   9600/tcp            \n### pull\n\n拉取服务镜像。\n\n### rm\n\n删除停止的服务容器。\n\n### run\n\n在一个服务上执行一个命令。`docker-compose run ubuntu ping docker.com`\n\n将会启动一个 ubuntu 服务，执行 ping docker.com 命令。    \n\n如果不希望自动启动关联的容器，可以使用 --no-deps 选项，例如\n\n    $ docker-compose run --no-deps web python manage.py shell\n    \n将不会启动 web 容器所关联的其它容器。  \n\n说明：\n\n- 给定命令将会覆盖原有的自动运行命令；\n- 不会自动创建端口，以避免冲突。\n\n### scale\n\n设置同一个服务运行的容器个数。    \n\n    $ docker-compose scale web=2 worker=3\n    \n###  start\n\n启动一个已经存在的服务容器。\n\n### stop\n\n停止一个已经运行的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。\n\n### up\n\n构建，（重新）创建，启动，链接一个服务相关的容器。\n\n定义的服务都将会按照顺序启动，除非它们已经在运行。\n\n默认情况下，`docker-compose up`将会整合所有容器的输出，前台运行，退出的时候，所有容器将停止运行。\n\n如果使用`docker-compose up -d`,将会在后台启动并运行所有的程序。\n\n>默认情况下，如果该服务的容器已经存在，`docker-compose up`将会停止所有容器并尝试重新创建容器（保持使用volumes-from挂载的卷），以保证`docker-compose.yml`的修改生效。如果你不想容器被停止并重新创建，那么可以使用`docker-compose up --no-recreate`,这样将会启动已经停止的容器。\n\n                                                            \n                                                                   \n            \n","source":"_posts/docker-compose-command.md","raw":"---\ntitle: Docker Compose常用命令\ndate: 2018-08-01 20:33:33\ncategories: docker\ntags:\n---\n\n本节讨论Compose的一些常用命令。\n\n## Compose命令说明\n\n执行`docker-compose [COMMAND] --help` 查看具体某个命令的使用说明。\n\n选项: \n- --verbose 输出更多调试信息。   \n- --version 打印版本并退出。\n- -f, --file FILE 使用特定的 compose 模板文件，默认为 docker-compose.yml 。\n- -p, --project-name NAME 指定项目名称，默认使用目录名称。\n\n## 命令\n\n### build\n\n用于构建或重新构建服务。\n\n服务一旦构建后，将会带上一个标记名，例如 web_db。\n\n可以随时在项目目录下运行 docker-compose build 来重新构建服务。\n        \n### help\n\n获得一个命令的帮助。`docker compose --help`\n\n### kill\n\n通过发送 SIGKILL 信号来强制停止服务容器。支持通过参数来指定发送的信号，例如\n\n    $ docker-compose kill -s SIGINT\n    \n### logs\n\n查看服务的输出。`docker-compose logs`\n\n### port\n\n打印绑定的公共端口。\n\n### ps\n\n列出所有容器。\n\n进入compose工程目录，执行下面命令：\n\n    [root@izwz9guplfsq8ltfk0wnjiz ELK]# docker-compose ps\n           Name                      Command               State                                Ports                              \n    -------------------------------------------------------------------------------------------------------------------------------\n    elk_elasticsearch_1   /usr/local/bin/docker-entr ...   Up      0.0.0.0:9200->9200/tcp, 0.0.0.0:9300->9300/tcp                  \n    elk_kibana_1          /usr/local/bin/dumb-init - ...   Up      0.0.0.0:5601->5601/tcp                                          \n    elk_logstash_1        /usr/local/bin/docker-entr ...   Up      0.0.0.0:5000->5000/tcp, 5044/tcp, 0.0.0.0:8088->8088/tcp,       \n                                                                   9600/tcp            \n### pull\n\n拉取服务镜像。\n\n### rm\n\n删除停止的服务容器。\n\n### run\n\n在一个服务上执行一个命令。`docker-compose run ubuntu ping docker.com`\n\n将会启动一个 ubuntu 服务，执行 ping docker.com 命令。    \n\n如果不希望自动启动关联的容器，可以使用 --no-deps 选项，例如\n\n    $ docker-compose run --no-deps web python manage.py shell\n    \n将不会启动 web 容器所关联的其它容器。  \n\n说明：\n\n- 给定命令将会覆盖原有的自动运行命令；\n- 不会自动创建端口，以避免冲突。\n\n### scale\n\n设置同一个服务运行的容器个数。    \n\n    $ docker-compose scale web=2 worker=3\n    \n###  start\n\n启动一个已经存在的服务容器。\n\n### stop\n\n停止一个已经运行的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。\n\n### up\n\n构建，（重新）创建，启动，链接一个服务相关的容器。\n\n定义的服务都将会按照顺序启动，除非它们已经在运行。\n\n默认情况下，`docker-compose up`将会整合所有容器的输出，前台运行，退出的时候，所有容器将停止运行。\n\n如果使用`docker-compose up -d`,将会在后台启动并运行所有的程序。\n\n>默认情况下，如果该服务的容器已经存在，`docker-compose up`将会停止所有容器并尝试重新创建容器（保持使用volumes-from挂载的卷），以保证`docker-compose.yml`的修改生效。如果你不想容器被停止并重新创建，那么可以使用`docker-compose up --no-recreate`,这样将会启动已经停止的容器。\n\n                                                            \n                                                                   \n            \n","slug":"docker-compose-command","published":1,"updated":"2019-09-12T16:18:24.844Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqax001qg4va8ok85sqt","content":"<p>本节讨论Compose的一些常用命令。</p>\n<h2 id=\"Compose命令说明\"><a href=\"#Compose命令说明\" class=\"headerlink\" title=\"Compose命令说明\"></a>Compose命令说明</h2><p>执行<code>docker-compose [COMMAND] --help</code> 查看具体某个命令的使用说明。</p>\n<p>选项: </p>\n<ul>\n<li>–verbose 输出更多调试信息。   </li>\n<li>–version 打印版本并退出。</li>\n<li>-f, –file FILE 使用特定的 compose 模板文件，默认为 docker-compose.yml 。</li>\n<li>-p, –project-name NAME 指定项目名称，默认使用目录名称。</li>\n</ul>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><h3 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h3><p>用于构建或重新构建服务。</p>\n<p>服务一旦构建后，将会带上一个标记名，例如 web_db。</p>\n<p>可以随时在项目目录下运行 docker-compose build 来重新构建服务。</p>\n<h3 id=\"help\"><a href=\"#help\" class=\"headerlink\" title=\"help\"></a>help</h3><p>获得一个命令的帮助。<code>docker compose --help</code></p>\n<h3 id=\"kill\"><a href=\"#kill\" class=\"headerlink\" title=\"kill\"></a>kill</h3><p>通过发送 SIGKILL 信号来强制停止服务容器。支持通过参数来指定发送的信号，例如</p>\n<pre><code>$ docker-compose kill -s SIGINT\n</code></pre><h3 id=\"logs\"><a href=\"#logs\" class=\"headerlink\" title=\"logs\"></a>logs</h3><p>查看服务的输出。<code>docker-compose logs</code></p>\n<h3 id=\"port\"><a href=\"#port\" class=\"headerlink\" title=\"port\"></a>port</h3><p>打印绑定的公共端口。</p>\n<h3 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h3><p>列出所有容器。</p>\n<p>进入compose工程目录，执行下面命令：</p>\n<pre><code>[root@izwz9guplfsq8ltfk0wnjiz ELK]# docker-compose ps\n       Name                      Command               State                                Ports                              \n-------------------------------------------------------------------------------------------------------------------------------\nelk_elasticsearch_1   /usr/local/bin/docker-entr ...   Up      0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp                  \nelk_kibana_1          /usr/local/bin/dumb-init - ...   Up      0.0.0.0:5601-&gt;5601/tcp                                          \nelk_logstash_1        /usr/local/bin/docker-entr ...   Up      0.0.0.0:5000-&gt;5000/tcp, 5044/tcp, 0.0.0.0:8088-&gt;8088/tcp,       \n                                                               9600/tcp            \n</code></pre><h3 id=\"pull\"><a href=\"#pull\" class=\"headerlink\" title=\"pull\"></a>pull</h3><p>拉取服务镜像。</p>\n<h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><p>删除停止的服务容器。</p>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>在一个服务上执行一个命令。<code>docker-compose run ubuntu ping docker.com</code></p>\n<p>将会启动一个 ubuntu 服务，执行 ping docker.com 命令。    </p>\n<p>如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如</p>\n<pre><code>$ docker-compose run --no-deps web python manage.py shell\n</code></pre><p>将不会启动 web 容器所关联的其它容器。  </p>\n<p>说明：</p>\n<ul>\n<li>给定命令将会覆盖原有的自动运行命令；</li>\n<li>不会自动创建端口，以避免冲突。</li>\n</ul>\n<h3 id=\"scale\"><a href=\"#scale\" class=\"headerlink\" title=\"scale\"></a>scale</h3><p>设置同一个服务运行的容器个数。    </p>\n<pre><code>$ docker-compose scale web=2 worker=3\n</code></pre><h3 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h3><p>启动一个已经存在的服务容器。</p>\n<h3 id=\"stop\"><a href=\"#stop\" class=\"headerlink\" title=\"stop\"></a>stop</h3><p>停止一个已经运行的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。</p>\n<h3 id=\"up\"><a href=\"#up\" class=\"headerlink\" title=\"up\"></a>up</h3><p>构建，（重新）创建，启动，链接一个服务相关的容器。</p>\n<p>定义的服务都将会按照顺序启动，除非它们已经在运行。</p>\n<p>默认情况下，<code>docker-compose up</code>将会整合所有容器的输出，前台运行，退出的时候，所有容器将停止运行。</p>\n<p>如果使用<code>docker-compose up -d</code>,将会在后台启动并运行所有的程序。</p>\n<blockquote>\n<p>默认情况下，如果该服务的容器已经存在，<code>docker-compose up</code>将会停止所有容器并尝试重新创建容器（保持使用volumes-from挂载的卷），以保证<code>docker-compose.yml</code>的修改生效。如果你不想容器被停止并重新创建，那么可以使用<code>docker-compose up --no-recreate</code>,这样将会启动已经停止的容器。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>本节讨论Compose的一些常用命令。</p>\n<h2 id=\"Compose命令说明\"><a href=\"#Compose命令说明\" class=\"headerlink\" title=\"Compose命令说明\"></a>Compose命令说明</h2><p>执行<code>docker-compose [COMMAND] --help</code> 查看具体某个命令的使用说明。</p>\n<p>选项: </p>\n<ul>\n<li>–verbose 输出更多调试信息。   </li>\n<li>–version 打印版本并退出。</li>\n<li>-f, –file FILE 使用特定的 compose 模板文件，默认为 docker-compose.yml 。</li>\n<li>-p, –project-name NAME 指定项目名称，默认使用目录名称。</li>\n</ul>\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><h3 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h3><p>用于构建或重新构建服务。</p>\n<p>服务一旦构建后，将会带上一个标记名，例如 web_db。</p>\n<p>可以随时在项目目录下运行 docker-compose build 来重新构建服务。</p>\n<h3 id=\"help\"><a href=\"#help\" class=\"headerlink\" title=\"help\"></a>help</h3><p>获得一个命令的帮助。<code>docker compose --help</code></p>\n<h3 id=\"kill\"><a href=\"#kill\" class=\"headerlink\" title=\"kill\"></a>kill</h3><p>通过发送 SIGKILL 信号来强制停止服务容器。支持通过参数来指定发送的信号，例如</p>\n<pre><code>$ docker-compose kill -s SIGINT\n</code></pre><h3 id=\"logs\"><a href=\"#logs\" class=\"headerlink\" title=\"logs\"></a>logs</h3><p>查看服务的输出。<code>docker-compose logs</code></p>\n<h3 id=\"port\"><a href=\"#port\" class=\"headerlink\" title=\"port\"></a>port</h3><p>打印绑定的公共端口。</p>\n<h3 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h3><p>列出所有容器。</p>\n<p>进入compose工程目录，执行下面命令：</p>\n<pre><code>[root@izwz9guplfsq8ltfk0wnjiz ELK]# docker-compose ps\n       Name                      Command               State                                Ports                              \n-------------------------------------------------------------------------------------------------------------------------------\nelk_elasticsearch_1   /usr/local/bin/docker-entr ...   Up      0.0.0.0:9200-&gt;9200/tcp, 0.0.0.0:9300-&gt;9300/tcp                  \nelk_kibana_1          /usr/local/bin/dumb-init - ...   Up      0.0.0.0:5601-&gt;5601/tcp                                          \nelk_logstash_1        /usr/local/bin/docker-entr ...   Up      0.0.0.0:5000-&gt;5000/tcp, 5044/tcp, 0.0.0.0:8088-&gt;8088/tcp,       \n                                                               9600/tcp            \n</code></pre><h3 id=\"pull\"><a href=\"#pull\" class=\"headerlink\" title=\"pull\"></a>pull</h3><p>拉取服务镜像。</p>\n<h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><p>删除停止的服务容器。</p>\n<h3 id=\"run\"><a href=\"#run\" class=\"headerlink\" title=\"run\"></a>run</h3><p>在一个服务上执行一个命令。<code>docker-compose run ubuntu ping docker.com</code></p>\n<p>将会启动一个 ubuntu 服务，执行 ping docker.com 命令。    </p>\n<p>如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如</p>\n<pre><code>$ docker-compose run --no-deps web python manage.py shell\n</code></pre><p>将不会启动 web 容器所关联的其它容器。  </p>\n<p>说明：</p>\n<ul>\n<li>给定命令将会覆盖原有的自动运行命令；</li>\n<li>不会自动创建端口，以避免冲突。</li>\n</ul>\n<h3 id=\"scale\"><a href=\"#scale\" class=\"headerlink\" title=\"scale\"></a>scale</h3><p>设置同一个服务运行的容器个数。    </p>\n<pre><code>$ docker-compose scale web=2 worker=3\n</code></pre><h3 id=\"start\"><a href=\"#start\" class=\"headerlink\" title=\"start\"></a>start</h3><p>启动一个已经存在的服务容器。</p>\n<h3 id=\"stop\"><a href=\"#stop\" class=\"headerlink\" title=\"stop\"></a>stop</h3><p>停止一个已经运行的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。</p>\n<h3 id=\"up\"><a href=\"#up\" class=\"headerlink\" title=\"up\"></a>up</h3><p>构建，（重新）创建，启动，链接一个服务相关的容器。</p>\n<p>定义的服务都将会按照顺序启动，除非它们已经在运行。</p>\n<p>默认情况下，<code>docker-compose up</code>将会整合所有容器的输出，前台运行，退出的时候，所有容器将停止运行。</p>\n<p>如果使用<code>docker-compose up -d</code>,将会在后台启动并运行所有的程序。</p>\n<blockquote>\n<p>默认情况下，如果该服务的容器已经存在，<code>docker-compose up</code>将会停止所有容器并尝试重新创建容器（保持使用volumes-from挂载的卷），以保证<code>docker-compose.yml</code>的修改生效。如果你不想容器被停止并重新创建，那么可以使用<code>docker-compose up --no-recreate</code>,这样将会启动已经停止的容器。</p>\n</blockquote>\n"},{"title":"docker常用命令收藏","date":"2019-01-03T06:31:42.000Z","_content":"\n## 容器\n\n#### 查看容器端口映射\n\n    [root@sqjr-client-demo-server1-hn zookeeper]# docker port zk-server1\n    2181/tcp -> 0.0.0.0:2181\n    2888/tcp -> 0.0.0.0:2888\n    3888/tcp -> 0.0.0.0:3888\n    \n#### 强制删除运行中的容器\n\n    docker rm -f 容器名称    \n    \n#### 拷贝本地文件到容器\n\n    docker cp 本地文件路径 ID全称:容器路径  \n    \n#### 删除所有容器\n\n    docker rm `docker ps -a -q`\n    \n    //运行中的也删除\n    docker rm -f `docker ps -a -q`\n    \n#### 按条件筛选之后删除容器\n\n    docker rm `docker ps -a | grep xxxxx | awk '{print $1}'`    \n    \n## 镜像\n\n#### 删除所有镜像\n\n    docker rmi `docker images -q`\n    \n#### 按条件删除镜像\n\n1.没有打标签     \n\n    docker rmi `docker images -q | awk '/^<none>/ { print $3 }'`\n    \n2.镜像名包含关键字\n\n    docker rmi --force `docker images | grep doss-api | awk '{print $3}'`    //其中doss-api为关键字 \n    \n3.删除所有none镜像\n\n    docker rmi `docker images | grep  \"<none>\" | awk '{print $3}'`                ","source":"_posts/docker-commond-collect.md","raw":"---\ntitle: docker常用命令收藏\ndate: 2019-01-03 14:31:42\ncategories: docker\ntags:\n---\n\n## 容器\n\n#### 查看容器端口映射\n\n    [root@sqjr-client-demo-server1-hn zookeeper]# docker port zk-server1\n    2181/tcp -> 0.0.0.0:2181\n    2888/tcp -> 0.0.0.0:2888\n    3888/tcp -> 0.0.0.0:3888\n    \n#### 强制删除运行中的容器\n\n    docker rm -f 容器名称    \n    \n#### 拷贝本地文件到容器\n\n    docker cp 本地文件路径 ID全称:容器路径  \n    \n#### 删除所有容器\n\n    docker rm `docker ps -a -q`\n    \n    //运行中的也删除\n    docker rm -f `docker ps -a -q`\n    \n#### 按条件筛选之后删除容器\n\n    docker rm `docker ps -a | grep xxxxx | awk '{print $1}'`    \n    \n## 镜像\n\n#### 删除所有镜像\n\n    docker rmi `docker images -q`\n    \n#### 按条件删除镜像\n\n1.没有打标签     \n\n    docker rmi `docker images -q | awk '/^<none>/ { print $3 }'`\n    \n2.镜像名包含关键字\n\n    docker rmi --force `docker images | grep doss-api | awk '{print $3}'`    //其中doss-api为关键字 \n    \n3.删除所有none镜像\n\n    docker rmi `docker images | grep  \"<none>\" | awk '{print $3}'`                ","slug":"docker-commond-collect","published":1,"updated":"2019-11-10T14:27:50.789Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqaz001sg4vaoaj3fwnw","content":"<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><h4 id=\"查看容器端口映射\"><a href=\"#查看容器端口映射\" class=\"headerlink\" title=\"查看容器端口映射\"></a>查看容器端口映射</h4><pre><code>[root@sqjr-client-demo-server1-hn zookeeper]# docker port zk-server1\n2181/tcp -&gt; 0.0.0.0:2181\n2888/tcp -&gt; 0.0.0.0:2888\n3888/tcp -&gt; 0.0.0.0:3888\n</code></pre><h4 id=\"强制删除运行中的容器\"><a href=\"#强制删除运行中的容器\" class=\"headerlink\" title=\"强制删除运行中的容器\"></a>强制删除运行中的容器</h4><pre><code>docker rm -f 容器名称    \n</code></pre><h4 id=\"拷贝本地文件到容器\"><a href=\"#拷贝本地文件到容器\" class=\"headerlink\" title=\"拷贝本地文件到容器\"></a>拷贝本地文件到容器</h4><pre><code>docker cp 本地文件路径 ID全称:容器路径  \n</code></pre><h4 id=\"删除所有容器\"><a href=\"#删除所有容器\" class=\"headerlink\" title=\"删除所有容器\"></a>删除所有容器</h4><pre><code>docker rm `docker ps -a -q`\n\n//运行中的也删除\ndocker rm -f `docker ps -a -q`\n</code></pre><h4 id=\"按条件筛选之后删除容器\"><a href=\"#按条件筛选之后删除容器\" class=\"headerlink\" title=\"按条件筛选之后删除容器\"></a>按条件筛选之后删除容器</h4><pre><code>docker rm `docker ps -a | grep xxxxx | awk &apos;{print $1}&apos;`    \n</code></pre><h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><h4 id=\"删除所有镜像\"><a href=\"#删除所有镜像\" class=\"headerlink\" title=\"删除所有镜像\"></a>删除所有镜像</h4><pre><code>docker rmi `docker images -q`\n</code></pre><h4 id=\"按条件删除镜像\"><a href=\"#按条件删除镜像\" class=\"headerlink\" title=\"按条件删除镜像\"></a>按条件删除镜像</h4><p>1.没有打标签     </p>\n<pre><code>docker rmi `docker images -q | awk &apos;/^&lt;none&gt;/ { print $3 }&apos;`\n</code></pre><p>2.镜像名包含关键字</p>\n<pre><code>docker rmi --force `docker images | grep doss-api | awk &apos;{print $3}&apos;`    //其中doss-api为关键字 \n</code></pre><p>3.删除所有none镜像</p>\n<pre><code>docker rmi `docker images | grep  &quot;&lt;none&gt;&quot; | awk &apos;{print $3}&apos;`                \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><h4 id=\"查看容器端口映射\"><a href=\"#查看容器端口映射\" class=\"headerlink\" title=\"查看容器端口映射\"></a>查看容器端口映射</h4><pre><code>[root@sqjr-client-demo-server1-hn zookeeper]# docker port zk-server1\n2181/tcp -&gt; 0.0.0.0:2181\n2888/tcp -&gt; 0.0.0.0:2888\n3888/tcp -&gt; 0.0.0.0:3888\n</code></pre><h4 id=\"强制删除运行中的容器\"><a href=\"#强制删除运行中的容器\" class=\"headerlink\" title=\"强制删除运行中的容器\"></a>强制删除运行中的容器</h4><pre><code>docker rm -f 容器名称    \n</code></pre><h4 id=\"拷贝本地文件到容器\"><a href=\"#拷贝本地文件到容器\" class=\"headerlink\" title=\"拷贝本地文件到容器\"></a>拷贝本地文件到容器</h4><pre><code>docker cp 本地文件路径 ID全称:容器路径  \n</code></pre><h4 id=\"删除所有容器\"><a href=\"#删除所有容器\" class=\"headerlink\" title=\"删除所有容器\"></a>删除所有容器</h4><pre><code>docker rm `docker ps -a -q`\n\n//运行中的也删除\ndocker rm -f `docker ps -a -q`\n</code></pre><h4 id=\"按条件筛选之后删除容器\"><a href=\"#按条件筛选之后删除容器\" class=\"headerlink\" title=\"按条件筛选之后删除容器\"></a>按条件筛选之后删除容器</h4><pre><code>docker rm `docker ps -a | grep xxxxx | awk &apos;{print $1}&apos;`    \n</code></pre><h2 id=\"镜像\"><a href=\"#镜像\" class=\"headerlink\" title=\"镜像\"></a>镜像</h2><h4 id=\"删除所有镜像\"><a href=\"#删除所有镜像\" class=\"headerlink\" title=\"删除所有镜像\"></a>删除所有镜像</h4><pre><code>docker rmi `docker images -q`\n</code></pre><h4 id=\"按条件删除镜像\"><a href=\"#按条件删除镜像\" class=\"headerlink\" title=\"按条件删除镜像\"></a>按条件删除镜像</h4><p>1.没有打标签     </p>\n<pre><code>docker rmi `docker images -q | awk &apos;/^&lt;none&gt;/ { print $3 }&apos;`\n</code></pre><p>2.镜像名包含关键字</p>\n<pre><code>docker rmi --force `docker images | grep doss-api | awk &apos;{print $3}&apos;`    //其中doss-api为关键字 \n</code></pre><p>3.删除所有none镜像</p>\n<pre><code>docker rmi `docker images | grep  &quot;&lt;none&gt;&quot; | awk &apos;{print $3}&apos;`                \n</code></pre>"},{"title":"docker-compose.yml常用命令","date":"2018-08-01T12:33:35.000Z","_content":"\n默认的模板文件是 docker-compose.yml ，其中定义的每个服务都必须通过 image 指令指定镜像或\nbuild 指令（需要 Dockerfile）来自动构建。\n\n## image\n\n指定为镜像名称或者id，如果本地没有该镜像，将会到配置的镜像仓库拉取该镜像。\n\n例如：\n\n    image: ubuntu\n    image: orchardup/postgresql\n    image: a4bc65fd\n    \n## build\n\n指定`Dockerfile`所在文件夹的路径。Compose将会利用它自动构建这个镜像，然后使用这个镜像。\n\n    build: /path/to/build/dir\n    \n也可以是一个对象，用于指定Dockerfile和参数，例如：\n\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n        \n## command\n\n覆盖容器启动后默认执行的命令。\n\n    command: bundle exec thin -p 3000\n    \n也可以是一个list，类似于Dockerfile中的CMD指令，格式如下：\n\n    command: [bundle, exec, thin, -p, 3000]\n    \n## links\n\n链接到其它服务中的容器。使用服务名称（同时作为别名）或服务名称：服务别名（SERVICE:ALIAS） 格\n式都可以。\n\n    links:\n    - db\n    - db:database\n    - redis\n    \n使用的别名将会自动在服务容器中的 /etc/hosts 里创建。例如：\n\n    172.17.2.186 db\n    172.17.2.186 database\n    172.17.2.187 redis\n    \n相应的环境变量也将被创建。\n\n## external_links\n\n链接到`docker-compose.yml`外部的容器，甚至并非Compose管理的容器。参数格式跟links类似。  \n\n    external_links:\n     - redis_1\n     - project_db_1:mysql\n     - project_db_1:postgresql\n     \n## ports\n\n暴露端口信息。\n\n使用宿主：容器（HOST:CONTAINER）格式或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。  \n\n需要注意的是，当使用HOST:CONTAINER 格式映射端口时，容器端口小于60将会得到错误的接口，因为yaml会把xx:yy 的数字解析为60进制。因此，建议使用字符串的形式。示例：\n\n    ports:\n     - \"3000\"\n     - \"3000-3005\"\n     - \"8000:8000\"\n     - \"9090-9091:8080-8081\"\n     - \"49100:22\"\n     - \"127.0.0.1:8001:8001\"\n     - \"127.0.0.1:5000-5010:5000-5010\"\n\n## expose\n\n暴露端口，但不映射到宿主机，只被连接的服务访问。\n\n    expose:\n     - \"3000\"\n     - \"8000\"\n     \n## volumes\n\n卷挂载路径设置。可以设置宿主机路径（HOST:CONTAINER） ，也可指定访问模式（HOST:CONTAINER:ro）。示例：\n     \n     volumes:\n       # Just specify a path and let the Engine create a volume\n       - /var/lib/mysql\n     \n       # Specify an absolute path mapping\n       - /opt/data:/var/lib/mysql\n     \n       # Path on the host, relative to the Compose file\n       - ./cache:/tmp/cache\n     \n       # User-relative path\n       - ~/configs:/etc/configs/:ro\n     \n       # Named volume\n       - datavolume:/var/lib/mysql\n       \n## volumes_from\n\n从另外一个服务或者容器挂载它的所有卷。 可指定只读（ro）或读写（rw），默认是读写（rw）。示例：\n\n    volumes_from:\n     - service_name\n     - service_name:ro\n     - container:container_name\n     - container:container_name:rw\n      \n## environment\n\n设置环境变量，可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。\n\n    environment:\n      RACK_ENV: development\n      SHOW: 'true'\n      SESSION_SECRET:\n    \n    environment:\n      - RACK_ENV=development\n      - SHOW=true\n      - SESSION_SECRET\n      \n## env_file\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果使用`docker-compose -f FILE`指定模板文件，则`env_file`中路径会基于模板文件路径。\n\n如果有变量和`environment`指令冲突，则以后者为准。即使用environment指定的环境变量会覆盖env_file指定的环境变量\n\n    env_file: .env\n    \n    env_file:\n      - ./common.env   # 共用\n      - ./apps/web.env # web用\n      - /opt/secrets.env # 密码用            \n\n## extends       \n\n          \n","source":"_posts/docker-compose-template-command.md","raw":"---\ntitle: docker-compose.yml常用命令\ndate: 2018-08-01 20:33:35\ncategories: docker\ntags:\n---\n\n默认的模板文件是 docker-compose.yml ，其中定义的每个服务都必须通过 image 指令指定镜像或\nbuild 指令（需要 Dockerfile）来自动构建。\n\n## image\n\n指定为镜像名称或者id，如果本地没有该镜像，将会到配置的镜像仓库拉取该镜像。\n\n例如：\n\n    image: ubuntu\n    image: orchardup/postgresql\n    image: a4bc65fd\n    \n## build\n\n指定`Dockerfile`所在文件夹的路径。Compose将会利用它自动构建这个镜像，然后使用这个镜像。\n\n    build: /path/to/build/dir\n    \n也可以是一个对象，用于指定Dockerfile和参数，例如：\n\n    build:\n      context: ./dir\n      dockerfile: Dockerfile-alternate\n      args:\n        buildno: 1\n        \n## command\n\n覆盖容器启动后默认执行的命令。\n\n    command: bundle exec thin -p 3000\n    \n也可以是一个list，类似于Dockerfile中的CMD指令，格式如下：\n\n    command: [bundle, exec, thin, -p, 3000]\n    \n## links\n\n链接到其它服务中的容器。使用服务名称（同时作为别名）或服务名称：服务别名（SERVICE:ALIAS） 格\n式都可以。\n\n    links:\n    - db\n    - db:database\n    - redis\n    \n使用的别名将会自动在服务容器中的 /etc/hosts 里创建。例如：\n\n    172.17.2.186 db\n    172.17.2.186 database\n    172.17.2.187 redis\n    \n相应的环境变量也将被创建。\n\n## external_links\n\n链接到`docker-compose.yml`外部的容器，甚至并非Compose管理的容器。参数格式跟links类似。  \n\n    external_links:\n     - redis_1\n     - project_db_1:mysql\n     - project_db_1:postgresql\n     \n## ports\n\n暴露端口信息。\n\n使用宿主：容器（HOST:CONTAINER）格式或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。  \n\n需要注意的是，当使用HOST:CONTAINER 格式映射端口时，容器端口小于60将会得到错误的接口，因为yaml会把xx:yy 的数字解析为60进制。因此，建议使用字符串的形式。示例：\n\n    ports:\n     - \"3000\"\n     - \"3000-3005\"\n     - \"8000:8000\"\n     - \"9090-9091:8080-8081\"\n     - \"49100:22\"\n     - \"127.0.0.1:8001:8001\"\n     - \"127.0.0.1:5000-5010:5000-5010\"\n\n## expose\n\n暴露端口，但不映射到宿主机，只被连接的服务访问。\n\n    expose:\n     - \"3000\"\n     - \"8000\"\n     \n## volumes\n\n卷挂载路径设置。可以设置宿主机路径（HOST:CONTAINER） ，也可指定访问模式（HOST:CONTAINER:ro）。示例：\n     \n     volumes:\n       # Just specify a path and let the Engine create a volume\n       - /var/lib/mysql\n     \n       # Specify an absolute path mapping\n       - /opt/data:/var/lib/mysql\n     \n       # Path on the host, relative to the Compose file\n       - ./cache:/tmp/cache\n     \n       # User-relative path\n       - ~/configs:/etc/configs/:ro\n     \n       # Named volume\n       - datavolume:/var/lib/mysql\n       \n## volumes_from\n\n从另外一个服务或者容器挂载它的所有卷。 可指定只读（ro）或读写（rw），默认是读写（rw）。示例：\n\n    volumes_from:\n     - service_name\n     - service_name:ro\n     - container:container_name\n     - container:container_name:rw\n      \n## environment\n\n设置环境变量，可以使用数组或字典两种格式。\n\n只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。\n\n    environment:\n      RACK_ENV: development\n      SHOW: 'true'\n      SESSION_SECRET:\n    \n    environment:\n      - RACK_ENV=development\n      - SHOW=true\n      - SESSION_SECRET\n      \n## env_file\n\n从文件中获取环境变量，可以为单独的文件路径或列表。\n\n如果使用`docker-compose -f FILE`指定模板文件，则`env_file`中路径会基于模板文件路径。\n\n如果有变量和`environment`指令冲突，则以后者为准。即使用environment指定的环境变量会覆盖env_file指定的环境变量\n\n    env_file: .env\n    \n    env_file:\n      - ./common.env   # 共用\n      - ./apps/web.env # web用\n      - /opt/secrets.env # 密码用            \n\n## extends       \n\n          \n","slug":"docker-compose-template-command","published":1,"updated":"2019-09-22T00:56:27.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqb0001wg4vavgte12zs","content":"<p>默认的模板文件是 docker-compose.yml ，其中定义的每个服务都必须通过 image 指令指定镜像或<br>build 指令（需要 Dockerfile）来自动构建。</p>\n<h2 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h2><p>指定为镜像名称或者id，如果本地没有该镜像，将会到配置的镜像仓库拉取该镜像。</p>\n<p>例如：</p>\n<pre><code>image: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n</code></pre><h2 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h2><p>指定<code>Dockerfile</code>所在文件夹的路径。Compose将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre><code>build: /path/to/build/dir\n</code></pre><p>也可以是一个对象，用于指定Dockerfile和参数，例如：</p>\n<pre><code>build:\n  context: ./dir\n  dockerfile: Dockerfile-alternate\n  args:\n    buildno: 1\n</code></pre><h2 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h2><p>覆盖容器启动后默认执行的命令。</p>\n<pre><code>command: bundle exec thin -p 3000\n</code></pre><p>也可以是一个list，类似于Dockerfile中的CMD指令，格式如下：</p>\n<pre><code>command: [bundle, exec, thin, -p, 3000]\n</code></pre><h2 id=\"links\"><a href=\"#links\" class=\"headerlink\" title=\"links\"></a>links</h2><p>链接到其它服务中的容器。使用服务名称（同时作为别名）或服务名称：服务别名（SERVICE:ALIAS） 格<br>式都可以。</p>\n<pre><code>links:\n- db\n- db:database\n- redis\n</code></pre><p>使用的别名将会自动在服务容器中的 /etc/hosts 里创建。例如：</p>\n<pre><code>172.17.2.186 db\n172.17.2.186 database\n172.17.2.187 redis\n</code></pre><p>相应的环境变量也将被创建。</p>\n<h2 id=\"external-links\"><a href=\"#external-links\" class=\"headerlink\" title=\"external_links\"></a>external_links</h2><p>链接到<code>docker-compose.yml</code>外部的容器，甚至并非Compose管理的容器。参数格式跟links类似。  </p>\n<pre><code>external_links:\n - redis_1\n - project_db_1:mysql\n - project_db_1:postgresql\n</code></pre><h2 id=\"ports\"><a href=\"#ports\" class=\"headerlink\" title=\"ports\"></a>ports</h2><p>暴露端口信息。</p>\n<p>使用宿主：容器（HOST:CONTAINER）格式或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。  </p>\n<p>需要注意的是，当使用HOST:CONTAINER 格式映射端口时，容器端口小于60将会得到错误的接口，因为yaml会把xx:yy 的数字解析为60进制。因此，建议使用字符串的形式。示例：</p>\n<pre><code>ports:\n - &quot;3000&quot;\n - &quot;3000-3005&quot;\n - &quot;8000:8000&quot;\n - &quot;9090-9091:8080-8081&quot;\n - &quot;49100:22&quot;\n - &quot;127.0.0.1:8001:8001&quot;\n - &quot;127.0.0.1:5000-5010:5000-5010&quot;\n</code></pre><h2 id=\"expose\"><a href=\"#expose\" class=\"headerlink\" title=\"expose\"></a>expose</h2><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>\n<pre><code>expose:\n - &quot;3000&quot;\n - &quot;8000&quot;\n</code></pre><h2 id=\"volumes\"><a href=\"#volumes\" class=\"headerlink\" title=\"volumes\"></a>volumes</h2><p>卷挂载路径设置。可以设置宿主机路径（HOST:CONTAINER） ，也可指定访问模式（HOST:CONTAINER:ro）。示例：</p>\n<pre><code>volumes:\n  # Just specify a path and let the Engine create a volume\n  - /var/lib/mysql\n\n  # Specify an absolute path mapping\n  - /opt/data:/var/lib/mysql\n\n  # Path on the host, relative to the Compose file\n  - ./cache:/tmp/cache\n\n  # User-relative path\n  - ~/configs:/etc/configs/:ro\n\n  # Named volume\n  - datavolume:/var/lib/mysql\n</code></pre><h2 id=\"volumes-from\"><a href=\"#volumes-from\" class=\"headerlink\" title=\"volumes_from\"></a>volumes_from</h2><p>从另外一个服务或者容器挂载它的所有卷。 可指定只读（ro）或读写（rw），默认是读写（rw）。示例：</p>\n<pre><code>volumes_from:\n - service_name\n - service_name:ro\n - container:container_name\n - container:container_name:rw\n</code></pre><h2 id=\"environment\"><a href=\"#environment\" class=\"headerlink\" title=\"environment\"></a>environment</h2><p>设置环境变量，可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。</p>\n<pre><code>environment:\n  RACK_ENV: development\n  SHOW: &apos;true&apos;\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SHOW=true\n  - SESSION_SECRET\n</code></pre><h2 id=\"env-file\"><a href=\"#env-file\" class=\"headerlink\" title=\"env_file\"></a>env_file</h2><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果使用<code>docker-compose -f FILE</code>指定模板文件，则<code>env_file</code>中路径会基于模板文件路径。</p>\n<p>如果有变量和<code>environment</code>指令冲突，则以后者为准。即使用environment指定的环境变量会覆盖env_file指定的环境变量</p>\n<pre><code>env_file: .env\n\nenv_file:\n  - ./common.env   # 共用\n  - ./apps/web.env # web用\n  - /opt/secrets.env # 密码用            \n</code></pre><h2 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h2>","site":{"data":{}},"excerpt":"","more":"<p>默认的模板文件是 docker-compose.yml ，其中定义的每个服务都必须通过 image 指令指定镜像或<br>build 指令（需要 Dockerfile）来自动构建。</p>\n<h2 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h2><p>指定为镜像名称或者id，如果本地没有该镜像，将会到配置的镜像仓库拉取该镜像。</p>\n<p>例如：</p>\n<pre><code>image: ubuntu\nimage: orchardup/postgresql\nimage: a4bc65fd\n</code></pre><h2 id=\"build\"><a href=\"#build\" class=\"headerlink\" title=\"build\"></a>build</h2><p>指定<code>Dockerfile</code>所在文件夹的路径。Compose将会利用它自动构建这个镜像，然后使用这个镜像。</p>\n<pre><code>build: /path/to/build/dir\n</code></pre><p>也可以是一个对象，用于指定Dockerfile和参数，例如：</p>\n<pre><code>build:\n  context: ./dir\n  dockerfile: Dockerfile-alternate\n  args:\n    buildno: 1\n</code></pre><h2 id=\"command\"><a href=\"#command\" class=\"headerlink\" title=\"command\"></a>command</h2><p>覆盖容器启动后默认执行的命令。</p>\n<pre><code>command: bundle exec thin -p 3000\n</code></pre><p>也可以是一个list，类似于Dockerfile中的CMD指令，格式如下：</p>\n<pre><code>command: [bundle, exec, thin, -p, 3000]\n</code></pre><h2 id=\"links\"><a href=\"#links\" class=\"headerlink\" title=\"links\"></a>links</h2><p>链接到其它服务中的容器。使用服务名称（同时作为别名）或服务名称：服务别名（SERVICE:ALIAS） 格<br>式都可以。</p>\n<pre><code>links:\n- db\n- db:database\n- redis\n</code></pre><p>使用的别名将会自动在服务容器中的 /etc/hosts 里创建。例如：</p>\n<pre><code>172.17.2.186 db\n172.17.2.186 database\n172.17.2.187 redis\n</code></pre><p>相应的环境变量也将被创建。</p>\n<h2 id=\"external-links\"><a href=\"#external-links\" class=\"headerlink\" title=\"external_links\"></a>external_links</h2><p>链接到<code>docker-compose.yml</code>外部的容器，甚至并非Compose管理的容器。参数格式跟links类似。  </p>\n<pre><code>external_links:\n - redis_1\n - project_db_1:mysql\n - project_db_1:postgresql\n</code></pre><h2 id=\"ports\"><a href=\"#ports\" class=\"headerlink\" title=\"ports\"></a>ports</h2><p>暴露端口信息。</p>\n<p>使用宿主：容器（HOST:CONTAINER）格式或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。  </p>\n<p>需要注意的是，当使用HOST:CONTAINER 格式映射端口时，容器端口小于60将会得到错误的接口，因为yaml会把xx:yy 的数字解析为60进制。因此，建议使用字符串的形式。示例：</p>\n<pre><code>ports:\n - &quot;3000&quot;\n - &quot;3000-3005&quot;\n - &quot;8000:8000&quot;\n - &quot;9090-9091:8080-8081&quot;\n - &quot;49100:22&quot;\n - &quot;127.0.0.1:8001:8001&quot;\n - &quot;127.0.0.1:5000-5010:5000-5010&quot;\n</code></pre><h2 id=\"expose\"><a href=\"#expose\" class=\"headerlink\" title=\"expose\"></a>expose</h2><p>暴露端口，但不映射到宿主机，只被连接的服务访问。</p>\n<pre><code>expose:\n - &quot;3000&quot;\n - &quot;8000&quot;\n</code></pre><h2 id=\"volumes\"><a href=\"#volumes\" class=\"headerlink\" title=\"volumes\"></a>volumes</h2><p>卷挂载路径设置。可以设置宿主机路径（HOST:CONTAINER） ，也可指定访问模式（HOST:CONTAINER:ro）。示例：</p>\n<pre><code>volumes:\n  # Just specify a path and let the Engine create a volume\n  - /var/lib/mysql\n\n  # Specify an absolute path mapping\n  - /opt/data:/var/lib/mysql\n\n  # Path on the host, relative to the Compose file\n  - ./cache:/tmp/cache\n\n  # User-relative path\n  - ~/configs:/etc/configs/:ro\n\n  # Named volume\n  - datavolume:/var/lib/mysql\n</code></pre><h2 id=\"volumes-from\"><a href=\"#volumes-from\" class=\"headerlink\" title=\"volumes_from\"></a>volumes_from</h2><p>从另外一个服务或者容器挂载它的所有卷。 可指定只读（ro）或读写（rw），默认是读写（rw）。示例：</p>\n<pre><code>volumes_from:\n - service_name\n - service_name:ro\n - container:container_name\n - container:container_name:rw\n</code></pre><h2 id=\"environment\"><a href=\"#environment\" class=\"headerlink\" title=\"environment\"></a>environment</h2><p>设置环境变量，可以使用数组或字典两种格式。</p>\n<p>只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。</p>\n<pre><code>environment:\n  RACK_ENV: development\n  SHOW: &apos;true&apos;\n  SESSION_SECRET:\n\nenvironment:\n  - RACK_ENV=development\n  - SHOW=true\n  - SESSION_SECRET\n</code></pre><h2 id=\"env-file\"><a href=\"#env-file\" class=\"headerlink\" title=\"env_file\"></a>env_file</h2><p>从文件中获取环境变量，可以为单独的文件路径或列表。</p>\n<p>如果使用<code>docker-compose -f FILE</code>指定模板文件，则<code>env_file</code>中路径会基于模板文件路径。</p>\n<p>如果有变量和<code>environment</code>指令冲突，则以后者为准。即使用environment指定的环境变量会覆盖env_file指定的环境变量</p>\n<pre><code>env_file: .env\n\nenv_file:\n  - ./common.env   # 共用\n  - ./apps/web.env # web用\n  - /opt/secrets.env # 密码用            \n</code></pre><h2 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h2>"},{"title":"docker给运行中的容器添加映射端口","date":"2018-12-26T08:31:53.000Z","_content":"\n容器启动的时候，只映射了一些端口，那如果想给运行中的容器映射端口到主机该怎么弄呢……\n\n- 方法一：\n\n1.获取容器id\n\n    docker ps\n    docker inspect `container_name` | grep IPAddress\n    \n    [root@api data]# docker inspect nexus3 | grep IPAddress\n                \"SecondaryIPAddresses\": null,\n                \"IPAddress\": \"172.17.0.4\",\n                        \"IPAddress\": \"172.17.0.4\",\n    \n2.iptable转发端口  \n\n将容器的80端口映射到dockers宿主机的9998端口\n\n   iptables -t nat -A  DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.19:8000\n    \n3.查看docker端口映射\n\n    [root@api docker]# docker port nexus3 \n    8081/tcp -> 0.0.0.0:8085  \n  \n发现没映射成功……悲剧 \n\n无效，未解决……\n\n    \n- 方法二：\n\n1.提交一个运行中的容器为镜像\n\n    docker commit containerid foo/live\n    \n2.运行镜像并添加端口\n\n    docker run -d -p 8000:80  foo/live /bin/bash\n    \n- 方法三（比方法二方便，推荐）\n\n1.首先stop容器，在宿主机编辑：`/var/lib/docker/containers/[hash_of_the_container]/hostconfig.json` \n\n添加映射，容器端口8082映射到宿主8888\n\n     \"PortBindings\": {\n        \"8081/tcp\": [\n            {\n                \"HostIp\": \"\",\n                \"HostPort\": \"8085\"\n            }\n        ],\n        \"8082/tcp\": [\n            {\n                \"HostIp\": \"\",\n                \"HostPort\": \"8888\"\n            }\n        ]\n     }    \n     \n2.重启docker引擎\n\n    systemctl restart docker.service\n    \n3.启动容器\n\n    docker start 容器名\n    \n4.查看容器端口映射\n\n    docker port 容器名                   ","source":"_posts/docker-container-add-port.md","raw":"---\ntitle: docker给运行中的容器添加映射端口\ndate: 2018-12-26 16:31:53\ncategories: docker\ntags:\n---\n\n容器启动的时候，只映射了一些端口，那如果想给运行中的容器映射端口到主机该怎么弄呢……\n\n- 方法一：\n\n1.获取容器id\n\n    docker ps\n    docker inspect `container_name` | grep IPAddress\n    \n    [root@api data]# docker inspect nexus3 | grep IPAddress\n                \"SecondaryIPAddresses\": null,\n                \"IPAddress\": \"172.17.0.4\",\n                        \"IPAddress\": \"172.17.0.4\",\n    \n2.iptable转发端口  \n\n将容器的80端口映射到dockers宿主机的9998端口\n\n   iptables -t nat -A  DOCKER -p tcp --dport 8001 -j DNAT --to-destination 172.17.0.19:8000\n    \n3.查看docker端口映射\n\n    [root@api docker]# docker port nexus3 \n    8081/tcp -> 0.0.0.0:8085  \n  \n发现没映射成功……悲剧 \n\n无效，未解决……\n\n    \n- 方法二：\n\n1.提交一个运行中的容器为镜像\n\n    docker commit containerid foo/live\n    \n2.运行镜像并添加端口\n\n    docker run -d -p 8000:80  foo/live /bin/bash\n    \n- 方法三（比方法二方便，推荐）\n\n1.首先stop容器，在宿主机编辑：`/var/lib/docker/containers/[hash_of_the_container]/hostconfig.json` \n\n添加映射，容器端口8082映射到宿主8888\n\n     \"PortBindings\": {\n        \"8081/tcp\": [\n            {\n                \"HostIp\": \"\",\n                \"HostPort\": \"8085\"\n            }\n        ],\n        \"8082/tcp\": [\n            {\n                \"HostIp\": \"\",\n                \"HostPort\": \"8888\"\n            }\n        ]\n     }    \n     \n2.重启docker引擎\n\n    systemctl restart docker.service\n    \n3.启动容器\n\n    docker start 容器名\n    \n4.查看容器端口映射\n\n    docker port 容器名                   ","slug":"docker-container-add-port","published":1,"updated":"2019-06-16T14:38:33.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqb1001yg4vap3y91c0s","content":"<p>容器启动的时候，只映射了一些端口，那如果想给运行中的容器映射端口到主机该怎么弄呢……</p>\n<ul>\n<li>方法一：</li>\n</ul>\n<p>1.获取容器id</p>\n<pre><code>docker ps\ndocker inspect `container_name` | grep IPAddress\n\n[root@api data]# docker inspect nexus3 | grep IPAddress\n            &quot;SecondaryIPAddresses&quot;: null,\n            &quot;IPAddress&quot;: &quot;172.17.0.4&quot;,\n                    &quot;IPAddress&quot;: &quot;172.17.0.4&quot;,\n</code></pre><p>2.iptable转发端口  </p>\n<p>将容器的80端口映射到dockers宿主机的9998端口</p>\n<p>   iptables -t nat -A  DOCKER -p tcp –dport 8001 -j DNAT –to-destination 172.17.0.19:8000</p>\n<p>3.查看docker端口映射</p>\n<pre><code>[root@api docker]# docker port nexus3 \n8081/tcp -&gt; 0.0.0.0:8085  \n</code></pre><p>发现没映射成功……悲剧 </p>\n<p>无效，未解决……</p>\n<ul>\n<li>方法二：</li>\n</ul>\n<p>1.提交一个运行中的容器为镜像</p>\n<pre><code>docker commit containerid foo/live\n</code></pre><p>2.运行镜像并添加端口</p>\n<pre><code>docker run -d -p 8000:80  foo/live /bin/bash\n</code></pre><ul>\n<li>方法三（比方法二方便，推荐）</li>\n</ul>\n<p>1.首先stop容器，在宿主机编辑：<code>/var/lib/docker/containers/[hash_of_the_container]/hostconfig.json</code> </p>\n<p>添加映射，容器端口8082映射到宿主8888</p>\n<pre><code>&quot;PortBindings&quot;: {\n   &quot;8081/tcp&quot;: [\n       {\n           &quot;HostIp&quot;: &quot;&quot;,\n           &quot;HostPort&quot;: &quot;8085&quot;\n       }\n   ],\n   &quot;8082/tcp&quot;: [\n       {\n           &quot;HostIp&quot;: &quot;&quot;,\n           &quot;HostPort&quot;: &quot;8888&quot;\n       }\n   ]\n}    \n</code></pre><p>2.重启docker引擎</p>\n<pre><code>systemctl restart docker.service\n</code></pre><p>3.启动容器</p>\n<pre><code>docker start 容器名\n</code></pre><p>4.查看容器端口映射</p>\n<pre><code>docker port 容器名                   \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>容器启动的时候，只映射了一些端口，那如果想给运行中的容器映射端口到主机该怎么弄呢……</p>\n<ul>\n<li>方法一：</li>\n</ul>\n<p>1.获取容器id</p>\n<pre><code>docker ps\ndocker inspect `container_name` | grep IPAddress\n\n[root@api data]# docker inspect nexus3 | grep IPAddress\n            &quot;SecondaryIPAddresses&quot;: null,\n            &quot;IPAddress&quot;: &quot;172.17.0.4&quot;,\n                    &quot;IPAddress&quot;: &quot;172.17.0.4&quot;,\n</code></pre><p>2.iptable转发端口  </p>\n<p>将容器的80端口映射到dockers宿主机的9998端口</p>\n<p>   iptables -t nat -A  DOCKER -p tcp –dport 8001 -j DNAT –to-destination 172.17.0.19:8000</p>\n<p>3.查看docker端口映射</p>\n<pre><code>[root@api docker]# docker port nexus3 \n8081/tcp -&gt; 0.0.0.0:8085  \n</code></pre><p>发现没映射成功……悲剧 </p>\n<p>无效，未解决……</p>\n<ul>\n<li>方法二：</li>\n</ul>\n<p>1.提交一个运行中的容器为镜像</p>\n<pre><code>docker commit containerid foo/live\n</code></pre><p>2.运行镜像并添加端口</p>\n<pre><code>docker run -d -p 8000:80  foo/live /bin/bash\n</code></pre><ul>\n<li>方法三（比方法二方便，推荐）</li>\n</ul>\n<p>1.首先stop容器，在宿主机编辑：<code>/var/lib/docker/containers/[hash_of_the_container]/hostconfig.json</code> </p>\n<p>添加映射，容器端口8082映射到宿主8888</p>\n<pre><code>&quot;PortBindings&quot;: {\n   &quot;8081/tcp&quot;: [\n       {\n           &quot;HostIp&quot;: &quot;&quot;,\n           &quot;HostPort&quot;: &quot;8085&quot;\n       }\n   ],\n   &quot;8082/tcp&quot;: [\n       {\n           &quot;HostIp&quot;: &quot;&quot;,\n           &quot;HostPort&quot;: &quot;8888&quot;\n       }\n   ]\n}    \n</code></pre><p>2.重启docker引擎</p>\n<pre><code>systemctl restart docker.service\n</code></pre><p>3.启动容器</p>\n<pre><code>docker start 容器名\n</code></pre><p>4.查看容器端口映射</p>\n<pre><code>docker port 容器名                   \n</code></pre>"},{"title":"docker使用错误收集","date":"2019-01-23T07:41:18.000Z","_content":"\n##  docker 端口映射错误解决方法\n\n错误描述：\n\n    COMMAND_FAILED: '/sbin/iptables -t nat -A DOCKER -p tcp -d 0/0 --dport 8111 -j DNAT --to-destination 172.17.0.6:8111 ! -i docker0' failed: iptables: No chain/target/match by that name.\n   \n解决：    \n \n依次执行以下命令：  \n \n    pkill docker\n   \n    iptables -t nat -F\n    ifconfig docker0 down\n    brctl delbr docker0   \n    \n然后重启docker引擎。`systemctl restart docker.service`      \n\n","source":"_posts/docker-erro-show.md","raw":"---\ntitle: docker使用错误收集\ndate: 2019-01-23 15:41:18\ncategories: docker\ntags:\n---\n\n##  docker 端口映射错误解决方法\n\n错误描述：\n\n    COMMAND_FAILED: '/sbin/iptables -t nat -A DOCKER -p tcp -d 0/0 --dport 8111 -j DNAT --to-destination 172.17.0.6:8111 ! -i docker0' failed: iptables: No chain/target/match by that name.\n   \n解决：    \n \n依次执行以下命令：  \n \n    pkill docker\n   \n    iptables -t nat -F\n    ifconfig docker0 down\n    brctl delbr docker0   \n    \n然后重启docker引擎。`systemctl restart docker.service`      \n\n","slug":"docker-erro-show","published":1,"updated":"2019-06-16T14:38:33.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqb30022g4vab7pebexl","content":"<h2 id=\"docker-端口映射错误解决方法\"><a href=\"#docker-端口映射错误解决方法\" class=\"headerlink\" title=\"docker 端口映射错误解决方法\"></a>docker 端口映射错误解决方法</h2><p>错误描述：</p>\n<pre><code>COMMAND_FAILED: &apos;/sbin/iptables -t nat -A DOCKER -p tcp -d 0/0 --dport 8111 -j DNAT --to-destination 172.17.0.6:8111 ! -i docker0&apos; failed: iptables: No chain/target/match by that name.\n</code></pre><p>解决：    </p>\n<p>依次执行以下命令：  </p>\n<pre><code>pkill docker\n\niptables -t nat -F\nifconfig docker0 down\nbrctl delbr docker0   \n</code></pre><p>然后重启docker引擎。<code>systemctl restart docker.service</code>      </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"docker-端口映射错误解决方法\"><a href=\"#docker-端口映射错误解决方法\" class=\"headerlink\" title=\"docker 端口映射错误解决方法\"></a>docker 端口映射错误解决方法</h2><p>错误描述：</p>\n<pre><code>COMMAND_FAILED: &apos;/sbin/iptables -t nat -A DOCKER -p tcp -d 0/0 --dport 8111 -j DNAT --to-destination 172.17.0.6:8111 ! -i docker0&apos; failed: iptables: No chain/target/match by that name.\n</code></pre><p>解决：    </p>\n<p>依次执行以下命令：  </p>\n<pre><code>pkill docker\n\niptables -t nat -F\nifconfig docker0 down\nbrctl delbr docker0   \n</code></pre><p>然后重启docker引擎。<code>systemctl restart docker.service</code>      </p>\n"},{"title":"centos6安装docker-ce","date":"2018-12-18T08:00:19.000Z","_content":"\nDocker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。\nDocker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本\n\nCentOS 7 的内核一般都是3.10的，而CentOS 6.X 的内核一般都是2.6，在2.6的内核下，Docker运行会比较卡，所以一般会选择升级到3.10版本。\n\ncentos升级内核方法：{% post_link  centos6-kernel-update Linux升级内核 %}\n\n\n1.安装docker\n\n    [root@localhost ~]# yum install docker-io\n\n2.查看Docker版本信息\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# docker version\n    Client version: 1.7.1\n    Client API version: 1.19\n    Go version (client): go1.4.2\n    Git commit (client): 786b29d/1.7.1\n    OS/Arch (client): linux/amd64\n    Get http:///var/run/docker.sock/v1.19/version: dial unix /var/run/docker.sock: no such file or directory. Are you trying to connect to a TLS-enabled daemon without TLS?\n\n3.启动Docker\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# service docker start\n    Starting cgconfig service:                                 [  OK  ]\n    Starting docker:\t                                   [  OK  ]\n\n\n4.查看Docker日志\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /var/log/docker\n    \\nTue Dec 18 16:19:04 CST 2018\\n\n    time=\"2018-12-18T16:19:04.578091169+08:00\" level=info msg=\"Listening for HTTP on unix (/var/run/docker.sock)\" \n    time=\"2018-12-18T16:19:06.456619838+08:00\" level=warning msg=\"Running modprobe bridge nf_nat failed with message: install /sbin/modprobe --ignore-install bridge && /sbin/sysctl -q -w net.bridge.bridge-nf-call-arptables=0 net.bridge.bridge-nf-call-iptables=0 net.bridge.bridge-nf-call-ip6tables=0\\ninsmod /lib/modules/4.4.167-1.el6.elrepo.x86_64/kernel/net/netfilter/nf_conntrack.ko \\ninsmod /lib/modules/4.4.167-1.el6.elrepo.x86_64/kernel/net/netfilter/nf_nat.ko \\n, error: exit status 1\" \n    time=\"2018-12-18T16:19:06.713397637+08:00\" level=info msg=\"Loading containers: start.\" \n    \n    time=\"2018-12-18T16:19:06.713664810+08:00\" level=info msg=\"Loading containers: done.\" \n    time=\"2018-12-18T16:19:06.713684883+08:00\" level=info msg=\"Daemon has completed initialization\" \n    time=\"2018-12-18T16:19:06.713703135+08:00\" level=info msg=\"Docker daemon\" commit=\"786b29d/1.7.1\" execdriver=native-0.2 graphdriver=devicemapper version=1.7.1 \n\n5.停止Docker\n\n    [root@localhost ~]# service docker stop\n    \n6.卸载Docker\n\n6.1  查看安装的Docker包\n\n    [root@localhost ~]# yum list installed | grep docker\n    \n6.2 yum 卸载 Docker\n\n    [root@localhost ~]# yum -y remove docker-io.x86_64\n    \n6.3 删除Docker镜像\n\n    [root@localhost ~]# rm -rf /var/lib/docker               ","source":"_posts/docker-install-centos6.md","raw":"---\ntitle: centos6安装docker-ce\ndate: 2018-12-18 16:00:19\ncategories: docker\ntags:\n---\n\nDocker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。\nDocker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本\n\nCentOS 7 的内核一般都是3.10的，而CentOS 6.X 的内核一般都是2.6，在2.6的内核下，Docker运行会比较卡，所以一般会选择升级到3.10版本。\n\ncentos升级内核方法：{% post_link  centos6-kernel-update Linux升级内核 %}\n\n\n1.安装docker\n\n    [root@localhost ~]# yum install docker-io\n\n2.查看Docker版本信息\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# docker version\n    Client version: 1.7.1\n    Client API version: 1.19\n    Go version (client): go1.4.2\n    Git commit (client): 786b29d/1.7.1\n    OS/Arch (client): linux/amd64\n    Get http:///var/run/docker.sock/v1.19/version: dial unix /var/run/docker.sock: no such file or directory. Are you trying to connect to a TLS-enabled daemon without TLS?\n\n3.启动Docker\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# service docker start\n    Starting cgconfig service:                                 [  OK  ]\n    Starting docker:\t                                   [  OK  ]\n\n\n4.查看Docker日志\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /var/log/docker\n    \\nTue Dec 18 16:19:04 CST 2018\\n\n    time=\"2018-12-18T16:19:04.578091169+08:00\" level=info msg=\"Listening for HTTP on unix (/var/run/docker.sock)\" \n    time=\"2018-12-18T16:19:06.456619838+08:00\" level=warning msg=\"Running modprobe bridge nf_nat failed with message: install /sbin/modprobe --ignore-install bridge && /sbin/sysctl -q -w net.bridge.bridge-nf-call-arptables=0 net.bridge.bridge-nf-call-iptables=0 net.bridge.bridge-nf-call-ip6tables=0\\ninsmod /lib/modules/4.4.167-1.el6.elrepo.x86_64/kernel/net/netfilter/nf_conntrack.ko \\ninsmod /lib/modules/4.4.167-1.el6.elrepo.x86_64/kernel/net/netfilter/nf_nat.ko \\n, error: exit status 1\" \n    time=\"2018-12-18T16:19:06.713397637+08:00\" level=info msg=\"Loading containers: start.\" \n    \n    time=\"2018-12-18T16:19:06.713664810+08:00\" level=info msg=\"Loading containers: done.\" \n    time=\"2018-12-18T16:19:06.713684883+08:00\" level=info msg=\"Daemon has completed initialization\" \n    time=\"2018-12-18T16:19:06.713703135+08:00\" level=info msg=\"Docker daemon\" commit=\"786b29d/1.7.1\" execdriver=native-0.2 graphdriver=devicemapper version=1.7.1 \n\n5.停止Docker\n\n    [root@localhost ~]# service docker stop\n    \n6.卸载Docker\n\n6.1  查看安装的Docker包\n\n    [root@localhost ~]# yum list installed | grep docker\n    \n6.2 yum 卸载 Docker\n\n    [root@localhost ~]# yum -y remove docker-io.x86_64\n    \n6.3 删除Docker镜像\n\n    [root@localhost ~]# rm -rf /var/lib/docker               ","slug":"docker-install-centos6","published":1,"updated":"2019-06-16T14:38:33.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqb40024g4vazm934k1o","content":"<p>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本</p>\n<p>CentOS 7 的内核一般都是3.10的，而CentOS 6.X 的内核一般都是2.6，在2.6的内核下，Docker运行会比较卡，所以一般会选择升级到3.10版本。</p>\n<p>centos升级内核方法：<a href=\"/2018/12/18/centos6-kernel-update/\" title=\"Linux升级内核\">Linux升级内核</a></p>\n<p>1.安装docker</p>\n<pre><code>[root@localhost ~]# yum install docker-io\n</code></pre><p>2.查看Docker版本信息</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# docker version\nClient version: 1.7.1\nClient API version: 1.19\nGo version (client): go1.4.2\nGit commit (client): 786b29d/1.7.1\nOS/Arch (client): linux/amd64\nGet http:///var/run/docker.sock/v1.19/version: dial unix /var/run/docker.sock: no such file or directory. Are you trying to connect to a TLS-enabled daemon without TLS?\n</code></pre><p>3.启动Docker</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# service docker start\nStarting cgconfig service:                                 [  OK  ]\nStarting docker:                                       [  OK  ]\n</code></pre><p>4.查看Docker日志</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /var/log/docker\n\\nTue Dec 18 16:19:04 CST 2018\\n\ntime=&quot;2018-12-18T16:19:04.578091169+08:00&quot; level=info msg=&quot;Listening for HTTP on unix (/var/run/docker.sock)&quot; \ntime=&quot;2018-12-18T16:19:06.456619838+08:00&quot; level=warning msg=&quot;Running modprobe bridge nf_nat failed with message: install /sbin/modprobe --ignore-install bridge &amp;&amp; /sbin/sysctl -q -w net.bridge.bridge-nf-call-arptables=0 net.bridge.bridge-nf-call-iptables=0 net.bridge.bridge-nf-call-ip6tables=0\\ninsmod /lib/modules/4.4.167-1.el6.elrepo.x86_64/kernel/net/netfilter/nf_conntrack.ko \\ninsmod /lib/modules/4.4.167-1.el6.elrepo.x86_64/kernel/net/netfilter/nf_nat.ko \\n, error: exit status 1&quot; \ntime=&quot;2018-12-18T16:19:06.713397637+08:00&quot; level=info msg=&quot;Loading containers: start.&quot; \n\ntime=&quot;2018-12-18T16:19:06.713664810+08:00&quot; level=info msg=&quot;Loading containers: done.&quot; \ntime=&quot;2018-12-18T16:19:06.713684883+08:00&quot; level=info msg=&quot;Daemon has completed initialization&quot; \ntime=&quot;2018-12-18T16:19:06.713703135+08:00&quot; level=info msg=&quot;Docker daemon&quot; commit=&quot;786b29d/1.7.1&quot; execdriver=native-0.2 graphdriver=devicemapper version=1.7.1 \n</code></pre><p>5.停止Docker</p>\n<pre><code>[root@localhost ~]# service docker stop\n</code></pre><p>6.卸载Docker</p>\n<p>6.1  查看安装的Docker包</p>\n<pre><code>[root@localhost ~]# yum list installed | grep docker\n</code></pre><p>6.2 yum 卸载 Docker</p>\n<pre><code>[root@localhost ~]# yum -y remove docker-io.x86_64\n</code></pre><p>6.3 删除Docker镜像</p>\n<pre><code>[root@localhost ~]# rm -rf /var/lib/docker               \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>Docker 运行在 CentOS 7 上，要求系统为64位、系统内核版本为 3.10 以上。<br>Docker 运行在 CentOS-6.5 或更高的版本的 CentOS 上，要求系统为64位、系统内核版本为 2.6.32-431 或者更高版本</p>\n<p>CentOS 7 的内核一般都是3.10的，而CentOS 6.X 的内核一般都是2.6，在2.6的内核下，Docker运行会比较卡，所以一般会选择升级到3.10版本。</p>\n<p>centos升级内核方法：<a href=\"/2018/12/18/centos6-kernel-update/\" title=\"Linux升级内核\">Linux升级内核</a></p>\n<p>1.安装docker</p>\n<pre><code>[root@localhost ~]# yum install docker-io\n</code></pre><p>2.查看Docker版本信息</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# docker version\nClient version: 1.7.1\nClient API version: 1.19\nGo version (client): go1.4.2\nGit commit (client): 786b29d/1.7.1\nOS/Arch (client): linux/amd64\nGet http:///var/run/docker.sock/v1.19/version: dial unix /var/run/docker.sock: no such file or directory. Are you trying to connect to a TLS-enabled daemon without TLS?\n</code></pre><p>3.启动Docker</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# service docker start\nStarting cgconfig service:                                 [  OK  ]\nStarting docker:                                       [  OK  ]\n</code></pre><p>4.查看Docker日志</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# cat /var/log/docker\n\\nTue Dec 18 16:19:04 CST 2018\\n\ntime=&quot;2018-12-18T16:19:04.578091169+08:00&quot; level=info msg=&quot;Listening for HTTP on unix (/var/run/docker.sock)&quot; \ntime=&quot;2018-12-18T16:19:06.456619838+08:00&quot; level=warning msg=&quot;Running modprobe bridge nf_nat failed with message: install /sbin/modprobe --ignore-install bridge &amp;&amp; /sbin/sysctl -q -w net.bridge.bridge-nf-call-arptables=0 net.bridge.bridge-nf-call-iptables=0 net.bridge.bridge-nf-call-ip6tables=0\\ninsmod /lib/modules/4.4.167-1.el6.elrepo.x86_64/kernel/net/netfilter/nf_conntrack.ko \\ninsmod /lib/modules/4.4.167-1.el6.elrepo.x86_64/kernel/net/netfilter/nf_nat.ko \\n, error: exit status 1&quot; \ntime=&quot;2018-12-18T16:19:06.713397637+08:00&quot; level=info msg=&quot;Loading containers: start.&quot; \n\ntime=&quot;2018-12-18T16:19:06.713664810+08:00&quot; level=info msg=&quot;Loading containers: done.&quot; \ntime=&quot;2018-12-18T16:19:06.713684883+08:00&quot; level=info msg=&quot;Daemon has completed initialization&quot; \ntime=&quot;2018-12-18T16:19:06.713703135+08:00&quot; level=info msg=&quot;Docker daemon&quot; commit=&quot;786b29d/1.7.1&quot; execdriver=native-0.2 graphdriver=devicemapper version=1.7.1 \n</code></pre><p>5.停止Docker</p>\n<pre><code>[root@localhost ~]# service docker stop\n</code></pre><p>6.卸载Docker</p>\n<p>6.1  查看安装的Docker包</p>\n<pre><code>[root@localhost ~]# yum list installed | grep docker\n</code></pre><p>6.2 yum 卸载 Docker</p>\n<pre><code>[root@localhost ~]# yum -y remove docker-io.x86_64\n</code></pre><p>6.3 删除Docker镜像</p>\n<pre><code>[root@localhost ~]# rm -rf /var/lib/docker               \n</code></pre>"},{"title":"centos7安装docker-ce","date":"2017-11-15T05:55:39.000Z","_content":"\n本文介绍docker在centos7系统上的安装。\n参考：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\n参考中文：http://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85\n\n## 1. 卸载旧版本docker\n\n    $ sudo yum remove docker \\\n                      docker-common \\\n                      docker-selinux \\\n                      docker-engine\n\n---\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n    >                   docker-common \\\n    >                   docker-selinux \\\n    >                   docker-engine\n    Loaded plugins: fastestmirror\n    No Match for argument: docker\n    No Match for argument: docker-common\n    No Match for argument: docker-selinux\n    No Match for argument: docker-engine\n    No Packages marked for removal\n    \n    ---\n    表明没有旧版本\n    \n旧版本的会安装在`/var/lib/docker/`，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。\n \n## 2. 安装docker-ce\n\n共有三种方式安装,根据自己喜欢方式选择一种安装：\n- 配置安装源，从安装源拉取安装。推荐，但是网络要好\n- 下载安装包，执行安装。网络不好，采用。\n- 下载脚本执行安装。开发环境这种方式方便。\n\n### 2.1 repository方式安装，推荐\n第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。\n1. 安装依赖包\n\n\n    $ sudo yum install -y yum-utils \\\n      device-mapper-persistent-data \\\n      lvm2\n\n\n2. 安装源\n        \n        \n    $ sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo                   \n                      \n3. 可选: 开启edge和test源\n\n\n    $ sudo yum-config-manager --enable docker-ce-edge\n    $ sudo yum-config-manager --enable docker-ce-test                     \n    -----\n    关闭：\n    $ sudo yum-config-manager --disable docker-ce-edge    \n    \n4. 安装docker\n\n4.1 安装最新版本\n\n    $ sudo yum install docker-ce\n    \n> Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.\n\n4.2 安装指定版本\n在生成环境，有时候要安装指定版本。\n\n- 查看所有可用版本\n\n        $ yum list docker-ce --showduplicates | sort -r\n        \n        docker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n\n第二列是版本号。        \nThe contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).\n> Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.\n\n    $ sudo yum install docker-ce-<VERSION>\n    如： sudo yum install docker-ce- 17.09.ce-1.el7.centos\n    \n4.3 启动docker                 \n    \n    $ sudo systemctl start docker                      \n\n4.4 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n会下载docker镜像，然后执行，打印信息。\n\n4.5 更新docker\n根据上面安装过程，重新安装即可。\n\n### 2.2 安装包方式（更喜欢方式）\n\n如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。\n\n1. 下载安装包：\n\n打开网址 *https://download.docker.com/linux/centos/7/x86_64/stable/Packages/*，下载`.rpm`合适版本下载。\n\n> Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.\n\n2. 安装docker\n指向包所在路径，如果是更新，把`install`改成`update`\n\n\n    $ sudo yum install /path/to/package.rpm\n      \n      \n3. 启动docker\n\n    $ sudo systemctl start docker\n    \n4. 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n{% asset_img a.png %}\n\n看到红色标注部分说明安装成功。    \n    \n5. 更新docker-ce\n下载新的安装包，用`yum -y upgrade`替换`yum -y install`,指向新的安装包。    \n\n## 3. 卸载docker-ce\n\n1. 卸载docker安装包：\n\n\n    $ sudo yum remove docker-ce\n    \n2. 卸载docker安装包不会自动删除相关资源，要手动删除：\n\n\n    $ sudo rm -rf /var/lib/docker\n                                      ","source":"_posts/docker-install-centos7.md","raw":"---\ntitle: centos7安装docker-ce\ndate: 2017-11-15 13:55:39\ncategories: docker\ntags: centos-docker-install\n---\n\n本文介绍docker在centos7系统上的安装。\n参考：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\n参考中文：http://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85\n\n## 1. 卸载旧版本docker\n\n    $ sudo yum remove docker \\\n                      docker-common \\\n                      docker-selinux \\\n                      docker-engine\n\n---\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n    >                   docker-common \\\n    >                   docker-selinux \\\n    >                   docker-engine\n    Loaded plugins: fastestmirror\n    No Match for argument: docker\n    No Match for argument: docker-common\n    No Match for argument: docker-selinux\n    No Match for argument: docker-engine\n    No Packages marked for removal\n    \n    ---\n    表明没有旧版本\n    \n旧版本的会安装在`/var/lib/docker/`，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。\n \n## 2. 安装docker-ce\n\n共有三种方式安装,根据自己喜欢方式选择一种安装：\n- 配置安装源，从安装源拉取安装。推荐，但是网络要好\n- 下载安装包，执行安装。网络不好，采用。\n- 下载脚本执行安装。开发环境这种方式方便。\n\n### 2.1 repository方式安装，推荐\n第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。\n1. 安装依赖包\n\n\n    $ sudo yum install -y yum-utils \\\n      device-mapper-persistent-data \\\n      lvm2\n\n\n2. 安装源\n        \n        \n    $ sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo                   \n                      \n3. 可选: 开启edge和test源\n\n\n    $ sudo yum-config-manager --enable docker-ce-edge\n    $ sudo yum-config-manager --enable docker-ce-test                     \n    -----\n    关闭：\n    $ sudo yum-config-manager --disable docker-ce-edge    \n    \n4. 安装docker\n\n4.1 安装最新版本\n\n    $ sudo yum install docker-ce\n    \n> Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.\n\n4.2 安装指定版本\n在生成环境，有时候要安装指定版本。\n\n- 查看所有可用版本\n\n        $ yum list docker-ce --showduplicates | sort -r\n        \n        docker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n\n第二列是版本号。        \nThe contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).\n> Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.\n\n    $ sudo yum install docker-ce-<VERSION>\n    如： sudo yum install docker-ce- 17.09.ce-1.el7.centos\n    \n4.3 启动docker                 \n    \n    $ sudo systemctl start docker                      \n\n4.4 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n会下载docker镜像，然后执行，打印信息。\n\n4.5 更新docker\n根据上面安装过程，重新安装即可。\n\n### 2.2 安装包方式（更喜欢方式）\n\n如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。\n\n1. 下载安装包：\n\n打开网址 *https://download.docker.com/linux/centos/7/x86_64/stable/Packages/*，下载`.rpm`合适版本下载。\n\n> Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.\n\n2. 安装docker\n指向包所在路径，如果是更新，把`install`改成`update`\n\n\n    $ sudo yum install /path/to/package.rpm\n      \n      \n3. 启动docker\n\n    $ sudo systemctl start docker\n    \n4. 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n{% asset_img a.png %}\n\n看到红色标注部分说明安装成功。    \n    \n5. 更新docker-ce\n下载新的安装包，用`yum -y upgrade`替换`yum -y install`,指向新的安装包。    \n\n## 3. 卸载docker-ce\n\n1. 卸载docker安装包：\n\n\n    $ sudo yum remove docker-ce\n    \n2. 卸载docker安装包不会自动删除相关资源，要手动删除：\n\n\n    $ sudo rm -rf /var/lib/docker\n                                      ","slug":"docker-install-centos7","published":1,"updated":"2019-06-16T14:38:33.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqb50027g4va8wcohl75","content":"<p>本文介绍docker在centos7系统上的安装。<br>参考：<a href=\"https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions</a><br>参考中文：<a href=\"http://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85\" target=\"_blank\" rel=\"noopener\">http://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85</a></p>\n<h2 id=\"1-卸载旧版本docker\"><a href=\"#1-卸载旧版本docker\" class=\"headerlink\" title=\"1. 卸载旧版本docker\"></a>1. 卸载旧版本docker</h2><pre><code>$ sudo yum remove docker \\\n                  docker-common \\\n                  docker-selinux \\\n                  docker-engine\n</code></pre><hr>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n&gt;                   docker-common \\\n&gt;                   docker-selinux \\\n&gt;                   docker-engine\nLoaded plugins: fastestmirror\nNo Match for argument: docker\nNo Match for argument: docker-common\nNo Match for argument: docker-selinux\nNo Match for argument: docker-engine\nNo Packages marked for removal\n\n---\n表明没有旧版本\n</code></pre><p>旧版本的会安装在<code>/var/lib/docker/</code>，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。</p>\n<h2 id=\"2-安装docker-ce\"><a href=\"#2-安装docker-ce\" class=\"headerlink\" title=\"2. 安装docker-ce\"></a>2. 安装docker-ce</h2><p>共有三种方式安装,根据自己喜欢方式选择一种安装：</p>\n<ul>\n<li>配置安装源，从安装源拉取安装。推荐，但是网络要好</li>\n<li>下载安装包，执行安装。网络不好，采用。</li>\n<li>下载脚本执行安装。开发环境这种方式方便。</li>\n</ul>\n<h3 id=\"2-1-repository方式安装，推荐\"><a href=\"#2-1-repository方式安装，推荐\" class=\"headerlink\" title=\"2.1 repository方式安装，推荐\"></a>2.1 repository方式安装，推荐</h3><p>第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。</p>\n<ol>\n<li>安装依赖包</li>\n</ol>\n<pre><code>$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre><ol start=\"2\">\n<li>安装源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo                   \n</code></pre><ol start=\"3\">\n<li>可选: 开启edge和test源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager --enable docker-ce-edge\n$ sudo yum-config-manager --enable docker-ce-test                     \n-----\n关闭：\n$ sudo yum-config-manager --disable docker-ce-edge    \n</code></pre><ol start=\"4\">\n<li>安装docker</li>\n</ol>\n<p>4.1 安装最新版本</p>\n<pre><code>$ sudo yum install docker-ce\n</code></pre><blockquote>\n<p>Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.</p>\n</blockquote>\n<p>4.2 安装指定版本<br>在生成环境，有时候要安装指定版本。</p>\n<ul>\n<li><p>查看所有可用版本</p>\n<pre><code>$ yum list docker-ce --showduplicates | sort -r\n\ndocker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n</code></pre></li>\n</ul>\n<p>第二列是版本号。<br>The contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).</p>\n<blockquote>\n<p>Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.</p>\n</blockquote>\n<pre><code>$ sudo yum install docker-ce-&lt;VERSION&gt;\n如： sudo yum install docker-ce- 17.09.ce-1.el7.centos\n</code></pre><p>4.3 启动docker                 </p>\n<pre><code>$ sudo systemctl start docker                      \n</code></pre><p>4.4 验证是否安装成功</p>\n<pre><code>$ sudo docker run hello-world\n</code></pre><p>会下载docker镜像，然后执行，打印信息。</p>\n<p>4.5 更新docker<br>根据上面安装过程，重新安装即可。</p>\n<h3 id=\"2-2-安装包方式（更喜欢方式）\"><a href=\"#2-2-安装包方式（更喜欢方式）\" class=\"headerlink\" title=\"2.2 安装包方式（更喜欢方式）\"></a>2.2 安装包方式（更喜欢方式）</h3><p>如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。</p>\n<ol>\n<li>下载安装包：</li>\n</ol>\n<p>打开网址 <em><a href=\"https://download.docker.com/linux/centos/7/x86_64/stable/Packages/\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></em>，下载<code>.rpm</code>合适版本下载。</p>\n<blockquote>\n<p>Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.</p>\n</blockquote>\n<ol start=\"2\">\n<li>安装docker<br>指向包所在路径，如果是更新，把<code>install</code>改成<code>update</code></li>\n</ol>\n<pre><code>$ sudo yum install /path/to/package.rpm\n</code></pre><ol start=\"3\">\n<li><p>启动docker</p>\n<p> $ sudo systemctl start docker</p>\n</li>\n<li><p>验证是否安装成功</p>\n<p> $ sudo docker run hello-world</p>\n</li>\n</ol>\n<img src=\"/2017/11/15/docker-install-centos7/a.png\">\n<p>看到红色标注部分说明安装成功。    </p>\n<ol start=\"5\">\n<li>更新docker-ce<br>下载新的安装包，用<code>yum -y upgrade</code>替换<code>yum -y install</code>,指向新的安装包。    </li>\n</ol>\n<h2 id=\"3-卸载docker-ce\"><a href=\"#3-卸载docker-ce\" class=\"headerlink\" title=\"3. 卸载docker-ce\"></a>3. 卸载docker-ce</h2><ol>\n<li>卸载docker安装包：</li>\n</ol>\n<pre><code>$ sudo yum remove docker-ce\n</code></pre><ol start=\"2\">\n<li>卸载docker安装包不会自动删除相关资源，要手动删除：</li>\n</ol>\n<pre><code>$ sudo rm -rf /var/lib/docker\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍docker在centos7系统上的安装。<br>参考：<a href=\"https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions</a><br>参考中文：<a href=\"http://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85\" target=\"_blank\" rel=\"noopener\">http://docs.docker-cn.com/engine/installation/linux/docker-ce/centos/#%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93%E8%BF%9B%E8%A1%8C%E5%AE%89%E8%A3%85</a></p>\n<h2 id=\"1-卸载旧版本docker\"><a href=\"#1-卸载旧版本docker\" class=\"headerlink\" title=\"1. 卸载旧版本docker\"></a>1. 卸载旧版本docker</h2><pre><code>$ sudo yum remove docker \\\n                  docker-common \\\n                  docker-selinux \\\n                  docker-engine\n</code></pre><hr>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n&gt;                   docker-common \\\n&gt;                   docker-selinux \\\n&gt;                   docker-engine\nLoaded plugins: fastestmirror\nNo Match for argument: docker\nNo Match for argument: docker-common\nNo Match for argument: docker-selinux\nNo Match for argument: docker-engine\nNo Packages marked for removal\n\n---\n表明没有旧版本\n</code></pre><p>旧版本的会安装在<code>/var/lib/docker/</code>，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。</p>\n<h2 id=\"2-安装docker-ce\"><a href=\"#2-安装docker-ce\" class=\"headerlink\" title=\"2. 安装docker-ce\"></a>2. 安装docker-ce</h2><p>共有三种方式安装,根据自己喜欢方式选择一种安装：</p>\n<ul>\n<li>配置安装源，从安装源拉取安装。推荐，但是网络要好</li>\n<li>下载安装包，执行安装。网络不好，采用。</li>\n<li>下载脚本执行安装。开发环境这种方式方便。</li>\n</ul>\n<h3 id=\"2-1-repository方式安装，推荐\"><a href=\"#2-1-repository方式安装，推荐\" class=\"headerlink\" title=\"2.1 repository方式安装，推荐\"></a>2.1 repository方式安装，推荐</h3><p>第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。</p>\n<ol>\n<li>安装依赖包</li>\n</ol>\n<pre><code>$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre><ol start=\"2\">\n<li>安装源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo                   \n</code></pre><ol start=\"3\">\n<li>可选: 开启edge和test源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager --enable docker-ce-edge\n$ sudo yum-config-manager --enable docker-ce-test                     \n-----\n关闭：\n$ sudo yum-config-manager --disable docker-ce-edge    \n</code></pre><ol start=\"4\">\n<li>安装docker</li>\n</ol>\n<p>4.1 安装最新版本</p>\n<pre><code>$ sudo yum install docker-ce\n</code></pre><blockquote>\n<p>Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.</p>\n</blockquote>\n<p>4.2 安装指定版本<br>在生成环境，有时候要安装指定版本。</p>\n<ul>\n<li><p>查看所有可用版本</p>\n<pre><code>$ yum list docker-ce --showduplicates | sort -r\n\ndocker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n</code></pre></li>\n</ul>\n<p>第二列是版本号。<br>The contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).</p>\n<blockquote>\n<p>Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.</p>\n</blockquote>\n<pre><code>$ sudo yum install docker-ce-&lt;VERSION&gt;\n如： sudo yum install docker-ce- 17.09.ce-1.el7.centos\n</code></pre><p>4.3 启动docker                 </p>\n<pre><code>$ sudo systemctl start docker                      \n</code></pre><p>4.4 验证是否安装成功</p>\n<pre><code>$ sudo docker run hello-world\n</code></pre><p>会下载docker镜像，然后执行，打印信息。</p>\n<p>4.5 更新docker<br>根据上面安装过程，重新安装即可。</p>\n<h3 id=\"2-2-安装包方式（更喜欢方式）\"><a href=\"#2-2-安装包方式（更喜欢方式）\" class=\"headerlink\" title=\"2.2 安装包方式（更喜欢方式）\"></a>2.2 安装包方式（更喜欢方式）</h3><p>如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。</p>\n<ol>\n<li>下载安装包：</li>\n</ol>\n<p>打开网址 <em><a href=\"https://download.docker.com/linux/centos/7/x86_64/stable/Packages/\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></em>，下载<code>.rpm</code>合适版本下载。</p>\n<blockquote>\n<p>Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.</p>\n</blockquote>\n<ol start=\"2\">\n<li>安装docker<br>指向包所在路径，如果是更新，把<code>install</code>改成<code>update</code></li>\n</ol>\n<pre><code>$ sudo yum install /path/to/package.rpm\n</code></pre><ol start=\"3\">\n<li><p>启动docker</p>\n<p> $ sudo systemctl start docker</p>\n</li>\n<li><p>验证是否安装成功</p>\n<p> $ sudo docker run hello-world</p>\n</li>\n</ol>\n<img src=\"/2017/11/15/docker-install-centos7/a.png\">\n<p>看到红色标注部分说明安装成功。    </p>\n<ol start=\"5\">\n<li>更新docker-ce<br>下载新的安装包，用<code>yum -y upgrade</code>替换<code>yum -y install</code>,指向新的安装包。    </li>\n</ol>\n<h2 id=\"3-卸载docker-ce\"><a href=\"#3-卸载docker-ce\" class=\"headerlink\" title=\"3. 卸载docker-ce\"></a>3. 卸载docker-ce</h2><ol>\n<li>卸载docker安装包：</li>\n</ol>\n<pre><code>$ sudo yum remove docker-ce\n</code></pre><ol start=\"2\">\n<li>卸载docker安装包不会自动删除相关资源，要手动删除：</li>\n</ol>\n<pre><code>$ sudo rm -rf /var/lib/docker\n</code></pre>"},{"title":"Ubuntu16.0.4安装docker-ce","date":"2018-02-28T01:55:22.000Z","_content":"\n本文介绍在Ubuntu环境下安装Docker ce……\n\n参考：https://docs.docker.com/install/linux/docker-ce/ubuntu/\n\n##  卸载旧版本：\n\n    $ sudo apt-get remove docker docker-engine docker.io\n\n## 安装系统可选内核\n\n参考：\nhttps://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\n\n## 使用 APT 安装\n\n- *更新系统包*\n\n\n    $ sudo apt-get update\n    \n    \n- *添加ca证书*\n\n由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。\n\n    \n    $ sudo apt-get install \\\n        apt-transport-https \\\n        ca-certificates \\\n        curl \\\n        software-properties-common    \n   \n如果出现错误：\n\n    E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\n    E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n\n执行下面命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n    \n然后再重试。\n\n\n- *添加软件源的GPG密钥*\n\n为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。\n\n    $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n    \n\n验证密钥：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\n    pub   4096R/0EBFCD88 2017-02-22\n          Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n    uid                  Docker Release (CE deb) <docker@docker.com>\n    sub   4096R/F273FCD8 2017-02-22\n    \n    mutian@mutian-ThinkPad-T440p:~$ \n\n\n- *添加Docker软件源* \n\n然后,我们需要向source.list\t中添加Docker软件源\n\n    $ sudo add-apt-repository \\\n       \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n       $(lsb_release -cs) \\\n       stable\"\n       \n>以上命令会添加稳定版本的\tDocker\tCE\tAPT\t镜像源,如果需要最新或者测试版本的\nDocker\tCE\t请将\tstable\t改为\tedge\t或者\ttest。从\tDocker\t17.06\t开始,edge\ttest\t版本的\nAPT\t镜像源也会包含稳定版本的\tDocker。 \n\n- *安装DOCKER CE*\n\n1.更新系统包\n\n    $ sudo apt-get update\n    \n2.安装\n\n    $ sudo apt-get install docker-ce    \n\n\n## 镜像加速\n      \n国内从Docker\tHub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker\t官方和国\n内很多云服务商都提供了国内加速器服务,例如:   \n\n- [Docker官方提供的中国registry mirror](https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror)\n- [阿里云加速器](https://cr.console.aliyun.com/#/accelerator)\n- [DaoCloud\t加速器](https://www.daocloud.io/mirror#accelerator-doc) \n\n我们以Docker官方加速器为例进行介绍。\n\nUbuntu16.04+、Debian\t8+、CentOS7环境下：\n\n对于使用\tsystemd\t的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存\n在请新建该文件)\n\n    {\n    \t\t\"registry-mirrors\":\t[\n    \t\t\t\t\"https://registry.docker-cn.com\"\n    \t\t]\n    }\n    \n>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 \n\n之后重新启动服务。\n\n    $\tsudo systemctl daemon-reload\n    $\tsudo systemctl restart docker\n    \n\n## 测试安装是否成功\n\n    $ sudo docker run hello-world\n    \n\n如图出现则表示安装成功：\n\n{% asset_img a.png %}    \n    \n           ","source":"_posts/docker-install-ubuntu16.md","raw":"---\ntitle: Ubuntu16.0.4安装docker-ce\ndate: 2018-02-28 09:55:22\ncategories: docker\ntags: docker ce安装\n---\n\n本文介绍在Ubuntu环境下安装Docker ce……\n\n参考：https://docs.docker.com/install/linux/docker-ce/ubuntu/\n\n##  卸载旧版本：\n\n    $ sudo apt-get remove docker docker-engine docker.io\n\n## 安装系统可选内核\n\n参考：\nhttps://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\n\n## 使用 APT 安装\n\n- *更新系统包*\n\n\n    $ sudo apt-get update\n    \n    \n- *添加ca证书*\n\n由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。\n\n    \n    $ sudo apt-get install \\\n        apt-transport-https \\\n        ca-certificates \\\n        curl \\\n        software-properties-common    \n   \n如果出现错误：\n\n    E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\n    E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n\n执行下面命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n    \n然后再重试。\n\n\n- *添加软件源的GPG密钥*\n\n为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。\n\n    $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n    \n\n验证密钥：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\n    pub   4096R/0EBFCD88 2017-02-22\n          Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n    uid                  Docker Release (CE deb) <docker@docker.com>\n    sub   4096R/F273FCD8 2017-02-22\n    \n    mutian@mutian-ThinkPad-T440p:~$ \n\n\n- *添加Docker软件源* \n\n然后,我们需要向source.list\t中添加Docker软件源\n\n    $ sudo add-apt-repository \\\n       \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n       $(lsb_release -cs) \\\n       stable\"\n       \n>以上命令会添加稳定版本的\tDocker\tCE\tAPT\t镜像源,如果需要最新或者测试版本的\nDocker\tCE\t请将\tstable\t改为\tedge\t或者\ttest。从\tDocker\t17.06\t开始,edge\ttest\t版本的\nAPT\t镜像源也会包含稳定版本的\tDocker。 \n\n- *安装DOCKER CE*\n\n1.更新系统包\n\n    $ sudo apt-get update\n    \n2.安装\n\n    $ sudo apt-get install docker-ce    \n\n\n## 镜像加速\n      \n国内从Docker\tHub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker\t官方和国\n内很多云服务商都提供了国内加速器服务,例如:   \n\n- [Docker官方提供的中国registry mirror](https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror)\n- [阿里云加速器](https://cr.console.aliyun.com/#/accelerator)\n- [DaoCloud\t加速器](https://www.daocloud.io/mirror#accelerator-doc) \n\n我们以Docker官方加速器为例进行介绍。\n\nUbuntu16.04+、Debian\t8+、CentOS7环境下：\n\n对于使用\tsystemd\t的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存\n在请新建该文件)\n\n    {\n    \t\t\"registry-mirrors\":\t[\n    \t\t\t\t\"https://registry.docker-cn.com\"\n    \t\t]\n    }\n    \n>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 \n\n之后重新启动服务。\n\n    $\tsudo systemctl daemon-reload\n    $\tsudo systemctl restart docker\n    \n\n## 测试安装是否成功\n\n    $ sudo docker run hello-world\n    \n\n如图出现则表示安装成功：\n\n{% asset_img a.png %}    \n    \n           ","slug":"docker-install-ubuntu16","published":1,"updated":"2019-06-16T14:38:33.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqb60029g4vadltfsccg","content":"<p>本文介绍在Ubuntu环境下安装Docker ce……</p>\n<p>参考：<a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>\n<h2 id=\"卸载旧版本：\"><a href=\"#卸载旧版本：\" class=\"headerlink\" title=\"卸载旧版本：\"></a>卸载旧版本：</h2><pre><code>$ sudo apt-get remove docker docker-engine docker.io\n</code></pre><h2 id=\"安装系统可选内核\"><a href=\"#安装系统可选内核\" class=\"headerlink\" title=\"安装系统可选内核\"></a>安装系统可选内核</h2><p>参考：<br><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers</a></p>\n<h2 id=\"使用-APT-安装\"><a href=\"#使用-APT-安装\" class=\"headerlink\" title=\"使用 APT 安装\"></a>使用 APT 安装</h2><ul>\n<li><em>更新系统包</em></li>\n</ul>\n<pre><code>$ sudo apt-get update\n</code></pre><ul>\n<li><em>添加ca证书</em></li>\n</ul>\n<p>由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p>\n<pre><code>$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    software-properties-common    \n</code></pre><p>如果出现错误：</p>\n<pre><code>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\nE: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n</code></pre><p>执行下面命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\nmutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n</code></pre><p>然后再重试。</p>\n<ul>\n<li><em>添加软件源的GPG密钥</em></li>\n</ul>\n<p>为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。</p>\n<pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre><p>验证密钥：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\npub   4096R/0EBFCD88 2017-02-22\n      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid                  Docker Release (CE deb) &lt;docker@docker.com&gt;\nsub   4096R/F273FCD8 2017-02-22\n\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><ul>\n<li><em>添加Docker软件源</em> </li>\n</ul>\n<p>然后,我们需要向source.list    中添加Docker软件源</p>\n<pre><code>$ sudo add-apt-repository \\\n   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n</code></pre><blockquote>\n<p>以上命令会添加稳定版本的    Docker    CE    APT    镜像源,如果需要最新或者测试版本的<br>Docker    CE    请将    stable    改为    edge    或者    test。从    Docker    17.06    开始,edge    test    版本的<br>APT    镜像源也会包含稳定版本的    Docker。 </p>\n</blockquote>\n<ul>\n<li><em>安装DOCKER CE</em></li>\n</ul>\n<p>1.更新系统包</p>\n<pre><code>$ sudo apt-get update\n</code></pre><p>2.安装</p>\n<pre><code>$ sudo apt-get install docker-ce    \n</code></pre><h2 id=\"镜像加速\"><a href=\"#镜像加速\" class=\"headerlink\" title=\"镜像加速\"></a>镜像加速</h2><p>国内从Docker    Hub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker    官方和国<br>内很多云服务商都提供了国内加速器服务,例如:   </p>\n<ul>\n<li><a href=\"https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror\" target=\"_blank\" rel=\"noopener\">Docker官方提供的中国registry mirror</a></li>\n<li><a href=\"https://cr.console.aliyun.com/#/accelerator\" target=\"_blank\" rel=\"noopener\">阿里云加速器</a></li>\n<li><a href=\"https://www.daocloud.io/mirror#accelerator-doc\" target=\"_blank\" rel=\"noopener\">DaoCloud    加速器</a> </li>\n</ul>\n<p>我们以Docker官方加速器为例进行介绍。</p>\n<p>Ubuntu16.04+、Debian    8+、CentOS7环境下：</p>\n<p>对于使用    systemd    的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存<br>在请新建该文件)</p>\n<pre><code>{\n        &quot;registry-mirrors&quot;:    [\n                &quot;https://registry.docker-cn.com&quot;\n        ]\n}\n</code></pre><blockquote>\n<p>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 </p>\n</blockquote>\n<p>之后重新启动服务。</p>\n<pre><code>$    sudo systemctl daemon-reload\n$    sudo systemctl restart docker\n</code></pre><h2 id=\"测试安装是否成功\"><a href=\"#测试安装是否成功\" class=\"headerlink\" title=\"测试安装是否成功\"></a>测试安装是否成功</h2><pre><code>$ sudo docker run hello-world\n</code></pre><p>如图出现则表示安装成功：</p>\n<img src=\"/2018/02/28/docker-install-ubuntu16/a.png\">    \n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍在Ubuntu环境下安装Docker ce……</p>\n<p>参考：<a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>\n<h2 id=\"卸载旧版本：\"><a href=\"#卸载旧版本：\" class=\"headerlink\" title=\"卸载旧版本：\"></a>卸载旧版本：</h2><pre><code>$ sudo apt-get remove docker docker-engine docker.io\n</code></pre><h2 id=\"安装系统可选内核\"><a href=\"#安装系统可选内核\" class=\"headerlink\" title=\"安装系统可选内核\"></a>安装系统可选内核</h2><p>参考：<br><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers</a></p>\n<h2 id=\"使用-APT-安装\"><a href=\"#使用-APT-安装\" class=\"headerlink\" title=\"使用 APT 安装\"></a>使用 APT 安装</h2><ul>\n<li><em>更新系统包</em></li>\n</ul>\n<pre><code>$ sudo apt-get update\n</code></pre><ul>\n<li><em>添加ca证书</em></li>\n</ul>\n<p>由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p>\n<pre><code>$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    software-properties-common    \n</code></pre><p>如果出现错误：</p>\n<pre><code>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\nE: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n</code></pre><p>执行下面命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\nmutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n</code></pre><p>然后再重试。</p>\n<ul>\n<li><em>添加软件源的GPG密钥</em></li>\n</ul>\n<p>为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。</p>\n<pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre><p>验证密钥：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\npub   4096R/0EBFCD88 2017-02-22\n      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid                  Docker Release (CE deb) &lt;docker@docker.com&gt;\nsub   4096R/F273FCD8 2017-02-22\n\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><ul>\n<li><em>添加Docker软件源</em> </li>\n</ul>\n<p>然后,我们需要向source.list    中添加Docker软件源</p>\n<pre><code>$ sudo add-apt-repository \\\n   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n</code></pre><blockquote>\n<p>以上命令会添加稳定版本的    Docker    CE    APT    镜像源,如果需要最新或者测试版本的<br>Docker    CE    请将    stable    改为    edge    或者    test。从    Docker    17.06    开始,edge    test    版本的<br>APT    镜像源也会包含稳定版本的    Docker。 </p>\n</blockquote>\n<ul>\n<li><em>安装DOCKER CE</em></li>\n</ul>\n<p>1.更新系统包</p>\n<pre><code>$ sudo apt-get update\n</code></pre><p>2.安装</p>\n<pre><code>$ sudo apt-get install docker-ce    \n</code></pre><h2 id=\"镜像加速\"><a href=\"#镜像加速\" class=\"headerlink\" title=\"镜像加速\"></a>镜像加速</h2><p>国内从Docker    Hub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker    官方和国<br>内很多云服务商都提供了国内加速器服务,例如:   </p>\n<ul>\n<li><a href=\"https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror\" target=\"_blank\" rel=\"noopener\">Docker官方提供的中国registry mirror</a></li>\n<li><a href=\"https://cr.console.aliyun.com/#/accelerator\" target=\"_blank\" rel=\"noopener\">阿里云加速器</a></li>\n<li><a href=\"https://www.daocloud.io/mirror#accelerator-doc\" target=\"_blank\" rel=\"noopener\">DaoCloud    加速器</a> </li>\n</ul>\n<p>我们以Docker官方加速器为例进行介绍。</p>\n<p>Ubuntu16.04+、Debian    8+、CentOS7环境下：</p>\n<p>对于使用    systemd    的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存<br>在请新建该文件)</p>\n<pre><code>{\n        &quot;registry-mirrors&quot;:    [\n                &quot;https://registry.docker-cn.com&quot;\n        ]\n}\n</code></pre><blockquote>\n<p>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 </p>\n</blockquote>\n<p>之后重新启动服务。</p>\n<pre><code>$    sudo systemctl daemon-reload\n$    sudo systemctl restart docker\n</code></pre><h2 id=\"测试安装是否成功\"><a href=\"#测试安装是否成功\" class=\"headerlink\" title=\"测试安装是否成功\"></a>测试安装是否成功</h2><pre><code>$ sudo docker run hello-world\n</code></pre><p>如图出现则表示安装成功：</p>\n<img src=\"/2018/02/28/docker-install-ubuntu16/a.png\">    \n"},{"title":"docker学习-第二课：发布一个web应用","date":"2018-02-02T03:00:11.000Z","_content":"\n介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……\n\n参考网址：https://github.com/docker/labs/tree/master/beginner/\n\n\n","source":"_posts/docker-lesson2.md","raw":"---\ntitle: docker学习-第二课：发布一个web应用\ndate: 2018-02-02 11:00:11\ncategories: docker\ntags: docker镜像创建、docker容器启动、docker发布web应用\n---\n\n介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……\n\n参考网址：https://github.com/docker/labs/tree/master/beginner/\n\n\n","slug":"docker-lesson2","published":1,"updated":"2019-06-16T14:38:33.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqb8002dg4vavj7bs9uu","content":"<p>介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……</p>\n<p>参考网址：<a href=\"https://github.com/docker/labs/tree/master/beginner/\" target=\"_blank\" rel=\"noopener\">https://github.com/docker/labs/tree/master/beginner/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……</p>\n<p>参考网址：<a href=\"https://github.com/docker/labs/tree/master/beginner/\" target=\"_blank\" rel=\"noopener\">https://github.com/docker/labs/tree/master/beginner/</a></p>\n"},{"title":"docker学习-第一课：基础概念理解","date":"2018-02-02T02:16:25.000Z","_content":"\nDocker\t包括三个基本概念\n镜像(Image)\n容器(Container)\n仓库(Repository)\n理解了这三个概念,就理解了\tDocker\t的整个生命周期。\n\n## Docker镜像\ndocker镜像就像是一个只读的模板。 \n\n例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 \n\n镜像可以用来创建容器。甚至多个容器。 \n\nDocker\t提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一\n个已经做好的镜像来直接使用。\n\n## Docker容器\ndocker利用容器来运行应用。 \n\n容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全\n的平台\n\n可以把容器看做是一个简易版的\tLinux\t环境(包括root用户权限、进程空间、用户空间和网络空间等)和运\n行在其中的应用程序。\n\n`注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。`\n\n## Docker仓库\n仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区\n分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的\n标签(tag)。\n\n仓库分为公开仓库(Public)和私有仓库(Private)两种形式。\n\n最大的公开仓库是[Docker\tHub](https://hub.docker.com/),存放了数量庞大的镜像供用户下载。\t国内的公开仓库包括[Docker Pool]()等,可以提供大陆用户更稳定快速的访问。\n\n当然,用户也可以在本地网络内创建一个私有仓库。\n\n当用户创建了自己的镜像之后就可以使用\t \tpush\t \t命令将它上传到公有或者私有仓库,这样下次在另外一台\n机器上使用这个镜像时候,只需要从仓库上\t \tpull\t \t下来就可以了。\n\n`注:Docker\t仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。`\n\n","source":"_posts/docker-lesson1.md","raw":"---\ntitle: docker学习-第一课：基础概念理解\ndate: 2018-02-02 10:16:25\ncategories: docker\ntags: 基础概念\n---\n\nDocker\t包括三个基本概念\n镜像(Image)\n容器(Container)\n仓库(Repository)\n理解了这三个概念,就理解了\tDocker\t的整个生命周期。\n\n## Docker镜像\ndocker镜像就像是一个只读的模板。 \n\n例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 \n\n镜像可以用来创建容器。甚至多个容器。 \n\nDocker\t提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一\n个已经做好的镜像来直接使用。\n\n## Docker容器\ndocker利用容器来运行应用。 \n\n容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全\n的平台\n\n可以把容器看做是一个简易版的\tLinux\t环境(包括root用户权限、进程空间、用户空间和网络空间等)和运\n行在其中的应用程序。\n\n`注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。`\n\n## Docker仓库\n仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区\n分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的\n标签(tag)。\n\n仓库分为公开仓库(Public)和私有仓库(Private)两种形式。\n\n最大的公开仓库是[Docker\tHub](https://hub.docker.com/),存放了数量庞大的镜像供用户下载。\t国内的公开仓库包括[Docker Pool]()等,可以提供大陆用户更稳定快速的访问。\n\n当然,用户也可以在本地网络内创建一个私有仓库。\n\n当用户创建了自己的镜像之后就可以使用\t \tpush\t \t命令将它上传到公有或者私有仓库,这样下次在另外一台\n机器上使用这个镜像时候,只需要从仓库上\t \tpull\t \t下来就可以了。\n\n`注:Docker\t仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。`\n\n","slug":"docker-lesson1","published":1,"updated":"2019-06-16T14:38:33.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqb8002eg4vabjf0of5w","content":"<p>Docker    包括三个基本概念<br>镜像(Image)<br>容器(Container)<br>仓库(Repository)<br>理解了这三个概念,就理解了    Docker    的整个生命周期。</p>\n<h2 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h2><p>docker镜像就像是一个只读的模板。 </p>\n<p>例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 </p>\n<p>镜像可以用来创建容器。甚至多个容器。 </p>\n<p>Docker    提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一<br>个已经做好的镜像来直接使用。</p>\n<h2 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h2><p>docker利用容器来运行应用。 </p>\n<p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全<br>的平台</p>\n<p>可以把容器看做是一个简易版的    Linux    环境(包括root用户权限、进程空间、用户空间和网络空间等)和运<br>行在其中的应用程序。</p>\n<p><code>注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。</code></p>\n<h2 id=\"Docker仓库\"><a href=\"#Docker仓库\" class=\"headerlink\" title=\"Docker仓库\"></a>Docker仓库</h2><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区<br>分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的<br>标签(tag)。</p>\n<p>仓库分为公开仓库(Public)和私有仓库(Private)两种形式。</p>\n<p>最大的公开仓库是<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker    Hub</a>,存放了数量庞大的镜像供用户下载。    国内的公开仓库包括<a href=\"\">Docker Pool</a>等,可以提供大陆用户更稳定快速的访问。</p>\n<p>当然,用户也可以在本地网络内创建一个私有仓库。</p>\n<p>当用户创建了自己的镜像之后就可以使用         push         命令将它上传到公有或者私有仓库,这样下次在另外一台<br>机器上使用这个镜像时候,只需要从仓库上         pull         下来就可以了。</p>\n<p><code>注:Docker    仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Docker    包括三个基本概念<br>镜像(Image)<br>容器(Container)<br>仓库(Repository)<br>理解了这三个概念,就理解了    Docker    的整个生命周期。</p>\n<h2 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h2><p>docker镜像就像是一个只读的模板。 </p>\n<p>例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 </p>\n<p>镜像可以用来创建容器。甚至多个容器。 </p>\n<p>Docker    提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一<br>个已经做好的镜像来直接使用。</p>\n<h2 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h2><p>docker利用容器来运行应用。 </p>\n<p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全<br>的平台</p>\n<p>可以把容器看做是一个简易版的    Linux    环境(包括root用户权限、进程空间、用户空间和网络空间等)和运<br>行在其中的应用程序。</p>\n<p><code>注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。</code></p>\n<h2 id=\"Docker仓库\"><a href=\"#Docker仓库\" class=\"headerlink\" title=\"Docker仓库\"></a>Docker仓库</h2><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区<br>分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的<br>标签(tag)。</p>\n<p>仓库分为公开仓库(Public)和私有仓库(Private)两种形式。</p>\n<p>最大的公开仓库是<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker    Hub</a>,存放了数量庞大的镜像供用户下载。    国内的公开仓库包括<a href=\"\">Docker Pool</a>等,可以提供大陆用户更稳定快速的访问。</p>\n<p>当然,用户也可以在本地网络内创建一个私有仓库。</p>\n<p>当用户创建了自己的镜像之后就可以使用         push         命令将它上传到公有或者私有仓库,这样下次在另外一台<br>机器上使用这个镜像时候,只需要从仓库上         pull         下来就可以了。</p>\n<p><code>注:Docker    仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。</code></p>\n"},{"title":"docker学习-第三课：镜像","date":"2018-02-02T13:36:08.000Z","_content":"\nDocker\t运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker\t会从镜像仓库下载(默认是\nDocker\tHub\t公共注册服务器中的仓库)。\n\n本章将介绍更多关于镜像的内容,包括:\n- 从仓库获取镜像;\n- 管理本地主机上的镜像;\n- 介绍镜像实现的基本原理。\n\n## 获取镜像\n\n在官方[Docker Hub](https://hub.docker.com/explore/)有大量高质量可用镜像。下面我们来看怎样获取这些镜像。\n\n从Docker\t镜像仓库获取镜像的命令是docker\tpull。其命令格式为: \n\n    docker pull\t[选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n\n具体的先选可以通过`docker pull\t--help`命令查看。镜像名称的格式：\n\n- Docker 镜像仓库地址:地址的格式一般是`<域名/IP>[:端口号]`。默认地址是Docker Hub。\n- 仓库名:如之前所说,这里的仓库名是两段式名称,即`<用户名>/<软件名>`。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。\n\n比如:\n\n    $\tdocker\tpull\tubuntu:16.04\n    16.04:\tPulling\tfrom\tlibrary/ubuntu\n    bf5d46315322:\tPull\tcomplete\n    9f13e0ac480c:\tPull\tcomplete\n    e8988b5b3097:\tPull\tcomplete\n    40af181810e7:\tPull\tcomplete\n    e6f7c7e5c03e:\tPull\tcomplete\n    Digest:\tsha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\n    Status:\tDownloaded\tnewer\timage\tfor\tubuntu:16.04\n    \n上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04\t,因此将会获取官方镜像library/ubuntu\t仓库中标签为16.04的镜像。    \n\n例子： \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n    [sudo] password for mutian: \n    Using default tag: latest\n    latest: Pulling from library/centos\n    af4b0a2388c6: Pull complete \n    Digest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n    Status: Downloaded newer image for centos:latest\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n\n## 运行\n\n有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。\n\n`sudo docker run -it --rm centos bash`\n\n    [root@5f6c0a6b41c1 ~]# cat /etc/os-release \n    NAME=\"CentOS Linux\"\n    VERSION=\"7 (Core)\"\n    ID=\"centos\"\n    ID_LIKE=\"rhel fedora\"\n    VERSION_ID=\"7\"\n    PRETTY_NAME=\"CentOS Linux 7 (Core)\"\n    ANSI_COLOR=\"0;31\"\n    CPE_NAME=\"cpe:/o:centos:centos:7\"\n    HOME_URL=\"https://www.centos.org/\"\n    BUG_REPORT_URL=\"https://bugs.centos.org/\"\n    \n    CENTOS_MANTISBT_PROJECT=\"CentOS-7\"\n    CENTOS_MANTISBT_PROJECT_VERSION=\"7\"\n    REDHAT_SUPPORT_PRODUCT=\"centos\"\n    REDHAT_SUPPORT_PRODUCT_VERSION=\"7\"\n    \n    [root@5f6c0a6b41c1 ~]# \n\n通过上面信息我们可以看到容器内系统信息。\n\n命令说明：\n\n`docker\trun`就是运行容器的命令,具体格式我们会在\t容器\t一节进行详细讲解,我们这里简要的说明一下上面用到的参数。\n\n- `-it`:这是两个参数,一个是`-i`:交互式操作,一个是`-t`终端。我们这里打算进入`bash`执行一些命令并查看返回结果,因此我们需要交互式终端。\n- `--rm`:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动`docker\trm`。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用`--rm`可以避免浪费空间。\n- `centos`:这是指用`centos`镜像为基础来启动容器。\n- `bash`:放在镜像名后的是命令,这里我们希望有个交互式`Shell`,因此用的是`bash`。\n\n进入系统后我们可以执行任何linux下的命令。\n\n最后我们通过`exit`退出了这个容器。\n退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了`--rm`命令。\n\n## 列出所有的镜像\n\n想列出所有已经下载的镜像，可以使用命令`docker\timage ls`\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    [sudo] password for mutian: \n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest              f2a91732366c        3 months ago        1.85kB\n\n\n上面列表包含了`仓库名`、`标签`、`镜像ID`、`创建时间`以及所占用空间。\n镜像\tID\t则是镜像的唯一标识,一个镜像可以对应多个标签。\n\n- 镜像体积SIZE：\n上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比\n每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。\n\n你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\n    TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\n    Images              2                   1                   207.2MB             207.2MB (99%)\n    Containers          1                   0                   0B                  0B\n    Local Volumes       0                   0                   0B                  0B\n    Build Cache \n\n\n- 虚悬镜像\n\n{%asset_img a.png %}\n\n如上图，命令查出来的就是虚悬镜像。其产生的原因是：\n由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。\n\n这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：\n\n    $ sudo docker image\tprune\n\n- 中间层镜像\n为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可\n能会看到一些依赖的中间层镜像。默认的`docker image\tls`列表中只会显示顶层镜像,如果\n希望显示包括中间层镜像在内的所有镜像的话,需要加\t`-a`参数。\n\n\n    $ sudo docker image ls -a\n\n这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 \n\n- 列出部分镜像\n上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。\n\n根据仓库名称列出镜像：\n    \n    sudo docker image ls centos\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n\n列出特定的某个镜像,也就是说指定仓库名和标签\n\n{%asset_img b.png%}\n\n过滤查找镜像，使用`--filter`。具体使用请百度。\n\n- 以特定格式显示\n\n只显示ID列：\n\n    sudo docker image ls -q\n    ff426288ea90\n    f2a91732366c\n\n用go模板语法定制格式显示\n比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"{{.ID}}:{{.Repository}}\"\n    ff426288ea90:centos\n    f2a91732366c:hello-world\n\n或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n    IMAGE ID            REPOSITORY          TAG\n    ff426288ea90        centos              latest\n    f2a91732366c        hello-world         latest\n\n## 删除本地镜像\n\n可以使用`docker\timage\trm`命令来删除本地镜像。格式如下：\n\n    $\tdocker image rm [选项] <镜像1> [<镜像2> ...]\n\n- 用\tID、镜像名、摘要删除镜像\n\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest        \n\n    #删除hello-world，段id，id一部分，能区分就行。\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n\n用仓库名删除：\n    \n    $ sudo docker image\trm\thello-world    \n\n当然,更精确的是使用镜像摘要删除镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n\n- 用\t`docker\timage\tls`命令来配合\n\n比如,我们需要删除所有仓库名为redis的镜像:\n\n    $ docker image rm $(docker image ls -q redis)\n\n## 利用commit理解镜像构成\n镜像是一层一层构成的。\n\n现在让我们以定制一个Web\t服务器为例子,来讲解镜像是如何构建的。\n\n    docker run --name webserver -d -p 80:80 nginx\n\n在浏览器可查看：\n\n{%asset_img c.png%}\n\n现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎\tDocker的文字,我们可以使用`docker\texec`命令进入容器,修改其内容 \n\n    > sudo docker exec -it webserver bash\n    root@3729b97e8226:/# echo '<h1>Hello,Docker!</h1>' >\t/usr/share/nginx/html/index.html\n    root@3729b97e8226:/#\texit\n\n然后刷新浏览器，就可以看到更改了。\n\n我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过`docker\tdiff`命令看到具体的改动。\n\n下面我们可以用下面的命令将容器保存为镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n    > --author \"zmt\" \\\n    > --message \"修改了默认页面\" \\\n    > webserver \\\n    > nginx:v2\n    sha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n    \n    #查看\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               v2                  e8023c09eed5        8 seconds ago       109MB\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest  \n\n查看镜像内历史记录：\n\n    $ docker history nginx:v2\n\n新的镜像定制好后,我们可以来运行这个镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n\n\n在浏览器查看：http://localhost:81/\n\n停止容器：`sudo docker kill --signal=SIGINT web2`\n    \n至此,我们第一次完成了定制镜像,使用的是`docker\tcommit`命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。\n\n> 注意：通常不会使用`docker commit`来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。\n\n## 使用Dockerfile定制镜像\n从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。\n\nDockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,\n因此每一条指令的内容,就是描述该层应当如何构建。\n\n### 简单例子：\n\n1.创建Dockerfile文件\n\n    mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\n    mutian@mutian-ThinkPad-T440p:~$ cd mynginx/\n    mutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n\n2.打开Dockerfile文件，编辑如下内容：\n    \n    FROM nginx\n    RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n\n3.构建镜像\n进入Dockerfile所在目录，执行命令：\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\n    Sending build context to Docker daemon  2.048kB\n    Step 1/2 : FROM nginx\n     ---> e548f1a579cf\n    Step 2/2 : RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n     ---> Running in d8c0149adf7e\n    Removing intermediate container d8c0149adf7e\n     ---> b92f375b41f0\n    Successfully built b92f375b41f0\n    Successfully tagged nginx:v3\n\n4.查看\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\n    nginx               v3                  b92f375b41f0        About a minute ago   109MB\n    nginx               v2                  e8023c09eed5        17 hours ago         109MB\n    nginx               latest              e548f1a579cf        8 days ago           109MB\n    centos              latest              ff426288ea90        7 weeks ago          207MB\n    hello-world         latest              f2a91732366c        3 months ago    \n    \n我们看到，TAG为v3的镜像就是我们刚才构建。    \n\n### FROM指定基础镜像\n\n定制镜像必须是以一个镜像为基础来构建，基础镜像是必须要指定的，而FROM命令就是指定基础镜像，且第一步就要指定。   \n\n除了选择一些先前定制好的镜像作为基础镜像，Docker还存在一个特殊的镜像，名为`scratch`，表示空镜像，是个虚拟的概念，不实际存在。\n\n    FROM\tscratch\n    ...\n    \n如果以`scratch`为基础，则意味着不以任何镜像为基础，后面所写的命令将作为镜像的第一层存在。\n\n对于一些二进制的可执行文件，直接最为第一层存在，不依赖其它运行时系统支持，可以用空镜像。类似go语言编译的程序。\n\n### RUN 执行命令\n\nRUN命令是用来执行命令行命令的，就像shell脚本一样，用来执行linux命令。\n\n注意避免错误：\n\n    FROM\tdebian:jessie\n    RUN\tapt-get\tupdate\n    RUN\tapt-get\tinstall\t-y\tgcc\tlibc6-dev\tmake\n    RUN\twget\t-O\tredis.tar.gz\t\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\n    RUN\tmkdir\t-p\t/usr/src/redis\n    RUN\ttar\t-xzf\tredis.tar.gz\t-C\t/usr/src/redis\t--strip-components=1\n    RUN\tmake\t-C\t/usr/src/redis\n    RUN\tmake\t-C\t/usr/src/redis\tinstall\n    \n每一个指令都会创建一层，每层都会带有上层垃圾，因此一定要避免这样写。正确的写法如下： \n\n    FROM\tdebian:jessie\n    RUN\tbuildDeps='gcc\tlibc6-dev\tmake'\t\\\n    \t\t\t\t&&\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\t$buildDeps\t\\\n    \t\t\t\t&&\twget\t-O\tredis.tar.gz\t\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\t\\\n    \t\t\t\t&&\tmkdir\t-p\t/usr/src/redis\t\\\n    \t\t\t\t&&\ttar\t-xzf\tredis.tar.gz\t-C\t/usr/src/redis\t--strip-components=1\t\\\n    \t\t\t\t&&\tmake\t-C\t/usr/src/redis\t\\\n    \t\t\t\t&&\tmake\t-C\t/usr/src/redis\tinstall\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\t\\\n    \t\t\t\t&&\trm\tredis.tar.gz\t\\\n    \t\t\t\t&&\trm\t-r\t/usr/src/redis\t\\\n    \t\t\t\t&&\tapt-get\tpurge\t-y\t--auto-remove\t$buildDeps\n    \t\t\t\t\n用了`&&`，这和`shell`执行命令一样，就相当一个命令，所以算一层。执行完后，一定要记得删除不必要的垃圾数据，垃圾包。  \n在编写`Dockerfile`时候，一定要面向类似事件的思维，比如，安装redis环境，是一个事件，算一层。安装mysql，算一个事件，一层。  \n\n## Dockerfile指令详解 \n\n上面我们已经了解了`From`、`RUN`指令，下面我们来介绍其余的……\n\n### COPY复制文件\n\n格式：\n\n- `COPY\t<源路径>...\t<目标路径>`\n\n- `COPY\t[\"<源路径1>\",...\t\"<目标路径>\"]`\n\n源路径指当前电脑系统文件路径，目标路径指容器的文件路径。  \n\n`COPY`指令将从构建上下文目录中<源路径>的文件/目录复制到新的一层的镜像内的<目标路\n径>位置。比如:  \n\n    COPY\tpackage.json\t/usr/src/app/\n    \n`<源路径>`可以是多个，甚至可以是通配符，只要满足`GO`的[filepath.Match](https://golang.org/pkg/path/filepath/#Match)规则，如： \n\n    COPY\thom*\t/mydir/\n    COPY\thom?.txt\t/mydir/\n    \n`<目标路径>` 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）       \n\n_注意一点_： \n\n使用\t`COPY`指令,源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。\n   \t\t\n\n### ADD\t更高级的复制文件   \n\n`ADD`指令和`COPY`指令本质上是一样的，只是添加了更多功能。 它的源文件可以是个url，也可以是tar，如果是tar还可以自动解压。  \n\n但是，如果是url，下载下来后，还要新建一层解压，授权，因此不如用`COPY` ，然后用`wget`命令。  \n\n在某个场景下，自动解压缩功能非常有用。 如： \n\n    FROM\tscratch\n    ADD\tubuntu-xenial-core-cloudimg-amd64-root.tar.gz\t/\n    ...\n    \n_注意_：  \n\n在`COPY`\t和`ADD`指令中选择的时候,可以遵循这样的原则,所有的文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD。 \n\n### CMD容器启动命令\n\n也有两种格式：\n\n- `shell`格式：`CMD <命令>`\n- `exec`格式：`CMD\t[\"可执行文件\",\t\"参数1\",\t\"参数2\"...]`    \n- 参数列表格式: \t`CMD\t[\"参数1\",\t\"参数2\"...]`\t 。在指定了`ENTRYPOINT`指令后,用`CMD`指定具体的参数。\n\n在指令格式上，推荐`exec`格式。  \n\nDocker不是虚拟机，只是一个进程。因此，在容器中启动程序，不要以后台形式启动，要以前台形式启动。   \n容器内没有后台概念。 \n\n不要这样启动：\n\n`CMD service ginx start`\n\n直接启动可执行文件，并以前台形式启动：\n\n`CMD [\"nginx\",\"-g\",\"daemon off;\"]`\n\n### ENTRYPOINT入口点\n\n也分为：`exec`格式和`shell`格式\n\n当指定了`ENTRYPOINT`后，就会把`CMD`的内容作为参数传给`ENTRYPOINT\t`指令，换句话说实际执行时，将变为：\n\n    <ENTRYPOINT>\t\"<CMD>\"\n\n_场景一_：\n把镜像当成命令一样使用。\n\n    FROM\tubuntu:16.04\n    RUN\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\tcurl\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\n    CMD\t[\t\"curl\",\t\"-s\",\t\"http://ip.cn\"\t]\n    \n执行：\n\n    $\tdocker\trun\tmyip\n    当前\tIP:61.148.226.66\t来自:北京市\t联通    \n\n再执行：\n    \n    $\tdocker\trun\tmyip\t-i\n    docker:\tError\tresponse\tfrom\tdaemon:\tinvalid\theader\tfield\tvalue\t\"oci\truntime\terror:\tcon\n    tainer_linux.go:247:\tstarting\tcontainer\tprocess\tcaused\t\\\"exec:\t\\\\\\\"-i\\\\\\\":\texecutable\t\n    file\tnot\tfound\tin\t$PATH\\\"\\n\".\n\n可以看到，报错了，因为`-i`不能参数不能传到`CMD`上去。\n\n正确方式：\n\n    FROM\tubuntu:16.04\n    RUN\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\tcurl\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\n    ENTRYPOINT\t[\t\"curl\",\t\"-s\",\t\"http://ip.cn\"\t]\n    \n执行：\n\n    $\tdocker\trun\tmyip\n    当前\tIP:61.148.226.66\t来自:北京市\t联通\n    \n    $\tdocker\trun\tmyip\t-i\n    HTTP/1.1\t200\tOK\n    Server:\tnginx/1.8.0\n    Date:\tTue,\t22\tNov\t2016\t05:12:40\tGMT\n    Content-Type:\ttext/html;\tcharset=UTF-8\n    Vary:\tAccept-Encoding\n    X-Powered-By:\tPHP/5.6.24-1~dotdeb+7.1\n    X-Cache:\tMISS\tfrom\tcache-2\n    X-Cache-Lookup:\tMISS\tfrom\tcache-2:80\n    X-Cache:\tMISS\tfrom\tproxy-2_6\n    Transfer-Encoding:\tchunked\n    Via:\t1.1\tcache-2:80,\t1.1\tproxy-2_6:8006\n    Connection:\tkeep-alive\n    当前\tIP:61.148.226.66\t来自:北京市\t联通\n    \n可以看到,这次成功了。这是因为当存在`ENTRYPOINT`后,`CMD`的内容将会作为参数传给`ENTRYPOINT`,而这里`-i`就是新的`CMD`,因此会作为参数传给`curl`,从而达到了我们预`期的效果。      \n\n_场景二_：\n\n在应用程序启动前等做一些初始化工作。 \n\n比如启动redis，不以`root`，而以`redis`用户身份启动。 \n\n    FROM alpine:3.4\n    ...\n    RUN addgroup -S\tredis && adduser -S -G redis redis\n    ...\n    ENTRYPOINT [\"docker-entrypoint.sh\"]\n    EXPOSE\t6379\n    CMD [\"redis-server\"]\n    \n可以看到其中为了`redis`服务创建了`redis\t`用户,并在最后指定了`ENTRYPOINT`为`docker-entrypoint.sh`脚本。   \n\n    #!/bin/sh\n    ...\n    #allow the container to be started with\t`--user`\n    if [\"$1\" = 'redis-server' -a \"$(id -u)\"\t= '0'];\tthen\n    \t\t\t\tchown -R redis\t.\n    \t\t\t\texec su-exec redis \"$0\" \"$@\"\n    fi\n    exec \"$@\"\n    \n执行：\n\n    $ docker run -it redis id\n    uid=0(root) gid=0(root) groups=0(root)\n    \n### ENV\t设置环境变量\n\n格式有两种:\n\n- `ENV\t<key>\t<value>\t`    \n- `\tENV\t<key1>=<value1>\t<key2>=<value2>...`  \n\n如：\n    \n    ENV\tVERSION=1.0\tDEBUG=on \\\n    \tNAME=\"Happy\tFeet\"   \n    \t\n这里展示了用法，还展示了换行，有空格的话用双引号。 \n\n定义了变量，后面的命令中就可以使用了。可以使用它的命令如下一些： \n\n    ADD\t 、 \tCOPY\t 、 \tENV\t 、 \tEXPOSE\t 、 \tLABEL\t 、 \tUSER\t 、 \tWORKDIR\t 、 \tVOLUME\t 、 \tSTOPSIGNAL\t 、 \tONBU\n    ILD\t\n    \nnode官方Dockerfile例子：\n\n    ENV\tNODE_VERSION\t7.2.0\n    RUN\tcurl\t-SLO\t\"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta\n    r.xz\"\t\\\n    \t\t&&\tcurl\t-SLO\t\"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\"\t\\\n    \t\t&&\tgpg\t--batch\t--decrypt\t--output\tSHASUMS256.txt\tSHASUMS256.txt.asc\t\\\n    \t\t&&\tgrep\t\"\tnode-v$NODE_VERSION-linux-x64.tar.xz\\$\"\tSHASUMS256.txt\t|\tsha256sum\t-c\t-\t\\\n    \t\t&&\ttar\t-xJf\t\"node-v$NODE_VERSION-linux-x64.tar.xz\"\t-C\t/usr/local\t--strip-components=\n    1\t\\\n    \t\t&&\trm\t\"node-v$NODE_VERSION-linux-x64.tar.xz\"\tSHASUMS25    \n    \t\n可以看到，定义了变量，后面就可以不断重复引入使用。改变的时候，只需要改一个地方。同时可以创建不同的多个镜像。 \n\n### ARG\t构建参数\n\n构建参数和`ENV`的效果一样,都是设置环境变量。所不同的是,`ARG`所设置的构建环境的环境变量,在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用`ARG`保存密码之类的信息,因为`docker\thistory`还是可以看到所有值的。 \n\n### VOLUME\t定义匿名卷\n\n两种格式：\n\n- `VOLUME\t[\"<路径1>\",\t\"<路径2>\"...]`\n- `VOLUME\t<路径>`\n\n不应该在容器存储层发生写操作。这样容器就能保持无状态的。对于动态数据，文件，我们应该保存到卷中。为了防止用户在运行时将动态文件写到存储层， \n所以要预先指定动态文件写入的目录挂载为卷，如下： \n\n    VOLUME\t/data\n    \n这里，指定`/data`为匿名卷，任何写入该目录下的数据都不会写入到容器存储层。这样容器就是无状态的。可以运行时替换掉所挂载卷： \n\n    docker\trun\t-d\t-v\tmydata:/data\txxxx\n    \n在这行命令中,就使用了`mydata`这个命名卷挂载到了`/data`这个位置,替代了`Dockerfile`中定义的匿名卷的挂载配置。  \n\n### EXPOSE\t声明端口\n\n格式：`EXPOSE\t<端口1>\t[<端口2>...]\t`    \n\n`EXPOSE`指令是声明运行时容器提供服务端口,这只是一个声明,在运行时并不会因为这个声明应用就会开启这个端口的服务。   \n\n要将`EXPOSE`和在运行时使用`-p\t<宿主端口>:<容器端口>`区分开来。`-p\t`,是映射宿主端口和容器端口,换句话说,就是将容器的对应端口服务公开给外界访问,而`EXPOSE`仅仅是声明容器打算使用什么端口而已,并不会自动在宿主进行端口映射。\n\n### WORKDIR指定工作目录\n\n格式：`WORKDIR\t<工作目录路径>`\n\n该命令可以指定工作目录（当前目录），后面各层都使用该指定目录。该目录如果不存在，则会创建空目录。\n\n写`Dockerfile`千万不能按照`shell`的思维写，应为`docker`是分层的。比如下面错误写法：\n\n     RUN cd /app\n     RUN echo \"hello\" > world.txt\n     \n构建后，你会发现找不到`/app/world.txt`文件。原因是：在`shell`中执行命令，是在同一进程中，操作的是同样的内存。但是在`docker`中不是。你知道，每一个`RUN`命令都是构建一层的，启动不同的容器。第一次`RUN`只是操作进入`/app`目录，没有操作任何文件变更，只是内存的变化而已，第二次启动了个新的容器，跟第一层的容器完全没关系了。\n所以：在写`Dockerfile`到时候，一定要有分层的思维，每一个完整的操作要在同一层里面做。\n\n如果要改变以后各层的工作目录都在指定的工作目录，那么`WORKDIR`指令就派上用场了。\n\n### `USER`指定当前用户\n\n格式:`USER <用户名>`  用户名系统已经添加好\n\n和`WORKDIR`一样，都会影响后面的每一层。改变执行后面命令的执行身份。\n\n下面建立用户，并切换到该用户，启动`redis`：\n\n    RUN groupadd -r redis && useradd -r -g redis edis\n    USER redis\n    RUN [\"redis-server\"]\n\n如果以`root`执行脚本，在执行期间想切换用户，可以参考下面做法：\n\n    # 建立redis用户,并使用gosu换另一个用户执行命令\n    RUN groupadd -r redis && useradd -r -g redis redis\n    #下载gosu\n    RUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.7/\n    gosu-amd64\" \\\n        && chmod +x /usr/local/bin/gosu\t\\\n            && gosu nobody true\n    #设置CMD,并以另外的用户执行\n    CMD [\"exec\",\"gosu\",\"redis\",\"redis-server\"]\n    \n`gosu`使用更多信息参考：https://github.com/tianon/gosu\n\n### HEALTHCHECK 健康检查    \n\n格式：\n- `HEALTHCHECK [选项] CMD <命令>`:设置检查容器健康状况的命令\t\n- `HEALTHCHECK NONE`:如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令。\n\n该指令是告诉`Docker`应该如何进行判断容器的状态是否正常。\n\n### ONBUILD\t为他人做嫁衣裳\n\n格式: `ONBUILD <其它指令>\t`\n\n`ONBUILD` 后面的指令，在当前镜像构建的时候是不会执行的，只有以它所在的镜像为基础镜像的镜像在构建的时候才会执行。 \n\n`Docker`中其它的命令都是为了定制当前的镜像准备的，只有`ONBUILD`是为了他人而准备。   \n\n所以，这里就可以看出，该指令可以用来做命令的继承。类似`maven`中的父`pom`。把`ONBUILD`后面的命令都看做各个子`Dockerfile`的共用命令。\n\n    FROM node:slim\n    RUN mkdir /app\n    WORKDIR\t/app\n    ONBUILD\tCOPY ./package.json /app\n    ONBUILD RUN [\"npm\",\t\"install\"]\n    ONBUILD\tCOPY . /app/\n    CMD [\"npm\", \"start\"]\n    \n 后面每一个子`Dockerfile`只需要以上面镜像伟基础镜像:\n \n    FROM my-node  \n    \n这样，`ONBUILD`后面的指令都会在每个子`Dockerfile`中执行。     \n\n\n## 删除本地镜像\n\n可以使用命令`docker rmi`，格式：\n\n    `docker\trmi\t[选项]\t<镜像1>\t[<镜像2>\t...]`\n    \n    _注意_: docker rm 命令是删除容器,不要混淆。\n\n可以用ID、镜像名、摘要删除镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker images\n    [sudo] password for mutian: \n    REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\n    mysql/mysql-server   latest              02d081b9c73e        2 months ago        300MB\n    nginx                v3                  b92f375b41f0        4 months ago        109MB\n    nginx                v2                  e8023c09eed5        4 months ago        109MB\n    nginx                latest              e548f1a579cf        4 months ago        109MB\n    centos               latest              ff426288ea90        5 months ago        207MB\n    hello-world          latest              f2a91732366c        7 months ago        1.85kB\n    season/fastdfs       latest              c6cc94c34f8e        2 years ago         205MB\n\n1. 用短id删除，人工输入的时候使用，方便：\n\n`$\tdocker\trmi\tff4`\n\n2. 用长id，一般使用脚本的时候：\n\n`$\tdocker\trmi\tf2a91732366c`\n\n3. 用镜像名,`<仓库名>:<标签>`：\n\n`docker\trmi\tnginx：v3`\n\n4. 使用摘要，最精确： \n    \n查看摘要：\n    \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker images --digests\n    REPOSITORY           TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE\n    mysql/mysql-server   latest              sha256:f1cb1e3f0124601b1496f485e9f4401ad10138294b5a38d932089daafd555e34   02d081b9c73e        2 months ago        300MB\n    nginx                v3                  <none>                                                                    b92f375b41f0        4 months ago        109MB\n    nginx                v2                  <none>                                                                    e8023c09eed5        4 months ago        109MB\n    nginx                latest              sha256:4771d09578c7c6a65299e110b3ee1c0a2592f5ea2618d23e4ffe7a4cab1ce5de   e548f1a579cf        4 months ago        109MB\n    centos               latest              sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce   ff426288ea90        5 months ago        207MB\n    hello-world          latest              sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7   f2a91732366c        7 months ago        1.85kB\n    season/fastdfs       latest              sha256:408acdebaa278e8ed875f7c63aa0c7ac8e633cf92f615d8295d279e137217003   c6cc94c34f8e        2 years ago         205MB\n\n    \n删除：\n\n    docker rmi centos@sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n \n\n### Untagged和Deleted\n\n仔细观察，发现两种删除行为。\n\n实际上，镜像都是一层层的，一个镜像有多个标签，只有每个标签都取消了，才有可能删除镜像。删除的时候从上最上层往下，逐步判断删除。 \n\n### 用`docker images`命令来配合\n\n配合`docker\timages\t-q`，可以成批的删除你想要删除的镜像，可以指定你想要删除的镜像。\n\n删除虚悬镜像：\n\n`$\tdocker\trmi\t$(docker\timages\t-q\t-f\tdangling=true)`\n\n删除所有仓库名为redis的镜像:\n\n`$\tdocker\trmi\t$(docker\timages\t-q\tredis)`\n\n删除所有在mongo:3.2之前的镜像:\n\n`$\tdocker\trmi\t$(docker\timages\t-q\t-f\tbefore=mongo:3.2)`\n\n\n### docker image\n\n后面版本，推荐使用`docker image`来管理镜像。\n\n如删除：\n\n`$\tdocker\timage\trm`\n\n## 基于本地模板导入导出镜像\n\n## 把镜像上传到docker公共仓库\n\nhttps://hub.docker.com\n\n现在上面网址中注册：\n\n{% asset_img b-1.png %}\n\n1.登录docker\n\n    [root@xr-server-dev ~]# docker login \n    Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\n    Username: xinxiamu\n    Password: \n    Login Succeeded\n\n2.对本地自定义的docker镜像打标签，必须先打标签：\n\n    [root@xr-server-dev ~]# docker tag fastdfs-server:v1 xinxiamu/fdfs-server:0.1\n    \n3.上传到hub.docker.com:\n\n    [root@xr-server-dev ~]# docker push xinxiamu/fdfs-server:0.1\n    The push refers to repository [docker.io/xinxiamu/fdfs-server]\n    77f438662c4e: Pushed \n    7051cce03d08: Pushed \n    47262386cb42: Pushed \n    89b5ef66bef1: Pushed \n    6498ec7e0c6f: Pushed \n    939591e6b702: Pushed \n    d99d7b3f4b3f: Pushed \n    e5f0ae3c8627: Pushed \n    79332ca36cf7: Pushed \n    d69483a6face: Pushed \n    0.1: digest: sha256:811bc129bc6da0fe648e8dc4388dac39db592d86c14f4df87b2b70fc13b80fb5 size: 2403\n\n刷新页面可以看到已经上传：\n\n{% asset_img b-2.png %}        \n\n## 把镜像上传到私服\n\n后面章节有介绍……\n\n## 镜像的实现原理\n\n[UnionFS](https://en.wikipedia.org/wiki/UnionFS)\n\n## 配置镜像加速器\n\n注册阿里云账号后，即可在阿里云控制台（https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。\n\n{% asset_img yy.png %}\n\n按照上图说明配置即可。 \n\n   ","source":"_posts/docker-lesson3-images.md","raw":"---\ntitle: docker学习-第三课：镜像\ndate: 2018-02-02 21:36:08\ncategories: docker\ntags: docker镜像\n---\n\nDocker\t运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker\t会从镜像仓库下载(默认是\nDocker\tHub\t公共注册服务器中的仓库)。\n\n本章将介绍更多关于镜像的内容,包括:\n- 从仓库获取镜像;\n- 管理本地主机上的镜像;\n- 介绍镜像实现的基本原理。\n\n## 获取镜像\n\n在官方[Docker Hub](https://hub.docker.com/explore/)有大量高质量可用镜像。下面我们来看怎样获取这些镜像。\n\n从Docker\t镜像仓库获取镜像的命令是docker\tpull。其命令格式为: \n\n    docker pull\t[选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n\n具体的先选可以通过`docker pull\t--help`命令查看。镜像名称的格式：\n\n- Docker 镜像仓库地址:地址的格式一般是`<域名/IP>[:端口号]`。默认地址是Docker Hub。\n- 仓库名:如之前所说,这里的仓库名是两段式名称,即`<用户名>/<软件名>`。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。\n\n比如:\n\n    $\tdocker\tpull\tubuntu:16.04\n    16.04:\tPulling\tfrom\tlibrary/ubuntu\n    bf5d46315322:\tPull\tcomplete\n    9f13e0ac480c:\tPull\tcomplete\n    e8988b5b3097:\tPull\tcomplete\n    40af181810e7:\tPull\tcomplete\n    e6f7c7e5c03e:\tPull\tcomplete\n    Digest:\tsha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\n    Status:\tDownloaded\tnewer\timage\tfor\tubuntu:16.04\n    \n上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04\t,因此将会获取官方镜像library/ubuntu\t仓库中标签为16.04的镜像。    \n\n例子： \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n    [sudo] password for mutian: \n    Using default tag: latest\n    latest: Pulling from library/centos\n    af4b0a2388c6: Pull complete \n    Digest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n    Status: Downloaded newer image for centos:latest\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n\n## 运行\n\n有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。\n\n`sudo docker run -it --rm centos bash`\n\n    [root@5f6c0a6b41c1 ~]# cat /etc/os-release \n    NAME=\"CentOS Linux\"\n    VERSION=\"7 (Core)\"\n    ID=\"centos\"\n    ID_LIKE=\"rhel fedora\"\n    VERSION_ID=\"7\"\n    PRETTY_NAME=\"CentOS Linux 7 (Core)\"\n    ANSI_COLOR=\"0;31\"\n    CPE_NAME=\"cpe:/o:centos:centos:7\"\n    HOME_URL=\"https://www.centos.org/\"\n    BUG_REPORT_URL=\"https://bugs.centos.org/\"\n    \n    CENTOS_MANTISBT_PROJECT=\"CentOS-7\"\n    CENTOS_MANTISBT_PROJECT_VERSION=\"7\"\n    REDHAT_SUPPORT_PRODUCT=\"centos\"\n    REDHAT_SUPPORT_PRODUCT_VERSION=\"7\"\n    \n    [root@5f6c0a6b41c1 ~]# \n\n通过上面信息我们可以看到容器内系统信息。\n\n命令说明：\n\n`docker\trun`就是运行容器的命令,具体格式我们会在\t容器\t一节进行详细讲解,我们这里简要的说明一下上面用到的参数。\n\n- `-it`:这是两个参数,一个是`-i`:交互式操作,一个是`-t`终端。我们这里打算进入`bash`执行一些命令并查看返回结果,因此我们需要交互式终端。\n- `--rm`:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动`docker\trm`。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用`--rm`可以避免浪费空间。\n- `centos`:这是指用`centos`镜像为基础来启动容器。\n- `bash`:放在镜像名后的是命令,这里我们希望有个交互式`Shell`,因此用的是`bash`。\n\n进入系统后我们可以执行任何linux下的命令。\n\n最后我们通过`exit`退出了这个容器。\n退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了`--rm`命令。\n\n## 列出所有的镜像\n\n想列出所有已经下载的镜像，可以使用命令`docker\timage ls`\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    [sudo] password for mutian: \n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest              f2a91732366c        3 months ago        1.85kB\n\n\n上面列表包含了`仓库名`、`标签`、`镜像ID`、`创建时间`以及所占用空间。\n镜像\tID\t则是镜像的唯一标识,一个镜像可以对应多个标签。\n\n- 镜像体积SIZE：\n上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比\n每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。\n\n你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\n    TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\n    Images              2                   1                   207.2MB             207.2MB (99%)\n    Containers          1                   0                   0B                  0B\n    Local Volumes       0                   0                   0B                  0B\n    Build Cache \n\n\n- 虚悬镜像\n\n{%asset_img a.png %}\n\n如上图，命令查出来的就是虚悬镜像。其产生的原因是：\n由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。\n\n这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：\n\n    $ sudo docker image\tprune\n\n- 中间层镜像\n为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可\n能会看到一些依赖的中间层镜像。默认的`docker image\tls`列表中只会显示顶层镜像,如果\n希望显示包括中间层镜像在内的所有镜像的话,需要加\t`-a`参数。\n\n\n    $ sudo docker image ls -a\n\n这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 \n\n- 列出部分镜像\n上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。\n\n根据仓库名称列出镜像：\n    \n    sudo docker image ls centos\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n\n列出特定的某个镜像,也就是说指定仓库名和标签\n\n{%asset_img b.png%}\n\n过滤查找镜像，使用`--filter`。具体使用请百度。\n\n- 以特定格式显示\n\n只显示ID列：\n\n    sudo docker image ls -q\n    ff426288ea90\n    f2a91732366c\n\n用go模板语法定制格式显示\n比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"{{.ID}}:{{.Repository}}\"\n    ff426288ea90:centos\n    f2a91732366c:hello-world\n\n或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n    IMAGE ID            REPOSITORY          TAG\n    ff426288ea90        centos              latest\n    f2a91732366c        hello-world         latest\n\n## 删除本地镜像\n\n可以使用`docker\timage\trm`命令来删除本地镜像。格式如下：\n\n    $\tdocker image rm [选项] <镜像1> [<镜像2> ...]\n\n- 用\tID、镜像名、摘要删除镜像\n\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest        \n\n    #删除hello-world，段id，id一部分，能区分就行。\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n\n用仓库名删除：\n    \n    $ sudo docker image\trm\thello-world    \n\n当然,更精确的是使用镜像摘要删除镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n\n- 用\t`docker\timage\tls`命令来配合\n\n比如,我们需要删除所有仓库名为redis的镜像:\n\n    $ docker image rm $(docker image ls -q redis)\n\n## 利用commit理解镜像构成\n镜像是一层一层构成的。\n\n现在让我们以定制一个Web\t服务器为例子,来讲解镜像是如何构建的。\n\n    docker run --name webserver -d -p 80:80 nginx\n\n在浏览器可查看：\n\n{%asset_img c.png%}\n\n现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎\tDocker的文字,我们可以使用`docker\texec`命令进入容器,修改其内容 \n\n    > sudo docker exec -it webserver bash\n    root@3729b97e8226:/# echo '<h1>Hello,Docker!</h1>' >\t/usr/share/nginx/html/index.html\n    root@3729b97e8226:/#\texit\n\n然后刷新浏览器，就可以看到更改了。\n\n我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过`docker\tdiff`命令看到具体的改动。\n\n下面我们可以用下面的命令将容器保存为镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n    > --author \"zmt\" \\\n    > --message \"修改了默认页面\" \\\n    > webserver \\\n    > nginx:v2\n    sha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n    \n    #查看\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               v2                  e8023c09eed5        8 seconds ago       109MB\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest  \n\n查看镜像内历史记录：\n\n    $ docker history nginx:v2\n\n新的镜像定制好后,我们可以来运行这个镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n\n\n在浏览器查看：http://localhost:81/\n\n停止容器：`sudo docker kill --signal=SIGINT web2`\n    \n至此,我们第一次完成了定制镜像,使用的是`docker\tcommit`命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。\n\n> 注意：通常不会使用`docker commit`来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。\n\n## 使用Dockerfile定制镜像\n从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。\n\nDockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,\n因此每一条指令的内容,就是描述该层应当如何构建。\n\n### 简单例子：\n\n1.创建Dockerfile文件\n\n    mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\n    mutian@mutian-ThinkPad-T440p:~$ cd mynginx/\n    mutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n\n2.打开Dockerfile文件，编辑如下内容：\n    \n    FROM nginx\n    RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n\n3.构建镜像\n进入Dockerfile所在目录，执行命令：\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\n    Sending build context to Docker daemon  2.048kB\n    Step 1/2 : FROM nginx\n     ---> e548f1a579cf\n    Step 2/2 : RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n     ---> Running in d8c0149adf7e\n    Removing intermediate container d8c0149adf7e\n     ---> b92f375b41f0\n    Successfully built b92f375b41f0\n    Successfully tagged nginx:v3\n\n4.查看\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\n    nginx               v3                  b92f375b41f0        About a minute ago   109MB\n    nginx               v2                  e8023c09eed5        17 hours ago         109MB\n    nginx               latest              e548f1a579cf        8 days ago           109MB\n    centos              latest              ff426288ea90        7 weeks ago          207MB\n    hello-world         latest              f2a91732366c        3 months ago    \n    \n我们看到，TAG为v3的镜像就是我们刚才构建。    \n\n### FROM指定基础镜像\n\n定制镜像必须是以一个镜像为基础来构建，基础镜像是必须要指定的，而FROM命令就是指定基础镜像，且第一步就要指定。   \n\n除了选择一些先前定制好的镜像作为基础镜像，Docker还存在一个特殊的镜像，名为`scratch`，表示空镜像，是个虚拟的概念，不实际存在。\n\n    FROM\tscratch\n    ...\n    \n如果以`scratch`为基础，则意味着不以任何镜像为基础，后面所写的命令将作为镜像的第一层存在。\n\n对于一些二进制的可执行文件，直接最为第一层存在，不依赖其它运行时系统支持，可以用空镜像。类似go语言编译的程序。\n\n### RUN 执行命令\n\nRUN命令是用来执行命令行命令的，就像shell脚本一样，用来执行linux命令。\n\n注意避免错误：\n\n    FROM\tdebian:jessie\n    RUN\tapt-get\tupdate\n    RUN\tapt-get\tinstall\t-y\tgcc\tlibc6-dev\tmake\n    RUN\twget\t-O\tredis.tar.gz\t\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\n    RUN\tmkdir\t-p\t/usr/src/redis\n    RUN\ttar\t-xzf\tredis.tar.gz\t-C\t/usr/src/redis\t--strip-components=1\n    RUN\tmake\t-C\t/usr/src/redis\n    RUN\tmake\t-C\t/usr/src/redis\tinstall\n    \n每一个指令都会创建一层，每层都会带有上层垃圾，因此一定要避免这样写。正确的写法如下： \n\n    FROM\tdebian:jessie\n    RUN\tbuildDeps='gcc\tlibc6-dev\tmake'\t\\\n    \t\t\t\t&&\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\t$buildDeps\t\\\n    \t\t\t\t&&\twget\t-O\tredis.tar.gz\t\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\t\\\n    \t\t\t\t&&\tmkdir\t-p\t/usr/src/redis\t\\\n    \t\t\t\t&&\ttar\t-xzf\tredis.tar.gz\t-C\t/usr/src/redis\t--strip-components=1\t\\\n    \t\t\t\t&&\tmake\t-C\t/usr/src/redis\t\\\n    \t\t\t\t&&\tmake\t-C\t/usr/src/redis\tinstall\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\t\\\n    \t\t\t\t&&\trm\tredis.tar.gz\t\\\n    \t\t\t\t&&\trm\t-r\t/usr/src/redis\t\\\n    \t\t\t\t&&\tapt-get\tpurge\t-y\t--auto-remove\t$buildDeps\n    \t\t\t\t\n用了`&&`，这和`shell`执行命令一样，就相当一个命令，所以算一层。执行完后，一定要记得删除不必要的垃圾数据，垃圾包。  \n在编写`Dockerfile`时候，一定要面向类似事件的思维，比如，安装redis环境，是一个事件，算一层。安装mysql，算一个事件，一层。  \n\n## Dockerfile指令详解 \n\n上面我们已经了解了`From`、`RUN`指令，下面我们来介绍其余的……\n\n### COPY复制文件\n\n格式：\n\n- `COPY\t<源路径>...\t<目标路径>`\n\n- `COPY\t[\"<源路径1>\",...\t\"<目标路径>\"]`\n\n源路径指当前电脑系统文件路径，目标路径指容器的文件路径。  \n\n`COPY`指令将从构建上下文目录中<源路径>的文件/目录复制到新的一层的镜像内的<目标路\n径>位置。比如:  \n\n    COPY\tpackage.json\t/usr/src/app/\n    \n`<源路径>`可以是多个，甚至可以是通配符，只要满足`GO`的[filepath.Match](https://golang.org/pkg/path/filepath/#Match)规则，如： \n\n    COPY\thom*\t/mydir/\n    COPY\thom?.txt\t/mydir/\n    \n`<目标路径>` 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）       \n\n_注意一点_： \n\n使用\t`COPY`指令,源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。\n   \t\t\n\n### ADD\t更高级的复制文件   \n\n`ADD`指令和`COPY`指令本质上是一样的，只是添加了更多功能。 它的源文件可以是个url，也可以是tar，如果是tar还可以自动解压。  \n\n但是，如果是url，下载下来后，还要新建一层解压，授权，因此不如用`COPY` ，然后用`wget`命令。  \n\n在某个场景下，自动解压缩功能非常有用。 如： \n\n    FROM\tscratch\n    ADD\tubuntu-xenial-core-cloudimg-amd64-root.tar.gz\t/\n    ...\n    \n_注意_：  \n\n在`COPY`\t和`ADD`指令中选择的时候,可以遵循这样的原则,所有的文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD。 \n\n### CMD容器启动命令\n\n也有两种格式：\n\n- `shell`格式：`CMD <命令>`\n- `exec`格式：`CMD\t[\"可执行文件\",\t\"参数1\",\t\"参数2\"...]`    \n- 参数列表格式: \t`CMD\t[\"参数1\",\t\"参数2\"...]`\t 。在指定了`ENTRYPOINT`指令后,用`CMD`指定具体的参数。\n\n在指令格式上，推荐`exec`格式。  \n\nDocker不是虚拟机，只是一个进程。因此，在容器中启动程序，不要以后台形式启动，要以前台形式启动。   \n容器内没有后台概念。 \n\n不要这样启动：\n\n`CMD service ginx start`\n\n直接启动可执行文件，并以前台形式启动：\n\n`CMD [\"nginx\",\"-g\",\"daemon off;\"]`\n\n### ENTRYPOINT入口点\n\n也分为：`exec`格式和`shell`格式\n\n当指定了`ENTRYPOINT`后，就会把`CMD`的内容作为参数传给`ENTRYPOINT\t`指令，换句话说实际执行时，将变为：\n\n    <ENTRYPOINT>\t\"<CMD>\"\n\n_场景一_：\n把镜像当成命令一样使用。\n\n    FROM\tubuntu:16.04\n    RUN\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\tcurl\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\n    CMD\t[\t\"curl\",\t\"-s\",\t\"http://ip.cn\"\t]\n    \n执行：\n\n    $\tdocker\trun\tmyip\n    当前\tIP:61.148.226.66\t来自:北京市\t联通    \n\n再执行：\n    \n    $\tdocker\trun\tmyip\t-i\n    docker:\tError\tresponse\tfrom\tdaemon:\tinvalid\theader\tfield\tvalue\t\"oci\truntime\terror:\tcon\n    tainer_linux.go:247:\tstarting\tcontainer\tprocess\tcaused\t\\\"exec:\t\\\\\\\"-i\\\\\\\":\texecutable\t\n    file\tnot\tfound\tin\t$PATH\\\"\\n\".\n\n可以看到，报错了，因为`-i`不能参数不能传到`CMD`上去。\n\n正确方式：\n\n    FROM\tubuntu:16.04\n    RUN\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\tcurl\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\n    ENTRYPOINT\t[\t\"curl\",\t\"-s\",\t\"http://ip.cn\"\t]\n    \n执行：\n\n    $\tdocker\trun\tmyip\n    当前\tIP:61.148.226.66\t来自:北京市\t联通\n    \n    $\tdocker\trun\tmyip\t-i\n    HTTP/1.1\t200\tOK\n    Server:\tnginx/1.8.0\n    Date:\tTue,\t22\tNov\t2016\t05:12:40\tGMT\n    Content-Type:\ttext/html;\tcharset=UTF-8\n    Vary:\tAccept-Encoding\n    X-Powered-By:\tPHP/5.6.24-1~dotdeb+7.1\n    X-Cache:\tMISS\tfrom\tcache-2\n    X-Cache-Lookup:\tMISS\tfrom\tcache-2:80\n    X-Cache:\tMISS\tfrom\tproxy-2_6\n    Transfer-Encoding:\tchunked\n    Via:\t1.1\tcache-2:80,\t1.1\tproxy-2_6:8006\n    Connection:\tkeep-alive\n    当前\tIP:61.148.226.66\t来自:北京市\t联通\n    \n可以看到,这次成功了。这是因为当存在`ENTRYPOINT`后,`CMD`的内容将会作为参数传给`ENTRYPOINT`,而这里`-i`就是新的`CMD`,因此会作为参数传给`curl`,从而达到了我们预`期的效果。      \n\n_场景二_：\n\n在应用程序启动前等做一些初始化工作。 \n\n比如启动redis，不以`root`，而以`redis`用户身份启动。 \n\n    FROM alpine:3.4\n    ...\n    RUN addgroup -S\tredis && adduser -S -G redis redis\n    ...\n    ENTRYPOINT [\"docker-entrypoint.sh\"]\n    EXPOSE\t6379\n    CMD [\"redis-server\"]\n    \n可以看到其中为了`redis`服务创建了`redis\t`用户,并在最后指定了`ENTRYPOINT`为`docker-entrypoint.sh`脚本。   \n\n    #!/bin/sh\n    ...\n    #allow the container to be started with\t`--user`\n    if [\"$1\" = 'redis-server' -a \"$(id -u)\"\t= '0'];\tthen\n    \t\t\t\tchown -R redis\t.\n    \t\t\t\texec su-exec redis \"$0\" \"$@\"\n    fi\n    exec \"$@\"\n    \n执行：\n\n    $ docker run -it redis id\n    uid=0(root) gid=0(root) groups=0(root)\n    \n### ENV\t设置环境变量\n\n格式有两种:\n\n- `ENV\t<key>\t<value>\t`    \n- `\tENV\t<key1>=<value1>\t<key2>=<value2>...`  \n\n如：\n    \n    ENV\tVERSION=1.0\tDEBUG=on \\\n    \tNAME=\"Happy\tFeet\"   \n    \t\n这里展示了用法，还展示了换行，有空格的话用双引号。 \n\n定义了变量，后面的命令中就可以使用了。可以使用它的命令如下一些： \n\n    ADD\t 、 \tCOPY\t 、 \tENV\t 、 \tEXPOSE\t 、 \tLABEL\t 、 \tUSER\t 、 \tWORKDIR\t 、 \tVOLUME\t 、 \tSTOPSIGNAL\t 、 \tONBU\n    ILD\t\n    \nnode官方Dockerfile例子：\n\n    ENV\tNODE_VERSION\t7.2.0\n    RUN\tcurl\t-SLO\t\"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta\n    r.xz\"\t\\\n    \t\t&&\tcurl\t-SLO\t\"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\"\t\\\n    \t\t&&\tgpg\t--batch\t--decrypt\t--output\tSHASUMS256.txt\tSHASUMS256.txt.asc\t\\\n    \t\t&&\tgrep\t\"\tnode-v$NODE_VERSION-linux-x64.tar.xz\\$\"\tSHASUMS256.txt\t|\tsha256sum\t-c\t-\t\\\n    \t\t&&\ttar\t-xJf\t\"node-v$NODE_VERSION-linux-x64.tar.xz\"\t-C\t/usr/local\t--strip-components=\n    1\t\\\n    \t\t&&\trm\t\"node-v$NODE_VERSION-linux-x64.tar.xz\"\tSHASUMS25    \n    \t\n可以看到，定义了变量，后面就可以不断重复引入使用。改变的时候，只需要改一个地方。同时可以创建不同的多个镜像。 \n\n### ARG\t构建参数\n\n构建参数和`ENV`的效果一样,都是设置环境变量。所不同的是,`ARG`所设置的构建环境的环境变量,在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用`ARG`保存密码之类的信息,因为`docker\thistory`还是可以看到所有值的。 \n\n### VOLUME\t定义匿名卷\n\n两种格式：\n\n- `VOLUME\t[\"<路径1>\",\t\"<路径2>\"...]`\n- `VOLUME\t<路径>`\n\n不应该在容器存储层发生写操作。这样容器就能保持无状态的。对于动态数据，文件，我们应该保存到卷中。为了防止用户在运行时将动态文件写到存储层， \n所以要预先指定动态文件写入的目录挂载为卷，如下： \n\n    VOLUME\t/data\n    \n这里，指定`/data`为匿名卷，任何写入该目录下的数据都不会写入到容器存储层。这样容器就是无状态的。可以运行时替换掉所挂载卷： \n\n    docker\trun\t-d\t-v\tmydata:/data\txxxx\n    \n在这行命令中,就使用了`mydata`这个命名卷挂载到了`/data`这个位置,替代了`Dockerfile`中定义的匿名卷的挂载配置。  \n\n### EXPOSE\t声明端口\n\n格式：`EXPOSE\t<端口1>\t[<端口2>...]\t`    \n\n`EXPOSE`指令是声明运行时容器提供服务端口,这只是一个声明,在运行时并不会因为这个声明应用就会开启这个端口的服务。   \n\n要将`EXPOSE`和在运行时使用`-p\t<宿主端口>:<容器端口>`区分开来。`-p\t`,是映射宿主端口和容器端口,换句话说,就是将容器的对应端口服务公开给外界访问,而`EXPOSE`仅仅是声明容器打算使用什么端口而已,并不会自动在宿主进行端口映射。\n\n### WORKDIR指定工作目录\n\n格式：`WORKDIR\t<工作目录路径>`\n\n该命令可以指定工作目录（当前目录），后面各层都使用该指定目录。该目录如果不存在，则会创建空目录。\n\n写`Dockerfile`千万不能按照`shell`的思维写，应为`docker`是分层的。比如下面错误写法：\n\n     RUN cd /app\n     RUN echo \"hello\" > world.txt\n     \n构建后，你会发现找不到`/app/world.txt`文件。原因是：在`shell`中执行命令，是在同一进程中，操作的是同样的内存。但是在`docker`中不是。你知道，每一个`RUN`命令都是构建一层的，启动不同的容器。第一次`RUN`只是操作进入`/app`目录，没有操作任何文件变更，只是内存的变化而已，第二次启动了个新的容器，跟第一层的容器完全没关系了。\n所以：在写`Dockerfile`到时候，一定要有分层的思维，每一个完整的操作要在同一层里面做。\n\n如果要改变以后各层的工作目录都在指定的工作目录，那么`WORKDIR`指令就派上用场了。\n\n### `USER`指定当前用户\n\n格式:`USER <用户名>`  用户名系统已经添加好\n\n和`WORKDIR`一样，都会影响后面的每一层。改变执行后面命令的执行身份。\n\n下面建立用户，并切换到该用户，启动`redis`：\n\n    RUN groupadd -r redis && useradd -r -g redis edis\n    USER redis\n    RUN [\"redis-server\"]\n\n如果以`root`执行脚本，在执行期间想切换用户，可以参考下面做法：\n\n    # 建立redis用户,并使用gosu换另一个用户执行命令\n    RUN groupadd -r redis && useradd -r -g redis redis\n    #下载gosu\n    RUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.7/\n    gosu-amd64\" \\\n        && chmod +x /usr/local/bin/gosu\t\\\n            && gosu nobody true\n    #设置CMD,并以另外的用户执行\n    CMD [\"exec\",\"gosu\",\"redis\",\"redis-server\"]\n    \n`gosu`使用更多信息参考：https://github.com/tianon/gosu\n\n### HEALTHCHECK 健康检查    \n\n格式：\n- `HEALTHCHECK [选项] CMD <命令>`:设置检查容器健康状况的命令\t\n- `HEALTHCHECK NONE`:如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令。\n\n该指令是告诉`Docker`应该如何进行判断容器的状态是否正常。\n\n### ONBUILD\t为他人做嫁衣裳\n\n格式: `ONBUILD <其它指令>\t`\n\n`ONBUILD` 后面的指令，在当前镜像构建的时候是不会执行的，只有以它所在的镜像为基础镜像的镜像在构建的时候才会执行。 \n\n`Docker`中其它的命令都是为了定制当前的镜像准备的，只有`ONBUILD`是为了他人而准备。   \n\n所以，这里就可以看出，该指令可以用来做命令的继承。类似`maven`中的父`pom`。把`ONBUILD`后面的命令都看做各个子`Dockerfile`的共用命令。\n\n    FROM node:slim\n    RUN mkdir /app\n    WORKDIR\t/app\n    ONBUILD\tCOPY ./package.json /app\n    ONBUILD RUN [\"npm\",\t\"install\"]\n    ONBUILD\tCOPY . /app/\n    CMD [\"npm\", \"start\"]\n    \n 后面每一个子`Dockerfile`只需要以上面镜像伟基础镜像:\n \n    FROM my-node  \n    \n这样，`ONBUILD`后面的指令都会在每个子`Dockerfile`中执行。     \n\n\n## 删除本地镜像\n\n可以使用命令`docker rmi`，格式：\n\n    `docker\trmi\t[选项]\t<镜像1>\t[<镜像2>\t...]`\n    \n    _注意_: docker rm 命令是删除容器,不要混淆。\n\n可以用ID、镜像名、摘要删除镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker images\n    [sudo] password for mutian: \n    REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\n    mysql/mysql-server   latest              02d081b9c73e        2 months ago        300MB\n    nginx                v3                  b92f375b41f0        4 months ago        109MB\n    nginx                v2                  e8023c09eed5        4 months ago        109MB\n    nginx                latest              e548f1a579cf        4 months ago        109MB\n    centos               latest              ff426288ea90        5 months ago        207MB\n    hello-world          latest              f2a91732366c        7 months ago        1.85kB\n    season/fastdfs       latest              c6cc94c34f8e        2 years ago         205MB\n\n1. 用短id删除，人工输入的时候使用，方便：\n\n`$\tdocker\trmi\tff4`\n\n2. 用长id，一般使用脚本的时候：\n\n`$\tdocker\trmi\tf2a91732366c`\n\n3. 用镜像名,`<仓库名>:<标签>`：\n\n`docker\trmi\tnginx：v3`\n\n4. 使用摘要，最精确： \n    \n查看摘要：\n    \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker images --digests\n    REPOSITORY           TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE\n    mysql/mysql-server   latest              sha256:f1cb1e3f0124601b1496f485e9f4401ad10138294b5a38d932089daafd555e34   02d081b9c73e        2 months ago        300MB\n    nginx                v3                  <none>                                                                    b92f375b41f0        4 months ago        109MB\n    nginx                v2                  <none>                                                                    e8023c09eed5        4 months ago        109MB\n    nginx                latest              sha256:4771d09578c7c6a65299e110b3ee1c0a2592f5ea2618d23e4ffe7a4cab1ce5de   e548f1a579cf        4 months ago        109MB\n    centos               latest              sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce   ff426288ea90        5 months ago        207MB\n    hello-world          latest              sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7   f2a91732366c        7 months ago        1.85kB\n    season/fastdfs       latest              sha256:408acdebaa278e8ed875f7c63aa0c7ac8e633cf92f615d8295d279e137217003   c6cc94c34f8e        2 years ago         205MB\n\n    \n删除：\n\n    docker rmi centos@sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n \n\n### Untagged和Deleted\n\n仔细观察，发现两种删除行为。\n\n实际上，镜像都是一层层的，一个镜像有多个标签，只有每个标签都取消了，才有可能删除镜像。删除的时候从上最上层往下，逐步判断删除。 \n\n### 用`docker images`命令来配合\n\n配合`docker\timages\t-q`，可以成批的删除你想要删除的镜像，可以指定你想要删除的镜像。\n\n删除虚悬镜像：\n\n`$\tdocker\trmi\t$(docker\timages\t-q\t-f\tdangling=true)`\n\n删除所有仓库名为redis的镜像:\n\n`$\tdocker\trmi\t$(docker\timages\t-q\tredis)`\n\n删除所有在mongo:3.2之前的镜像:\n\n`$\tdocker\trmi\t$(docker\timages\t-q\t-f\tbefore=mongo:3.2)`\n\n\n### docker image\n\n后面版本，推荐使用`docker image`来管理镜像。\n\n如删除：\n\n`$\tdocker\timage\trm`\n\n## 基于本地模板导入导出镜像\n\n## 把镜像上传到docker公共仓库\n\nhttps://hub.docker.com\n\n现在上面网址中注册：\n\n{% asset_img b-1.png %}\n\n1.登录docker\n\n    [root@xr-server-dev ~]# docker login \n    Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one.\n    Username: xinxiamu\n    Password: \n    Login Succeeded\n\n2.对本地自定义的docker镜像打标签，必须先打标签：\n\n    [root@xr-server-dev ~]# docker tag fastdfs-server:v1 xinxiamu/fdfs-server:0.1\n    \n3.上传到hub.docker.com:\n\n    [root@xr-server-dev ~]# docker push xinxiamu/fdfs-server:0.1\n    The push refers to repository [docker.io/xinxiamu/fdfs-server]\n    77f438662c4e: Pushed \n    7051cce03d08: Pushed \n    47262386cb42: Pushed \n    89b5ef66bef1: Pushed \n    6498ec7e0c6f: Pushed \n    939591e6b702: Pushed \n    d99d7b3f4b3f: Pushed \n    e5f0ae3c8627: Pushed \n    79332ca36cf7: Pushed \n    d69483a6face: Pushed \n    0.1: digest: sha256:811bc129bc6da0fe648e8dc4388dac39db592d86c14f4df87b2b70fc13b80fb5 size: 2403\n\n刷新页面可以看到已经上传：\n\n{% asset_img b-2.png %}        \n\n## 把镜像上传到私服\n\n后面章节有介绍……\n\n## 镜像的实现原理\n\n[UnionFS](https://en.wikipedia.org/wiki/UnionFS)\n\n## 配置镜像加速器\n\n注册阿里云账号后，即可在阿里云控制台（https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。\n\n{% asset_img yy.png %}\n\n按照上图说明配置即可。 \n\n   ","slug":"docker-lesson3-images","published":1,"updated":"2019-06-22T10:03:30.041Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqba002hg4vayb6tads7","content":"<p>Docker    运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker    会从镜像仓库下载(默认是<br>Docker    Hub    公共注册服务器中的仓库)。</p>\n<p>本章将介绍更多关于镜像的内容,包括:</p>\n<ul>\n<li>从仓库获取镜像;</li>\n<li>管理本地主机上的镜像;</li>\n<li>介绍镜像实现的基本原理。</li>\n</ul>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>在官方<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>有大量高质量可用镜像。下面我们来看怎样获取这些镜像。</p>\n<p>从Docker    镜像仓库获取镜像的命令是docker    pull。其命令格式为: </p>\n<pre><code>docker pull    [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n</code></pre><p>具体的先选可以通过<code>docker pull    --help</code>命令查看。镜像名称的格式：</p>\n<ul>\n<li>Docker 镜像仓库地址:地址的格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是Docker Hub。</li>\n<li>仓库名:如之前所说,这里的仓库名是两段式名称,即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。</li>\n</ul>\n<p>比如:</p>\n<pre><code>$    docker    pull    ubuntu:16.04\n16.04:    Pulling    from    library/ubuntu\nbf5d46315322:    Pull    complete\n9f13e0ac480c:    Pull    complete\ne8988b5b3097:    Pull    complete\n40af181810e7:    Pull    complete\ne6f7c7e5c03e:    Pull    complete\nDigest:    sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\nStatus:    Downloaded    newer    image    for    ubuntu:16.04\n</code></pre><p>上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04    ,因此将会获取官方镜像library/ubuntu    仓库中标签为16.04的镜像。    </p>\n<p>例子： </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n[sudo] password for mutian: \nUsing default tag: latest\nlatest: Pulling from library/centos\naf4b0a2388c6: Pull complete \nDigest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\nStatus: Downloaded newer image for centos:latest\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。</p>\n<p><code>sudo docker run -it --rm centos bash</code></p>\n<pre><code>[root@5f6c0a6b41c1 ~]# cat /etc/os-release \nNAME=&quot;CentOS Linux&quot;\nVERSION=&quot;7 (Core)&quot;\nID=&quot;centos&quot;\nID_LIKE=&quot;rhel fedora&quot;\nVERSION_ID=&quot;7&quot;\nPRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;\nANSI_COLOR=&quot;0;31&quot;\nCPE_NAME=&quot;cpe:/o:centos:centos:7&quot;\nHOME_URL=&quot;https://www.centos.org/&quot;\nBUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;\n\nCENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;\nCENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;\nREDHAT_SUPPORT_PRODUCT=&quot;centos&quot;\nREDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;\n\n[root@5f6c0a6b41c1 ~]# \n</code></pre><p>通过上面信息我们可以看到容器内系统信息。</p>\n<p>命令说明：</p>\n<p><code>docker    run</code>就是运行容器的命令,具体格式我们会在    容器    一节进行详细讲解,我们这里简要的说明一下上面用到的参数。</p>\n<ul>\n<li><code>-it</code>:这是两个参数,一个是<code>-i</code>:交互式操作,一个是<code>-t</code>终端。我们这里打算进入<code>bash</code>执行一些命令并查看返回结果,因此我们需要交互式终端。</li>\n<li><code>--rm</code>:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动<code>docker    rm</code>。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用<code>--rm</code>可以避免浪费空间。</li>\n<li><code>centos</code>:这是指用<code>centos</code>镜像为基础来启动容器。</li>\n<li><code>bash</code>:放在镜像名后的是命令,这里我们希望有个交互式<code>Shell</code>,因此用的是<code>bash</code>。</li>\n</ul>\n<p>进入系统后我们可以执行任何linux下的命令。</p>\n<p>最后我们通过<code>exit</code>退出了这个容器。<br>退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了<code>--rm</code>命令。</p>\n<h2 id=\"列出所有的镜像\"><a href=\"#列出所有的镜像\" class=\"headerlink\" title=\"列出所有的镜像\"></a>列出所有的镜像</h2><p>想列出所有已经下载的镜像，可以使用命令<code>docker    image ls</code></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n[sudo] password for mutian: \nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest              f2a91732366c        3 months ago        1.85kB\n</code></pre><p>上面列表包含了<code>仓库名</code>、<code>标签</code>、<code>镜像ID</code>、<code>创建时间</code>以及所占用空间。<br>镜像    ID    则是镜像的唯一标识,一个镜像可以对应多个标签。</p>\n<ul>\n<li>镜像体积SIZE：<br>上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比<br>每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。</li>\n</ul>\n<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\nTYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\nImages              2                   1                   207.2MB             207.2MB (99%)\nContainers          1                   0                   0B                  0B\nLocal Volumes       0                   0                   0B                  0B\nBuild Cache \n</code></pre><ul>\n<li>虚悬镜像</li>\n</ul>\n<img src=\"/2018/02/02/docker-lesson3-images/a.png\">\n<p>如上图，命令查出来的就是虚悬镜像。其产生的原因是：<br>由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。</none></p>\n<p>这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：</p>\n<pre><code>$ sudo docker image    prune\n</code></pre><ul>\n<li>中间层镜像<br>为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可<br>能会看到一些依赖的中间层镜像。默认的<code>docker image    ls</code>列表中只会显示顶层镜像,如果<br>希望显示包括中间层镜像在内的所有镜像的话,需要加    <code>-a</code>参数。</li>\n</ul>\n<pre><code>$ sudo docker image ls -a\n</code></pre><p>这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 </p>\n<ul>\n<li>列出部分镜像<br>上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。</li>\n</ul>\n<p>根据仓库名称列出镜像：</p>\n<pre><code>sudo docker image ls centos\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\n</code></pre><p>列出特定的某个镜像,也就是说指定仓库名和标签</p>\n<img src=\"/2018/02/02/docker-lesson3-images/b.png\">\n<p>过滤查找镜像，使用<code>--filter</code>。具体使用请百度。</p>\n<ul>\n<li>以特定格式显示</li>\n</ul>\n<p>只显示ID列：</p>\n<pre><code>sudo docker image ls -q\nff426288ea90\nf2a91732366c\n</code></pre><p>用go模板语法定制格式显示<br>比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;{{.ID}}:{{.Repository}}&quot;\nff426288ea90:centos\nf2a91732366c:hello-world\n</code></pre><p>或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}&quot;\nIMAGE ID            REPOSITORY          TAG\nff426288ea90        centos              latest\nf2a91732366c        hello-world         latest\n</code></pre><h2 id=\"删除本地镜像\"><a href=\"#删除本地镜像\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用<code>docker    image    rm</code>命令来删除本地镜像。格式如下：</p>\n<pre><code>$    docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]\n</code></pre><ul>\n<li>用    ID、镜像名、摘要删除镜像</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest        \n\n#删除hello-world，段id，id一部分，能区分就行。\nmutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n</code></pre><p>用仓库名删除：</p>\n<pre><code>$ sudo docker image    rm    hello-world    \n</code></pre><p>当然,更精确的是使用镜像摘要删除镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n</code></pre><ul>\n<li>用    <code>docker    image    ls</code>命令来配合</li>\n</ul>\n<p>比如,我们需要删除所有仓库名为redis的镜像:</p>\n<pre><code>$ docker image rm $(docker image ls -q redis)\n</code></pre><h2 id=\"利用commit理解镜像构成\"><a href=\"#利用commit理解镜像构成\" class=\"headerlink\" title=\"利用commit理解镜像构成\"></a>利用commit理解镜像构成</h2><p>镜像是一层一层构成的。</p>\n<p>现在让我们以定制一个Web    服务器为例子,来讲解镜像是如何构建的。</p>\n<pre><code>docker run --name webserver -d -p 80:80 nginx\n</code></pre><p>在浏览器可查看：</p>\n<img src=\"/2018/02/02/docker-lesson3-images/c.png\">\n<p>现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎    Docker的文字,我们可以使用<code>docker    exec</code>命令进入容器,修改其内容 </p>\n<pre><code>&gt; sudo docker exec -it webserver bash\nroot@3729b97e8226:/# echo &apos;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&apos; &gt;    /usr/share/nginx/html/index.html\nroot@3729b97e8226:/#    exit\n</code></pre><p>然后刷新浏览器，就可以看到更改了。</p>\n<p>我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过<code>docker    diff</code>命令看到具体的改动。</p>\n<p>下面我们可以用下面的命令将容器保存为镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n&gt; --author &quot;zmt&quot; \\\n&gt; --message &quot;修改了默认页面&quot; \\\n&gt; webserver \\\n&gt; nginx:v2\nsha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n\n#查看\nmutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               v2                  e8023c09eed5        8 seconds ago       109MB\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest  \n</code></pre><p>查看镜像内历史记录：</p>\n<pre><code>$ docker history nginx:v2\n</code></pre><p>新的镜像定制好后,我们可以来运行这个镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n</code></pre><p>在浏览器查看：<a href=\"http://localhost:81/\" target=\"_blank\" rel=\"noopener\">http://localhost:81/</a></p>\n<p>停止容器：<code>sudo docker kill --signal=SIGINT web2</code></p>\n<p>至此,我们第一次完成了定制镜像,使用的是<code>docker    commit</code>命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。</p>\n<blockquote>\n<p>注意：通常不会使用<code>docker commit</code>来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。</p>\n</blockquote>\n<h2 id=\"使用Dockerfile定制镜像\"><a href=\"#使用Dockerfile定制镜像\" class=\"headerlink\" title=\"使用Dockerfile定制镜像\"></a>使用Dockerfile定制镜像</h2><p>从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。</p>\n<p>Dockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,<br>因此每一条指令的内容,就是描述该层应当如何构建。</p>\n<h3 id=\"简单例子：\"><a href=\"#简单例子：\" class=\"headerlink\" title=\"简单例子：\"></a>简单例子：</h3><p>1.创建Dockerfile文件</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\nmutian@mutian-ThinkPad-T440p:~$ cd mynginx/\nmutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n</code></pre><p>2.打开Dockerfile文件，编辑如下内容：</p>\n<pre><code>FROM nginx\nRUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n</code></pre><p>3.构建镜像<br>进入Dockerfile所在目录，执行命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\nSending build context to Docker daemon  2.048kB\nStep 1/2 : FROM nginx\n ---&gt; e548f1a579cf\nStep 2/2 : RUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n ---&gt; Running in d8c0149adf7e\nRemoving intermediate container d8c0149adf7e\n ---&gt; b92f375b41f0\nSuccessfully built b92f375b41f0\nSuccessfully tagged nginx:v3\n</code></pre><p>4.查看</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\nnginx               v3                  b92f375b41f0        About a minute ago   109MB\nnginx               v2                  e8023c09eed5        17 hours ago         109MB\nnginx               latest              e548f1a579cf        8 days ago           109MB\ncentos              latest              ff426288ea90        7 weeks ago          207MB\nhello-world         latest              f2a91732366c        3 months ago    \n</code></pre><p>我们看到，TAG为v3的镜像就是我们刚才构建。    </p>\n<h3 id=\"FROM指定基础镜像\"><a href=\"#FROM指定基础镜像\" class=\"headerlink\" title=\"FROM指定基础镜像\"></a>FROM指定基础镜像</h3><p>定制镜像必须是以一个镜像为基础来构建，基础镜像是必须要指定的，而FROM命令就是指定基础镜像，且第一步就要指定。   </p>\n<p>除了选择一些先前定制好的镜像作为基础镜像，Docker还存在一个特殊的镜像，名为<code>scratch</code>，表示空镜像，是个虚拟的概念，不实际存在。</p>\n<pre><code>FROM    scratch\n...\n</code></pre><p>如果以<code>scratch</code>为基础，则意味着不以任何镜像为基础，后面所写的命令将作为镜像的第一层存在。</p>\n<p>对于一些二进制的可执行文件，直接最为第一层存在，不依赖其它运行时系统支持，可以用空镜像。类似go语言编译的程序。</p>\n<h3 id=\"RUN-执行命令\"><a href=\"#RUN-执行命令\" class=\"headerlink\" title=\"RUN 执行命令\"></a>RUN 执行命令</h3><p>RUN命令是用来执行命令行命令的，就像shell脚本一样，用来执行linux命令。</p>\n<p>注意避免错误：</p>\n<pre><code>FROM    debian:jessie\nRUN    apt-get    update\nRUN    apt-get    install    -y    gcc    libc6-dev    make\nRUN    wget    -O    redis.tar.gz    &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;\nRUN    mkdir    -p    /usr/src/redis\nRUN    tar    -xzf    redis.tar.gz    -C    /usr/src/redis    --strip-components=1\nRUN    make    -C    /usr/src/redis\nRUN    make    -C    /usr/src/redis    install\n</code></pre><p>每一个指令都会创建一层，每层都会带有上层垃圾，因此一定要避免这样写。正确的写法如下： </p>\n<pre><code>FROM    debian:jessie\nRUN    buildDeps=&apos;gcc    libc6-dev    make&apos;    \\\n                &amp;&amp;    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    $buildDeps    \\\n                &amp;&amp;    wget    -O    redis.tar.gz    &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;    \\\n                &amp;&amp;    mkdir    -p    /usr/src/redis    \\\n                &amp;&amp;    tar    -xzf    redis.tar.gz    -C    /usr/src/redis    --strip-components=1    \\\n                &amp;&amp;    make    -C    /usr/src/redis    \\\n                &amp;&amp;    make    -C    /usr/src/redis    install    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*    \\\n                &amp;&amp;    rm    redis.tar.gz    \\\n                &amp;&amp;    rm    -r    /usr/src/redis    \\\n                &amp;&amp;    apt-get    purge    -y    --auto-remove    $buildDeps\n</code></pre><p>用了<code>&amp;&amp;</code>，这和<code>shell</code>执行命令一样，就相当一个命令，所以算一层。执行完后，一定要记得删除不必要的垃圾数据，垃圾包。<br>在编写<code>Dockerfile</code>时候，一定要面向类似事件的思维，比如，安装redis环境，是一个事件，算一层。安装mysql，算一个事件，一层。  </p>\n<h2 id=\"Dockerfile指令详解\"><a href=\"#Dockerfile指令详解\" class=\"headerlink\" title=\"Dockerfile指令详解\"></a>Dockerfile指令详解</h2><p>上面我们已经了解了<code>From</code>、<code>RUN</code>指令，下面我们来介绍其余的……</p>\n<h3 id=\"COPY复制文件\"><a href=\"#COPY复制文件\" class=\"headerlink\" title=\"COPY复制文件\"></a>COPY复制文件</h3><p>格式：</p>\n<ul>\n<li><p><code>COPY    &lt;源路径&gt;...    &lt;目标路径&gt;</code></p>\n</li>\n<li><p><code>COPY    [&quot;&lt;源路径1&gt;&quot;,...    &quot;&lt;目标路径&gt;&quot;]</code></p>\n</li>\n</ul>\n<p>源路径指当前电脑系统文件路径，目标路径指容器的文件路径。  </p>\n<p><code>COPY</code>指令将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路<br>径&gt;位置。比如:  </p>\n<pre><code>COPY    package.json    /usr/src/app/\n</code></pre><p><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，只要满足<code>GO</code>的<a href=\"https://golang.org/pkg/path/filepath/#Match\" target=\"_blank\" rel=\"noopener\">filepath.Match</a>规则，如： </p>\n<pre><code>COPY    hom*    /mydir/\nCOPY    hom?.txt    /mydir/\n</code></pre><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）       </p>\n<p><em>注意一点</em>： </p>\n<p>使用    <code>COPY</code>指令,源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p>\n<h3 id=\"ADD-更高级的复制文件\"><a href=\"#ADD-更高级的复制文件\" class=\"headerlink\" title=\"ADD    更高级的复制文件\"></a>ADD    更高级的复制文件</h3><p><code>ADD</code>指令和<code>COPY</code>指令本质上是一样的，只是添加了更多功能。 它的源文件可以是个url，也可以是tar，如果是tar还可以自动解压。  </p>\n<p>但是，如果是url，下载下来后，还要新建一层解压，授权，因此不如用<code>COPY</code> ，然后用<code>wget</code>命令。  </p>\n<p>在某个场景下，自动解压缩功能非常有用。 如： </p>\n<pre><code>FROM    scratch\nADD    ubuntu-xenial-core-cloudimg-amd64-root.tar.gz    /\n...\n</code></pre><p>_注意_：  </p>\n<p>在<code>COPY</code>    和<code>ADD</code>指令中选择的时候,可以遵循这样的原则,所有的文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD。 </p>\n<h3 id=\"CMD容器启动命令\"><a href=\"#CMD容器启动命令\" class=\"headerlink\" title=\"CMD容器启动命令\"></a>CMD容器启动命令</h3><p>也有两种格式：</p>\n<ul>\n<li><code>shell</code>格式：<code>CMD &lt;命令&gt;</code></li>\n<li><code>exec</code>格式：<code>CMD    [&quot;可执行文件&quot;,    &quot;参数1&quot;,    &quot;参数2&quot;...]</code>    </li>\n<li>参数列表格式:     <code>CMD    [&quot;参数1&quot;,    &quot;参数2&quot;...]</code>     。在指定了<code>ENTRYPOINT</code>指令后,用<code>CMD</code>指定具体的参数。</li>\n</ul>\n<p>在指令格式上，推荐<code>exec</code>格式。  </p>\n<p>Docker不是虚拟机，只是一个进程。因此，在容器中启动程序，不要以后台形式启动，要以前台形式启动。<br>容器内没有后台概念。 </p>\n<p>不要这样启动：</p>\n<p><code>CMD service ginx start</code></p>\n<p>直接启动可执行文件，并以前台形式启动：</p>\n<p><code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></p>\n<h3 id=\"ENTRYPOINT入口点\"><a href=\"#ENTRYPOINT入口点\" class=\"headerlink\" title=\"ENTRYPOINT入口点\"></a>ENTRYPOINT入口点</h3><p>也分为：<code>exec</code>格式和<code>shell</code>格式</p>\n<p>当指定了<code>ENTRYPOINT</code>后，就会把<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code>指令，换句话说实际执行时，将变为：</p>\n<pre><code>&lt;ENTRYPOINT&gt;    &quot;&lt;CMD&gt;&quot;\n</code></pre><p><em>场景一</em>：<br>把镜像当成命令一样使用。</p>\n<pre><code>FROM    ubuntu:16.04\nRUN    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    curl    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*\nCMD    [    &quot;curl&quot;,    &quot;-s&quot;,    &quot;http://ip.cn&quot;    ]\n</code></pre><p>执行：</p>\n<pre><code>$    docker    run    myip\n当前    IP:61.148.226.66    来自:北京市    联通    \n</code></pre><p>再执行：</p>\n<pre><code>$    docker    run    myip    -i\ndocker:    Error    response    from    daemon:    invalid    header    field    value    &quot;oci    runtime    error:    con\ntainer_linux.go:247:    starting    container    process    caused    \\&quot;exec:    \\\\\\&quot;-i\\\\\\&quot;:    executable    \nfile    not    found    in    $PATH\\&quot;\\n&quot;.\n</code></pre><p>可以看到，报错了，因为<code>-i</code>不能参数不能传到<code>CMD</code>上去。</p>\n<p>正确方式：</p>\n<pre><code>FROM    ubuntu:16.04\nRUN    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    curl    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*\nENTRYPOINT    [    &quot;curl&quot;,    &quot;-s&quot;,    &quot;http://ip.cn&quot;    ]\n</code></pre><p>执行：</p>\n<pre><code>$    docker    run    myip\n当前    IP:61.148.226.66    来自:北京市    联通\n\n$    docker    run    myip    -i\nHTTP/1.1    200    OK\nServer:    nginx/1.8.0\nDate:    Tue,    22    Nov    2016    05:12:40    GMT\nContent-Type:    text/html;    charset=UTF-8\nVary:    Accept-Encoding\nX-Powered-By:    PHP/5.6.24-1~dotdeb+7.1\nX-Cache:    MISS    from    cache-2\nX-Cache-Lookup:    MISS    from    cache-2:80\nX-Cache:    MISS    from    proxy-2_6\nTransfer-Encoding:    chunked\nVia:    1.1    cache-2:80,    1.1    proxy-2_6:8006\nConnection:    keep-alive\n当前    IP:61.148.226.66    来自:北京市    联通\n</code></pre><p>可以看到,这次成功了。这是因为当存在<code>ENTRYPOINT</code>后,<code>CMD</code>的内容将会作为参数传给<code>ENTRYPOINT</code>,而这里<code>-i</code>就是新的<code>CMD</code>,因此会作为参数传给<code>curl</code>,从而达到了我们预`期的效果。      </p>\n<p><em>场景二</em>：</p>\n<p>在应用程序启动前等做一些初始化工作。 </p>\n<p>比如启动redis，不以<code>root</code>，而以<code>redis</code>用户身份启动。 </p>\n<pre><code>FROM alpine:3.4\n...\nRUN addgroup -S    redis &amp;&amp; adduser -S -G redis redis\n...\nENTRYPOINT [&quot;docker-entrypoint.sh&quot;]\nEXPOSE    6379\nCMD [&quot;redis-server&quot;]\n</code></pre><p>可以看到其中为了<code>redis</code>服务创建了<code>redis</code>用户,并在最后指定了<code>ENTRYPOINT</code>为<code>docker-entrypoint.sh</code>脚本。   </p>\n<pre><code>#!/bin/sh\n...\n#allow the container to be started with    `--user`\nif [&quot;$1&quot; = &apos;redis-server&apos; -a &quot;$(id -u)&quot;    = &apos;0&apos;];    then\n                chown -R redis    .\n                exec su-exec redis &quot;$0&quot; &quot;$@&quot;\nfi\nexec &quot;$@&quot;\n</code></pre><p>执行：</p>\n<pre><code>$ docker run -it redis id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre><h3 id=\"ENV-设置环境变量\"><a href=\"#ENV-设置环境变量\" class=\"headerlink\" title=\"ENV    设置环境变量\"></a>ENV    设置环境变量</h3><p>格式有两种:</p>\n<ul>\n<li><code>ENV    &lt;key&gt;    &lt;value&gt;</code>    </li>\n<li><code>ENV    &lt;key1&gt;=&lt;value1&gt;    &lt;key2&gt;=&lt;value2&gt;...</code>  </li>\n</ul>\n<p>如：</p>\n<pre><code>ENV    VERSION=1.0    DEBUG=on \\\n    NAME=&quot;Happy    Feet&quot;   \n</code></pre><p>这里展示了用法，还展示了换行，有空格的话用双引号。 </p>\n<p>定义了变量，后面的命令中就可以使用了。可以使用它的命令如下一些： </p>\n<pre><code>ADD     、     COPY     、     ENV     、     EXPOSE     、     LABEL     、     USER     、     WORKDIR     、     VOLUME     、     STOPSIGNAL     、     ONBU\nILD    \n</code></pre><p>node官方Dockerfile例子：</p>\n<pre><code>ENV    NODE_VERSION    7.2.0\nRUN    curl    -SLO    &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta\nr.xz&quot;    \\\n        &amp;&amp;    curl    -SLO    &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;    \\\n        &amp;&amp;    gpg    --batch    --decrypt    --output    SHASUMS256.txt    SHASUMS256.txt.asc    \\\n        &amp;&amp;    grep    &quot;    node-v$NODE_VERSION-linux-x64.tar.xz\\$&quot;    SHASUMS256.txt    |    sha256sum    -c    -    \\\n        &amp;&amp;    tar    -xJf    &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;    -C    /usr/local    --strip-components=\n1    \\\n        &amp;&amp;    rm    &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;    SHASUMS25    \n</code></pre><p>可以看到，定义了变量，后面就可以不断重复引入使用。改变的时候，只需要改一个地方。同时可以创建不同的多个镜像。 </p>\n<h3 id=\"ARG-构建参数\"><a href=\"#ARG-构建参数\" class=\"headerlink\" title=\"ARG    构建参数\"></a>ARG    构建参数</h3><p>构建参数和<code>ENV</code>的效果一样,都是设置环境变量。所不同的是,<code>ARG</code>所设置的构建环境的环境变量,在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用<code>ARG</code>保存密码之类的信息,因为<code>docker    history</code>还是可以看到所有值的。 </p>\n<h3 id=\"VOLUME-定义匿名卷\"><a href=\"#VOLUME-定义匿名卷\" class=\"headerlink\" title=\"VOLUME    定义匿名卷\"></a>VOLUME    定义匿名卷</h3><p>两种格式：</p>\n<ul>\n<li><code>VOLUME    [&quot;&lt;路径1&gt;&quot;,    &quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><code>VOLUME    &lt;路径&gt;</code></li>\n</ul>\n<p>不应该在容器存储层发生写操作。这样容器就能保持无状态的。对于动态数据，文件，我们应该保存到卷中。为了防止用户在运行时将动态文件写到存储层，<br>所以要预先指定动态文件写入的目录挂载为卷，如下： </p>\n<pre><code>VOLUME    /data\n</code></pre><p>这里，指定<code>/data</code>为匿名卷，任何写入该目录下的数据都不会写入到容器存储层。这样容器就是无状态的。可以运行时替换掉所挂载卷： </p>\n<pre><code>docker    run    -d    -v    mydata:/data    xxxx\n</code></pre><p>在这行命令中,就使用了<code>mydata</code>这个命名卷挂载到了<code>/data</code>这个位置,替代了<code>Dockerfile</code>中定义的匿名卷的挂载配置。  </p>\n<h3 id=\"EXPOSE-声明端口\"><a href=\"#EXPOSE-声明端口\" class=\"headerlink\" title=\"EXPOSE    声明端口\"></a>EXPOSE    声明端口</h3><p>格式：<code>EXPOSE    &lt;端口1&gt;    [&lt;端口2&gt;...]</code>    </p>\n<p><code>EXPOSE</code>指令是声明运行时容器提供服务端口,这只是一个声明,在运行时并不会因为这个声明应用就会开启这个端口的服务。   </p>\n<p>要将<code>EXPOSE</code>和在运行时使用<code>-p    &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开来。<code>-p</code>,是映射宿主端口和容器端口,换句话说,就是将容器的对应端口服务公开给外界访问,而<code>EXPOSE</code>仅仅是声明容器打算使用什么端口而已,并不会自动在宿主进行端口映射。</p>\n<h3 id=\"WORKDIR指定工作目录\"><a href=\"#WORKDIR指定工作目录\" class=\"headerlink\" title=\"WORKDIR指定工作目录\"></a>WORKDIR指定工作目录</h3><p>格式：<code>WORKDIR    &lt;工作目录路径&gt;</code></p>\n<p>该命令可以指定工作目录（当前目录），后面各层都使用该指定目录。该目录如果不存在，则会创建空目录。</p>\n<p>写<code>Dockerfile</code>千万不能按照<code>shell</code>的思维写，应为<code>docker</code>是分层的。比如下面错误写法：</p>\n<pre><code>RUN cd /app\nRUN echo &quot;hello&quot; &gt; world.txt\n</code></pre><p>构建后，你会发现找不到<code>/app/world.txt</code>文件。原因是：在<code>shell</code>中执行命令，是在同一进程中，操作的是同样的内存。但是在<code>docker</code>中不是。你知道，每一个<code>RUN</code>命令都是构建一层的，启动不同的容器。第一次<code>RUN</code>只是操作进入<code>/app</code>目录，没有操作任何文件变更，只是内存的变化而已，第二次启动了个新的容器，跟第一层的容器完全没关系了。<br>所以：在写<code>Dockerfile</code>到时候，一定要有分层的思维，每一个完整的操作要在同一层里面做。</p>\n<p>如果要改变以后各层的工作目录都在指定的工作目录，那么<code>WORKDIR</code>指令就派上用场了。</p>\n<h3 id=\"USER指定当前用户\"><a href=\"#USER指定当前用户\" class=\"headerlink\" title=\"USER指定当前用户\"></a><code>USER</code>指定当前用户</h3><p>格式:<code>USER &lt;用户名&gt;</code>  用户名系统已经添加好</p>\n<p>和<code>WORKDIR</code>一样，都会影响后面的每一层。改变执行后面命令的执行身份。</p>\n<p>下面建立用户，并切换到该用户，启动<code>redis</code>：</p>\n<pre><code>RUN groupadd -r redis &amp;&amp; useradd -r -g redis edis\nUSER redis\nRUN [&quot;redis-server&quot;]\n</code></pre><p>如果以<code>root</code>执行脚本，在执行期间想切换用户，可以参考下面做法：</p>\n<pre><code># 建立redis用户,并使用gosu换另一个用户执行命令\nRUN groupadd -r redis &amp;&amp; useradd -r -g redis redis\n#下载gosu\nRUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/\ngosu-amd64&quot; \\\n    &amp;&amp; chmod +x /usr/local/bin/gosu    \\\n        &amp;&amp; gosu nobody true\n#设置CMD,并以另外的用户执行\nCMD [&quot;exec&quot;,&quot;gosu&quot;,&quot;redis&quot;,&quot;redis-server&quot;]\n</code></pre><p><code>gosu</code>使用更多信息参考：<a href=\"https://github.com/tianon/gosu\" target=\"_blank\" rel=\"noopener\">https://github.com/tianon/gosu</a></p>\n<h3 id=\"HEALTHCHECK-健康检查\"><a href=\"#HEALTHCHECK-健康检查\" class=\"headerlink\" title=\"HEALTHCHECK 健康检查\"></a>HEALTHCHECK 健康检查</h3><p>格式：</p>\n<ul>\n<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>:设置检查容器健康状况的命令    </li>\n<li><code>HEALTHCHECK NONE</code>:如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令。</li>\n</ul>\n<p>该指令是告诉<code>Docker</code>应该如何进行判断容器的状态是否正常。</p>\n<h3 id=\"ONBUILD-为他人做嫁衣裳\"><a href=\"#ONBUILD-为他人做嫁衣裳\" class=\"headerlink\" title=\"ONBUILD    为他人做嫁衣裳\"></a>ONBUILD    为他人做嫁衣裳</h3><p>格式: <code>ONBUILD &lt;其它指令&gt;</code></p>\n<p><code>ONBUILD</code> 后面的指令，在当前镜像构建的时候是不会执行的，只有以它所在的镜像为基础镜像的镜像在构建的时候才会执行。 </p>\n<p><code>Docker</code>中其它的命令都是为了定制当前的镜像准备的，只有<code>ONBUILD</code>是为了他人而准备。   </p>\n<p>所以，这里就可以看出，该指令可以用来做命令的继承。类似<code>maven</code>中的父<code>pom</code>。把<code>ONBUILD</code>后面的命令都看做各个子<code>Dockerfile</code>的共用命令。</p>\n<pre><code>FROM node:slim\nRUN mkdir /app\nWORKDIR    /app\nONBUILD    COPY ./package.json /app\nONBUILD RUN [&quot;npm&quot;,    &quot;install&quot;]\nONBUILD    COPY . /app/\nCMD [&quot;npm&quot;, &quot;start&quot;]\n</code></pre><p> 后面每一个子<code>Dockerfile</code>只需要以上面镜像伟基础镜像:</p>\n<pre><code>FROM my-node  \n</code></pre><p>这样，<code>ONBUILD</code>后面的指令都会在每个子<code>Dockerfile</code>中执行。     </p>\n<h2 id=\"删除本地镜像-1\"><a href=\"#删除本地镜像-1\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用命令<code>docker rmi</code>，格式：</p>\n<pre><code>`docker    rmi    [选项]    &lt;镜像1&gt;    [&lt;镜像2&gt;    ...]`\n\n_注意_: docker rm 命令是删除容器,不要混淆。\n</code></pre><p>可以用ID、镜像名、摘要删除镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker images\n[sudo] password for mutian: \nREPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\nmysql/mysql-server   latest              02d081b9c73e        2 months ago        300MB\nnginx                v3                  b92f375b41f0        4 months ago        109MB\nnginx                v2                  e8023c09eed5        4 months ago        109MB\nnginx                latest              e548f1a579cf        4 months ago        109MB\ncentos               latest              ff426288ea90        5 months ago        207MB\nhello-world          latest              f2a91732366c        7 months ago        1.85kB\nseason/fastdfs       latest              c6cc94c34f8e        2 years ago         205MB\n</code></pre><ol>\n<li>用短id删除，人工输入的时候使用，方便：</li>\n</ol>\n<p><code>$    docker    rmi    ff4</code></p>\n<ol start=\"2\">\n<li>用长id，一般使用脚本的时候：</li>\n</ol>\n<p><code>$    docker    rmi    f2a91732366c</code></p>\n<ol start=\"3\">\n<li>用镜像名,<code>&lt;仓库名&gt;:&lt;标签&gt;</code>：</li>\n</ol>\n<p><code>docker    rmi    nginx：v3</code></p>\n<ol start=\"4\">\n<li>使用摘要，最精确： </li>\n</ol>\n<p>查看摘要：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker images --digests\nREPOSITORY           TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE\nmysql/mysql-server   latest              sha256:f1cb1e3f0124601b1496f485e9f4401ad10138294b5a38d932089daafd555e34   02d081b9c73e        2 months ago        300MB\nnginx                v3                  &lt;none&gt;                                                                    b92f375b41f0        4 months ago        109MB\nnginx                v2                  &lt;none&gt;                                                                    e8023c09eed5        4 months ago        109MB\nnginx                latest              sha256:4771d09578c7c6a65299e110b3ee1c0a2592f5ea2618d23e4ffe7a4cab1ce5de   e548f1a579cf        4 months ago        109MB\ncentos               latest              sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce   ff426288ea90        5 months ago        207MB\nhello-world          latest              sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7   f2a91732366c        7 months ago        1.85kB\nseason/fastdfs       latest              sha256:408acdebaa278e8ed875f7c63aa0c7ac8e633cf92f615d8295d279e137217003   c6cc94c34f8e        2 years ago         205MB\n</code></pre><p>删除：</p>\n<pre><code>docker rmi centos@sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n</code></pre><h3 id=\"Untagged和Deleted\"><a href=\"#Untagged和Deleted\" class=\"headerlink\" title=\"Untagged和Deleted\"></a>Untagged和Deleted</h3><p>仔细观察，发现两种删除行为。</p>\n<p>实际上，镜像都是一层层的，一个镜像有多个标签，只有每个标签都取消了，才有可能删除镜像。删除的时候从上最上层往下，逐步判断删除。 </p>\n<h3 id=\"用docker-images命令来配合\"><a href=\"#用docker-images命令来配合\" class=\"headerlink\" title=\"用docker images命令来配合\"></a>用<code>docker images</code>命令来配合</h3><p>配合<code>docker    images    -q</code>，可以成批的删除你想要删除的镜像，可以指定你想要删除的镜像。</p>\n<p>删除虚悬镜像：</p>\n<p><code>$    docker    rmi    $(docker    images    -q    -f    dangling=true)</code></p>\n<p>删除所有仓库名为redis的镜像:</p>\n<p><code>$    docker    rmi    $(docker    images    -q    redis)</code></p>\n<p>删除所有在mongo:3.2之前的镜像:</p>\n<p><code>$    docker    rmi    $(docker    images    -q    -f    before=mongo:3.2)</code></p>\n<h3 id=\"docker-image\"><a href=\"#docker-image\" class=\"headerlink\" title=\"docker image\"></a>docker image</h3><p>后面版本，推荐使用<code>docker image</code>来管理镜像。</p>\n<p>如删除：</p>\n<p><code>$    docker    image    rm</code></p>\n<h2 id=\"基于本地模板导入导出镜像\"><a href=\"#基于本地模板导入导出镜像\" class=\"headerlink\" title=\"基于本地模板导入导出镜像\"></a>基于本地模板导入导出镜像</h2><h2 id=\"把镜像上传到docker公共仓库\"><a href=\"#把镜像上传到docker公共仓库\" class=\"headerlink\" title=\"把镜像上传到docker公共仓库\"></a>把镜像上传到docker公共仓库</h2><p><a href=\"https://hub.docker.com\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a></p>\n<p>现在上面网址中注册：</p>\n<img src=\"/2018/02/02/docker-lesson3-images/b-1.png\">\n<p>1.登录docker</p>\n<pre><code>[root@xr-server-dev ~]# docker login \nLogin with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: xinxiamu\nPassword: \nLogin Succeeded\n</code></pre><p>2.对本地自定义的docker镜像打标签，必须先打标签：</p>\n<pre><code>[root@xr-server-dev ~]# docker tag fastdfs-server:v1 xinxiamu/fdfs-server:0.1\n</code></pre><p>3.上传到hub.docker.com:</p>\n<pre><code>[root@xr-server-dev ~]# docker push xinxiamu/fdfs-server:0.1\nThe push refers to repository [docker.io/xinxiamu/fdfs-server]\n77f438662c4e: Pushed \n7051cce03d08: Pushed \n47262386cb42: Pushed \n89b5ef66bef1: Pushed \n6498ec7e0c6f: Pushed \n939591e6b702: Pushed \nd99d7b3f4b3f: Pushed \ne5f0ae3c8627: Pushed \n79332ca36cf7: Pushed \nd69483a6face: Pushed \n0.1: digest: sha256:811bc129bc6da0fe648e8dc4388dac39db592d86c14f4df87b2b70fc13b80fb5 size: 2403\n</code></pre><p>刷新页面可以看到已经上传：</p>\n<img src=\"/2018/02/02/docker-lesson3-images/b-2.png\">        \n<h2 id=\"把镜像上传到私服\"><a href=\"#把镜像上传到私服\" class=\"headerlink\" title=\"把镜像上传到私服\"></a>把镜像上传到私服</h2><p>后面章节有介绍……</p>\n<h2 id=\"镜像的实现原理\"><a href=\"#镜像的实现原理\" class=\"headerlink\" title=\"镜像的实现原理\"></a>镜像的实现原理</h2><p><a href=\"https://en.wikipedia.org/wiki/UnionFS\" target=\"_blank\" rel=\"noopener\">UnionFS</a></p>\n<h2 id=\"配置镜像加速器\"><a href=\"#配置镜像加速器\" class=\"headerlink\" title=\"配置镜像加速器\"></a>配置镜像加速器</h2><p>注册阿里云账号后，即可在阿里云控制台（<a href=\"https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。\" target=\"_blank\" rel=\"noopener\">https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。</a></p>\n<img src=\"/2018/02/02/docker-lesson3-images/yy.png\">\n<p>按照上图说明配置即可。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>Docker    运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker    会从镜像仓库下载(默认是<br>Docker    Hub    公共注册服务器中的仓库)。</p>\n<p>本章将介绍更多关于镜像的内容,包括:</p>\n<ul>\n<li>从仓库获取镜像;</li>\n<li>管理本地主机上的镜像;</li>\n<li>介绍镜像实现的基本原理。</li>\n</ul>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>在官方<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>有大量高质量可用镜像。下面我们来看怎样获取这些镜像。</p>\n<p>从Docker    镜像仓库获取镜像的命令是docker    pull。其命令格式为: </p>\n<pre><code>docker pull    [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n</code></pre><p>具体的先选可以通过<code>docker pull    --help</code>命令查看。镜像名称的格式：</p>\n<ul>\n<li>Docker 镜像仓库地址:地址的格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是Docker Hub。</li>\n<li>仓库名:如之前所说,这里的仓库名是两段式名称,即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。</li>\n</ul>\n<p>比如:</p>\n<pre><code>$    docker    pull    ubuntu:16.04\n16.04:    Pulling    from    library/ubuntu\nbf5d46315322:    Pull    complete\n9f13e0ac480c:    Pull    complete\ne8988b5b3097:    Pull    complete\n40af181810e7:    Pull    complete\ne6f7c7e5c03e:    Pull    complete\nDigest:    sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\nStatus:    Downloaded    newer    image    for    ubuntu:16.04\n</code></pre><p>上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04    ,因此将会获取官方镜像library/ubuntu    仓库中标签为16.04的镜像。    </p>\n<p>例子： </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n[sudo] password for mutian: \nUsing default tag: latest\nlatest: Pulling from library/centos\naf4b0a2388c6: Pull complete \nDigest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\nStatus: Downloaded newer image for centos:latest\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。</p>\n<p><code>sudo docker run -it --rm centos bash</code></p>\n<pre><code>[root@5f6c0a6b41c1 ~]# cat /etc/os-release \nNAME=&quot;CentOS Linux&quot;\nVERSION=&quot;7 (Core)&quot;\nID=&quot;centos&quot;\nID_LIKE=&quot;rhel fedora&quot;\nVERSION_ID=&quot;7&quot;\nPRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;\nANSI_COLOR=&quot;0;31&quot;\nCPE_NAME=&quot;cpe:/o:centos:centos:7&quot;\nHOME_URL=&quot;https://www.centos.org/&quot;\nBUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;\n\nCENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;\nCENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;\nREDHAT_SUPPORT_PRODUCT=&quot;centos&quot;\nREDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;\n\n[root@5f6c0a6b41c1 ~]# \n</code></pre><p>通过上面信息我们可以看到容器内系统信息。</p>\n<p>命令说明：</p>\n<p><code>docker    run</code>就是运行容器的命令,具体格式我们会在    容器    一节进行详细讲解,我们这里简要的说明一下上面用到的参数。</p>\n<ul>\n<li><code>-it</code>:这是两个参数,一个是<code>-i</code>:交互式操作,一个是<code>-t</code>终端。我们这里打算进入<code>bash</code>执行一些命令并查看返回结果,因此我们需要交互式终端。</li>\n<li><code>--rm</code>:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动<code>docker    rm</code>。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用<code>--rm</code>可以避免浪费空间。</li>\n<li><code>centos</code>:这是指用<code>centos</code>镜像为基础来启动容器。</li>\n<li><code>bash</code>:放在镜像名后的是命令,这里我们希望有个交互式<code>Shell</code>,因此用的是<code>bash</code>。</li>\n</ul>\n<p>进入系统后我们可以执行任何linux下的命令。</p>\n<p>最后我们通过<code>exit</code>退出了这个容器。<br>退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了<code>--rm</code>命令。</p>\n<h2 id=\"列出所有的镜像\"><a href=\"#列出所有的镜像\" class=\"headerlink\" title=\"列出所有的镜像\"></a>列出所有的镜像</h2><p>想列出所有已经下载的镜像，可以使用命令<code>docker    image ls</code></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n[sudo] password for mutian: \nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest              f2a91732366c        3 months ago        1.85kB\n</code></pre><p>上面列表包含了<code>仓库名</code>、<code>标签</code>、<code>镜像ID</code>、<code>创建时间</code>以及所占用空间。<br>镜像    ID    则是镜像的唯一标识,一个镜像可以对应多个标签。</p>\n<ul>\n<li>镜像体积SIZE：<br>上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比<br>每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。</li>\n</ul>\n<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\nTYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\nImages              2                   1                   207.2MB             207.2MB (99%)\nContainers          1                   0                   0B                  0B\nLocal Volumes       0                   0                   0B                  0B\nBuild Cache \n</code></pre><ul>\n<li>虚悬镜像</li>\n</ul>\n<img src=\"/2018/02/02/docker-lesson3-images/a.png\">\n<p>如上图，命令查出来的就是虚悬镜像。其产生的原因是：<br>由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。</none></p>\n<p>这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：</p>\n<pre><code>$ sudo docker image    prune\n</code></pre><ul>\n<li>中间层镜像<br>为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可<br>能会看到一些依赖的中间层镜像。默认的<code>docker image    ls</code>列表中只会显示顶层镜像,如果<br>希望显示包括中间层镜像在内的所有镜像的话,需要加    <code>-a</code>参数。</li>\n</ul>\n<pre><code>$ sudo docker image ls -a\n</code></pre><p>这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 </p>\n<ul>\n<li>列出部分镜像<br>上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。</li>\n</ul>\n<p>根据仓库名称列出镜像：</p>\n<pre><code>sudo docker image ls centos\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\n</code></pre><p>列出特定的某个镜像,也就是说指定仓库名和标签</p>\n<img src=\"/2018/02/02/docker-lesson3-images/b.png\">\n<p>过滤查找镜像，使用<code>--filter</code>。具体使用请百度。</p>\n<ul>\n<li>以特定格式显示</li>\n</ul>\n<p>只显示ID列：</p>\n<pre><code>sudo docker image ls -q\nff426288ea90\nf2a91732366c\n</code></pre><p>用go模板语法定制格式显示<br>比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;{{.ID}}:{{.Repository}}&quot;\nff426288ea90:centos\nf2a91732366c:hello-world\n</code></pre><p>或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}&quot;\nIMAGE ID            REPOSITORY          TAG\nff426288ea90        centos              latest\nf2a91732366c        hello-world         latest\n</code></pre><h2 id=\"删除本地镜像\"><a href=\"#删除本地镜像\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用<code>docker    image    rm</code>命令来删除本地镜像。格式如下：</p>\n<pre><code>$    docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]\n</code></pre><ul>\n<li>用    ID、镜像名、摘要删除镜像</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest        \n\n#删除hello-world，段id，id一部分，能区分就行。\nmutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n</code></pre><p>用仓库名删除：</p>\n<pre><code>$ sudo docker image    rm    hello-world    \n</code></pre><p>当然,更精确的是使用镜像摘要删除镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n</code></pre><ul>\n<li>用    <code>docker    image    ls</code>命令来配合</li>\n</ul>\n<p>比如,我们需要删除所有仓库名为redis的镜像:</p>\n<pre><code>$ docker image rm $(docker image ls -q redis)\n</code></pre><h2 id=\"利用commit理解镜像构成\"><a href=\"#利用commit理解镜像构成\" class=\"headerlink\" title=\"利用commit理解镜像构成\"></a>利用commit理解镜像构成</h2><p>镜像是一层一层构成的。</p>\n<p>现在让我们以定制一个Web    服务器为例子,来讲解镜像是如何构建的。</p>\n<pre><code>docker run --name webserver -d -p 80:80 nginx\n</code></pre><p>在浏览器可查看：</p>\n<img src=\"/2018/02/02/docker-lesson3-images/c.png\">\n<p>现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎    Docker的文字,我们可以使用<code>docker    exec</code>命令进入容器,修改其内容 </p>\n<pre><code>&gt; sudo docker exec -it webserver bash\nroot@3729b97e8226:/# echo &apos;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&apos; &gt;    /usr/share/nginx/html/index.html\nroot@3729b97e8226:/#    exit\n</code></pre><p>然后刷新浏览器，就可以看到更改了。</p>\n<p>我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过<code>docker    diff</code>命令看到具体的改动。</p>\n<p>下面我们可以用下面的命令将容器保存为镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n&gt; --author &quot;zmt&quot; \\\n&gt; --message &quot;修改了默认页面&quot; \\\n&gt; webserver \\\n&gt; nginx:v2\nsha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n\n#查看\nmutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               v2                  e8023c09eed5        8 seconds ago       109MB\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest  \n</code></pre><p>查看镜像内历史记录：</p>\n<pre><code>$ docker history nginx:v2\n</code></pre><p>新的镜像定制好后,我们可以来运行这个镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n</code></pre><p>在浏览器查看：<a href=\"http://localhost:81/\" target=\"_blank\" rel=\"noopener\">http://localhost:81/</a></p>\n<p>停止容器：<code>sudo docker kill --signal=SIGINT web2</code></p>\n<p>至此,我们第一次完成了定制镜像,使用的是<code>docker    commit</code>命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。</p>\n<blockquote>\n<p>注意：通常不会使用<code>docker commit</code>来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。</p>\n</blockquote>\n<h2 id=\"使用Dockerfile定制镜像\"><a href=\"#使用Dockerfile定制镜像\" class=\"headerlink\" title=\"使用Dockerfile定制镜像\"></a>使用Dockerfile定制镜像</h2><p>从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。</p>\n<p>Dockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,<br>因此每一条指令的内容,就是描述该层应当如何构建。</p>\n<h3 id=\"简单例子：\"><a href=\"#简单例子：\" class=\"headerlink\" title=\"简单例子：\"></a>简单例子：</h3><p>1.创建Dockerfile文件</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\nmutian@mutian-ThinkPad-T440p:~$ cd mynginx/\nmutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n</code></pre><p>2.打开Dockerfile文件，编辑如下内容：</p>\n<pre><code>FROM nginx\nRUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n</code></pre><p>3.构建镜像<br>进入Dockerfile所在目录，执行命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\nSending build context to Docker daemon  2.048kB\nStep 1/2 : FROM nginx\n ---&gt; e548f1a579cf\nStep 2/2 : RUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n ---&gt; Running in d8c0149adf7e\nRemoving intermediate container d8c0149adf7e\n ---&gt; b92f375b41f0\nSuccessfully built b92f375b41f0\nSuccessfully tagged nginx:v3\n</code></pre><p>4.查看</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\nnginx               v3                  b92f375b41f0        About a minute ago   109MB\nnginx               v2                  e8023c09eed5        17 hours ago         109MB\nnginx               latest              e548f1a579cf        8 days ago           109MB\ncentos              latest              ff426288ea90        7 weeks ago          207MB\nhello-world         latest              f2a91732366c        3 months ago    \n</code></pre><p>我们看到，TAG为v3的镜像就是我们刚才构建。    </p>\n<h3 id=\"FROM指定基础镜像\"><a href=\"#FROM指定基础镜像\" class=\"headerlink\" title=\"FROM指定基础镜像\"></a>FROM指定基础镜像</h3><p>定制镜像必须是以一个镜像为基础来构建，基础镜像是必须要指定的，而FROM命令就是指定基础镜像，且第一步就要指定。   </p>\n<p>除了选择一些先前定制好的镜像作为基础镜像，Docker还存在一个特殊的镜像，名为<code>scratch</code>，表示空镜像，是个虚拟的概念，不实际存在。</p>\n<pre><code>FROM    scratch\n...\n</code></pre><p>如果以<code>scratch</code>为基础，则意味着不以任何镜像为基础，后面所写的命令将作为镜像的第一层存在。</p>\n<p>对于一些二进制的可执行文件，直接最为第一层存在，不依赖其它运行时系统支持，可以用空镜像。类似go语言编译的程序。</p>\n<h3 id=\"RUN-执行命令\"><a href=\"#RUN-执行命令\" class=\"headerlink\" title=\"RUN 执行命令\"></a>RUN 执行命令</h3><p>RUN命令是用来执行命令行命令的，就像shell脚本一样，用来执行linux命令。</p>\n<p>注意避免错误：</p>\n<pre><code>FROM    debian:jessie\nRUN    apt-get    update\nRUN    apt-get    install    -y    gcc    libc6-dev    make\nRUN    wget    -O    redis.tar.gz    &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;\nRUN    mkdir    -p    /usr/src/redis\nRUN    tar    -xzf    redis.tar.gz    -C    /usr/src/redis    --strip-components=1\nRUN    make    -C    /usr/src/redis\nRUN    make    -C    /usr/src/redis    install\n</code></pre><p>每一个指令都会创建一层，每层都会带有上层垃圾，因此一定要避免这样写。正确的写法如下： </p>\n<pre><code>FROM    debian:jessie\nRUN    buildDeps=&apos;gcc    libc6-dev    make&apos;    \\\n                &amp;&amp;    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    $buildDeps    \\\n                &amp;&amp;    wget    -O    redis.tar.gz    &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;    \\\n                &amp;&amp;    mkdir    -p    /usr/src/redis    \\\n                &amp;&amp;    tar    -xzf    redis.tar.gz    -C    /usr/src/redis    --strip-components=1    \\\n                &amp;&amp;    make    -C    /usr/src/redis    \\\n                &amp;&amp;    make    -C    /usr/src/redis    install    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*    \\\n                &amp;&amp;    rm    redis.tar.gz    \\\n                &amp;&amp;    rm    -r    /usr/src/redis    \\\n                &amp;&amp;    apt-get    purge    -y    --auto-remove    $buildDeps\n</code></pre><p>用了<code>&amp;&amp;</code>，这和<code>shell</code>执行命令一样，就相当一个命令，所以算一层。执行完后，一定要记得删除不必要的垃圾数据，垃圾包。<br>在编写<code>Dockerfile</code>时候，一定要面向类似事件的思维，比如，安装redis环境，是一个事件，算一层。安装mysql，算一个事件，一层。  </p>\n<h2 id=\"Dockerfile指令详解\"><a href=\"#Dockerfile指令详解\" class=\"headerlink\" title=\"Dockerfile指令详解\"></a>Dockerfile指令详解</h2><p>上面我们已经了解了<code>From</code>、<code>RUN</code>指令，下面我们来介绍其余的……</p>\n<h3 id=\"COPY复制文件\"><a href=\"#COPY复制文件\" class=\"headerlink\" title=\"COPY复制文件\"></a>COPY复制文件</h3><p>格式：</p>\n<ul>\n<li><p><code>COPY    &lt;源路径&gt;...    &lt;目标路径&gt;</code></p>\n</li>\n<li><p><code>COPY    [&quot;&lt;源路径1&gt;&quot;,...    &quot;&lt;目标路径&gt;&quot;]</code></p>\n</li>\n</ul>\n<p>源路径指当前电脑系统文件路径，目标路径指容器的文件路径。  </p>\n<p><code>COPY</code>指令将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路<br>径&gt;位置。比如:  </p>\n<pre><code>COPY    package.json    /usr/src/app/\n</code></pre><p><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，只要满足<code>GO</code>的<a href=\"https://golang.org/pkg/path/filepath/#Match\" target=\"_blank\" rel=\"noopener\">filepath.Match</a>规则，如： </p>\n<pre><code>COPY    hom*    /mydir/\nCOPY    hom?.txt    /mydir/\n</code></pre><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）       </p>\n<p><em>注意一点</em>： </p>\n<p>使用    <code>COPY</code>指令,源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p>\n<h3 id=\"ADD-更高级的复制文件\"><a href=\"#ADD-更高级的复制文件\" class=\"headerlink\" title=\"ADD    更高级的复制文件\"></a>ADD    更高级的复制文件</h3><p><code>ADD</code>指令和<code>COPY</code>指令本质上是一样的，只是添加了更多功能。 它的源文件可以是个url，也可以是tar，如果是tar还可以自动解压。  </p>\n<p>但是，如果是url，下载下来后，还要新建一层解压，授权，因此不如用<code>COPY</code> ，然后用<code>wget</code>命令。  </p>\n<p>在某个场景下，自动解压缩功能非常有用。 如： </p>\n<pre><code>FROM    scratch\nADD    ubuntu-xenial-core-cloudimg-amd64-root.tar.gz    /\n...\n</code></pre><p>_注意_：  </p>\n<p>在<code>COPY</code>    和<code>ADD</code>指令中选择的时候,可以遵循这样的原则,所有的文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD。 </p>\n<h3 id=\"CMD容器启动命令\"><a href=\"#CMD容器启动命令\" class=\"headerlink\" title=\"CMD容器启动命令\"></a>CMD容器启动命令</h3><p>也有两种格式：</p>\n<ul>\n<li><code>shell</code>格式：<code>CMD &lt;命令&gt;</code></li>\n<li><code>exec</code>格式：<code>CMD    [&quot;可执行文件&quot;,    &quot;参数1&quot;,    &quot;参数2&quot;...]</code>    </li>\n<li>参数列表格式:     <code>CMD    [&quot;参数1&quot;,    &quot;参数2&quot;...]</code>     。在指定了<code>ENTRYPOINT</code>指令后,用<code>CMD</code>指定具体的参数。</li>\n</ul>\n<p>在指令格式上，推荐<code>exec</code>格式。  </p>\n<p>Docker不是虚拟机，只是一个进程。因此，在容器中启动程序，不要以后台形式启动，要以前台形式启动。<br>容器内没有后台概念。 </p>\n<p>不要这样启动：</p>\n<p><code>CMD service ginx start</code></p>\n<p>直接启动可执行文件，并以前台形式启动：</p>\n<p><code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></p>\n<h3 id=\"ENTRYPOINT入口点\"><a href=\"#ENTRYPOINT入口点\" class=\"headerlink\" title=\"ENTRYPOINT入口点\"></a>ENTRYPOINT入口点</h3><p>也分为：<code>exec</code>格式和<code>shell</code>格式</p>\n<p>当指定了<code>ENTRYPOINT</code>后，就会把<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code>指令，换句话说实际执行时，将变为：</p>\n<pre><code>&lt;ENTRYPOINT&gt;    &quot;&lt;CMD&gt;&quot;\n</code></pre><p><em>场景一</em>：<br>把镜像当成命令一样使用。</p>\n<pre><code>FROM    ubuntu:16.04\nRUN    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    curl    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*\nCMD    [    &quot;curl&quot;,    &quot;-s&quot;,    &quot;http://ip.cn&quot;    ]\n</code></pre><p>执行：</p>\n<pre><code>$    docker    run    myip\n当前    IP:61.148.226.66    来自:北京市    联通    \n</code></pre><p>再执行：</p>\n<pre><code>$    docker    run    myip    -i\ndocker:    Error    response    from    daemon:    invalid    header    field    value    &quot;oci    runtime    error:    con\ntainer_linux.go:247:    starting    container    process    caused    \\&quot;exec:    \\\\\\&quot;-i\\\\\\&quot;:    executable    \nfile    not    found    in    $PATH\\&quot;\\n&quot;.\n</code></pre><p>可以看到，报错了，因为<code>-i</code>不能参数不能传到<code>CMD</code>上去。</p>\n<p>正确方式：</p>\n<pre><code>FROM    ubuntu:16.04\nRUN    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    curl    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*\nENTRYPOINT    [    &quot;curl&quot;,    &quot;-s&quot;,    &quot;http://ip.cn&quot;    ]\n</code></pre><p>执行：</p>\n<pre><code>$    docker    run    myip\n当前    IP:61.148.226.66    来自:北京市    联通\n\n$    docker    run    myip    -i\nHTTP/1.1    200    OK\nServer:    nginx/1.8.0\nDate:    Tue,    22    Nov    2016    05:12:40    GMT\nContent-Type:    text/html;    charset=UTF-8\nVary:    Accept-Encoding\nX-Powered-By:    PHP/5.6.24-1~dotdeb+7.1\nX-Cache:    MISS    from    cache-2\nX-Cache-Lookup:    MISS    from    cache-2:80\nX-Cache:    MISS    from    proxy-2_6\nTransfer-Encoding:    chunked\nVia:    1.1    cache-2:80,    1.1    proxy-2_6:8006\nConnection:    keep-alive\n当前    IP:61.148.226.66    来自:北京市    联通\n</code></pre><p>可以看到,这次成功了。这是因为当存在<code>ENTRYPOINT</code>后,<code>CMD</code>的内容将会作为参数传给<code>ENTRYPOINT</code>,而这里<code>-i</code>就是新的<code>CMD</code>,因此会作为参数传给<code>curl</code>,从而达到了我们预`期的效果。      </p>\n<p><em>场景二</em>：</p>\n<p>在应用程序启动前等做一些初始化工作。 </p>\n<p>比如启动redis，不以<code>root</code>，而以<code>redis</code>用户身份启动。 </p>\n<pre><code>FROM alpine:3.4\n...\nRUN addgroup -S    redis &amp;&amp; adduser -S -G redis redis\n...\nENTRYPOINT [&quot;docker-entrypoint.sh&quot;]\nEXPOSE    6379\nCMD [&quot;redis-server&quot;]\n</code></pre><p>可以看到其中为了<code>redis</code>服务创建了<code>redis</code>用户,并在最后指定了<code>ENTRYPOINT</code>为<code>docker-entrypoint.sh</code>脚本。   </p>\n<pre><code>#!/bin/sh\n...\n#allow the container to be started with    `--user`\nif [&quot;$1&quot; = &apos;redis-server&apos; -a &quot;$(id -u)&quot;    = &apos;0&apos;];    then\n                chown -R redis    .\n                exec su-exec redis &quot;$0&quot; &quot;$@&quot;\nfi\nexec &quot;$@&quot;\n</code></pre><p>执行：</p>\n<pre><code>$ docker run -it redis id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre><h3 id=\"ENV-设置环境变量\"><a href=\"#ENV-设置环境变量\" class=\"headerlink\" title=\"ENV    设置环境变量\"></a>ENV    设置环境变量</h3><p>格式有两种:</p>\n<ul>\n<li><code>ENV    &lt;key&gt;    &lt;value&gt;</code>    </li>\n<li><code>ENV    &lt;key1&gt;=&lt;value1&gt;    &lt;key2&gt;=&lt;value2&gt;...</code>  </li>\n</ul>\n<p>如：</p>\n<pre><code>ENV    VERSION=1.0    DEBUG=on \\\n    NAME=&quot;Happy    Feet&quot;   \n</code></pre><p>这里展示了用法，还展示了换行，有空格的话用双引号。 </p>\n<p>定义了变量，后面的命令中就可以使用了。可以使用它的命令如下一些： </p>\n<pre><code>ADD     、     COPY     、     ENV     、     EXPOSE     、     LABEL     、     USER     、     WORKDIR     、     VOLUME     、     STOPSIGNAL     、     ONBU\nILD    \n</code></pre><p>node官方Dockerfile例子：</p>\n<pre><code>ENV    NODE_VERSION    7.2.0\nRUN    curl    -SLO    &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta\nr.xz&quot;    \\\n        &amp;&amp;    curl    -SLO    &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;    \\\n        &amp;&amp;    gpg    --batch    --decrypt    --output    SHASUMS256.txt    SHASUMS256.txt.asc    \\\n        &amp;&amp;    grep    &quot;    node-v$NODE_VERSION-linux-x64.tar.xz\\$&quot;    SHASUMS256.txt    |    sha256sum    -c    -    \\\n        &amp;&amp;    tar    -xJf    &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;    -C    /usr/local    --strip-components=\n1    \\\n        &amp;&amp;    rm    &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;    SHASUMS25    \n</code></pre><p>可以看到，定义了变量，后面就可以不断重复引入使用。改变的时候，只需要改一个地方。同时可以创建不同的多个镜像。 </p>\n<h3 id=\"ARG-构建参数\"><a href=\"#ARG-构建参数\" class=\"headerlink\" title=\"ARG    构建参数\"></a>ARG    构建参数</h3><p>构建参数和<code>ENV</code>的效果一样,都是设置环境变量。所不同的是,<code>ARG</code>所设置的构建环境的环境变量,在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用<code>ARG</code>保存密码之类的信息,因为<code>docker    history</code>还是可以看到所有值的。 </p>\n<h3 id=\"VOLUME-定义匿名卷\"><a href=\"#VOLUME-定义匿名卷\" class=\"headerlink\" title=\"VOLUME    定义匿名卷\"></a>VOLUME    定义匿名卷</h3><p>两种格式：</p>\n<ul>\n<li><code>VOLUME    [&quot;&lt;路径1&gt;&quot;,    &quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><code>VOLUME    &lt;路径&gt;</code></li>\n</ul>\n<p>不应该在容器存储层发生写操作。这样容器就能保持无状态的。对于动态数据，文件，我们应该保存到卷中。为了防止用户在运行时将动态文件写到存储层，<br>所以要预先指定动态文件写入的目录挂载为卷，如下： </p>\n<pre><code>VOLUME    /data\n</code></pre><p>这里，指定<code>/data</code>为匿名卷，任何写入该目录下的数据都不会写入到容器存储层。这样容器就是无状态的。可以运行时替换掉所挂载卷： </p>\n<pre><code>docker    run    -d    -v    mydata:/data    xxxx\n</code></pre><p>在这行命令中,就使用了<code>mydata</code>这个命名卷挂载到了<code>/data</code>这个位置,替代了<code>Dockerfile</code>中定义的匿名卷的挂载配置。  </p>\n<h3 id=\"EXPOSE-声明端口\"><a href=\"#EXPOSE-声明端口\" class=\"headerlink\" title=\"EXPOSE    声明端口\"></a>EXPOSE    声明端口</h3><p>格式：<code>EXPOSE    &lt;端口1&gt;    [&lt;端口2&gt;...]</code>    </p>\n<p><code>EXPOSE</code>指令是声明运行时容器提供服务端口,这只是一个声明,在运行时并不会因为这个声明应用就会开启这个端口的服务。   </p>\n<p>要将<code>EXPOSE</code>和在运行时使用<code>-p    &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开来。<code>-p</code>,是映射宿主端口和容器端口,换句话说,就是将容器的对应端口服务公开给外界访问,而<code>EXPOSE</code>仅仅是声明容器打算使用什么端口而已,并不会自动在宿主进行端口映射。</p>\n<h3 id=\"WORKDIR指定工作目录\"><a href=\"#WORKDIR指定工作目录\" class=\"headerlink\" title=\"WORKDIR指定工作目录\"></a>WORKDIR指定工作目录</h3><p>格式：<code>WORKDIR    &lt;工作目录路径&gt;</code></p>\n<p>该命令可以指定工作目录（当前目录），后面各层都使用该指定目录。该目录如果不存在，则会创建空目录。</p>\n<p>写<code>Dockerfile</code>千万不能按照<code>shell</code>的思维写，应为<code>docker</code>是分层的。比如下面错误写法：</p>\n<pre><code>RUN cd /app\nRUN echo &quot;hello&quot; &gt; world.txt\n</code></pre><p>构建后，你会发现找不到<code>/app/world.txt</code>文件。原因是：在<code>shell</code>中执行命令，是在同一进程中，操作的是同样的内存。但是在<code>docker</code>中不是。你知道，每一个<code>RUN</code>命令都是构建一层的，启动不同的容器。第一次<code>RUN</code>只是操作进入<code>/app</code>目录，没有操作任何文件变更，只是内存的变化而已，第二次启动了个新的容器，跟第一层的容器完全没关系了。<br>所以：在写<code>Dockerfile</code>到时候，一定要有分层的思维，每一个完整的操作要在同一层里面做。</p>\n<p>如果要改变以后各层的工作目录都在指定的工作目录，那么<code>WORKDIR</code>指令就派上用场了。</p>\n<h3 id=\"USER指定当前用户\"><a href=\"#USER指定当前用户\" class=\"headerlink\" title=\"USER指定当前用户\"></a><code>USER</code>指定当前用户</h3><p>格式:<code>USER &lt;用户名&gt;</code>  用户名系统已经添加好</p>\n<p>和<code>WORKDIR</code>一样，都会影响后面的每一层。改变执行后面命令的执行身份。</p>\n<p>下面建立用户，并切换到该用户，启动<code>redis</code>：</p>\n<pre><code>RUN groupadd -r redis &amp;&amp; useradd -r -g redis edis\nUSER redis\nRUN [&quot;redis-server&quot;]\n</code></pre><p>如果以<code>root</code>执行脚本，在执行期间想切换用户，可以参考下面做法：</p>\n<pre><code># 建立redis用户,并使用gosu换另一个用户执行命令\nRUN groupadd -r redis &amp;&amp; useradd -r -g redis redis\n#下载gosu\nRUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/\ngosu-amd64&quot; \\\n    &amp;&amp; chmod +x /usr/local/bin/gosu    \\\n        &amp;&amp; gosu nobody true\n#设置CMD,并以另外的用户执行\nCMD [&quot;exec&quot;,&quot;gosu&quot;,&quot;redis&quot;,&quot;redis-server&quot;]\n</code></pre><p><code>gosu</code>使用更多信息参考：<a href=\"https://github.com/tianon/gosu\" target=\"_blank\" rel=\"noopener\">https://github.com/tianon/gosu</a></p>\n<h3 id=\"HEALTHCHECK-健康检查\"><a href=\"#HEALTHCHECK-健康检查\" class=\"headerlink\" title=\"HEALTHCHECK 健康检查\"></a>HEALTHCHECK 健康检查</h3><p>格式：</p>\n<ul>\n<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>:设置检查容器健康状况的命令    </li>\n<li><code>HEALTHCHECK NONE</code>:如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令。</li>\n</ul>\n<p>该指令是告诉<code>Docker</code>应该如何进行判断容器的状态是否正常。</p>\n<h3 id=\"ONBUILD-为他人做嫁衣裳\"><a href=\"#ONBUILD-为他人做嫁衣裳\" class=\"headerlink\" title=\"ONBUILD    为他人做嫁衣裳\"></a>ONBUILD    为他人做嫁衣裳</h3><p>格式: <code>ONBUILD &lt;其它指令&gt;</code></p>\n<p><code>ONBUILD</code> 后面的指令，在当前镜像构建的时候是不会执行的，只有以它所在的镜像为基础镜像的镜像在构建的时候才会执行。 </p>\n<p><code>Docker</code>中其它的命令都是为了定制当前的镜像准备的，只有<code>ONBUILD</code>是为了他人而准备。   </p>\n<p>所以，这里就可以看出，该指令可以用来做命令的继承。类似<code>maven</code>中的父<code>pom</code>。把<code>ONBUILD</code>后面的命令都看做各个子<code>Dockerfile</code>的共用命令。</p>\n<pre><code>FROM node:slim\nRUN mkdir /app\nWORKDIR    /app\nONBUILD    COPY ./package.json /app\nONBUILD RUN [&quot;npm&quot;,    &quot;install&quot;]\nONBUILD    COPY . /app/\nCMD [&quot;npm&quot;, &quot;start&quot;]\n</code></pre><p> 后面每一个子<code>Dockerfile</code>只需要以上面镜像伟基础镜像:</p>\n<pre><code>FROM my-node  \n</code></pre><p>这样，<code>ONBUILD</code>后面的指令都会在每个子<code>Dockerfile</code>中执行。     </p>\n<h2 id=\"删除本地镜像-1\"><a href=\"#删除本地镜像-1\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用命令<code>docker rmi</code>，格式：</p>\n<pre><code>`docker    rmi    [选项]    &lt;镜像1&gt;    [&lt;镜像2&gt;    ...]`\n\n_注意_: docker rm 命令是删除容器,不要混淆。\n</code></pre><p>可以用ID、镜像名、摘要删除镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker images\n[sudo] password for mutian: \nREPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\nmysql/mysql-server   latest              02d081b9c73e        2 months ago        300MB\nnginx                v3                  b92f375b41f0        4 months ago        109MB\nnginx                v2                  e8023c09eed5        4 months ago        109MB\nnginx                latest              e548f1a579cf        4 months ago        109MB\ncentos               latest              ff426288ea90        5 months ago        207MB\nhello-world          latest              f2a91732366c        7 months ago        1.85kB\nseason/fastdfs       latest              c6cc94c34f8e        2 years ago         205MB\n</code></pre><ol>\n<li>用短id删除，人工输入的时候使用，方便：</li>\n</ol>\n<p><code>$    docker    rmi    ff4</code></p>\n<ol start=\"2\">\n<li>用长id，一般使用脚本的时候：</li>\n</ol>\n<p><code>$    docker    rmi    f2a91732366c</code></p>\n<ol start=\"3\">\n<li>用镜像名,<code>&lt;仓库名&gt;:&lt;标签&gt;</code>：</li>\n</ol>\n<p><code>docker    rmi    nginx：v3</code></p>\n<ol start=\"4\">\n<li>使用摘要，最精确： </li>\n</ol>\n<p>查看摘要：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker images --digests\nREPOSITORY           TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE\nmysql/mysql-server   latest              sha256:f1cb1e3f0124601b1496f485e9f4401ad10138294b5a38d932089daafd555e34   02d081b9c73e        2 months ago        300MB\nnginx                v3                  &lt;none&gt;                                                                    b92f375b41f0        4 months ago        109MB\nnginx                v2                  &lt;none&gt;                                                                    e8023c09eed5        4 months ago        109MB\nnginx                latest              sha256:4771d09578c7c6a65299e110b3ee1c0a2592f5ea2618d23e4ffe7a4cab1ce5de   e548f1a579cf        4 months ago        109MB\ncentos               latest              sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce   ff426288ea90        5 months ago        207MB\nhello-world          latest              sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7   f2a91732366c        7 months ago        1.85kB\nseason/fastdfs       latest              sha256:408acdebaa278e8ed875f7c63aa0c7ac8e633cf92f615d8295d279e137217003   c6cc94c34f8e        2 years ago         205MB\n</code></pre><p>删除：</p>\n<pre><code>docker rmi centos@sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n</code></pre><h3 id=\"Untagged和Deleted\"><a href=\"#Untagged和Deleted\" class=\"headerlink\" title=\"Untagged和Deleted\"></a>Untagged和Deleted</h3><p>仔细观察，发现两种删除行为。</p>\n<p>实际上，镜像都是一层层的，一个镜像有多个标签，只有每个标签都取消了，才有可能删除镜像。删除的时候从上最上层往下，逐步判断删除。 </p>\n<h3 id=\"用docker-images命令来配合\"><a href=\"#用docker-images命令来配合\" class=\"headerlink\" title=\"用docker images命令来配合\"></a>用<code>docker images</code>命令来配合</h3><p>配合<code>docker    images    -q</code>，可以成批的删除你想要删除的镜像，可以指定你想要删除的镜像。</p>\n<p>删除虚悬镜像：</p>\n<p><code>$    docker    rmi    $(docker    images    -q    -f    dangling=true)</code></p>\n<p>删除所有仓库名为redis的镜像:</p>\n<p><code>$    docker    rmi    $(docker    images    -q    redis)</code></p>\n<p>删除所有在mongo:3.2之前的镜像:</p>\n<p><code>$    docker    rmi    $(docker    images    -q    -f    before=mongo:3.2)</code></p>\n<h3 id=\"docker-image\"><a href=\"#docker-image\" class=\"headerlink\" title=\"docker image\"></a>docker image</h3><p>后面版本，推荐使用<code>docker image</code>来管理镜像。</p>\n<p>如删除：</p>\n<p><code>$    docker    image    rm</code></p>\n<h2 id=\"基于本地模板导入导出镜像\"><a href=\"#基于本地模板导入导出镜像\" class=\"headerlink\" title=\"基于本地模板导入导出镜像\"></a>基于本地模板导入导出镜像</h2><h2 id=\"把镜像上传到docker公共仓库\"><a href=\"#把镜像上传到docker公共仓库\" class=\"headerlink\" title=\"把镜像上传到docker公共仓库\"></a>把镜像上传到docker公共仓库</h2><p><a href=\"https://hub.docker.com\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com</a></p>\n<p>现在上面网址中注册：</p>\n<img src=\"/2018/02/02/docker-lesson3-images/b-1.png\">\n<p>1.登录docker</p>\n<pre><code>[root@xr-server-dev ~]# docker login \nLogin with your Docker ID to push and pull images from Docker Hub. If you don&apos;t have a Docker ID, head over to https://hub.docker.com to create one.\nUsername: xinxiamu\nPassword: \nLogin Succeeded\n</code></pre><p>2.对本地自定义的docker镜像打标签，必须先打标签：</p>\n<pre><code>[root@xr-server-dev ~]# docker tag fastdfs-server:v1 xinxiamu/fdfs-server:0.1\n</code></pre><p>3.上传到hub.docker.com:</p>\n<pre><code>[root@xr-server-dev ~]# docker push xinxiamu/fdfs-server:0.1\nThe push refers to repository [docker.io/xinxiamu/fdfs-server]\n77f438662c4e: Pushed \n7051cce03d08: Pushed \n47262386cb42: Pushed \n89b5ef66bef1: Pushed \n6498ec7e0c6f: Pushed \n939591e6b702: Pushed \nd99d7b3f4b3f: Pushed \ne5f0ae3c8627: Pushed \n79332ca36cf7: Pushed \nd69483a6face: Pushed \n0.1: digest: sha256:811bc129bc6da0fe648e8dc4388dac39db592d86c14f4df87b2b70fc13b80fb5 size: 2403\n</code></pre><p>刷新页面可以看到已经上传：</p>\n<img src=\"/2018/02/02/docker-lesson3-images/b-2.png\">        \n<h2 id=\"把镜像上传到私服\"><a href=\"#把镜像上传到私服\" class=\"headerlink\" title=\"把镜像上传到私服\"></a>把镜像上传到私服</h2><p>后面章节有介绍……</p>\n<h2 id=\"镜像的实现原理\"><a href=\"#镜像的实现原理\" class=\"headerlink\" title=\"镜像的实现原理\"></a>镜像的实现原理</h2><p><a href=\"https://en.wikipedia.org/wiki/UnionFS\" target=\"_blank\" rel=\"noopener\">UnionFS</a></p>\n<h2 id=\"配置镜像加速器\"><a href=\"#配置镜像加速器\" class=\"headerlink\" title=\"配置镜像加速器\"></a>配置镜像加速器</h2><p>注册阿里云账号后，即可在阿里云控制台（<a href=\"https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。\" target=\"_blank\" rel=\"noopener\">https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。</a></p>\n<img src=\"/2018/02/02/docker-lesson3-images/yy.png\">\n<p>按照上图说明配置即可。 </p>\n"},{"title":"docker学习-第五课：数据管理","date":"2018-07-19T08:25:30.000Z","_content":"\n本文介绍docker中数据的管理，持久化。在docker中需要持久化应用程序产生的数据，或者需要多个容器之间共享数据。在容器中管理数据主要有两种方式： \n\n- 数据卷（Data volumes）\n- 数据卷容器（Data volumes containers） \n\n在新版本中，推荐使用`docker volume`子命令来管理`Docker`数据卷。   \n\n## 数据卷\n\n数据卷是一个特殊的目录，它将主机目录直接映射到容器，可供一个或者多个容器使用。它绕过`UFS`可以提供很多特性。 \n\n- 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。\n- 数据卷可以在多个容器之中共享和重用。 \n- 对数据卷的修改会立马生效。\n- 对数据卷的更新不会影响镜像。\n- 数据卷默认会一直存在，即使容器被删除。 \n\n_注_ : 使用docker中的数据卷，类似于系统使用`mount`挂载一个文件系统。 \n\n### 创建数据卷\n\n1. 使用`-v`创建一个数据卷挂载到容器中\n\n`docker run --name nginx-data -v /mydir nginx`\n\n执行如下命令即可查看容器构造的详情  \n`docker inspect 容器ID`  \n\n注： 也可以在`Dockerfile`中添加一个或者多个卷到由该镜像创建的任何容器中。\n\n### 删除数据卷\n\n数据卷是设计来做持久化的，它的生命周期独立于容器，Docker不会在容器删除后删除数据卷。所以，要手动明确删除某个数据卷。\n\n删除容器的时候同时想删除数据卷可以使用下面命令：\n\n    docker rm -v 容器ID\n    \n### 挂载宿主机目录作为数据卷\n\n同样，使用`-v`可以将宿主机目录挂载到容器中，如下：\n\n    docker run --name nginx-data2 -v /host-dir:/container-dir nginx\n\n上面命令，会将宿主机目录`/host-dir`挂载到容器的`/container-dir`目录。 \n\n- 本地目录的路径必须是绝对路径。  \n- 如果宿主机路径不存在，Docker会自动创建。 \n\n_注意_ : Dockerfile不支持这种形式。因为Dockerfile是用来传播和分享的，不同操作系统，路径表示不一样，所以目前暂时不支持。 \n\nDocker挂载的数据卷默认权限是可读写，如果要改为只读，可以通过`：ro`指定。 \n\n    docker run --name nginx-data2 -v /host-dir:/container-dir：ro nginx\n\n加了`：ro`之后，就挂载伟只读了。 这样，在容器就只能读取`/container-dir`目录中的文件，不能写。\n\n### 查看数据卷具体信息\n\n可以通过下面命令查看：\n\n    docker inspect web\n    \n从输出内容中可以看到数据卷相关的部分。 \n\n## 数据卷容器     \n\n如果有数据需要不断更新并在多个容器之间共享，那么你就需要建立数据卷容器了。\n\n数据卷容器首先是个正常的容器，专门提供数据卷供其它容器挂载的。  \n\n创建数据卷容器： \n    \n    docker run --name nginx-volume -v /data nginx\n    \n然后，就可以在其它容器中使用`-volumes-from`来挂载nginx-volume容器中的数据卷。   \n\n    docker run --name v1 --volumes-from nginx-volume nginx\n    docker run --name v2 --volumes-from nginx-volume nginx\n\n这样：  \n\n- v1、v2便可以共享nginx-volume容器中的数据卷。  \n- 即使nginx-volume容器停止，也不会有任何影响。   \n\n也可以使用超过一个的`-volumes-from`参数来指定从多个容器挂载不同的数据卷。也可以从其它挂载了数据卷的容器来级联挂载数据卷。 \n\n     docker run --name v3 --volumes-from v1 nginx\n     \n## 利用数据卷容器来备份、恢复、迁移数据卷 \n\n### 备份\n\n首先创建一个挂载容器卷`nginx-volume`的容器，并从主机挂载当前目录到容器`/backup`目录。如下： \n\n    docker run --name data-backup --volume-from nginx-volume -v  $(pwd):/backup centos/7 tar cvf /backup/backup.tar /nginx-volume\n    \n容器启动后，使用命令`tar`将容器卷`nginx-volume`备份为容器中/backup/backup.tar文件，也就主机当前目录下的名为backup.tar的文件。 \n\n### 恢复\n\n如果要恢复数据到一个容器，首先创建一个挂载空数据卷的容器`nginx-volume2`。 \n\n    docker run -v /dbdata --name nginx-volume2 ngxin /bin/bash\n    \n然后创建另一个容器,挂载nginx-volume2容器卷中的数据卷,并使用`untar`解压备份文件到挂载的容器卷中。 \n\n    docker run --vulume-from /nginx-volume2 -v $(pwd):/backup nginx untar xvf /backup/backup.tar\n    \n为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看  \n\n    dcoker run --volume-from nginx-volume2 nginx /bin/ls /dbdata    \n","source":"_posts/docker-lesson5-dv.md","raw":"---\ntitle: docker学习-第五课：数据管理\ndate: 2018-07-19 16:25:30\ncategories: docker\ntags: docker数据管理\n---\n\n本文介绍docker中数据的管理，持久化。在docker中需要持久化应用程序产生的数据，或者需要多个容器之间共享数据。在容器中管理数据主要有两种方式： \n\n- 数据卷（Data volumes）\n- 数据卷容器（Data volumes containers） \n\n在新版本中，推荐使用`docker volume`子命令来管理`Docker`数据卷。   \n\n## 数据卷\n\n数据卷是一个特殊的目录，它将主机目录直接映射到容器，可供一个或者多个容器使用。它绕过`UFS`可以提供很多特性。 \n\n- 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。\n- 数据卷可以在多个容器之中共享和重用。 \n- 对数据卷的修改会立马生效。\n- 对数据卷的更新不会影响镜像。\n- 数据卷默认会一直存在，即使容器被删除。 \n\n_注_ : 使用docker中的数据卷，类似于系统使用`mount`挂载一个文件系统。 \n\n### 创建数据卷\n\n1. 使用`-v`创建一个数据卷挂载到容器中\n\n`docker run --name nginx-data -v /mydir nginx`\n\n执行如下命令即可查看容器构造的详情  \n`docker inspect 容器ID`  \n\n注： 也可以在`Dockerfile`中添加一个或者多个卷到由该镜像创建的任何容器中。\n\n### 删除数据卷\n\n数据卷是设计来做持久化的，它的生命周期独立于容器，Docker不会在容器删除后删除数据卷。所以，要手动明确删除某个数据卷。\n\n删除容器的时候同时想删除数据卷可以使用下面命令：\n\n    docker rm -v 容器ID\n    \n### 挂载宿主机目录作为数据卷\n\n同样，使用`-v`可以将宿主机目录挂载到容器中，如下：\n\n    docker run --name nginx-data2 -v /host-dir:/container-dir nginx\n\n上面命令，会将宿主机目录`/host-dir`挂载到容器的`/container-dir`目录。 \n\n- 本地目录的路径必须是绝对路径。  \n- 如果宿主机路径不存在，Docker会自动创建。 \n\n_注意_ : Dockerfile不支持这种形式。因为Dockerfile是用来传播和分享的，不同操作系统，路径表示不一样，所以目前暂时不支持。 \n\nDocker挂载的数据卷默认权限是可读写，如果要改为只读，可以通过`：ro`指定。 \n\n    docker run --name nginx-data2 -v /host-dir:/container-dir：ro nginx\n\n加了`：ro`之后，就挂载伟只读了。 这样，在容器就只能读取`/container-dir`目录中的文件，不能写。\n\n### 查看数据卷具体信息\n\n可以通过下面命令查看：\n\n    docker inspect web\n    \n从输出内容中可以看到数据卷相关的部分。 \n\n## 数据卷容器     \n\n如果有数据需要不断更新并在多个容器之间共享，那么你就需要建立数据卷容器了。\n\n数据卷容器首先是个正常的容器，专门提供数据卷供其它容器挂载的。  \n\n创建数据卷容器： \n    \n    docker run --name nginx-volume -v /data nginx\n    \n然后，就可以在其它容器中使用`-volumes-from`来挂载nginx-volume容器中的数据卷。   \n\n    docker run --name v1 --volumes-from nginx-volume nginx\n    docker run --name v2 --volumes-from nginx-volume nginx\n\n这样：  \n\n- v1、v2便可以共享nginx-volume容器中的数据卷。  \n- 即使nginx-volume容器停止，也不会有任何影响。   \n\n也可以使用超过一个的`-volumes-from`参数来指定从多个容器挂载不同的数据卷。也可以从其它挂载了数据卷的容器来级联挂载数据卷。 \n\n     docker run --name v3 --volumes-from v1 nginx\n     \n## 利用数据卷容器来备份、恢复、迁移数据卷 \n\n### 备份\n\n首先创建一个挂载容器卷`nginx-volume`的容器，并从主机挂载当前目录到容器`/backup`目录。如下： \n\n    docker run --name data-backup --volume-from nginx-volume -v  $(pwd):/backup centos/7 tar cvf /backup/backup.tar /nginx-volume\n    \n容器启动后，使用命令`tar`将容器卷`nginx-volume`备份为容器中/backup/backup.tar文件，也就主机当前目录下的名为backup.tar的文件。 \n\n### 恢复\n\n如果要恢复数据到一个容器，首先创建一个挂载空数据卷的容器`nginx-volume2`。 \n\n    docker run -v /dbdata --name nginx-volume2 ngxin /bin/bash\n    \n然后创建另一个容器,挂载nginx-volume2容器卷中的数据卷,并使用`untar`解压备份文件到挂载的容器卷中。 \n\n    docker run --vulume-from /nginx-volume2 -v $(pwd):/backup nginx untar xvf /backup/backup.tar\n    \n为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看  \n\n    dcoker run --volume-from nginx-volume2 nginx /bin/ls /dbdata    \n","slug":"docker-lesson5-dv","published":1,"updated":"2019-06-16T14:38:33.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbb002kg4vanebkpvnv","content":"<p>本文介绍docker中数据的管理，持久化。在docker中需要持久化应用程序产生的数据，或者需要多个容器之间共享数据。在容器中管理数据主要有两种方式： </p>\n<ul>\n<li>数据卷（Data volumes）</li>\n<li>数据卷容器（Data volumes containers） </li>\n</ul>\n<p>在新版本中，推荐使用<code>docker volume</code>子命令来管理<code>Docker</code>数据卷。   </p>\n<h2 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h2><p>数据卷是一个特殊的目录，它将主机目录直接映射到容器，可供一个或者多个容器使用。它绕过<code>UFS</code>可以提供很多特性。 </p>\n<ul>\n<li>数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。</li>\n<li>数据卷可以在多个容器之中共享和重用。 </li>\n<li>对数据卷的修改会立马生效。</li>\n<li>对数据卷的更新不会影响镜像。</li>\n<li>数据卷默认会一直存在，即使容器被删除。 </li>\n</ul>\n<p>_注_ : 使用docker中的数据卷，类似于系统使用<code>mount</code>挂载一个文件系统。 </p>\n<h3 id=\"创建数据卷\"><a href=\"#创建数据卷\" class=\"headerlink\" title=\"创建数据卷\"></a>创建数据卷</h3><ol>\n<li>使用<code>-v</code>创建一个数据卷挂载到容器中</li>\n</ol>\n<p><code>docker run --name nginx-data -v /mydir nginx</code></p>\n<p>执行如下命令即可查看容器构造的详情<br><code>docker inspect 容器ID</code>  </p>\n<p>注： 也可以在<code>Dockerfile</code>中添加一个或者多个卷到由该镜像创建的任何容器中。</p>\n<h3 id=\"删除数据卷\"><a href=\"#删除数据卷\" class=\"headerlink\" title=\"删除数据卷\"></a>删除数据卷</h3><p>数据卷是设计来做持久化的，它的生命周期独立于容器，Docker不会在容器删除后删除数据卷。所以，要手动明确删除某个数据卷。</p>\n<p>删除容器的时候同时想删除数据卷可以使用下面命令：</p>\n<pre><code>docker rm -v 容器ID\n</code></pre><h3 id=\"挂载宿主机目录作为数据卷\"><a href=\"#挂载宿主机目录作为数据卷\" class=\"headerlink\" title=\"挂载宿主机目录作为数据卷\"></a>挂载宿主机目录作为数据卷</h3><p>同样，使用<code>-v</code>可以将宿主机目录挂载到容器中，如下：</p>\n<pre><code>docker run --name nginx-data2 -v /host-dir:/container-dir nginx\n</code></pre><p>上面命令，会将宿主机目录<code>/host-dir</code>挂载到容器的<code>/container-dir</code>目录。 </p>\n<ul>\n<li>本地目录的路径必须是绝对路径。  </li>\n<li>如果宿主机路径不存在，Docker会自动创建。 </li>\n</ul>\n<p>_注意_ : Dockerfile不支持这种形式。因为Dockerfile是用来传播和分享的，不同操作系统，路径表示不一样，所以目前暂时不支持。 </p>\n<p>Docker挂载的数据卷默认权限是可读写，如果要改为只读，可以通过<code>：ro</code>指定。 </p>\n<pre><code>docker run --name nginx-data2 -v /host-dir:/container-dir：ro nginx\n</code></pre><p>加了<code>：ro</code>之后，就挂载伟只读了。 这样，在容器就只能读取<code>/container-dir</code>目录中的文件，不能写。</p>\n<h3 id=\"查看数据卷具体信息\"><a href=\"#查看数据卷具体信息\" class=\"headerlink\" title=\"查看数据卷具体信息\"></a>查看数据卷具体信息</h3><p>可以通过下面命令查看：</p>\n<pre><code>docker inspect web\n</code></pre><p>从输出内容中可以看到数据卷相关的部分。 </p>\n<h2 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h2><p>如果有数据需要不断更新并在多个容器之间共享，那么你就需要建立数据卷容器了。</p>\n<p>数据卷容器首先是个正常的容器，专门提供数据卷供其它容器挂载的。  </p>\n<p>创建数据卷容器： </p>\n<pre><code>docker run --name nginx-volume -v /data nginx\n</code></pre><p>然后，就可以在其它容器中使用<code>-volumes-from</code>来挂载nginx-volume容器中的数据卷。   </p>\n<pre><code>docker run --name v1 --volumes-from nginx-volume nginx\ndocker run --name v2 --volumes-from nginx-volume nginx\n</code></pre><p>这样：  </p>\n<ul>\n<li>v1、v2便可以共享nginx-volume容器中的数据卷。  </li>\n<li>即使nginx-volume容器停止，也不会有任何影响。   </li>\n</ul>\n<p>也可以使用超过一个的<code>-volumes-from</code>参数来指定从多个容器挂载不同的数据卷。也可以从其它挂载了数据卷的容器来级联挂载数据卷。 </p>\n<pre><code>docker run --name v3 --volumes-from v1 nginx\n</code></pre><h2 id=\"利用数据卷容器来备份、恢复、迁移数据卷\"><a href=\"#利用数据卷容器来备份、恢复、迁移数据卷\" class=\"headerlink\" title=\"利用数据卷容器来备份、恢复、迁移数据卷\"></a>利用数据卷容器来备份、恢复、迁移数据卷</h2><h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>首先创建一个挂载容器卷<code>nginx-volume</code>的容器，并从主机挂载当前目录到容器<code>/backup</code>目录。如下： </p>\n<pre><code>docker run --name data-backup --volume-from nginx-volume -v  $(pwd):/backup centos/7 tar cvf /backup/backup.tar /nginx-volume\n</code></pre><p>容器启动后，使用命令<code>tar</code>将容器卷<code>nginx-volume</code>备份为容器中/backup/backup.tar文件，也就主机当前目录下的名为backup.tar的文件。 </p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>如果要恢复数据到一个容器，首先创建一个挂载空数据卷的容器<code>nginx-volume2</code>。 </p>\n<pre><code>docker run -v /dbdata --name nginx-volume2 ngxin /bin/bash\n</code></pre><p>然后创建另一个容器,挂载nginx-volume2容器卷中的数据卷,并使用<code>untar</code>解压备份文件到挂载的容器卷中。 </p>\n<pre><code>docker run --vulume-from /nginx-volume2 -v $(pwd):/backup nginx untar xvf /backup/backup.tar\n</code></pre><p>为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看  </p>\n<pre><code>dcoker run --volume-from nginx-volume2 nginx /bin/ls /dbdata    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍docker中数据的管理，持久化。在docker中需要持久化应用程序产生的数据，或者需要多个容器之间共享数据。在容器中管理数据主要有两种方式： </p>\n<ul>\n<li>数据卷（Data volumes）</li>\n<li>数据卷容器（Data volumes containers） </li>\n</ul>\n<p>在新版本中，推荐使用<code>docker volume</code>子命令来管理<code>Docker</code>数据卷。   </p>\n<h2 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h2><p>数据卷是一个特殊的目录，它将主机目录直接映射到容器，可供一个或者多个容器使用。它绕过<code>UFS</code>可以提供很多特性。 </p>\n<ul>\n<li>数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。</li>\n<li>数据卷可以在多个容器之中共享和重用。 </li>\n<li>对数据卷的修改会立马生效。</li>\n<li>对数据卷的更新不会影响镜像。</li>\n<li>数据卷默认会一直存在，即使容器被删除。 </li>\n</ul>\n<p>_注_ : 使用docker中的数据卷，类似于系统使用<code>mount</code>挂载一个文件系统。 </p>\n<h3 id=\"创建数据卷\"><a href=\"#创建数据卷\" class=\"headerlink\" title=\"创建数据卷\"></a>创建数据卷</h3><ol>\n<li>使用<code>-v</code>创建一个数据卷挂载到容器中</li>\n</ol>\n<p><code>docker run --name nginx-data -v /mydir nginx</code></p>\n<p>执行如下命令即可查看容器构造的详情<br><code>docker inspect 容器ID</code>  </p>\n<p>注： 也可以在<code>Dockerfile</code>中添加一个或者多个卷到由该镜像创建的任何容器中。</p>\n<h3 id=\"删除数据卷\"><a href=\"#删除数据卷\" class=\"headerlink\" title=\"删除数据卷\"></a>删除数据卷</h3><p>数据卷是设计来做持久化的，它的生命周期独立于容器，Docker不会在容器删除后删除数据卷。所以，要手动明确删除某个数据卷。</p>\n<p>删除容器的时候同时想删除数据卷可以使用下面命令：</p>\n<pre><code>docker rm -v 容器ID\n</code></pre><h3 id=\"挂载宿主机目录作为数据卷\"><a href=\"#挂载宿主机目录作为数据卷\" class=\"headerlink\" title=\"挂载宿主机目录作为数据卷\"></a>挂载宿主机目录作为数据卷</h3><p>同样，使用<code>-v</code>可以将宿主机目录挂载到容器中，如下：</p>\n<pre><code>docker run --name nginx-data2 -v /host-dir:/container-dir nginx\n</code></pre><p>上面命令，会将宿主机目录<code>/host-dir</code>挂载到容器的<code>/container-dir</code>目录。 </p>\n<ul>\n<li>本地目录的路径必须是绝对路径。  </li>\n<li>如果宿主机路径不存在，Docker会自动创建。 </li>\n</ul>\n<p>_注意_ : Dockerfile不支持这种形式。因为Dockerfile是用来传播和分享的，不同操作系统，路径表示不一样，所以目前暂时不支持。 </p>\n<p>Docker挂载的数据卷默认权限是可读写，如果要改为只读，可以通过<code>：ro</code>指定。 </p>\n<pre><code>docker run --name nginx-data2 -v /host-dir:/container-dir：ro nginx\n</code></pre><p>加了<code>：ro</code>之后，就挂载伟只读了。 这样，在容器就只能读取<code>/container-dir</code>目录中的文件，不能写。</p>\n<h3 id=\"查看数据卷具体信息\"><a href=\"#查看数据卷具体信息\" class=\"headerlink\" title=\"查看数据卷具体信息\"></a>查看数据卷具体信息</h3><p>可以通过下面命令查看：</p>\n<pre><code>docker inspect web\n</code></pre><p>从输出内容中可以看到数据卷相关的部分。 </p>\n<h2 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h2><p>如果有数据需要不断更新并在多个容器之间共享，那么你就需要建立数据卷容器了。</p>\n<p>数据卷容器首先是个正常的容器，专门提供数据卷供其它容器挂载的。  </p>\n<p>创建数据卷容器： </p>\n<pre><code>docker run --name nginx-volume -v /data nginx\n</code></pre><p>然后，就可以在其它容器中使用<code>-volumes-from</code>来挂载nginx-volume容器中的数据卷。   </p>\n<pre><code>docker run --name v1 --volumes-from nginx-volume nginx\ndocker run --name v2 --volumes-from nginx-volume nginx\n</code></pre><p>这样：  </p>\n<ul>\n<li>v1、v2便可以共享nginx-volume容器中的数据卷。  </li>\n<li>即使nginx-volume容器停止，也不会有任何影响。   </li>\n</ul>\n<p>也可以使用超过一个的<code>-volumes-from</code>参数来指定从多个容器挂载不同的数据卷。也可以从其它挂载了数据卷的容器来级联挂载数据卷。 </p>\n<pre><code>docker run --name v3 --volumes-from v1 nginx\n</code></pre><h2 id=\"利用数据卷容器来备份、恢复、迁移数据卷\"><a href=\"#利用数据卷容器来备份、恢复、迁移数据卷\" class=\"headerlink\" title=\"利用数据卷容器来备份、恢复、迁移数据卷\"></a>利用数据卷容器来备份、恢复、迁移数据卷</h2><h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>首先创建一个挂载容器卷<code>nginx-volume</code>的容器，并从主机挂载当前目录到容器<code>/backup</code>目录。如下： </p>\n<pre><code>docker run --name data-backup --volume-from nginx-volume -v  $(pwd):/backup centos/7 tar cvf /backup/backup.tar /nginx-volume\n</code></pre><p>容器启动后，使用命令<code>tar</code>将容器卷<code>nginx-volume</code>备份为容器中/backup/backup.tar文件，也就主机当前目录下的名为backup.tar的文件。 </p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>如果要恢复数据到一个容器，首先创建一个挂载空数据卷的容器<code>nginx-volume2</code>。 </p>\n<pre><code>docker run -v /dbdata --name nginx-volume2 ngxin /bin/bash\n</code></pre><p>然后创建另一个容器,挂载nginx-volume2容器卷中的数据卷,并使用<code>untar</code>解压备份文件到挂载的容器卷中。 </p>\n<pre><code>docker run --vulume-from /nginx-volume2 -v $(pwd):/backup nginx untar xvf /backup/backup.tar\n</code></pre><p>为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看  </p>\n<pre><code>dcoker run --volume-from nginx-volume2 nginx /bin/ls /dbdata    \n</code></pre>"},{"title":"docker学习-第四课：容器","date":"2018-06-30T07:24:01.000Z","_content":"\n容器是`docker`的又一核心组件之一。  \n\n简单理解：容器就是独立运行的一个或者一组应用,以及一整套的运行态环境（提供运行态环境以及系统环境）。  \n\n## 启动容器：\n\n启动容器有两种方式：\n\n- 基于镜像创建一个容器并启动。\n- 将在终止状态(stopped)的容器重新启动。 \n\n新版本推荐使用子命令`\tdocker container` 。\n\n### 新建并启动容器\n\n使用命令：`docker run`\n\n输出hello world并终止容器：\n\n    $docker run ubuntu:14.04 /bin/echo 'Hello world'\n    Hello world\n    \n启动一个bash终端,允许用户进行交互。\n\n    $docker run -t -i ubuntu:14.04 /bin/bash\n    root@af8bae53bdd3:/#\n    \n其中, `-t`选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上,`-i`则让容器的标准输入保持打开。\n\n`docker\trun`启动容器流程：\n\n- 检查本地是否存在指定的镜像，没有则从仓库拉取。\n- 利用镜像创建一个容器并启动。\n- 分配一个文件系统，并且在添加一层可读写。\n- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。\n- 从地址池配置一个ip地址给容器。\n- 执行用户指定的应用程序。\n- 执行完毕后容器终止。\n\n### 启动已终止容器\n\n命令`docker\tstart`直接将一个已经终止的容器启动。\n\n容器的核心是，应用程序以及应用程序需要的资源。除此之外，并没有其它的资源。可以在伪终端中利用`ps`或`top`来查看进程信息。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run -t -i centos:latest /bin/bash\n    [root@b80715a7913e /]# ps\n      PID TTY          TIME CMD\n        1 pts/0    00:00:00 bash\n       15 pts/0    00:00:00 ps\n    [root@b80715a7913e /]# \n\n可以看到，容器只启动了`bash`，资源利用率极高，非常的轻量。以至于都可以随便删除，添加容器。\n\n### 容器管理`docker\tcontainer`\n\n在`Docker 1.13+`版本，推荐使用`docker container`来管理容器。\n\n    $ docker container run ubuntu:17.10 /bin/echo 'Hello world'\n    $ docker container start\n\n### 后台运行容器\n\n前台运行：\n\n    $docker\trun ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"\n    hello\tworld\n    hello\tworld\n    hello\tworld\n    hello\tworld\n    \n输出信息一直在宿主中输出。\n\n后台运行，添加参数`-d`：  \n\n    $docker run -d ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"\n    77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n    \n_注意_: 容器是否能长久运行，与`docker run`指定的命令有关，与`-d`无关。\n\n用命令`docker ps`查看容器信息。\n\n用命令`docker logs [container ID\tor NAMES]` 获取容器输出信息。\n\n-注_: 后面版本使用：\n\n    $\tdocker\tcontainer\trun\t-d\n    $\tdocker\tcontainer\tls\n    $\tdocker\tcontainer\tlogs   \n    \n## 终止容器\n\n命令`docker stop`可以终止一个运行中的容器。\n\n另外，当`Docker`中指定的应用程序终止时候，容器自动终止。 \n\n命令`docker ps -a`可以查看终止状态的容器。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker ps -a\n    [sudo] password for mutian: \n    CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS               NAMES\n    b80715a7913e        centos:latest               \"/bin/bash\"              About an hour ago   Up About an hour                              confident_colden\n    04288423a400        mysql/mysql-server:latest   \"/entrypoint.sh mysq…\"   6 weeks ago         Exited (0) 6 weeks ago                        mysql\n    37741b9edbd1        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web5\n    9e724b4f0f39        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Created                                       web4\n    a9d4f7554e91        nginx:v3                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web3\n    e28e7f69cbc8        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web2\n    c6074acec608        nginx                       \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       webserver\n    95088bff626d        hello-world                 \"/hello\"                 4 months ago        Exited (0) 4 months ago                       stupefied_mcnulty\n\n命令`docker start`可以重启终止状态下的容器。 \n命令`docker restart`将会终止一个一个运行的容器后并重启。\n\n- 强制停止容器\n\n可使用`docker kill` 命令停止一个或更多运行着的容器。\n\n格式：`docker kill [OPTIONS] CONTAINER [CONTAINER...]`\n\n例子：`docker kill 784fd3b294d7`\n\n\n_Doker 1.13+_:\n\n    docker container ls\n    docker container start\n    docker container restart\n    \n## 进入容器\n\n使用参数`-d`启动容器后，容器在后台执行了。有时候，需要进入容器操作。进入容器有多种方式：使用`docker\tattach`命令或者`nsenter`工具等。 \n    \n- attach命令\n\n命令格式：`docker attach [COMMAND]`  \n具体使用请百度……\n\n使用该命令有时候并不方便，当多个窗口同事通过`attach`命令进入到同一个容器的的时候，所有的窗口都会同步显示。这样，当有一个窗口阻塞的时候，所有的窗口都会阻塞。\n\n- nsenter进入容器\n\nnsenter工具包含在util-linux 2.23或更高版本中。  \n\n为了进入容器，你还需要找到容器的第一个进程的\tPID； \n\n    docker inspect --format \"{{.State.Pid}}\" $CONTAINER_ID\n\n通过这个PID就可以进入容器了：  \n`nsenter --target \"$PID\" --mount --uts --ipc --net --pid`\n\n完整例子： \n\n    [root@localhost ~]# docker ps\n    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES\n    784fd3b294d7        nginx               \"nginx -g 'daemon off\"   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91->80/tcp   backstabbing_archimedes\n    [root@localhost ~]# docker inspect --format \"{{.State.Pid}}\" 784fd3b294d7\n    95492\n    [root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pid\n    root@784fd3b294d7:/#\n    \n可以把以上命令封装程`shell`命令，简化操作。 \n\n- `docker exec`进入容器\n\n`docker exec -it 容器id /bin/bash`\n\n## 导出容器\n\n如果要导出本地的某个容器，可以使用命令`docker export`： \n命令格式： `docker export [OPTIONS] CONTAINER`    \n参数：\n  \t\t\n|  Name,shorthand  | Default | 将内容写到文件而非STDOUT |\n| :------: | :------: | :-----: |\n| --output, -o | - | 将内容写到文件而非STDOUT |\n\n示例：\n\n    docker export red_panda > latest.tar\n    docker export --output=\"latest.tar\" red_panda\n\n## 导入容器\n\n使用`docker import` 命令即可从归档文件导入内容并创建镜像。    \n命令格式： `docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]`  \n\n参数： \n\n|  Name,shorthand  | Default | 将内容写到文件而非STDOUT |\n| :------: | :------: | :-----: |\n| `--change, -c` | - | 将Dockerfile指令应用到创建的镜像 |\n| `--message, -m` | - | 为导入的镜像设置提交信息 |\n\n示例：\n\n    docker import nginx2.tar nginx\n\n## 删除容器\n\n可以使用命令`docker rm`来删除一个处于终止状态的容器。例如：\n\n    docker rm rusting_newton\n    \n如果要删除一个正在运行的容器，可以添加参数`-f`,Docker会发送`SIGKILL`信号给容器。 \n\n清理所有处于终止状态下容器： \n\n    $ docker ps -a\n    $ docker rm $(docker ps -a -q)    \n\n- Docker1.13+版本,使用命令：\n\n    docker container rm trusting_newton\n    docker container prune\n\n## 参考资源\n\n- http://itmuch.com/docker/05-docker-command-containers/    ","source":"_posts/docker-lesson4-container.md","raw":"---\ntitle: docker学习-第四课：容器\ndate: 2018-06-30 15:24:01\ncategories: docker\ntags: docker 容器\n---\n\n容器是`docker`的又一核心组件之一。  \n\n简单理解：容器就是独立运行的一个或者一组应用,以及一整套的运行态环境（提供运行态环境以及系统环境）。  \n\n## 启动容器：\n\n启动容器有两种方式：\n\n- 基于镜像创建一个容器并启动。\n- 将在终止状态(stopped)的容器重新启动。 \n\n新版本推荐使用子命令`\tdocker container` 。\n\n### 新建并启动容器\n\n使用命令：`docker run`\n\n输出hello world并终止容器：\n\n    $docker run ubuntu:14.04 /bin/echo 'Hello world'\n    Hello world\n    \n启动一个bash终端,允许用户进行交互。\n\n    $docker run -t -i ubuntu:14.04 /bin/bash\n    root@af8bae53bdd3:/#\n    \n其中, `-t`选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上,`-i`则让容器的标准输入保持打开。\n\n`docker\trun`启动容器流程：\n\n- 检查本地是否存在指定的镜像，没有则从仓库拉取。\n- 利用镜像创建一个容器并启动。\n- 分配一个文件系统，并且在添加一层可读写。\n- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。\n- 从地址池配置一个ip地址给容器。\n- 执行用户指定的应用程序。\n- 执行完毕后容器终止。\n\n### 启动已终止容器\n\n命令`docker\tstart`直接将一个已经终止的容器启动。\n\n容器的核心是，应用程序以及应用程序需要的资源。除此之外，并没有其它的资源。可以在伪终端中利用`ps`或`top`来查看进程信息。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run -t -i centos:latest /bin/bash\n    [root@b80715a7913e /]# ps\n      PID TTY          TIME CMD\n        1 pts/0    00:00:00 bash\n       15 pts/0    00:00:00 ps\n    [root@b80715a7913e /]# \n\n可以看到，容器只启动了`bash`，资源利用率极高，非常的轻量。以至于都可以随便删除，添加容器。\n\n### 容器管理`docker\tcontainer`\n\n在`Docker 1.13+`版本，推荐使用`docker container`来管理容器。\n\n    $ docker container run ubuntu:17.10 /bin/echo 'Hello world'\n    $ docker container start\n\n### 后台运行容器\n\n前台运行：\n\n    $docker\trun ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"\n    hello\tworld\n    hello\tworld\n    hello\tworld\n    hello\tworld\n    \n输出信息一直在宿主中输出。\n\n后台运行，添加参数`-d`：  \n\n    $docker run -d ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"\n    77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n    \n_注意_: 容器是否能长久运行，与`docker run`指定的命令有关，与`-d`无关。\n\n用命令`docker ps`查看容器信息。\n\n用命令`docker logs [container ID\tor NAMES]` 获取容器输出信息。\n\n-注_: 后面版本使用：\n\n    $\tdocker\tcontainer\trun\t-d\n    $\tdocker\tcontainer\tls\n    $\tdocker\tcontainer\tlogs   \n    \n## 终止容器\n\n命令`docker stop`可以终止一个运行中的容器。\n\n另外，当`Docker`中指定的应用程序终止时候，容器自动终止。 \n\n命令`docker ps -a`可以查看终止状态的容器。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker ps -a\n    [sudo] password for mutian: \n    CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS               NAMES\n    b80715a7913e        centos:latest               \"/bin/bash\"              About an hour ago   Up About an hour                              confident_colden\n    04288423a400        mysql/mysql-server:latest   \"/entrypoint.sh mysq…\"   6 weeks ago         Exited (0) 6 weeks ago                        mysql\n    37741b9edbd1        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web5\n    9e724b4f0f39        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Created                                       web4\n    a9d4f7554e91        nginx:v3                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web3\n    e28e7f69cbc8        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web2\n    c6074acec608        nginx                       \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       webserver\n    95088bff626d        hello-world                 \"/hello\"                 4 months ago        Exited (0) 4 months ago                       stupefied_mcnulty\n\n命令`docker start`可以重启终止状态下的容器。 \n命令`docker restart`将会终止一个一个运行的容器后并重启。\n\n- 强制停止容器\n\n可使用`docker kill` 命令停止一个或更多运行着的容器。\n\n格式：`docker kill [OPTIONS] CONTAINER [CONTAINER...]`\n\n例子：`docker kill 784fd3b294d7`\n\n\n_Doker 1.13+_:\n\n    docker container ls\n    docker container start\n    docker container restart\n    \n## 进入容器\n\n使用参数`-d`启动容器后，容器在后台执行了。有时候，需要进入容器操作。进入容器有多种方式：使用`docker\tattach`命令或者`nsenter`工具等。 \n    \n- attach命令\n\n命令格式：`docker attach [COMMAND]`  \n具体使用请百度……\n\n使用该命令有时候并不方便，当多个窗口同事通过`attach`命令进入到同一个容器的的时候，所有的窗口都会同步显示。这样，当有一个窗口阻塞的时候，所有的窗口都会阻塞。\n\n- nsenter进入容器\n\nnsenter工具包含在util-linux 2.23或更高版本中。  \n\n为了进入容器，你还需要找到容器的第一个进程的\tPID； \n\n    docker inspect --format \"{{.State.Pid}}\" $CONTAINER_ID\n\n通过这个PID就可以进入容器了：  \n`nsenter --target \"$PID\" --mount --uts --ipc --net --pid`\n\n完整例子： \n\n    [root@localhost ~]# docker ps\n    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES\n    784fd3b294d7        nginx               \"nginx -g 'daemon off\"   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91->80/tcp   backstabbing_archimedes\n    [root@localhost ~]# docker inspect --format \"{{.State.Pid}}\" 784fd3b294d7\n    95492\n    [root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pid\n    root@784fd3b294d7:/#\n    \n可以把以上命令封装程`shell`命令，简化操作。 \n\n- `docker exec`进入容器\n\n`docker exec -it 容器id /bin/bash`\n\n## 导出容器\n\n如果要导出本地的某个容器，可以使用命令`docker export`： \n命令格式： `docker export [OPTIONS] CONTAINER`    \n参数：\n  \t\t\n|  Name,shorthand  | Default | 将内容写到文件而非STDOUT |\n| :------: | :------: | :-----: |\n| --output, -o | - | 将内容写到文件而非STDOUT |\n\n示例：\n\n    docker export red_panda > latest.tar\n    docker export --output=\"latest.tar\" red_panda\n\n## 导入容器\n\n使用`docker import` 命令即可从归档文件导入内容并创建镜像。    \n命令格式： `docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]`  \n\n参数： \n\n|  Name,shorthand  | Default | 将内容写到文件而非STDOUT |\n| :------: | :------: | :-----: |\n| `--change, -c` | - | 将Dockerfile指令应用到创建的镜像 |\n| `--message, -m` | - | 为导入的镜像设置提交信息 |\n\n示例：\n\n    docker import nginx2.tar nginx\n\n## 删除容器\n\n可以使用命令`docker rm`来删除一个处于终止状态的容器。例如：\n\n    docker rm rusting_newton\n    \n如果要删除一个正在运行的容器，可以添加参数`-f`,Docker会发送`SIGKILL`信号给容器。 \n\n清理所有处于终止状态下容器： \n\n    $ docker ps -a\n    $ docker rm $(docker ps -a -q)    \n\n- Docker1.13+版本,使用命令：\n\n    docker container rm trusting_newton\n    docker container prune\n\n## 参考资源\n\n- http://itmuch.com/docker/05-docker-command-containers/    ","slug":"docker-lesson4-container","published":1,"updated":"2019-06-16T14:38:33.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbc002ng4vaiykok555","content":"<p>容器是<code>docker</code>的又一核心组件之一。  </p>\n<p>简单理解：容器就是独立运行的一个或者一组应用,以及一整套的运行态环境（提供运行态环境以及系统环境）。  </p>\n<h2 id=\"启动容器：\"><a href=\"#启动容器：\" class=\"headerlink\" title=\"启动容器：\"></a>启动容器：</h2><p>启动容器有两种方式：</p>\n<ul>\n<li>基于镜像创建一个容器并启动。</li>\n<li>将在终止状态(stopped)的容器重新启动。 </li>\n</ul>\n<p>新版本推荐使用子命令<code>docker container</code> 。</p>\n<h3 id=\"新建并启动容器\"><a href=\"#新建并启动容器\" class=\"headerlink\" title=\"新建并启动容器\"></a>新建并启动容器</h3><p>使用命令：<code>docker run</code></p>\n<p>输出hello world并终止容器：</p>\n<pre><code>$docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos;\nHello world\n</code></pre><p>启动一个bash终端,允许用户进行交互。</p>\n<pre><code>$docker run -t -i ubuntu:14.04 /bin/bash\nroot@af8bae53bdd3:/#\n</code></pre><p>其中, <code>-t</code>选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上,<code>-i</code>则让容器的标准输入保持打开。</p>\n<p><code>docker    run</code>启动容器流程：</p>\n<ul>\n<li>检查本地是否存在指定的镜像，没有则从仓库拉取。</li>\n<li>利用镜像创建一个容器并启动。</li>\n<li>分配一个文件系统，并且在添加一层可读写。</li>\n<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。</li>\n<li>从地址池配置一个ip地址给容器。</li>\n<li>执行用户指定的应用程序。</li>\n<li>执行完毕后容器终止。</li>\n</ul>\n<h3 id=\"启动已终止容器\"><a href=\"#启动已终止容器\" class=\"headerlink\" title=\"启动已终止容器\"></a>启动已终止容器</h3><p>命令<code>docker    start</code>直接将一个已经终止的容器启动。</p>\n<p>容器的核心是，应用程序以及应用程序需要的资源。除此之外，并没有其它的资源。可以在伪终端中利用<code>ps</code>或<code>top</code>来查看进程信息。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run -t -i centos:latest /bin/bash\n[root@b80715a7913e /]# ps\n  PID TTY          TIME CMD\n    1 pts/0    00:00:00 bash\n   15 pts/0    00:00:00 ps\n[root@b80715a7913e /]# \n</code></pre><p>可以看到，容器只启动了<code>bash</code>，资源利用率极高，非常的轻量。以至于都可以随便删除，添加容器。</p>\n<h3 id=\"容器管理docker-container\"><a href=\"#容器管理docker-container\" class=\"headerlink\" title=\"容器管理docker    container\"></a>容器管理<code>docker    container</code></h3><p>在<code>Docker 1.13+</code>版本，推荐使用<code>docker container</code>来管理容器。</p>\n<pre><code>$ docker container run ubuntu:17.10 /bin/echo &apos;Hello world&apos;\n$ docker container start\n</code></pre><h3 id=\"后台运行容器\"><a href=\"#后台运行容器\" class=\"headerlink\" title=\"后台运行容器\"></a>后台运行容器</h3><p>前台运行：</p>\n<pre><code>$docker    run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\nhello    world\nhello    world\nhello    world\nhello    world\n</code></pre><p>输出信息一直在宿主中输出。</p>\n<p>后台运行，添加参数<code>-d</code>：  </p>\n<pre><code>$docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\n77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n</code></pre><p>_注意_: 容器是否能长久运行，与<code>docker run</code>指定的命令有关，与<code>-d</code>无关。</p>\n<p>用命令<code>docker ps</code>查看容器信息。</p>\n<p>用命令<code>docker logs [container ID    or NAMES]</code> 获取容器输出信息。</p>\n<p>-注_: 后面版本使用：</p>\n<pre><code>$    docker    container    run    -d\n$    docker    container    ls\n$    docker    container    logs   \n</code></pre><h2 id=\"终止容器\"><a href=\"#终止容器\" class=\"headerlink\" title=\"终止容器\"></a>终止容器</h2><p>命令<code>docker stop</code>可以终止一个运行中的容器。</p>\n<p>另外，当<code>Docker</code>中指定的应用程序终止时候，容器自动终止。 </p>\n<p>命令<code>docker ps -a</code>可以查看终止状态的容器。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker ps -a\n[sudo] password for mutian: \nCONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS               NAMES\nb80715a7913e        centos:latest               &quot;/bin/bash&quot;              About an hour ago   Up About an hour                              confident_colden\n04288423a400        mysql/mysql-server:latest   &quot;/entrypoint.sh mysq…&quot;   6 weeks ago         Exited (0) 6 weeks ago                        mysql\n37741b9edbd1        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web5\n9e724b4f0f39        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Created                                       web4\na9d4f7554e91        nginx:v3                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web3\ne28e7f69cbc8        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web2\nc6074acec608        nginx                       &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       webserver\n95088bff626d        hello-world                 &quot;/hello&quot;                 4 months ago        Exited (0) 4 months ago                       stupefied_mcnulty\n</code></pre><p>命令<code>docker start</code>可以重启终止状态下的容器。<br>命令<code>docker restart</code>将会终止一个一个运行的容器后并重启。</p>\n<ul>\n<li>强制停止容器</li>\n</ul>\n<p>可使用<code>docker kill</code> 命令停止一个或更多运行着的容器。</p>\n<p>格式：<code>docker kill [OPTIONS] CONTAINER [CONTAINER...]</code></p>\n<p>例子：<code>docker kill 784fd3b294d7</code></p>\n<p><em>Doker 1.13+</em>:</p>\n<pre><code>docker container ls\ndocker container start\ndocker container restart\n</code></pre><h2 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h2><p>使用参数<code>-d</code>启动容器后，容器在后台执行了。有时候，需要进入容器操作。进入容器有多种方式：使用<code>docker    attach</code>命令或者<code>nsenter</code>工具等。 </p>\n<ul>\n<li>attach命令</li>\n</ul>\n<p>命令格式：<code>docker attach [COMMAND]</code><br>具体使用请百度……</p>\n<p>使用该命令有时候并不方便，当多个窗口同事通过<code>attach</code>命令进入到同一个容器的的时候，所有的窗口都会同步显示。这样，当有一个窗口阻塞的时候，所有的窗口都会阻塞。</p>\n<ul>\n<li>nsenter进入容器</li>\n</ul>\n<p>nsenter工具包含在util-linux 2.23或更高版本中。  </p>\n<p>为了进入容器，你还需要找到容器的第一个进程的    PID； </p>\n<pre><code>docker inspect --format &quot;{{.State.Pid}}&quot; $CONTAINER_ID\n</code></pre><p>通过这个PID就可以进入容器了：<br><code>nsenter --target &quot;$PID&quot; --mount --uts --ipc --net --pid</code></p>\n<p>完整例子： </p>\n<pre><code>[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES\n784fd3b294d7        nginx               &quot;nginx -g &apos;daemon off&quot;   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes\n[root@localhost ~]# docker inspect --format &quot;{{.State.Pid}}&quot; 784fd3b294d7\n95492\n[root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pid\nroot@784fd3b294d7:/#\n</code></pre><p>可以把以上命令封装程<code>shell</code>命令，简化操作。 </p>\n<ul>\n<li><code>docker exec</code>进入容器</li>\n</ul>\n<p><code>docker exec -it 容器id /bin/bash</code></p>\n<h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出本地的某个容器，可以使用命令<code>docker export</code>：<br>命令格式： <code>docker export [OPTIONS] CONTAINER</code><br>参数：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Name,shorthand</th>\n<th style=\"text-align:center\">Default</th>\n<th style=\"text-align:center\">将内容写到文件而非STDOUT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">–output, -o</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">将内容写到文件而非STDOUT</td>\n</tr>\n</tbody>\n</table>\n<p>示例：</p>\n<pre><code>docker export red_panda &gt; latest.tar\ndocker export --output=&quot;latest.tar&quot; red_panda\n</code></pre><h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><p>使用<code>docker import</code> 命令即可从归档文件导入内容并创建镜像。<br>命令格式： <code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code>  </p>\n<p>参数： </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Name,shorthand</th>\n<th style=\"text-align:center\">Default</th>\n<th style=\"text-align:center\">将内容写到文件而非STDOUT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>--change, -c</code></td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">将Dockerfile指令应用到创建的镜像</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>--message, -m</code></td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">为导入的镜像设置提交信息</td>\n</tr>\n</tbody>\n</table>\n<p>示例：</p>\n<pre><code>docker import nginx2.tar nginx\n</code></pre><h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><p>可以使用命令<code>docker rm</code>来删除一个处于终止状态的容器。例如：</p>\n<pre><code>docker rm rusting_newton\n</code></pre><p>如果要删除一个正在运行的容器，可以添加参数<code>-f</code>,Docker会发送<code>SIGKILL</code>信号给容器。 </p>\n<p>清理所有处于终止状态下容器： </p>\n<pre><code>$ docker ps -a\n$ docker rm $(docker ps -a -q)    \n</code></pre><ul>\n<li><p>Docker1.13+版本,使用命令：</p>\n<p>  docker container rm trusting_newton<br>  docker container prune</p>\n</li>\n</ul>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><ul>\n<li><a href=\"http://itmuch.com/docker/05-docker-command-containers/\" target=\"_blank\" rel=\"noopener\">http://itmuch.com/docker/05-docker-command-containers/</a>    </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>容器是<code>docker</code>的又一核心组件之一。  </p>\n<p>简单理解：容器就是独立运行的一个或者一组应用,以及一整套的运行态环境（提供运行态环境以及系统环境）。  </p>\n<h2 id=\"启动容器：\"><a href=\"#启动容器：\" class=\"headerlink\" title=\"启动容器：\"></a>启动容器：</h2><p>启动容器有两种方式：</p>\n<ul>\n<li>基于镜像创建一个容器并启动。</li>\n<li>将在终止状态(stopped)的容器重新启动。 </li>\n</ul>\n<p>新版本推荐使用子命令<code>docker container</code> 。</p>\n<h3 id=\"新建并启动容器\"><a href=\"#新建并启动容器\" class=\"headerlink\" title=\"新建并启动容器\"></a>新建并启动容器</h3><p>使用命令：<code>docker run</code></p>\n<p>输出hello world并终止容器：</p>\n<pre><code>$docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos;\nHello world\n</code></pre><p>启动一个bash终端,允许用户进行交互。</p>\n<pre><code>$docker run -t -i ubuntu:14.04 /bin/bash\nroot@af8bae53bdd3:/#\n</code></pre><p>其中, <code>-t</code>选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上,<code>-i</code>则让容器的标准输入保持打开。</p>\n<p><code>docker    run</code>启动容器流程：</p>\n<ul>\n<li>检查本地是否存在指定的镜像，没有则从仓库拉取。</li>\n<li>利用镜像创建一个容器并启动。</li>\n<li>分配一个文件系统，并且在添加一层可读写。</li>\n<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。</li>\n<li>从地址池配置一个ip地址给容器。</li>\n<li>执行用户指定的应用程序。</li>\n<li>执行完毕后容器终止。</li>\n</ul>\n<h3 id=\"启动已终止容器\"><a href=\"#启动已终止容器\" class=\"headerlink\" title=\"启动已终止容器\"></a>启动已终止容器</h3><p>命令<code>docker    start</code>直接将一个已经终止的容器启动。</p>\n<p>容器的核心是，应用程序以及应用程序需要的资源。除此之外，并没有其它的资源。可以在伪终端中利用<code>ps</code>或<code>top</code>来查看进程信息。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run -t -i centos:latest /bin/bash\n[root@b80715a7913e /]# ps\n  PID TTY          TIME CMD\n    1 pts/0    00:00:00 bash\n   15 pts/0    00:00:00 ps\n[root@b80715a7913e /]# \n</code></pre><p>可以看到，容器只启动了<code>bash</code>，资源利用率极高，非常的轻量。以至于都可以随便删除，添加容器。</p>\n<h3 id=\"容器管理docker-container\"><a href=\"#容器管理docker-container\" class=\"headerlink\" title=\"容器管理docker    container\"></a>容器管理<code>docker    container</code></h3><p>在<code>Docker 1.13+</code>版本，推荐使用<code>docker container</code>来管理容器。</p>\n<pre><code>$ docker container run ubuntu:17.10 /bin/echo &apos;Hello world&apos;\n$ docker container start\n</code></pre><h3 id=\"后台运行容器\"><a href=\"#后台运行容器\" class=\"headerlink\" title=\"后台运行容器\"></a>后台运行容器</h3><p>前台运行：</p>\n<pre><code>$docker    run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\nhello    world\nhello    world\nhello    world\nhello    world\n</code></pre><p>输出信息一直在宿主中输出。</p>\n<p>后台运行，添加参数<code>-d</code>：  </p>\n<pre><code>$docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\n77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n</code></pre><p>_注意_: 容器是否能长久运行，与<code>docker run</code>指定的命令有关，与<code>-d</code>无关。</p>\n<p>用命令<code>docker ps</code>查看容器信息。</p>\n<p>用命令<code>docker logs [container ID    or NAMES]</code> 获取容器输出信息。</p>\n<p>-注_: 后面版本使用：</p>\n<pre><code>$    docker    container    run    -d\n$    docker    container    ls\n$    docker    container    logs   \n</code></pre><h2 id=\"终止容器\"><a href=\"#终止容器\" class=\"headerlink\" title=\"终止容器\"></a>终止容器</h2><p>命令<code>docker stop</code>可以终止一个运行中的容器。</p>\n<p>另外，当<code>Docker</code>中指定的应用程序终止时候，容器自动终止。 </p>\n<p>命令<code>docker ps -a</code>可以查看终止状态的容器。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker ps -a\n[sudo] password for mutian: \nCONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS               NAMES\nb80715a7913e        centos:latest               &quot;/bin/bash&quot;              About an hour ago   Up About an hour                              confident_colden\n04288423a400        mysql/mysql-server:latest   &quot;/entrypoint.sh mysq…&quot;   6 weeks ago         Exited (0) 6 weeks ago                        mysql\n37741b9edbd1        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web5\n9e724b4f0f39        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Created                                       web4\na9d4f7554e91        nginx:v3                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web3\ne28e7f69cbc8        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web2\nc6074acec608        nginx                       &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       webserver\n95088bff626d        hello-world                 &quot;/hello&quot;                 4 months ago        Exited (0) 4 months ago                       stupefied_mcnulty\n</code></pre><p>命令<code>docker start</code>可以重启终止状态下的容器。<br>命令<code>docker restart</code>将会终止一个一个运行的容器后并重启。</p>\n<ul>\n<li>强制停止容器</li>\n</ul>\n<p>可使用<code>docker kill</code> 命令停止一个或更多运行着的容器。</p>\n<p>格式：<code>docker kill [OPTIONS] CONTAINER [CONTAINER...]</code></p>\n<p>例子：<code>docker kill 784fd3b294d7</code></p>\n<p><em>Doker 1.13+</em>:</p>\n<pre><code>docker container ls\ndocker container start\ndocker container restart\n</code></pre><h2 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h2><p>使用参数<code>-d</code>启动容器后，容器在后台执行了。有时候，需要进入容器操作。进入容器有多种方式：使用<code>docker    attach</code>命令或者<code>nsenter</code>工具等。 </p>\n<ul>\n<li>attach命令</li>\n</ul>\n<p>命令格式：<code>docker attach [COMMAND]</code><br>具体使用请百度……</p>\n<p>使用该命令有时候并不方便，当多个窗口同事通过<code>attach</code>命令进入到同一个容器的的时候，所有的窗口都会同步显示。这样，当有一个窗口阻塞的时候，所有的窗口都会阻塞。</p>\n<ul>\n<li>nsenter进入容器</li>\n</ul>\n<p>nsenter工具包含在util-linux 2.23或更高版本中。  </p>\n<p>为了进入容器，你还需要找到容器的第一个进程的    PID； </p>\n<pre><code>docker inspect --format &quot;{{.State.Pid}}&quot; $CONTAINER_ID\n</code></pre><p>通过这个PID就可以进入容器了：<br><code>nsenter --target &quot;$PID&quot; --mount --uts --ipc --net --pid</code></p>\n<p>完整例子： </p>\n<pre><code>[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES\n784fd3b294d7        nginx               &quot;nginx -g &apos;daemon off&quot;   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes\n[root@localhost ~]# docker inspect --format &quot;{{.State.Pid}}&quot; 784fd3b294d7\n95492\n[root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pid\nroot@784fd3b294d7:/#\n</code></pre><p>可以把以上命令封装程<code>shell</code>命令，简化操作。 </p>\n<ul>\n<li><code>docker exec</code>进入容器</li>\n</ul>\n<p><code>docker exec -it 容器id /bin/bash</code></p>\n<h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出本地的某个容器，可以使用命令<code>docker export</code>：<br>命令格式： <code>docker export [OPTIONS] CONTAINER</code><br>参数：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Name,shorthand</th>\n<th style=\"text-align:center\">Default</th>\n<th style=\"text-align:center\">将内容写到文件而非STDOUT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">–output, -o</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">将内容写到文件而非STDOUT</td>\n</tr>\n</tbody>\n</table>\n<p>示例：</p>\n<pre><code>docker export red_panda &gt; latest.tar\ndocker export --output=&quot;latest.tar&quot; red_panda\n</code></pre><h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><p>使用<code>docker import</code> 命令即可从归档文件导入内容并创建镜像。<br>命令格式： <code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code>  </p>\n<p>参数： </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Name,shorthand</th>\n<th style=\"text-align:center\">Default</th>\n<th style=\"text-align:center\">将内容写到文件而非STDOUT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>--change, -c</code></td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">将Dockerfile指令应用到创建的镜像</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>--message, -m</code></td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">为导入的镜像设置提交信息</td>\n</tr>\n</tbody>\n</table>\n<p>示例：</p>\n<pre><code>docker import nginx2.tar nginx\n</code></pre><h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><p>可以使用命令<code>docker rm</code>来删除一个处于终止状态的容器。例如：</p>\n<pre><code>docker rm rusting_newton\n</code></pre><p>如果要删除一个正在运行的容器，可以添加参数<code>-f</code>,Docker会发送<code>SIGKILL</code>信号给容器。 </p>\n<p>清理所有处于终止状态下容器： </p>\n<pre><code>$ docker ps -a\n$ docker rm $(docker ps -a -q)    \n</code></pre><ul>\n<li><p>Docker1.13+版本,使用命令：</p>\n<p>  docker container rm trusting_newton<br>  docker container prune</p>\n</li>\n</ul>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><ul>\n<li><a href=\"http://itmuch.com/docker/05-docker-command-containers/\" target=\"_blank\" rel=\"noopener\">http://itmuch.com/docker/05-docker-command-containers/</a>    </li>\n</ul>\n"},{"title":"docker学习-第六课：使用网络","date":"2018-07-26T12:23:35.000Z","_content":"\n本节概述docker中与网络相关的一些操作，如docker与主机之间的网络互通，docker之间的网络互相访问等……\n\n参考网址： https://docs.docker.com/network/\n\n## 外部访问网络\n\n容器中可以运行一些网络应用，要让外部也可以访问这些网络应用，可以使用`-P`或者`-p`参数来指定端口映射。  \n\n当使用`-P`标记时，Docker会随机主机的一个49000~49900端口到容器的内部端口。   \n使用`docker container ps`可以查看到。 \n\n    docker run -d -P --name ngxin-net nginx\n\n创建容器`nginx-net`并后台启动。 \n\n       [vagrant@ymu ~]$ sudo docker run -d -P --name ngxin-net nginx\n       cfb84ca5f6837d14ea5f9c4d670ca4f9b126fbbe3e0d78f9cbaa949772f892be\n       [vagrant@ymu ~]$ sudo docker container ps\n       CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES\n       cfb84ca5f683        nginx               \"nginx -g 'daemon of…\"   14 seconds ago      Up 13 seconds       0.0.0.0:32768->80/tcp   ngxin-net\n       d120d176e25c        nginx               \"nginx -g 'daemon of…\"   13 days ago         Up 3 minutes        0.0.0.0:80->80/tcp      nginx\n\n可以看到容器`ngxin-net`的端口映射信息，把主机32768端口映射到了容器的80端口。这样，在主机就可以访问：localhost:32768\n\n同样，可以查看应用访问日志： \n\n    [vagrant@ymu ~]$ sudo docker logs -f ngxin-net\n\n另外，小写`-p`可以明确指定主机和容器之间的端口映射。 并且,在一个指定端口上只可以绑定一个容器。      \n支持的格式： \n\n- ip:hostPort:containerPort\n- ip::containerPort \n- hostPort:containerPort\n\n前面一个为主机端口，后面一个为容器端口。 \n\n常用：\n\n`-p 80:80`\n\n将本地主机80端口映射到容器80端口。\n\n## 容器互联\n\n容器与容器之间的端口互通。 互相访问容器信息。 \n\n使用`--link`参数可以让容器之间安全的进行交互。  \n\n下面创建一个新的redis数据库容器：\n\n    docker run --name redis-test -d  redis\n    \n然后创建一个web容器：\n\n    docker run -d -p 80:80 --name nginx-web --link redis-test nginx \n    \n此时，redis-test容器和nginx-web容器建立了互联关系。  \n\n`--link` 参数格式 `--link name：alias`，其中name是容器名称，alias是这个连接的别名。 \n\n 可以通过`docker ps`查看连接信息。   \n 这样，nginx-web容器将可以访问redis-test容器中的信息。  \n \n Docker在两个容器之间建立起了一个安全隧道，而且不用映射它们的端口到宿主主机上。启动redis-test的时候，采用大写`-P`，从而避免了暴露数据库端口到外部网络上。  \n \n \n        \n\n","source":"_posts/docker-lesson6-net.md","raw":"---\ntitle: docker学习-第六课：使用网络\ndate: 2018-07-26 20:23:35\ncategories: docker\ntags: docker网络\n---\n\n本节概述docker中与网络相关的一些操作，如docker与主机之间的网络互通，docker之间的网络互相访问等……\n\n参考网址： https://docs.docker.com/network/\n\n## 外部访问网络\n\n容器中可以运行一些网络应用，要让外部也可以访问这些网络应用，可以使用`-P`或者`-p`参数来指定端口映射。  \n\n当使用`-P`标记时，Docker会随机主机的一个49000~49900端口到容器的内部端口。   \n使用`docker container ps`可以查看到。 \n\n    docker run -d -P --name ngxin-net nginx\n\n创建容器`nginx-net`并后台启动。 \n\n       [vagrant@ymu ~]$ sudo docker run -d -P --name ngxin-net nginx\n       cfb84ca5f6837d14ea5f9c4d670ca4f9b126fbbe3e0d78f9cbaa949772f892be\n       [vagrant@ymu ~]$ sudo docker container ps\n       CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES\n       cfb84ca5f683        nginx               \"nginx -g 'daemon of…\"   14 seconds ago      Up 13 seconds       0.0.0.0:32768->80/tcp   ngxin-net\n       d120d176e25c        nginx               \"nginx -g 'daemon of…\"   13 days ago         Up 3 minutes        0.0.0.0:80->80/tcp      nginx\n\n可以看到容器`ngxin-net`的端口映射信息，把主机32768端口映射到了容器的80端口。这样，在主机就可以访问：localhost:32768\n\n同样，可以查看应用访问日志： \n\n    [vagrant@ymu ~]$ sudo docker logs -f ngxin-net\n\n另外，小写`-p`可以明确指定主机和容器之间的端口映射。 并且,在一个指定端口上只可以绑定一个容器。      \n支持的格式： \n\n- ip:hostPort:containerPort\n- ip::containerPort \n- hostPort:containerPort\n\n前面一个为主机端口，后面一个为容器端口。 \n\n常用：\n\n`-p 80:80`\n\n将本地主机80端口映射到容器80端口。\n\n## 容器互联\n\n容器与容器之间的端口互通。 互相访问容器信息。 \n\n使用`--link`参数可以让容器之间安全的进行交互。  \n\n下面创建一个新的redis数据库容器：\n\n    docker run --name redis-test -d  redis\n    \n然后创建一个web容器：\n\n    docker run -d -p 80:80 --name nginx-web --link redis-test nginx \n    \n此时，redis-test容器和nginx-web容器建立了互联关系。  \n\n`--link` 参数格式 `--link name：alias`，其中name是容器名称，alias是这个连接的别名。 \n\n 可以通过`docker ps`查看连接信息。   \n 这样，nginx-web容器将可以访问redis-test容器中的信息。  \n \n Docker在两个容器之间建立起了一个安全隧道，而且不用映射它们的端口到宿主主机上。启动redis-test的时候，采用大写`-P`，从而避免了暴露数据库端口到外部网络上。  \n \n \n        \n\n","slug":"docker-lesson6-net","published":1,"updated":"2019-06-16T14:38:33.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbd002pg4vabiksl0e3","content":"<p>本节概述docker中与网络相关的一些操作，如docker与主机之间的网络互通，docker之间的网络互相访问等……</p>\n<p>参考网址： <a href=\"https://docs.docker.com/network/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/network/</a></p>\n<h2 id=\"外部访问网络\"><a href=\"#外部访问网络\" class=\"headerlink\" title=\"外部访问网络\"></a>外部访问网络</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些网络应用，可以使用<code>-P</code>或者<code>-p</code>参数来指定端口映射。  </p>\n<p>当使用<code>-P</code>标记时，Docker会随机主机的一个49000~49900端口到容器的内部端口。<br>使用<code>docker container ps</code>可以查看到。 </p>\n<pre><code>docker run -d -P --name ngxin-net nginx\n</code></pre><p>创建容器<code>nginx-net</code>并后台启动。 </p>\n<pre><code>[vagrant@ymu ~]$ sudo docker run -d -P --name ngxin-net nginx\ncfb84ca5f6837d14ea5f9c4d670ca4f9b126fbbe3e0d78f9cbaa949772f892be\n[vagrant@ymu ~]$ sudo docker container ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES\ncfb84ca5f683        nginx               &quot;nginx -g &apos;daemon of…&quot;   14 seconds ago      Up 13 seconds       0.0.0.0:32768-&gt;80/tcp   ngxin-net\nd120d176e25c        nginx               &quot;nginx -g &apos;daemon of…&quot;   13 days ago         Up 3 minutes        0.0.0.0:80-&gt;80/tcp      nginx\n</code></pre><p>可以看到容器<code>ngxin-net</code>的端口映射信息，把主机32768端口映射到了容器的80端口。这样，在主机就可以访问：localhost:32768</p>\n<p>同样，可以查看应用访问日志： </p>\n<pre><code>[vagrant@ymu ~]$ sudo docker logs -f ngxin-net\n</code></pre><p>另外，小写<code>-p</code>可以明确指定主机和容器之间的端口映射。 并且,在一个指定端口上只可以绑定一个容器。<br>支持的格式： </p>\n<ul>\n<li>ip:hostPort:containerPort</li>\n<li>ip::containerPort </li>\n<li>hostPort:containerPort</li>\n</ul>\n<p>前面一个为主机端口，后面一个为容器端口。 </p>\n<p>常用：</p>\n<p><code>-p 80:80</code></p>\n<p>将本地主机80端口映射到容器80端口。</p>\n<h2 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h2><p>容器与容器之间的端口互通。 互相访问容器信息。 </p>\n<p>使用<code>--link</code>参数可以让容器之间安全的进行交互。  </p>\n<p>下面创建一个新的redis数据库容器：</p>\n<pre><code>docker run --name redis-test -d  redis\n</code></pre><p>然后创建一个web容器：</p>\n<pre><code>docker run -d -p 80:80 --name nginx-web --link redis-test nginx \n</code></pre><p>此时，redis-test容器和nginx-web容器建立了互联关系。  </p>\n<p><code>--link</code> 参数格式 <code>--link name：alias</code>，其中name是容器名称，alias是这个连接的别名。 </p>\n<p> 可以通过<code>docker ps</code>查看连接信息。<br> 这样，nginx-web容器将可以访问redis-test容器中的信息。  </p>\n<p> Docker在两个容器之间建立起了一个安全隧道，而且不用映射它们的端口到宿主主机上。启动redis-test的时候，采用大写<code>-P</code>，从而避免了暴露数据库端口到外部网络上。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本节概述docker中与网络相关的一些操作，如docker与主机之间的网络互通，docker之间的网络互相访问等……</p>\n<p>参考网址： <a href=\"https://docs.docker.com/network/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/network/</a></p>\n<h2 id=\"外部访问网络\"><a href=\"#外部访问网络\" class=\"headerlink\" title=\"外部访问网络\"></a>外部访问网络</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些网络应用，可以使用<code>-P</code>或者<code>-p</code>参数来指定端口映射。  </p>\n<p>当使用<code>-P</code>标记时，Docker会随机主机的一个49000~49900端口到容器的内部端口。<br>使用<code>docker container ps</code>可以查看到。 </p>\n<pre><code>docker run -d -P --name ngxin-net nginx\n</code></pre><p>创建容器<code>nginx-net</code>并后台启动。 </p>\n<pre><code>[vagrant@ymu ~]$ sudo docker run -d -P --name ngxin-net nginx\ncfb84ca5f6837d14ea5f9c4d670ca4f9b126fbbe3e0d78f9cbaa949772f892be\n[vagrant@ymu ~]$ sudo docker container ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES\ncfb84ca5f683        nginx               &quot;nginx -g &apos;daemon of…&quot;   14 seconds ago      Up 13 seconds       0.0.0.0:32768-&gt;80/tcp   ngxin-net\nd120d176e25c        nginx               &quot;nginx -g &apos;daemon of…&quot;   13 days ago         Up 3 minutes        0.0.0.0:80-&gt;80/tcp      nginx\n</code></pre><p>可以看到容器<code>ngxin-net</code>的端口映射信息，把主机32768端口映射到了容器的80端口。这样，在主机就可以访问：localhost:32768</p>\n<p>同样，可以查看应用访问日志： </p>\n<pre><code>[vagrant@ymu ~]$ sudo docker logs -f ngxin-net\n</code></pre><p>另外，小写<code>-p</code>可以明确指定主机和容器之间的端口映射。 并且,在一个指定端口上只可以绑定一个容器。<br>支持的格式： </p>\n<ul>\n<li>ip:hostPort:containerPort</li>\n<li>ip::containerPort </li>\n<li>hostPort:containerPort</li>\n</ul>\n<p>前面一个为主机端口，后面一个为容器端口。 </p>\n<p>常用：</p>\n<p><code>-p 80:80</code></p>\n<p>将本地主机80端口映射到容器80端口。</p>\n<h2 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h2><p>容器与容器之间的端口互通。 互相访问容器信息。 </p>\n<p>使用<code>--link</code>参数可以让容器之间安全的进行交互。  </p>\n<p>下面创建一个新的redis数据库容器：</p>\n<pre><code>docker run --name redis-test -d  redis\n</code></pre><p>然后创建一个web容器：</p>\n<pre><code>docker run -d -p 80:80 --name nginx-web --link redis-test nginx \n</code></pre><p>此时，redis-test容器和nginx-web容器建立了互联关系。  </p>\n<p><code>--link</code> 参数格式 <code>--link name：alias</code>，其中name是容器名称，alias是这个连接的别名。 </p>\n<p> 可以通过<code>docker ps</code>查看连接信息。<br> 这样，nginx-web容器将可以访问redis-test容器中的信息。  </p>\n<p> Docker在两个容器之间建立起了一个安全隧道，而且不用映射它们的端口到宿主主机上。启动redis-test的时候，采用大写<code>-P</code>，从而避免了暴露数据库端口到外部网络上。  </p>\n"},{"title":"docker学习-第七课：三剑客之Docker Compose","date":"2018-08-01T12:33:32.000Z","_content":"\n在一个例如web应用中，除了应用本身之外，其还关联用到数据库等……，如果都采用docker化的话，那么就需要启动所有相关的docker容器。那么，有没有可能，按照某种顺序，对所有相关联的docker容器进行编排，然后按照一定的先后顺序依次启动。是的，Docker Compose就是这么一个工具，容器编排工具。定义和运行多个容器的应用。 \n\nCompose中有两个重要的概念：\n\n- 服务（Service）：一个应用的容器,实际上可以包括若干运行相同镜像的容器实例。\n- 项目(project)：由一组关联的应用容器组成的一个完整业务单元,在\tdocker-compose.yml文件中定义。\n\nCompose\t的默认管理对象是项目,通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n## 安装Docker Compose\n\n- 确保已经安装了docker引擎，docker compose依赖docker引擎。\n- docker compose不要在root账户权限下运行。（为啥？在root运行下会有什么问题吗，是否也可以？）\n\nDocker Compose安装：https://docs.docker.com/compose/install/\n\n### CentOs7下安装\n\n_注意：_ For alpine, the following dependency packages are needed: py-pip, python-dev, libffi-dev, openssl-dev, gcc, libc-dev, and make.\n\n1.执行下面命令获取合适版本：\n\n    sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n\n安装不同版本，只需要更改`1.24.1`。\n   \n2.给二进制可执行文件赋权：\n\n    sudo chmod +x /usr/local/bin/docker-compose\n    \n这样，Docker Compose就安装完成了。\n\n3.测试是否安装成功：\n\n    [root@izwz9guplfsq8ltfk0wnjiz ~]# docker-compose --version\n    docker-compose version 1.24.1, build 4667896b\n    \n看上面输出信息可知已经安装成功了。\n\n## 安装Docker Compose命令补全工具\n\n我们已经安装了Compose，但是在命令窗口输入docker-compose后，按下Tab键，没有显示其所有具有的命令。因此，我们需要安装命令补全工具。\n\n命令补全工具安装：https://docs.docker.com/compose/completion/\n\n安装命令补全工具只需要执行下面命令：\n\n    curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose\n\n这样，在重新登录后，输入docker-compose 并按下Tab键，Compose就可自动补全命令了。\n\n## 快速入门\n\n这里展示一个简单的示例，简单了解docker compose使用步骤。\n\n### 基本步骤：\n\n1.使用Dockerfile（或其他方式）定义应用程序环境，以便在任何地方重现该环境。     \n2.在docker-compose.yml文件中定义组成应用程序的服务，以便各个服务在一个隔离的环境中一起运行。       \n3.运行docker-compose up命令，启动并运行整个应用程序。\n\n### 入门示例\n\n- 新建文件夹`docker-compose-demo`,进入该目录，拷贝文件`eureka-server.jar`进来。\n\n- 新建文件`Dockerfile`，添加内容：\n\n\n    FROM java:8\n    VOLUME /tmp\n    ADD eureka-server.jar app.jar\n    RUN bash -c 'touch /app.jar'\n    EXPOSE 9000\n    ENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\"]\n    \n- 再新建文件`docker-compose.yml`,添加内容：\n\n\n    version: '2'\t\t\t# 表示该docker-compose.yml文件使用的是Version 2 file format\n    services:\n      eureka:\t\t\t\t# 指定服务名称\n        build: .\t\t\t# 指定Dockerfile所在路径\n        ports:\n          - \"8761:8761\"\t\t# 指定端口映射，类似docker run的-p选项，注意使用字符串形式           \n          \n- 在docker-compose.yml 所在路径执行以下命令。     \n  \n\n    docker-compose up\n    \nCompose就会自动构建镜像并使用镜像启动容器。我们也可使用docker-compose up -d 后台启动并运行这些容器。     \n\n- 访问：http://宿主机IP:8761/ ，即可访问Eureka Server首页   \n\n### 工程、服务、容器\n\nDocker Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker Compose运行目录下的所有文件（docker-compose.yml, extends文件或环境变量文件等）组成一个工程（默认为docker-compose.yml所在目录的目录名称）。一个工程可包含多个服务；每个服务中定义了容器运行的镜像、参数和依赖，一个服务可包括多个容器实例。\n\n对应《入门示例》一节，工程名称是docker-compose.yml所在的目录名。该工程包含了1个服务，服务名称是eureka；执行docker-compose up时，启动了eureka服务的1个容器实例。\n\n        ","source":"_posts/docker-lesson7-compose.md","raw":"---\ntitle: docker学习-第七课：三剑客之Docker Compose\ndate: 2018-08-01 20:33:32\ncategories: docker\ntags:\n---\n\n在一个例如web应用中，除了应用本身之外，其还关联用到数据库等……，如果都采用docker化的话，那么就需要启动所有相关的docker容器。那么，有没有可能，按照某种顺序，对所有相关联的docker容器进行编排，然后按照一定的先后顺序依次启动。是的，Docker Compose就是这么一个工具，容器编排工具。定义和运行多个容器的应用。 \n\nCompose中有两个重要的概念：\n\n- 服务（Service）：一个应用的容器,实际上可以包括若干运行相同镜像的容器实例。\n- 项目(project)：由一组关联的应用容器组成的一个完整业务单元,在\tdocker-compose.yml文件中定义。\n\nCompose\t的默认管理对象是项目,通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n## 安装Docker Compose\n\n- 确保已经安装了docker引擎，docker compose依赖docker引擎。\n- docker compose不要在root账户权限下运行。（为啥？在root运行下会有什么问题吗，是否也可以？）\n\nDocker Compose安装：https://docs.docker.com/compose/install/\n\n### CentOs7下安装\n\n_注意：_ For alpine, the following dependency packages are needed: py-pip, python-dev, libffi-dev, openssl-dev, gcc, libc-dev, and make.\n\n1.执行下面命令获取合适版本：\n\n    sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose\n\n安装不同版本，只需要更改`1.24.1`。\n   \n2.给二进制可执行文件赋权：\n\n    sudo chmod +x /usr/local/bin/docker-compose\n    \n这样，Docker Compose就安装完成了。\n\n3.测试是否安装成功：\n\n    [root@izwz9guplfsq8ltfk0wnjiz ~]# docker-compose --version\n    docker-compose version 1.24.1, build 4667896b\n    \n看上面输出信息可知已经安装成功了。\n\n## 安装Docker Compose命令补全工具\n\n我们已经安装了Compose，但是在命令窗口输入docker-compose后，按下Tab键，没有显示其所有具有的命令。因此，我们需要安装命令补全工具。\n\n命令补全工具安装：https://docs.docker.com/compose/completion/\n\n安装命令补全工具只需要执行下面命令：\n\n    curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose\n\n这样，在重新登录后，输入docker-compose 并按下Tab键，Compose就可自动补全命令了。\n\n## 快速入门\n\n这里展示一个简单的示例，简单了解docker compose使用步骤。\n\n### 基本步骤：\n\n1.使用Dockerfile（或其他方式）定义应用程序环境，以便在任何地方重现该环境。     \n2.在docker-compose.yml文件中定义组成应用程序的服务，以便各个服务在一个隔离的环境中一起运行。       \n3.运行docker-compose up命令，启动并运行整个应用程序。\n\n### 入门示例\n\n- 新建文件夹`docker-compose-demo`,进入该目录，拷贝文件`eureka-server.jar`进来。\n\n- 新建文件`Dockerfile`，添加内容：\n\n\n    FROM java:8\n    VOLUME /tmp\n    ADD eureka-server.jar app.jar\n    RUN bash -c 'touch /app.jar'\n    EXPOSE 9000\n    ENTRYPOINT [\"java\",\"-Djava.security.egd=file:/dev/./urandom\",\"-jar\",\"/app.jar\"]\n    \n- 再新建文件`docker-compose.yml`,添加内容：\n\n\n    version: '2'\t\t\t# 表示该docker-compose.yml文件使用的是Version 2 file format\n    services:\n      eureka:\t\t\t\t# 指定服务名称\n        build: .\t\t\t# 指定Dockerfile所在路径\n        ports:\n          - \"8761:8761\"\t\t# 指定端口映射，类似docker run的-p选项，注意使用字符串形式           \n          \n- 在docker-compose.yml 所在路径执行以下命令。     \n  \n\n    docker-compose up\n    \nCompose就会自动构建镜像并使用镜像启动容器。我们也可使用docker-compose up -d 后台启动并运行这些容器。     \n\n- 访问：http://宿主机IP:8761/ ，即可访问Eureka Server首页   \n\n### 工程、服务、容器\n\nDocker Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker Compose运行目录下的所有文件（docker-compose.yml, extends文件或环境变量文件等）组成一个工程（默认为docker-compose.yml所在目录的目录名称）。一个工程可包含多个服务；每个服务中定义了容器运行的镜像、参数和依赖，一个服务可包括多个容器实例。\n\n对应《入门示例》一节，工程名称是docker-compose.yml所在的目录名。该工程包含了1个服务，服务名称是eureka；执行docker-compose up时，启动了eureka服务的1个容器实例。\n\n        ","slug":"docker-lesson7-compose","published":1,"updated":"2019-09-12T16:18:24.852Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbf002sg4varsj1t52p","content":"<p>在一个例如web应用中，除了应用本身之外，其还关联用到数据库等……，如果都采用docker化的话，那么就需要启动所有相关的docker容器。那么，有没有可能，按照某种顺序，对所有相关联的docker容器进行编排，然后按照一定的先后顺序依次启动。是的，Docker Compose就是这么一个工具，容器编排工具。定义和运行多个容器的应用。 </p>\n<p>Compose中有两个重要的概念：</p>\n<ul>\n<li>服务（Service）：一个应用的容器,实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目(project)：由一组关联的应用容器组成的一个完整业务单元,在    docker-compose.yml文件中定义。</li>\n</ul>\n<p>Compose    的默认管理对象是项目,通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<h2 id=\"安装Docker-Compose\"><a href=\"#安装Docker-Compose\" class=\"headerlink\" title=\"安装Docker Compose\"></a>安装Docker Compose</h2><ul>\n<li>确保已经安装了docker引擎，docker compose依赖docker引擎。</li>\n<li>docker compose不要在root账户权限下运行。（为啥？在root运行下会有什么问题吗，是否也可以？）</li>\n</ul>\n<p>Docker Compose安装：<a href=\"https://docs.docker.com/compose/install/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/compose/install/</a></p>\n<h3 id=\"CentOs7下安装\"><a href=\"#CentOs7下安装\" class=\"headerlink\" title=\"CentOs7下安装\"></a>CentOs7下安装</h3><p><em>注意：</em> For alpine, the following dependency packages are needed: py-pip, python-dev, libffi-dev, openssl-dev, gcc, libc-dev, and make.</p>\n<p>1.执行下面命令获取合适版本：</p>\n<pre><code>sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose\n</code></pre><p>安装不同版本，只需要更改<code>1.24.1</code>。</p>\n<p>2.给二进制可执行文件赋权：</p>\n<pre><code>sudo chmod +x /usr/local/bin/docker-compose\n</code></pre><p>这样，Docker Compose就安装完成了。</p>\n<p>3.测试是否安装成功：</p>\n<pre><code>[root@izwz9guplfsq8ltfk0wnjiz ~]# docker-compose --version\ndocker-compose version 1.24.1, build 4667896b\n</code></pre><p>看上面输出信息可知已经安装成功了。</p>\n<h2 id=\"安装Docker-Compose命令补全工具\"><a href=\"#安装Docker-Compose命令补全工具\" class=\"headerlink\" title=\"安装Docker Compose命令补全工具\"></a>安装Docker Compose命令补全工具</h2><p>我们已经安装了Compose，但是在命令窗口输入docker-compose后，按下Tab键，没有显示其所有具有的命令。因此，我们需要安装命令补全工具。</p>\n<p>命令补全工具安装：<a href=\"https://docs.docker.com/compose/completion/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/compose/completion/</a></p>\n<p>安装命令补全工具只需要执行下面命令：</p>\n<pre><code>curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose\n</code></pre><p>这样，在重新登录后，输入docker-compose 并按下Tab键，Compose就可自动补全命令了。</p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><p>这里展示一个简单的示例，简单了解docker compose使用步骤。</p>\n<h3 id=\"基本步骤：\"><a href=\"#基本步骤：\" class=\"headerlink\" title=\"基本步骤：\"></a>基本步骤：</h3><p>1.使用Dockerfile（或其他方式）定义应用程序环境，以便在任何地方重现该环境。<br>2.在docker-compose.yml文件中定义组成应用程序的服务，以便各个服务在一个隔离的环境中一起运行。<br>3.运行docker-compose up命令，启动并运行整个应用程序。</p>\n<h3 id=\"入门示例\"><a href=\"#入门示例\" class=\"headerlink\" title=\"入门示例\"></a>入门示例</h3><ul>\n<li><p>新建文件夹<code>docker-compose-demo</code>,进入该目录，拷贝文件<code>eureka-server.jar</code>进来。</p>\n</li>\n<li><p>新建文件<code>Dockerfile</code>，添加内容：</p>\n</li>\n</ul>\n<pre><code>FROM java:8\nVOLUME /tmp\nADD eureka-server.jar app.jar\nRUN bash -c &apos;touch /app.jar&apos;\nEXPOSE 9000\nENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]\n</code></pre><ul>\n<li>再新建文件<code>docker-compose.yml</code>,添加内容：</li>\n</ul>\n<pre><code>version: &apos;2&apos;            # 表示该docker-compose.yml文件使用的是Version 2 file format\nservices:\n  eureka:                # 指定服务名称\n    build: .            # 指定Dockerfile所在路径\n    ports:\n      - &quot;8761:8761&quot;        # 指定端口映射，类似docker run的-p选项，注意使用字符串形式           \n</code></pre><ul>\n<li>在docker-compose.yml 所在路径执行以下命令。     </li>\n</ul>\n<pre><code>docker-compose up\n</code></pre><p>Compose就会自动构建镜像并使用镜像启动容器。我们也可使用docker-compose up -d 后台启动并运行这些容器。     </p>\n<ul>\n<li>访问：http://宿主机IP:8761/ ，即可访问Eureka Server首页   </li>\n</ul>\n<h3 id=\"工程、服务、容器\"><a href=\"#工程、服务、容器\" class=\"headerlink\" title=\"工程、服务、容器\"></a>工程、服务、容器</h3><p>Docker Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker Compose运行目录下的所有文件（docker-compose.yml, extends文件或环境变量文件等）组成一个工程（默认为docker-compose.yml所在目录的目录名称）。一个工程可包含多个服务；每个服务中定义了容器运行的镜像、参数和依赖，一个服务可包括多个容器实例。</p>\n<p>对应《入门示例》一节，工程名称是docker-compose.yml所在的目录名。该工程包含了1个服务，服务名称是eureka；执行docker-compose up时，启动了eureka服务的1个容器实例。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一个例如web应用中，除了应用本身之外，其还关联用到数据库等……，如果都采用docker化的话，那么就需要启动所有相关的docker容器。那么，有没有可能，按照某种顺序，对所有相关联的docker容器进行编排，然后按照一定的先后顺序依次启动。是的，Docker Compose就是这么一个工具，容器编排工具。定义和运行多个容器的应用。 </p>\n<p>Compose中有两个重要的概念：</p>\n<ul>\n<li>服务（Service）：一个应用的容器,实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目(project)：由一组关联的应用容器组成的一个完整业务单元,在    docker-compose.yml文件中定义。</li>\n</ul>\n<p>Compose    的默认管理对象是项目,通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n<h2 id=\"安装Docker-Compose\"><a href=\"#安装Docker-Compose\" class=\"headerlink\" title=\"安装Docker Compose\"></a>安装Docker Compose</h2><ul>\n<li>确保已经安装了docker引擎，docker compose依赖docker引擎。</li>\n<li>docker compose不要在root账户权限下运行。（为啥？在root运行下会有什么问题吗，是否也可以？）</li>\n</ul>\n<p>Docker Compose安装：<a href=\"https://docs.docker.com/compose/install/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/compose/install/</a></p>\n<h3 id=\"CentOs7下安装\"><a href=\"#CentOs7下安装\" class=\"headerlink\" title=\"CentOs7下安装\"></a>CentOs7下安装</h3><p><em>注意：</em> For alpine, the following dependency packages are needed: py-pip, python-dev, libffi-dev, openssl-dev, gcc, libc-dev, and make.</p>\n<p>1.执行下面命令获取合适版本：</p>\n<pre><code>sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose\n</code></pre><p>安装不同版本，只需要更改<code>1.24.1</code>。</p>\n<p>2.给二进制可执行文件赋权：</p>\n<pre><code>sudo chmod +x /usr/local/bin/docker-compose\n</code></pre><p>这样，Docker Compose就安装完成了。</p>\n<p>3.测试是否安装成功：</p>\n<pre><code>[root@izwz9guplfsq8ltfk0wnjiz ~]# docker-compose --version\ndocker-compose version 1.24.1, build 4667896b\n</code></pre><p>看上面输出信息可知已经安装成功了。</p>\n<h2 id=\"安装Docker-Compose命令补全工具\"><a href=\"#安装Docker-Compose命令补全工具\" class=\"headerlink\" title=\"安装Docker Compose命令补全工具\"></a>安装Docker Compose命令补全工具</h2><p>我们已经安装了Compose，但是在命令窗口输入docker-compose后，按下Tab键，没有显示其所有具有的命令。因此，我们需要安装命令补全工具。</p>\n<p>命令补全工具安装：<a href=\"https://docs.docker.com/compose/completion/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/compose/completion/</a></p>\n<p>安装命令补全工具只需要执行下面命令：</p>\n<pre><code>curl -L https://raw.githubusercontent.com/docker/compose/$(docker-compose version --short)/contrib/completion/bash/docker-compose -o /etc/bash_completion.d/docker-compose\n</code></pre><p>这样，在重新登录后，输入docker-compose 并按下Tab键，Compose就可自动补全命令了。</p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><p>这里展示一个简单的示例，简单了解docker compose使用步骤。</p>\n<h3 id=\"基本步骤：\"><a href=\"#基本步骤：\" class=\"headerlink\" title=\"基本步骤：\"></a>基本步骤：</h3><p>1.使用Dockerfile（或其他方式）定义应用程序环境，以便在任何地方重现该环境。<br>2.在docker-compose.yml文件中定义组成应用程序的服务，以便各个服务在一个隔离的环境中一起运行。<br>3.运行docker-compose up命令，启动并运行整个应用程序。</p>\n<h3 id=\"入门示例\"><a href=\"#入门示例\" class=\"headerlink\" title=\"入门示例\"></a>入门示例</h3><ul>\n<li><p>新建文件夹<code>docker-compose-demo</code>,进入该目录，拷贝文件<code>eureka-server.jar</code>进来。</p>\n</li>\n<li><p>新建文件<code>Dockerfile</code>，添加内容：</p>\n</li>\n</ul>\n<pre><code>FROM java:8\nVOLUME /tmp\nADD eureka-server.jar app.jar\nRUN bash -c &apos;touch /app.jar&apos;\nEXPOSE 9000\nENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd=file:/dev/./urandom&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]\n</code></pre><ul>\n<li>再新建文件<code>docker-compose.yml</code>,添加内容：</li>\n</ul>\n<pre><code>version: &apos;2&apos;            # 表示该docker-compose.yml文件使用的是Version 2 file format\nservices:\n  eureka:                # 指定服务名称\n    build: .            # 指定Dockerfile所在路径\n    ports:\n      - &quot;8761:8761&quot;        # 指定端口映射，类似docker run的-p选项，注意使用字符串形式           \n</code></pre><ul>\n<li>在docker-compose.yml 所在路径执行以下命令。     </li>\n</ul>\n<pre><code>docker-compose up\n</code></pre><p>Compose就会自动构建镜像并使用镜像启动容器。我们也可使用docker-compose up -d 后台启动并运行这些容器。     </p>\n<ul>\n<li>访问：http://宿主机IP:8761/ ，即可访问Eureka Server首页   </li>\n</ul>\n<h3 id=\"工程、服务、容器\"><a href=\"#工程、服务、容器\" class=\"headerlink\" title=\"工程、服务、容器\"></a>工程、服务、容器</h3><p>Docker Compose将所管理的容器分为三层，分别是工程（project），服务（service）以及容器（container）。Docker Compose运行目录下的所有文件（docker-compose.yml, extends文件或环境变量文件等）组成一个工程（默认为docker-compose.yml所在目录的目录名称）。一个工程可包含多个服务；每个服务中定义了容器运行的镜像、参数和依赖，一个服务可包括多个容器实例。</p>\n<p>对应《入门示例》一节，工程名称是docker-compose.yml所在的目录名。该工程包含了1个服务，服务名称是eureka；执行docker-compose up时，启动了eureka服务的1个容器实例。</p>\n"},{"title":"使用maven插件构建docker镜像并注册到nexus私仓","date":"2018-12-27T06:29:17.000Z","_content":"\nMaven是一个强大的项目管理和构建工具，下面我们介绍利用Maven插件构建Docker镜像并注册到Nexus私仓里面，这样，在服务器或者其它地方就可以直接拉取镜像并运行，这对服务共享或者服务器部署应用起到极大的方便。      \n在maven中央仓库，可以搜索到好几个docker-maven-pluging。\n\n下面我们采用一款由Spotify公司开发的Maven插件[docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)。\n\n参考网址：   \nhttp://itmuch.com/docker/12-docker-maven/   \nhttps://blog.csdn.net/aixiaoyang168/article/details/77453974\n\n## 快速入门\n\n1.新建spring-cloud项目，eureka-server。\n\n2.配置pom.xml文件：\n    \n    <plugin>\n        <groupId>com.spotify</groupId>\n        <artifactId>docker-maven-plugin</artifactId>\n        <version>1.2.0</version>\n        <configuration>\n            <imageName>my-image:${project.version}</imageName>\n            <baseImage>java</baseImage>\n            <entryPoint>[\"java\", \"-jar\", \"/${project.build.finalName}.jar\"]</entryPoint>\n            <!-- copy the service's jar file from target into the root directory of the image -->\n            <resources>\n                <resource>\n                    <targetPath>/</targetPath>\n                    <directory>${project.build.directory}</directory>\n                    <include>${project.build.finalName}.jar</include>\n                </resource>\n            </resources>\n        </configuration>\n    </plugin> \n\n插件配置说明：\n\n- imageName：指定镜像名称。一般是用`仓库名称+实际名字`作为镜像名称，如：`docker-repo/my-image`整个作为镜像名词，也可以直接用`my-image`作为镜像名称。冒号后面是镜像tag，如果不指定，则tag是`latest`,所以一般指定，就直接用maven项目的版本号。这里特别注意，tab不能带大写字母，否则报错。比如maven的版本号默认：0.0.1-SNAPSHOT。这样构建将会报错误。去掉`SNAPSHOT`。\n- baseImage：用于指定基础镜像，类似于Dockerfile中的FROM指令。这里用了`java`基础镜像，这是个集成了openJdk1.8的镜像，有643M那么大。因此，我们可以用这个替换[hub.docker.com](https://hub.docker.com/r/anapsix/alpine-java),只有127M大小，集成的jdk8。\n- entrypoint：类似于Dockerfile的ENTRYPOINT指令。\n- resources.resource.directory：用于指定需要复制的根目录，${project.build.directory}表示target目录。会在target目录下生成docker目录，jar包等生成在里面。\n- resources.resource.include：指定需要复制的文件。${project.build.finalName}.jar指的是打包后的jar包文件。\n\n3.设置环境变量DOCKER_HOS\n\n编辑/etc/profile文件，增加环境变量：\n    \n    export DOCKER_HOST=tcp://192.168.33.10:2375\n    \n可能报错：\n    \n    [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.2.0:build (default-cli) on project demo: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: com.spotify.docker.client.shaded.org.apache.http.conn.HttpHostConnectException: Connect to 192.168.33.10:2375 [/192.168.33.10] failed: Connection refused (Connection refused) -> [Help 1]\n\n报错的话，把跳过该步骤，后面也能成功。待解……    \n\nip是指本机ip。端口指定，不可更改。\n\n4.启动docker引擎，执行下面命令开始构建：\n\n    mvn clean package docker:build\n    \n    --查看是否生成镜像\n    docker image ls\n\n5.启动镜像：\n\n     docker run --name eureka-server -p 8084:8084 -d my-image\n\n可以正常访问网站啦！！      \n    \n## 使用Dockerfile进行构建\n\n    <build>\n      <plugins>\n        ...\n        <plugin>\n          <groupId>com.spotify</groupId>\n          <artifactId>docker-maven-plugin</artifactId>\n          <version>VERSION GOES HERE</version>\n          <configuration>\n            <imageName>example</imageName>\n            <dockerDirectory>docker</dockerDirectory>\n            <resources>\n               <resource>\n                 <targetPath>/</targetPath>\n                 <directory>${project.build.directory}</directory>\n                 <include>${project.build.finalName}.jar</include>\n               </resource>\n            </resources>\n          </configuration>\n        </plugin>\n        ...\n      </plugins>\n    </build>\n\n 基本不变，改成这个属性`<dockerDirectory>docker</dockerDirectory>` 。指定Dockerfile所在目录即可。然后也是执行`mvn clean package docker:build`就可构建了。     \n\n## 构建docker镜像并push到docker私服\n\n### 简洁配置：\n\n1.maven setting.xml配置：  \n添加：\n\n     <server>\n    \t<id>my-docker-registry</id>\n    \t<username>admin</username>\n    \t<password>admin123</password>\n    \t<configuration>\n    \t   <email>932852117@qq.com</email>\n    \t</configuration>\n      </server>\n\n账号密码，是私服nexus的账号密码。\n\n2.pom.xml配置：\n\n    <plugin>\n        <groupId>com.spotify</groupId>\n        <artifactId>docker-maven-plugin</artifactId>\n        <version>1.2.0</version>\n        <configuration>\n            <imageName>119.145.41.171:8082/ymu-micr/my-image:${project.version}</imageName>\n            <!-- <imageName>my-image:${project.version}</imageName> -->\n            <baseImage>anapsix/alpine-java</baseImage>\n            <entryPoint>[\"java\", \"-jar\", \"/${project.build.finalName}.jar\"]</entryPoint> \n            <forceTags>true</forceTags>\n            <!-- copy the service's jar file from target into the root directory \n                of the image -->\n            <resources>\n                <resource>\n                    <targetPath>/</targetPath>\n                    <directory>${project.build.directory}</directory>\n                    <include>${project.build.finalName}.jar</include>\n                </resource>\n            </resources>\n            <serverId>my-docker-registry</serverId>\n            <!-- <registryUrl>119.145.41.171:8082/v1/</registryUrl> -->\n        </configuration>\n    </plugin>\n    \n3.执行命令构建上传到nexus私服：\n\n    mvn clean package docker:build -DpushImage    \n    \n构建成功后可以在私服看到docker 镜像：\n\n{%asset_img a-1.png%}   \n     \n\n### 完整配置：   \n\n    <plugin>\n        <groupId>com.spotify</groupId>\n        <artifactId>docker-maven-plugin</artifactId>\n        <version>1.2.0</version>\n        <configuration>\n            <imageName>119.145.41.171:8082/ymu-micr/my-image:${project.version}</imageName>\n            <!-- <imageName>my-image:${project.version}</imageName> -->\n            <baseImage>anapsix/alpine-java</baseImage>\n            <entryPoint>[\"java\", \"-jar\", \"/${project.build.finalName}.jar\"]</entryPoint> \n            <forceTags>true</forceTags>\n            <!-- copy the service's jar file from target into the root directory \n                of the image -->\n            <resources>\n                <resource>\n                    <targetPath>/</targetPath>\n                    <directory>${project.build.directory}</directory>\n                    <include>${project.build.finalName}.jar</include>\n                </resource>\n            </resources>\n            <serverId>my-docker-registry</serverId>\n            <!-- <registryUrl>119.145.41.171:8082/v1/</registryUrl> -->\n        </configuration>\n        <executions>\n            <execution>\n              <id>build-image</id>\n              <phase>package</phase>\n              <goals>\n                <goal>build</goal>\n              </goals>\n            </execution>\n            <execution>\n              <id>tag-image</id>\n              <phase>package</phase>\n              <goals>\n                <goal>tag</goal>\n              </goals>\n              <configuration>\n                <image>my-image:${project.version}</image>\n                <newName>119.145.41.171:8082/ymu-micr/my-image:${project.version}</newName>\n              </configuration>\n            </execution>\n            <execution>\n              <id>push-image</id>\n              <phase>deploy</phase>\n              <goals>\n                <goal>push</goal>\n              </goals>\n              <configuration>\n                <imageName>119.145.41.171:8082/ymu-micr/my-image:${project.version}</imageName>\n              </configuration>\n            </execution>        \n        </executions>\n    </plugin>","source":"_posts/docker-maven-nexus.md","raw":"---\ntitle: 使用maven插件构建docker镜像并注册到nexus私仓\ndate: 2018-12-27 14:29:17\ncategories: docker\ntags:\n---\n\nMaven是一个强大的项目管理和构建工具，下面我们介绍利用Maven插件构建Docker镜像并注册到Nexus私仓里面，这样，在服务器或者其它地方就可以直接拉取镜像并运行，这对服务共享或者服务器部署应用起到极大的方便。      \n在maven中央仓库，可以搜索到好几个docker-maven-pluging。\n\n下面我们采用一款由Spotify公司开发的Maven插件[docker-maven-plugin](https://github.com/spotify/docker-maven-plugin)。\n\n参考网址：   \nhttp://itmuch.com/docker/12-docker-maven/   \nhttps://blog.csdn.net/aixiaoyang168/article/details/77453974\n\n## 快速入门\n\n1.新建spring-cloud项目，eureka-server。\n\n2.配置pom.xml文件：\n    \n    <plugin>\n        <groupId>com.spotify</groupId>\n        <artifactId>docker-maven-plugin</artifactId>\n        <version>1.2.0</version>\n        <configuration>\n            <imageName>my-image:${project.version}</imageName>\n            <baseImage>java</baseImage>\n            <entryPoint>[\"java\", \"-jar\", \"/${project.build.finalName}.jar\"]</entryPoint>\n            <!-- copy the service's jar file from target into the root directory of the image -->\n            <resources>\n                <resource>\n                    <targetPath>/</targetPath>\n                    <directory>${project.build.directory}</directory>\n                    <include>${project.build.finalName}.jar</include>\n                </resource>\n            </resources>\n        </configuration>\n    </plugin> \n\n插件配置说明：\n\n- imageName：指定镜像名称。一般是用`仓库名称+实际名字`作为镜像名称，如：`docker-repo/my-image`整个作为镜像名词，也可以直接用`my-image`作为镜像名称。冒号后面是镜像tag，如果不指定，则tag是`latest`,所以一般指定，就直接用maven项目的版本号。这里特别注意，tab不能带大写字母，否则报错。比如maven的版本号默认：0.0.1-SNAPSHOT。这样构建将会报错误。去掉`SNAPSHOT`。\n- baseImage：用于指定基础镜像，类似于Dockerfile中的FROM指令。这里用了`java`基础镜像，这是个集成了openJdk1.8的镜像，有643M那么大。因此，我们可以用这个替换[hub.docker.com](https://hub.docker.com/r/anapsix/alpine-java),只有127M大小，集成的jdk8。\n- entrypoint：类似于Dockerfile的ENTRYPOINT指令。\n- resources.resource.directory：用于指定需要复制的根目录，${project.build.directory}表示target目录。会在target目录下生成docker目录，jar包等生成在里面。\n- resources.resource.include：指定需要复制的文件。${project.build.finalName}.jar指的是打包后的jar包文件。\n\n3.设置环境变量DOCKER_HOS\n\n编辑/etc/profile文件，增加环境变量：\n    \n    export DOCKER_HOST=tcp://192.168.33.10:2375\n    \n可能报错：\n    \n    [ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.2.0:build (default-cli) on project demo: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: com.spotify.docker.client.shaded.org.apache.http.conn.HttpHostConnectException: Connect to 192.168.33.10:2375 [/192.168.33.10] failed: Connection refused (Connection refused) -> [Help 1]\n\n报错的话，把跳过该步骤，后面也能成功。待解……    \n\nip是指本机ip。端口指定，不可更改。\n\n4.启动docker引擎，执行下面命令开始构建：\n\n    mvn clean package docker:build\n    \n    --查看是否生成镜像\n    docker image ls\n\n5.启动镜像：\n\n     docker run --name eureka-server -p 8084:8084 -d my-image\n\n可以正常访问网站啦！！      \n    \n## 使用Dockerfile进行构建\n\n    <build>\n      <plugins>\n        ...\n        <plugin>\n          <groupId>com.spotify</groupId>\n          <artifactId>docker-maven-plugin</artifactId>\n          <version>VERSION GOES HERE</version>\n          <configuration>\n            <imageName>example</imageName>\n            <dockerDirectory>docker</dockerDirectory>\n            <resources>\n               <resource>\n                 <targetPath>/</targetPath>\n                 <directory>${project.build.directory}</directory>\n                 <include>${project.build.finalName}.jar</include>\n               </resource>\n            </resources>\n          </configuration>\n        </plugin>\n        ...\n      </plugins>\n    </build>\n\n 基本不变，改成这个属性`<dockerDirectory>docker</dockerDirectory>` 。指定Dockerfile所在目录即可。然后也是执行`mvn clean package docker:build`就可构建了。     \n\n## 构建docker镜像并push到docker私服\n\n### 简洁配置：\n\n1.maven setting.xml配置：  \n添加：\n\n     <server>\n    \t<id>my-docker-registry</id>\n    \t<username>admin</username>\n    \t<password>admin123</password>\n    \t<configuration>\n    \t   <email>932852117@qq.com</email>\n    \t</configuration>\n      </server>\n\n账号密码，是私服nexus的账号密码。\n\n2.pom.xml配置：\n\n    <plugin>\n        <groupId>com.spotify</groupId>\n        <artifactId>docker-maven-plugin</artifactId>\n        <version>1.2.0</version>\n        <configuration>\n            <imageName>119.145.41.171:8082/ymu-micr/my-image:${project.version}</imageName>\n            <!-- <imageName>my-image:${project.version}</imageName> -->\n            <baseImage>anapsix/alpine-java</baseImage>\n            <entryPoint>[\"java\", \"-jar\", \"/${project.build.finalName}.jar\"]</entryPoint> \n            <forceTags>true</forceTags>\n            <!-- copy the service's jar file from target into the root directory \n                of the image -->\n            <resources>\n                <resource>\n                    <targetPath>/</targetPath>\n                    <directory>${project.build.directory}</directory>\n                    <include>${project.build.finalName}.jar</include>\n                </resource>\n            </resources>\n            <serverId>my-docker-registry</serverId>\n            <!-- <registryUrl>119.145.41.171:8082/v1/</registryUrl> -->\n        </configuration>\n    </plugin>\n    \n3.执行命令构建上传到nexus私服：\n\n    mvn clean package docker:build -DpushImage    \n    \n构建成功后可以在私服看到docker 镜像：\n\n{%asset_img a-1.png%}   \n     \n\n### 完整配置：   \n\n    <plugin>\n        <groupId>com.spotify</groupId>\n        <artifactId>docker-maven-plugin</artifactId>\n        <version>1.2.0</version>\n        <configuration>\n            <imageName>119.145.41.171:8082/ymu-micr/my-image:${project.version}</imageName>\n            <!-- <imageName>my-image:${project.version}</imageName> -->\n            <baseImage>anapsix/alpine-java</baseImage>\n            <entryPoint>[\"java\", \"-jar\", \"/${project.build.finalName}.jar\"]</entryPoint> \n            <forceTags>true</forceTags>\n            <!-- copy the service's jar file from target into the root directory \n                of the image -->\n            <resources>\n                <resource>\n                    <targetPath>/</targetPath>\n                    <directory>${project.build.directory}</directory>\n                    <include>${project.build.finalName}.jar</include>\n                </resource>\n            </resources>\n            <serverId>my-docker-registry</serverId>\n            <!-- <registryUrl>119.145.41.171:8082/v1/</registryUrl> -->\n        </configuration>\n        <executions>\n            <execution>\n              <id>build-image</id>\n              <phase>package</phase>\n              <goals>\n                <goal>build</goal>\n              </goals>\n            </execution>\n            <execution>\n              <id>tag-image</id>\n              <phase>package</phase>\n              <goals>\n                <goal>tag</goal>\n              </goals>\n              <configuration>\n                <image>my-image:${project.version}</image>\n                <newName>119.145.41.171:8082/ymu-micr/my-image:${project.version}</newName>\n              </configuration>\n            </execution>\n            <execution>\n              <id>push-image</id>\n              <phase>deploy</phase>\n              <goals>\n                <goal>push</goal>\n              </goals>\n              <configuration>\n                <imageName>119.145.41.171:8082/ymu-micr/my-image:${project.version}</imageName>\n              </configuration>\n            </execution>        \n        </executions>\n    </plugin>","slug":"docker-maven-nexus","published":1,"updated":"2019-06-16T14:38:33.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbg002vg4varmbxurvm","content":"<p>Maven是一个强大的项目管理和构建工具，下面我们介绍利用Maven插件构建Docker镜像并注册到Nexus私仓里面，这样，在服务器或者其它地方就可以直接拉取镜像并运行，这对服务共享或者服务器部署应用起到极大的方便。<br>在maven中央仓库，可以搜索到好几个docker-maven-pluging。</p>\n<p>下面我们采用一款由Spotify公司开发的Maven插件<a href=\"https://github.com/spotify/docker-maven-plugin\" target=\"_blank\" rel=\"noopener\">docker-maven-plugin</a>。</p>\n<p>参考网址：<br><a href=\"http://itmuch.com/docker/12-docker-maven/\" target=\"_blank\" rel=\"noopener\">http://itmuch.com/docker/12-docker-maven/</a><br><a href=\"https://blog.csdn.net/aixiaoyang168/article/details/77453974\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/aixiaoyang168/article/details/77453974</a></p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><p>1.新建spring-cloud项目，eureka-server。</p>\n<p>2.配置pom.xml文件：</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2.0&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;imageName&gt;my-image:${project.version}&lt;/imageName&gt;\n        &lt;baseImage&gt;java&lt;/baseImage&gt;\n        &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;, &quot;/${project.build.finalName}.jar&quot;]&lt;/entryPoint&gt;\n        &lt;!-- copy the service&apos;s jar file from target into the root directory of the image --&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;targetPath&gt;/&lt;/targetPath&gt;\n                &lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n                &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt; \n</code></pre><p>插件配置说明：</p>\n<ul>\n<li>imageName：指定镜像名称。一般是用<code>仓库名称+实际名字</code>作为镜像名称，如：<code>docker-repo/my-image</code>整个作为镜像名词，也可以直接用<code>my-image</code>作为镜像名称。冒号后面是镜像tag，如果不指定，则tag是<code>latest</code>,所以一般指定，就直接用maven项目的版本号。这里特别注意，tab不能带大写字母，否则报错。比如maven的版本号默认：0.0.1-SNAPSHOT。这样构建将会报错误。去掉<code>SNAPSHOT</code>。</li>\n<li>baseImage：用于指定基础镜像，类似于Dockerfile中的FROM指令。这里用了<code>java</code>基础镜像，这是个集成了openJdk1.8的镜像，有643M那么大。因此，我们可以用这个替换<a href=\"https://hub.docker.com/r/anapsix/alpine-java\" target=\"_blank\" rel=\"noopener\">hub.docker.com</a>,只有127M大小，集成的jdk8。</li>\n<li>entrypoint：类似于Dockerfile的ENTRYPOINT指令。</li>\n<li>resources.resource.directory：用于指定需要复制的根目录，${project.build.directory}表示target目录。会在target目录下生成docker目录，jar包等生成在里面。</li>\n<li>resources.resource.include：指定需要复制的文件。${project.build.finalName}.jar指的是打包后的jar包文件。</li>\n</ul>\n<p>3.设置环境变量DOCKER_HOS</p>\n<p>编辑/etc/profile文件，增加环境变量：</p>\n<pre><code>export DOCKER_HOST=tcp://192.168.33.10:2375\n</code></pre><p>可能报错：</p>\n<pre><code>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.2.0:build (default-cli) on project demo: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: com.spotify.docker.client.shaded.org.apache.http.conn.HttpHostConnectException: Connect to 192.168.33.10:2375 [/192.168.33.10] failed: Connection refused (Connection refused) -&gt; [Help 1]\n</code></pre><p>报错的话，把跳过该步骤，后面也能成功。待解……    </p>\n<p>ip是指本机ip。端口指定，不可更改。</p>\n<p>4.启动docker引擎，执行下面命令开始构建：</p>\n<pre><code>mvn clean package docker:build\n\n--查看是否生成镜像\ndocker image ls\n</code></pre><p>5.启动镜像：</p>\n<pre><code>docker run --name eureka-server -p 8084:8084 -d my-image\n</code></pre><p>可以正常访问网站啦！！      </p>\n<h2 id=\"使用Dockerfile进行构建\"><a href=\"#使用Dockerfile进行构建\" class=\"headerlink\" title=\"使用Dockerfile进行构建\"></a>使用Dockerfile进行构建</h2><pre><code>&lt;build&gt;\n  &lt;plugins&gt;\n    ...\n    &lt;plugin&gt;\n      &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n      &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n      &lt;version&gt;VERSION GOES HERE&lt;/version&gt;\n      &lt;configuration&gt;\n        &lt;imageName&gt;example&lt;/imageName&gt;\n        &lt;dockerDirectory&gt;docker&lt;/dockerDirectory&gt;\n        &lt;resources&gt;\n           &lt;resource&gt;\n             &lt;targetPath&gt;/&lt;/targetPath&gt;\n             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n           &lt;/resource&gt;\n        &lt;/resources&gt;\n      &lt;/configuration&gt;\n    &lt;/plugin&gt;\n    ...\n  &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre><p> 基本不变，改成这个属性<code>&lt;dockerDirectory&gt;docker&lt;/dockerDirectory&gt;</code> 。指定Dockerfile所在目录即可。然后也是执行<code>mvn clean package docker:build</code>就可构建了。     </p>\n<h2 id=\"构建docker镜像并push到docker私服\"><a href=\"#构建docker镜像并push到docker私服\" class=\"headerlink\" title=\"构建docker镜像并push到docker私服\"></a>构建docker镜像并push到docker私服</h2><h3 id=\"简洁配置：\"><a href=\"#简洁配置：\" class=\"headerlink\" title=\"简洁配置：\"></a>简洁配置：</h3><p>1.maven setting.xml配置：<br>添加：</p>\n<pre><code>&lt;server&gt;\n   &lt;id&gt;my-docker-registry&lt;/id&gt;\n   &lt;username&gt;admin&lt;/username&gt;\n   &lt;password&gt;admin123&lt;/password&gt;\n   &lt;configuration&gt;\n      &lt;email&gt;932852117@qq.com&lt;/email&gt;\n   &lt;/configuration&gt;\n &lt;/server&gt;\n</code></pre><p>账号密码，是私服nexus的账号密码。</p>\n<p>2.pom.xml配置：</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2.0&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;imageName&gt;119.145.41.171:8082/ymu-micr/my-image:${project.version}&lt;/imageName&gt;\n        &lt;!-- &lt;imageName&gt;my-image:${project.version}&lt;/imageName&gt; --&gt;\n        &lt;baseImage&gt;anapsix/alpine-java&lt;/baseImage&gt;\n        &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;, &quot;/${project.build.finalName}.jar&quot;]&lt;/entryPoint&gt; \n        &lt;forceTags&gt;true&lt;/forceTags&gt;\n        &lt;!-- copy the service&apos;s jar file from target into the root directory \n            of the image --&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;targetPath&gt;/&lt;/targetPath&gt;\n                &lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n                &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n        &lt;serverId&gt;my-docker-registry&lt;/serverId&gt;\n        &lt;!-- &lt;registryUrl&gt;119.145.41.171:8082/v1/&lt;/registryUrl&gt; --&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><p>3.执行命令构建上传到nexus私服：</p>\n<pre><code>mvn clean package docker:build -DpushImage    \n</code></pre><p>构建成功后可以在私服看到docker 镜像：</p>\n<img src=\"/2018/12/27/docker-maven-nexus/a-1.png\">   \n<h3 id=\"完整配置：\"><a href=\"#完整配置：\" class=\"headerlink\" title=\"完整配置：\"></a>完整配置：</h3><pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2.0&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;imageName&gt;119.145.41.171:8082/ymu-micr/my-image:${project.version}&lt;/imageName&gt;\n        &lt;!-- &lt;imageName&gt;my-image:${project.version}&lt;/imageName&gt; --&gt;\n        &lt;baseImage&gt;anapsix/alpine-java&lt;/baseImage&gt;\n        &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;, &quot;/${project.build.finalName}.jar&quot;]&lt;/entryPoint&gt; \n        &lt;forceTags&gt;true&lt;/forceTags&gt;\n        &lt;!-- copy the service&apos;s jar file from target into the root directory \n            of the image --&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;targetPath&gt;/&lt;/targetPath&gt;\n                &lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n                &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n        &lt;serverId&gt;my-docker-registry&lt;/serverId&gt;\n        &lt;!-- &lt;registryUrl&gt;119.145.41.171:8082/v1/&lt;/registryUrl&gt; --&gt;\n    &lt;/configuration&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n          &lt;id&gt;build-image&lt;/id&gt;\n          &lt;phase&gt;package&lt;/phase&gt;\n          &lt;goals&gt;\n            &lt;goal&gt;build&lt;/goal&gt;\n          &lt;/goals&gt;\n        &lt;/execution&gt;\n        &lt;execution&gt;\n          &lt;id&gt;tag-image&lt;/id&gt;\n          &lt;phase&gt;package&lt;/phase&gt;\n          &lt;goals&gt;\n            &lt;goal&gt;tag&lt;/goal&gt;\n          &lt;/goals&gt;\n          &lt;configuration&gt;\n            &lt;image&gt;my-image:${project.version}&lt;/image&gt;\n            &lt;newName&gt;119.145.41.171:8082/ymu-micr/my-image:${project.version}&lt;/newName&gt;\n          &lt;/configuration&gt;\n        &lt;/execution&gt;\n        &lt;execution&gt;\n          &lt;id&gt;push-image&lt;/id&gt;\n          &lt;phase&gt;deploy&lt;/phase&gt;\n          &lt;goals&gt;\n            &lt;goal&gt;push&lt;/goal&gt;\n          &lt;/goals&gt;\n          &lt;configuration&gt;\n            &lt;imageName&gt;119.145.41.171:8082/ymu-micr/my-image:${project.version}&lt;/imageName&gt;\n          &lt;/configuration&gt;\n        &lt;/execution&gt;        \n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>Maven是一个强大的项目管理和构建工具，下面我们介绍利用Maven插件构建Docker镜像并注册到Nexus私仓里面，这样，在服务器或者其它地方就可以直接拉取镜像并运行，这对服务共享或者服务器部署应用起到极大的方便。<br>在maven中央仓库，可以搜索到好几个docker-maven-pluging。</p>\n<p>下面我们采用一款由Spotify公司开发的Maven插件<a href=\"https://github.com/spotify/docker-maven-plugin\" target=\"_blank\" rel=\"noopener\">docker-maven-plugin</a>。</p>\n<p>参考网址：<br><a href=\"http://itmuch.com/docker/12-docker-maven/\" target=\"_blank\" rel=\"noopener\">http://itmuch.com/docker/12-docker-maven/</a><br><a href=\"https://blog.csdn.net/aixiaoyang168/article/details/77453974\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/aixiaoyang168/article/details/77453974</a></p>\n<h2 id=\"快速入门\"><a href=\"#快速入门\" class=\"headerlink\" title=\"快速入门\"></a>快速入门</h2><p>1.新建spring-cloud项目，eureka-server。</p>\n<p>2.配置pom.xml文件：</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2.0&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;imageName&gt;my-image:${project.version}&lt;/imageName&gt;\n        &lt;baseImage&gt;java&lt;/baseImage&gt;\n        &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;, &quot;/${project.build.finalName}.jar&quot;]&lt;/entryPoint&gt;\n        &lt;!-- copy the service&apos;s jar file from target into the root directory of the image --&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;targetPath&gt;/&lt;/targetPath&gt;\n                &lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n                &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt; \n</code></pre><p>插件配置说明：</p>\n<ul>\n<li>imageName：指定镜像名称。一般是用<code>仓库名称+实际名字</code>作为镜像名称，如：<code>docker-repo/my-image</code>整个作为镜像名词，也可以直接用<code>my-image</code>作为镜像名称。冒号后面是镜像tag，如果不指定，则tag是<code>latest</code>,所以一般指定，就直接用maven项目的版本号。这里特别注意，tab不能带大写字母，否则报错。比如maven的版本号默认：0.0.1-SNAPSHOT。这样构建将会报错误。去掉<code>SNAPSHOT</code>。</li>\n<li>baseImage：用于指定基础镜像，类似于Dockerfile中的FROM指令。这里用了<code>java</code>基础镜像，这是个集成了openJdk1.8的镜像，有643M那么大。因此，我们可以用这个替换<a href=\"https://hub.docker.com/r/anapsix/alpine-java\" target=\"_blank\" rel=\"noopener\">hub.docker.com</a>,只有127M大小，集成的jdk8。</li>\n<li>entrypoint：类似于Dockerfile的ENTRYPOINT指令。</li>\n<li>resources.resource.directory：用于指定需要复制的根目录，${project.build.directory}表示target目录。会在target目录下生成docker目录，jar包等生成在里面。</li>\n<li>resources.resource.include：指定需要复制的文件。${project.build.finalName}.jar指的是打包后的jar包文件。</li>\n</ul>\n<p>3.设置环境变量DOCKER_HOS</p>\n<p>编辑/etc/profile文件，增加环境变量：</p>\n<pre><code>export DOCKER_HOST=tcp://192.168.33.10:2375\n</code></pre><p>可能报错：</p>\n<pre><code>[ERROR] Failed to execute goal com.spotify:docker-maven-plugin:1.2.0:build (default-cli) on project demo: Exception caught: java.util.concurrent.ExecutionException: com.spotify.docker.client.shaded.javax.ws.rs.ProcessingException: com.spotify.docker.client.shaded.org.apache.http.conn.HttpHostConnectException: Connect to 192.168.33.10:2375 [/192.168.33.10] failed: Connection refused (Connection refused) -&gt; [Help 1]\n</code></pre><p>报错的话，把跳过该步骤，后面也能成功。待解……    </p>\n<p>ip是指本机ip。端口指定，不可更改。</p>\n<p>4.启动docker引擎，执行下面命令开始构建：</p>\n<pre><code>mvn clean package docker:build\n\n--查看是否生成镜像\ndocker image ls\n</code></pre><p>5.启动镜像：</p>\n<pre><code>docker run --name eureka-server -p 8084:8084 -d my-image\n</code></pre><p>可以正常访问网站啦！！      </p>\n<h2 id=\"使用Dockerfile进行构建\"><a href=\"#使用Dockerfile进行构建\" class=\"headerlink\" title=\"使用Dockerfile进行构建\"></a>使用Dockerfile进行构建</h2><pre><code>&lt;build&gt;\n  &lt;plugins&gt;\n    ...\n    &lt;plugin&gt;\n      &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n      &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n      &lt;version&gt;VERSION GOES HERE&lt;/version&gt;\n      &lt;configuration&gt;\n        &lt;imageName&gt;example&lt;/imageName&gt;\n        &lt;dockerDirectory&gt;docker&lt;/dockerDirectory&gt;\n        &lt;resources&gt;\n           &lt;resource&gt;\n             &lt;targetPath&gt;/&lt;/targetPath&gt;\n             &lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n             &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n           &lt;/resource&gt;\n        &lt;/resources&gt;\n      &lt;/configuration&gt;\n    &lt;/plugin&gt;\n    ...\n  &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre><p> 基本不变，改成这个属性<code>&lt;dockerDirectory&gt;docker&lt;/dockerDirectory&gt;</code> 。指定Dockerfile所在目录即可。然后也是执行<code>mvn clean package docker:build</code>就可构建了。     </p>\n<h2 id=\"构建docker镜像并push到docker私服\"><a href=\"#构建docker镜像并push到docker私服\" class=\"headerlink\" title=\"构建docker镜像并push到docker私服\"></a>构建docker镜像并push到docker私服</h2><h3 id=\"简洁配置：\"><a href=\"#简洁配置：\" class=\"headerlink\" title=\"简洁配置：\"></a>简洁配置：</h3><p>1.maven setting.xml配置：<br>添加：</p>\n<pre><code>&lt;server&gt;\n   &lt;id&gt;my-docker-registry&lt;/id&gt;\n   &lt;username&gt;admin&lt;/username&gt;\n   &lt;password&gt;admin123&lt;/password&gt;\n   &lt;configuration&gt;\n      &lt;email&gt;932852117@qq.com&lt;/email&gt;\n   &lt;/configuration&gt;\n &lt;/server&gt;\n</code></pre><p>账号密码，是私服nexus的账号密码。</p>\n<p>2.pom.xml配置：</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2.0&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;imageName&gt;119.145.41.171:8082/ymu-micr/my-image:${project.version}&lt;/imageName&gt;\n        &lt;!-- &lt;imageName&gt;my-image:${project.version}&lt;/imageName&gt; --&gt;\n        &lt;baseImage&gt;anapsix/alpine-java&lt;/baseImage&gt;\n        &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;, &quot;/${project.build.finalName}.jar&quot;]&lt;/entryPoint&gt; \n        &lt;forceTags&gt;true&lt;/forceTags&gt;\n        &lt;!-- copy the service&apos;s jar file from target into the root directory \n            of the image --&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;targetPath&gt;/&lt;/targetPath&gt;\n                &lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n                &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n        &lt;serverId&gt;my-docker-registry&lt;/serverId&gt;\n        &lt;!-- &lt;registryUrl&gt;119.145.41.171:8082/v1/&lt;/registryUrl&gt; --&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><p>3.执行命令构建上传到nexus私服：</p>\n<pre><code>mvn clean package docker:build -DpushImage    \n</code></pre><p>构建成功后可以在私服看到docker 镜像：</p>\n<img src=\"/2018/12/27/docker-maven-nexus/a-1.png\">   \n<h3 id=\"完整配置：\"><a href=\"#完整配置：\" class=\"headerlink\" title=\"完整配置：\"></a>完整配置：</h3><pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n    &lt;artifactId&gt;docker-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.2.0&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;imageName&gt;119.145.41.171:8082/ymu-micr/my-image:${project.version}&lt;/imageName&gt;\n        &lt;!-- &lt;imageName&gt;my-image:${project.version}&lt;/imageName&gt; --&gt;\n        &lt;baseImage&gt;anapsix/alpine-java&lt;/baseImage&gt;\n        &lt;entryPoint&gt;[&quot;java&quot;, &quot;-jar&quot;, &quot;/${project.build.finalName}.jar&quot;]&lt;/entryPoint&gt; \n        &lt;forceTags&gt;true&lt;/forceTags&gt;\n        &lt;!-- copy the service&apos;s jar file from target into the root directory \n            of the image --&gt;\n        &lt;resources&gt;\n            &lt;resource&gt;\n                &lt;targetPath&gt;/&lt;/targetPath&gt;\n                &lt;directory&gt;${project.build.directory}&lt;/directory&gt;\n                &lt;include&gt;${project.build.finalName}.jar&lt;/include&gt;\n            &lt;/resource&gt;\n        &lt;/resources&gt;\n        &lt;serverId&gt;my-docker-registry&lt;/serverId&gt;\n        &lt;!-- &lt;registryUrl&gt;119.145.41.171:8082/v1/&lt;/registryUrl&gt; --&gt;\n    &lt;/configuration&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n          &lt;id&gt;build-image&lt;/id&gt;\n          &lt;phase&gt;package&lt;/phase&gt;\n          &lt;goals&gt;\n            &lt;goal&gt;build&lt;/goal&gt;\n          &lt;/goals&gt;\n        &lt;/execution&gt;\n        &lt;execution&gt;\n          &lt;id&gt;tag-image&lt;/id&gt;\n          &lt;phase&gt;package&lt;/phase&gt;\n          &lt;goals&gt;\n            &lt;goal&gt;tag&lt;/goal&gt;\n          &lt;/goals&gt;\n          &lt;configuration&gt;\n            &lt;image&gt;my-image:${project.version}&lt;/image&gt;\n            &lt;newName&gt;119.145.41.171:8082/ymu-micr/my-image:${project.version}&lt;/newName&gt;\n          &lt;/configuration&gt;\n        &lt;/execution&gt;\n        &lt;execution&gt;\n          &lt;id&gt;push-image&lt;/id&gt;\n          &lt;phase&gt;deploy&lt;/phase&gt;\n          &lt;goals&gt;\n            &lt;goal&gt;push&lt;/goal&gt;\n          &lt;/goals&gt;\n          &lt;configuration&gt;\n            &lt;imageName&gt;119.145.41.171:8082/ymu-micr/my-image:${project.version}&lt;/imageName&gt;\n          &lt;/configuration&gt;\n        &lt;/execution&gt;        \n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"title":"利用nexus搭建docker私服","date":"2018-12-26T11:31:05.000Z","_content":"\n本文介绍利用Nexus来做docker私服，来管理自己或者公司的镜像。类似于做maven私服一样……\n\n首先要安装nexus：参考章节{%post_link docker-app-install%}，docker安装nexus。  \n\n## 创建Docker仓库\n\n- 首先登录nexus3 。\n- 点击“Create repository”按钮，创建仓库。Nexus支持多种仓库类型，例如：maven、npm、docker等。本文创建一个docker仓库。一般来说，对于特定的仓库类型（例如docker），细分了三类，分别是proxy、hosted、group，含义如下：     \n  hosted，本地代理仓库，通常我们会部署自己的构件到这一类型的仓库，可以push和pull。   \n  proxy，代理的远程仓库，它们被用来代理远程的公共仓库，如maven中央仓库，只能pull。   \n  group，仓库组，用来合并多个hosted/proxy仓库，通常我们配置maven依赖仓库组，只能pull。   \n  \n- 下面创建仓库：\n\n{%asset_img a-1.png%}\n\n填写配置(注意端口号 )：\n  \n{%asset_img a-2.png%}\n\n\n## 连接仓库\n\n在其它机子或者本机，连接了仓库，才能做push、pull动作。\n\n- 首先，编辑`vim /etc/docker/daemon.json`\n\n\n    [root@api data]# cat /etc/docker/daemon.json \n    {\n      \"insecure-registries\" : [\n        \"11.148.41.11:8082\"\n      ]\n    }\n    \n`11.148.41.11:8082`：这里ip是nexus服务器的ip，端口是是上面配置的docker仓库的端口。\n\n然后重启docker引擎。\n\n- 登录\n\n\n    docker login -u admin -p admin123 ip:8082  #注意这里的端口是配置仓库时选择的端口号\n    \n_登录报错处理：_\n\n1.错误：\n\n    [root@xr-server-dev eureka-server]# docker login  -u admin -p admin123 localhost:8082\n    WARNING! Using --password via the CLI is insecure. Use --password-stdin.\n    Error response from daemon: login attempt to http://localhost:8082/v2/ failed with status: 401 Unauthorized\n\n错误处理：\n\n{%asset_img j-1.png%} \n\n再次登录：\n\n    [root@xr-server-dev eureka-server]# docker login  -u admin -p admin123 localhost:8082\n    WARNING! Using --password via the CLI is insecure. Use --password-stdin.\n    Login Succeeded\n成功        \n    \n## 上传镜像\n\n不能直接上传镜像：`docker push nginx:latest`。因为docker默认是上传到docker hub仓库的。\n\n所以要先改镜像标签：\n\n    docker tag nginx:latest ip:8082/nginx:0.1\n    \n然后上传：\n    \n    docker push ip:8082/nginx:0.1\n    \n下面成功截图：\n\n{%asset_img a-3.png%}   \n\n## 拉取镜像\n\n    docker pull ip:8082/nginx:0.1\n    \n## 搜索镜像\n\n    docker search ip:8082/nginx      \n    \n    ","source":"_posts/docker-register-nexus.md","raw":"---\ntitle: 利用nexus搭建docker私服\ndate: 2018-12-26 19:31:05\ncategories: docker\ntags:\n---\n\n本文介绍利用Nexus来做docker私服，来管理自己或者公司的镜像。类似于做maven私服一样……\n\n首先要安装nexus：参考章节{%post_link docker-app-install%}，docker安装nexus。  \n\n## 创建Docker仓库\n\n- 首先登录nexus3 。\n- 点击“Create repository”按钮，创建仓库。Nexus支持多种仓库类型，例如：maven、npm、docker等。本文创建一个docker仓库。一般来说，对于特定的仓库类型（例如docker），细分了三类，分别是proxy、hosted、group，含义如下：     \n  hosted，本地代理仓库，通常我们会部署自己的构件到这一类型的仓库，可以push和pull。   \n  proxy，代理的远程仓库，它们被用来代理远程的公共仓库，如maven中央仓库，只能pull。   \n  group，仓库组，用来合并多个hosted/proxy仓库，通常我们配置maven依赖仓库组，只能pull。   \n  \n- 下面创建仓库：\n\n{%asset_img a-1.png%}\n\n填写配置(注意端口号 )：\n  \n{%asset_img a-2.png%}\n\n\n## 连接仓库\n\n在其它机子或者本机，连接了仓库，才能做push、pull动作。\n\n- 首先，编辑`vim /etc/docker/daemon.json`\n\n\n    [root@api data]# cat /etc/docker/daemon.json \n    {\n      \"insecure-registries\" : [\n        \"11.148.41.11:8082\"\n      ]\n    }\n    \n`11.148.41.11:8082`：这里ip是nexus服务器的ip，端口是是上面配置的docker仓库的端口。\n\n然后重启docker引擎。\n\n- 登录\n\n\n    docker login -u admin -p admin123 ip:8082  #注意这里的端口是配置仓库时选择的端口号\n    \n_登录报错处理：_\n\n1.错误：\n\n    [root@xr-server-dev eureka-server]# docker login  -u admin -p admin123 localhost:8082\n    WARNING! Using --password via the CLI is insecure. Use --password-stdin.\n    Error response from daemon: login attempt to http://localhost:8082/v2/ failed with status: 401 Unauthorized\n\n错误处理：\n\n{%asset_img j-1.png%} \n\n再次登录：\n\n    [root@xr-server-dev eureka-server]# docker login  -u admin -p admin123 localhost:8082\n    WARNING! Using --password via the CLI is insecure. Use --password-stdin.\n    Login Succeeded\n成功        \n    \n## 上传镜像\n\n不能直接上传镜像：`docker push nginx:latest`。因为docker默认是上传到docker hub仓库的。\n\n所以要先改镜像标签：\n\n    docker tag nginx:latest ip:8082/nginx:0.1\n    \n然后上传：\n    \n    docker push ip:8082/nginx:0.1\n    \n下面成功截图：\n\n{%asset_img a-3.png%}   \n\n## 拉取镜像\n\n    docker pull ip:8082/nginx:0.1\n    \n## 搜索镜像\n\n    docker search ip:8082/nginx      \n    \n    ","slug":"docker-register-nexus","published":1,"updated":"2019-11-10T14:27:50.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbh002xg4va633cpy56","content":"<p>本文介绍利用Nexus来做docker私服，来管理自己或者公司的镜像。类似于做maven私服一样……</p>\n<p>首先要安装nexus：参考章节<a href=\"/2018/07/19/docker-app-install/\" title=\"docker安装各种常用开发应用软件\">docker安装各种常用开发应用软件</a>，docker安装nexus。  </p>\n<h2 id=\"创建Docker仓库\"><a href=\"#创建Docker仓库\" class=\"headerlink\" title=\"创建Docker仓库\"></a>创建Docker仓库</h2><ul>\n<li>首先登录nexus3 。</li>\n<li><p>点击“Create repository”按钮，创建仓库。Nexus支持多种仓库类型，例如：maven、npm、docker等。本文创建一个docker仓库。一般来说，对于特定的仓库类型（例如docker），细分了三类，分别是proxy、hosted、group，含义如下：<br>hosted，本地代理仓库，通常我们会部署自己的构件到这一类型的仓库，可以push和pull。<br>proxy，代理的远程仓库，它们被用来代理远程的公共仓库，如maven中央仓库，只能pull。<br>group，仓库组，用来合并多个hosted/proxy仓库，通常我们配置maven依赖仓库组，只能pull。   </p>\n</li>\n<li><p>下面创建仓库：</p>\n</li>\n</ul>\n<img src=\"/2018/12/26/docker-register-nexus/a-1.png\">\n<p>填写配置(注意端口号 )：</p>\n<img src=\"/2018/12/26/docker-register-nexus/a-2.png\">\n<h2 id=\"连接仓库\"><a href=\"#连接仓库\" class=\"headerlink\" title=\"连接仓库\"></a>连接仓库</h2><p>在其它机子或者本机，连接了仓库，才能做push、pull动作。</p>\n<ul>\n<li>首先，编辑<code>vim /etc/docker/daemon.json</code></li>\n</ul>\n<pre><code>[root@api data]# cat /etc/docker/daemon.json \n{\n  &quot;insecure-registries&quot; : [\n    &quot;11.148.41.11:8082&quot;\n  ]\n}\n</code></pre><p><code>11.148.41.11:8082</code>：这里ip是nexus服务器的ip，端口是是上面配置的docker仓库的端口。</p>\n<p>然后重启docker引擎。</p>\n<ul>\n<li>登录</li>\n</ul>\n<pre><code>docker login -u admin -p admin123 ip:8082  #注意这里的端口是配置仓库时选择的端口号\n</code></pre><p><em>登录报错处理：</em></p>\n<p>1.错误：</p>\n<pre><code>[root@xr-server-dev eureka-server]# docker login  -u admin -p admin123 localhost:8082\nWARNING! Using --password via the CLI is insecure. Use --password-stdin.\nError response from daemon: login attempt to http://localhost:8082/v2/ failed with status: 401 Unauthorized\n</code></pre><p>错误处理：</p>\n<img src=\"/2018/12/26/docker-register-nexus/j-1.png\"> \n<p>再次登录：</p>\n<pre><code>[root@xr-server-dev eureka-server]# docker login  -u admin -p admin123 localhost:8082\nWARNING! Using --password via the CLI is insecure. Use --password-stdin.\nLogin Succeeded\n</code></pre><p>成功        </p>\n<h2 id=\"上传镜像\"><a href=\"#上传镜像\" class=\"headerlink\" title=\"上传镜像\"></a>上传镜像</h2><p>不能直接上传镜像：<code>docker push nginx:latest</code>。因为docker默认是上传到docker hub仓库的。</p>\n<p>所以要先改镜像标签：</p>\n<pre><code>docker tag nginx:latest ip:8082/nginx:0.1\n</code></pre><p>然后上传：</p>\n<pre><code>docker push ip:8082/nginx:0.1\n</code></pre><p>下面成功截图：</p>\n<img src=\"/2018/12/26/docker-register-nexus/a-3.png\">   \n<h2 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h2><pre><code>docker pull ip:8082/nginx:0.1\n</code></pre><h2 id=\"搜索镜像\"><a href=\"#搜索镜像\" class=\"headerlink\" title=\"搜索镜像\"></a>搜索镜像</h2><pre><code>docker search ip:8082/nginx      \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍利用Nexus来做docker私服，来管理自己或者公司的镜像。类似于做maven私服一样……</p>\n<p>首先要安装nexus：参考章节<a href=\"/2018/07/19/docker-app-install/\" title=\"docker安装各种常用开发应用软件\">docker安装各种常用开发应用软件</a>，docker安装nexus。  </p>\n<h2 id=\"创建Docker仓库\"><a href=\"#创建Docker仓库\" class=\"headerlink\" title=\"创建Docker仓库\"></a>创建Docker仓库</h2><ul>\n<li>首先登录nexus3 。</li>\n<li><p>点击“Create repository”按钮，创建仓库。Nexus支持多种仓库类型，例如：maven、npm、docker等。本文创建一个docker仓库。一般来说，对于特定的仓库类型（例如docker），细分了三类，分别是proxy、hosted、group，含义如下：<br>hosted，本地代理仓库，通常我们会部署自己的构件到这一类型的仓库，可以push和pull。<br>proxy，代理的远程仓库，它们被用来代理远程的公共仓库，如maven中央仓库，只能pull。<br>group，仓库组，用来合并多个hosted/proxy仓库，通常我们配置maven依赖仓库组，只能pull。   </p>\n</li>\n<li><p>下面创建仓库：</p>\n</li>\n</ul>\n<img src=\"/2018/12/26/docker-register-nexus/a-1.png\">\n<p>填写配置(注意端口号 )：</p>\n<img src=\"/2018/12/26/docker-register-nexus/a-2.png\">\n<h2 id=\"连接仓库\"><a href=\"#连接仓库\" class=\"headerlink\" title=\"连接仓库\"></a>连接仓库</h2><p>在其它机子或者本机，连接了仓库，才能做push、pull动作。</p>\n<ul>\n<li>首先，编辑<code>vim /etc/docker/daemon.json</code></li>\n</ul>\n<pre><code>[root@api data]# cat /etc/docker/daemon.json \n{\n  &quot;insecure-registries&quot; : [\n    &quot;11.148.41.11:8082&quot;\n  ]\n}\n</code></pre><p><code>11.148.41.11:8082</code>：这里ip是nexus服务器的ip，端口是是上面配置的docker仓库的端口。</p>\n<p>然后重启docker引擎。</p>\n<ul>\n<li>登录</li>\n</ul>\n<pre><code>docker login -u admin -p admin123 ip:8082  #注意这里的端口是配置仓库时选择的端口号\n</code></pre><p><em>登录报错处理：</em></p>\n<p>1.错误：</p>\n<pre><code>[root@xr-server-dev eureka-server]# docker login  -u admin -p admin123 localhost:8082\nWARNING! Using --password via the CLI is insecure. Use --password-stdin.\nError response from daemon: login attempt to http://localhost:8082/v2/ failed with status: 401 Unauthorized\n</code></pre><p>错误处理：</p>\n<img src=\"/2018/12/26/docker-register-nexus/j-1.png\"> \n<p>再次登录：</p>\n<pre><code>[root@xr-server-dev eureka-server]# docker login  -u admin -p admin123 localhost:8082\nWARNING! Using --password via the CLI is insecure. Use --password-stdin.\nLogin Succeeded\n</code></pre><p>成功        </p>\n<h2 id=\"上传镜像\"><a href=\"#上传镜像\" class=\"headerlink\" title=\"上传镜像\"></a>上传镜像</h2><p>不能直接上传镜像：<code>docker push nginx:latest</code>。因为docker默认是上传到docker hub仓库的。</p>\n<p>所以要先改镜像标签：</p>\n<pre><code>docker tag nginx:latest ip:8082/nginx:0.1\n</code></pre><p>然后上传：</p>\n<pre><code>docker push ip:8082/nginx:0.1\n</code></pre><p>下面成功截图：</p>\n<img src=\"/2018/12/26/docker-register-nexus/a-3.png\">   \n<h2 id=\"拉取镜像\"><a href=\"#拉取镜像\" class=\"headerlink\" title=\"拉取镜像\"></a>拉取镜像</h2><pre><code>docker pull ip:8082/nginx:0.1\n</code></pre><h2 id=\"搜索镜像\"><a href=\"#搜索镜像\" class=\"headerlink\" title=\"搜索镜像\"></a>搜索镜像</h2><pre><code>docker search ip:8082/nginx      \n</code></pre>"},{"title":"pdf电子签名探索","date":"2019-05-16T07:28:35.000Z","_content":"\n现代很多的信息系统中，都涉及到电子合同。电子合同签章的方案市面上都已经很成熟，购买一些服务就可以用了。但是，他们都是怎么实现的呢。带着这些好奇，通过各种百度、谷歌，我们就来探索下，如果要自己来实现，要怎么做……\n\n## 如何做个人、企业实名认证呢\n\n实名认证很重要，是签章的基础，提供真实的签章者身份信息。    \n实名认证后，就可以根据实名信息生产电子章信息了。    \n\n## 如何拿到CA证书呢\n\n## 如何制作电子章图片呢\n\n## 如何根据模板动态生产pdf文件呢\n\n## 如何把有效的电子章加签到pdf文件呢\n\n参考： \n\nhttps://blog.csdn.net/goodlook0123/article/details/81121351 \n\nhttps://blog.csdn.net/do_bset_yourself/article/details/78171897?locationNum=8&fps=1 \n\nhttps://blog.csdn.net/javasun608/article/details/79307845\n\nhttps://blog.csdn.net/do_bset_yourself/article/details/78156161\n\n","source":"_posts/esign-bao-copy.md","raw":"---\ntitle: pdf电子签名探索\ndate: 2019-05-16 15:28:35\ncategories:\ntags:\n---\n\n现代很多的信息系统中，都涉及到电子合同。电子合同签章的方案市面上都已经很成熟，购买一些服务就可以用了。但是，他们都是怎么实现的呢。带着这些好奇，通过各种百度、谷歌，我们就来探索下，如果要自己来实现，要怎么做……\n\n## 如何做个人、企业实名认证呢\n\n实名认证很重要，是签章的基础，提供真实的签章者身份信息。    \n实名认证后，就可以根据实名信息生产电子章信息了。    \n\n## 如何拿到CA证书呢\n\n## 如何制作电子章图片呢\n\n## 如何根据模板动态生产pdf文件呢\n\n## 如何把有效的电子章加签到pdf文件呢\n\n参考： \n\nhttps://blog.csdn.net/goodlook0123/article/details/81121351 \n\nhttps://blog.csdn.net/do_bset_yourself/article/details/78171897?locationNum=8&fps=1 \n\nhttps://blog.csdn.net/javasun608/article/details/79307845\n\nhttps://blog.csdn.net/do_bset_yourself/article/details/78156161\n\n","slug":"esign-bao-copy","published":1,"updated":"2019-06-16T14:38:33.357Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbj0031g4vadzorq0zk","content":"<p>现代很多的信息系统中，都涉及到电子合同。电子合同签章的方案市面上都已经很成熟，购买一些服务就可以用了。但是，他们都是怎么实现的呢。带着这些好奇，通过各种百度、谷歌，我们就来探索下，如果要自己来实现，要怎么做……</p>\n<h2 id=\"如何做个人、企业实名认证呢\"><a href=\"#如何做个人、企业实名认证呢\" class=\"headerlink\" title=\"如何做个人、企业实名认证呢\"></a>如何做个人、企业实名认证呢</h2><p>实名认证很重要，是签章的基础，提供真实的签章者身份信息。<br>实名认证后，就可以根据实名信息生产电子章信息了。    </p>\n<h2 id=\"如何拿到CA证书呢\"><a href=\"#如何拿到CA证书呢\" class=\"headerlink\" title=\"如何拿到CA证书呢\"></a>如何拿到CA证书呢</h2><h2 id=\"如何制作电子章图片呢\"><a href=\"#如何制作电子章图片呢\" class=\"headerlink\" title=\"如何制作电子章图片呢\"></a>如何制作电子章图片呢</h2><h2 id=\"如何根据模板动态生产pdf文件呢\"><a href=\"#如何根据模板动态生产pdf文件呢\" class=\"headerlink\" title=\"如何根据模板动态生产pdf文件呢\"></a>如何根据模板动态生产pdf文件呢</h2><h2 id=\"如何把有效的电子章加签到pdf文件呢\"><a href=\"#如何把有效的电子章加签到pdf文件呢\" class=\"headerlink\" title=\"如何把有效的电子章加签到pdf文件呢\"></a>如何把有效的电子章加签到pdf文件呢</h2><p>参考： </p>\n<p><a href=\"https://blog.csdn.net/goodlook0123/article/details/81121351\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/goodlook0123/article/details/81121351</a> </p>\n<p><a href=\"https://blog.csdn.net/do_bset_yourself/article/details/78171897?locationNum=8&amp;fps=1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/do_bset_yourself/article/details/78171897?locationNum=8&amp;fps=1</a> </p>\n<p><a href=\"https://blog.csdn.net/javasun608/article/details/79307845\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/javasun608/article/details/79307845</a></p>\n<p><a href=\"https://blog.csdn.net/do_bset_yourself/article/details/78156161\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/do_bset_yourself/article/details/78156161</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>现代很多的信息系统中，都涉及到电子合同。电子合同签章的方案市面上都已经很成熟，购买一些服务就可以用了。但是，他们都是怎么实现的呢。带着这些好奇，通过各种百度、谷歌，我们就来探索下，如果要自己来实现，要怎么做……</p>\n<h2 id=\"如何做个人、企业实名认证呢\"><a href=\"#如何做个人、企业实名认证呢\" class=\"headerlink\" title=\"如何做个人、企业实名认证呢\"></a>如何做个人、企业实名认证呢</h2><p>实名认证很重要，是签章的基础，提供真实的签章者身份信息。<br>实名认证后，就可以根据实名信息生产电子章信息了。    </p>\n<h2 id=\"如何拿到CA证书呢\"><a href=\"#如何拿到CA证书呢\" class=\"headerlink\" title=\"如何拿到CA证书呢\"></a>如何拿到CA证书呢</h2><h2 id=\"如何制作电子章图片呢\"><a href=\"#如何制作电子章图片呢\" class=\"headerlink\" title=\"如何制作电子章图片呢\"></a>如何制作电子章图片呢</h2><h2 id=\"如何根据模板动态生产pdf文件呢\"><a href=\"#如何根据模板动态生产pdf文件呢\" class=\"headerlink\" title=\"如何根据模板动态生产pdf文件呢\"></a>如何根据模板动态生产pdf文件呢</h2><h2 id=\"如何把有效的电子章加签到pdf文件呢\"><a href=\"#如何把有效的电子章加签到pdf文件呢\" class=\"headerlink\" title=\"如何把有效的电子章加签到pdf文件呢\"></a>如何把有效的电子章加签到pdf文件呢</h2><p>参考： </p>\n<p><a href=\"https://blog.csdn.net/goodlook0123/article/details/81121351\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/goodlook0123/article/details/81121351</a> </p>\n<p><a href=\"https://blog.csdn.net/do_bset_yourself/article/details/78171897?locationNum=8&amp;fps=1\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/do_bset_yourself/article/details/78171897?locationNum=8&amp;fps=1</a> </p>\n<p><a href=\"https://blog.csdn.net/javasun608/article/details/79307845\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/javasun608/article/details/79307845</a></p>\n<p><a href=\"https://blog.csdn.net/do_bset_yourself/article/details/78156161\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/do_bset_yourself/article/details/78156161</a></p>\n"},{"title":"fastdfs-分布式文件系统安装使用","date":"2018-02-01T02:51:36.000Z","_content":"\n本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……\n\n网址：https://github.com/happyfish100/fastdfs\n\n参考：\nhttp://blog.csdn.net/xyang81/article/details/52837974\nhttp://blog.csdn.net/playadota/article/details/78381109\n\n## centos下搭建\n\n### 第一步：安装依赖\n安装fastdfs之前，先要安装相关依赖包libfastcommon。 \n\n下载地址：https://github.com/happyfish100/libfastcommon.git\n\n`git clone https://github.com/happyfish100/libfastcommon.git`\n\n编译安装：\n\n    > cd libfastcommon\n    > ./make.sh\n    > ./make.sh install\n\n### 第二部：安装fastdfs\n下载：https://github.com/happyfish100/fastdfs\n\n- step 2. download FastDFS source package and unpack it, \ntar xzf FastDFS_v5.x.tar.gz\n\n- step 3. enter the FastDFS dir\n\n    `cd FastDFS`\n\n- step 4. execute:\n\n    `./make.sh`\n\n- step 5. make install\n\n    ./make.sh install`\n\n- step 6. edit/modify the config file of tracker and storage\n\n\n    cd /etc/fdfs/\n    cp tracker.conf.sample tracker.conf\n    cp storage.conf.sample storage.conf\n    mkdir -p /server/data/fdfs\n\n首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。\n\nbase_path=/server/data/fdfs/tracker  \n\n启动：\n    \n    #start the tracker server:\n    /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n    #in Linux, you can start fdfs_trackerd as a service:\n    /sbin/service fdfs_trackerd start \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_trackerd `    \n    \n设置tracker服务开启启动：\n    \n\n--------------\n修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。\n\n        # the base path to store data and log files\n        base_path=/server/data/fdfs/storeage\n        # tracker_server can ocur more than once, and tracker_server format is\n        #  \"host:port\", host can be hostname or ip address\n        tracker_server=192.168.1.36:22122\n        # store_path#, based 0, if store_path0 not exists, it's value is base_path\n        # the paths must be exist\n        store_path0=/server/data/fdfs/storeage\n        #store_path1=/home/yuqing/fastdfs2\n        \n启动：\n    \n    #start the storage server:\n    /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n    #in Linux, you can start fdfs_storaged as a service:\n    /sbin/service fdfs_storaged start  \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_storaged `  \n    \n停止:\n\n    `/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n    \n设置storage服务开机启动  \n\n停止：\n\n`/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop`       \n\n……\n\n## 测试\n更改`/etc/fdfs/下client.conf配置文件。\n\n`base_path=~/dev/fastdfs/data/client`   \n`tracker_server=192.168.147` _不能是`localhost`或者`127.0.0.1`_\n\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \n    This is FastDFS client test program v5.08\n    \n    Copyright (C) 2008, Happy Fish / YuQing\n    \n    FastDFS may be copied only under the terms of the GNU General\n    Public License V3, which may be found in the FastDFS source kit.\n    Please visit the FastDFS Home Page http://www.csource.org/ \n    for more detail.\n    \n    [2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n    \n    tracker_query_storage_store_list_without_group: \n    \tserver 1. group_name=, ip_addr=192.168.1.146, port=23000\n    \n    group_name=group1, ip_addr=192.168.1.146, port=23000\n    storage_upload_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    storage_upload_slave_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n    ####\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \n    group1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ cd\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \n    group1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n    \n\n## ubuntu下搭建\n\n验证过，上面过程适用…… \n\n## 集成nginx模块\n\n参考：https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\n\n1.下载`fastdfs-nginx-module`\n\n`git clone https://github.com/happyfish100/fastdfs-nginx-module.git`\n\n注意：安装的FastDFS版本 >= 5.11\n\n2.安装nginx-1.8.1\n\n下载：http://nginx.org/en/download.html\n\n    > ./configure --prefix=~/nginx \\\n     --add-module=/home/mutian/fastdfs-nginx-module/src\n    \n    > make; make install\n    \n3.更改nginx配置，添加一行。\n\n如果文件分组  \n        \n    location ~/group([0-9])/M00 {\n    \n        ngx_fastdfs_module;\n    \n    }\n\n如果没分组\n\n    location /M00 {\n        root /home/mutian/dev/fastdfs/data/storage/data;\n        ngx_fastdfs_module;\n    }\n    \n> 注意：\n A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。\n B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:\n location ~/group([0-9])/M00 {\n     ngx_fastdfs_module;\n }\n    \n    \n4.拷贝fdfs_storage的文件存储软链接\n\n`ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00`          \n\n5.更改配置`mod_fastdfs.conf`\n\n拷贝到相关目录：\n\n    cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n    \n更改内容：\n\n    connect_timeout=10\n    base_path=/tmp\n    tracker_server=ip01:22122\n    storage_server_port=23000\n    group_name=group1\n    url_have_group_name = true\n    store_path0=/home/mutian/dev/fastdfs/data/storage      \n    \n6.复制FastDFS 的部分配置文件到`/etc/fdfs`目录\n\n    mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\n    mutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\n    anti-steal.jpg  http.conf   storage.conf      tracker.conf\n    client.conf     mime.types  storage_ids.conf\n\n    cp http.conf mime.types /etc/fdfs/   \n    \n7.启动nginx\n\n`~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx` \n\n8.测试\n按上面步骤，上传个文件，然后在浏览器打开：\n\nhttp://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png \n\nor \n\nhttp://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png          ","source":"_posts/fastdfs-start.md","raw":"---\ntitle: fastdfs-分布式文件系统安装使用\ndate: 2018-02-01 10:51:36\ncategories: 文件存储系统\ntags: \n---\n\n本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……\n\n网址：https://github.com/happyfish100/fastdfs\n\n参考：\nhttp://blog.csdn.net/xyang81/article/details/52837974\nhttp://blog.csdn.net/playadota/article/details/78381109\n\n## centos下搭建\n\n### 第一步：安装依赖\n安装fastdfs之前，先要安装相关依赖包libfastcommon。 \n\n下载地址：https://github.com/happyfish100/libfastcommon.git\n\n`git clone https://github.com/happyfish100/libfastcommon.git`\n\n编译安装：\n\n    > cd libfastcommon\n    > ./make.sh\n    > ./make.sh install\n\n### 第二部：安装fastdfs\n下载：https://github.com/happyfish100/fastdfs\n\n- step 2. download FastDFS source package and unpack it, \ntar xzf FastDFS_v5.x.tar.gz\n\n- step 3. enter the FastDFS dir\n\n    `cd FastDFS`\n\n- step 4. execute:\n\n    `./make.sh`\n\n- step 5. make install\n\n    ./make.sh install`\n\n- step 6. edit/modify the config file of tracker and storage\n\n\n    cd /etc/fdfs/\n    cp tracker.conf.sample tracker.conf\n    cp storage.conf.sample storage.conf\n    mkdir -p /server/data/fdfs\n\n首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。\n\nbase_path=/server/data/fdfs/tracker  \n\n启动：\n    \n    #start the tracker server:\n    /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n    #in Linux, you can start fdfs_trackerd as a service:\n    /sbin/service fdfs_trackerd start \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_trackerd `    \n    \n设置tracker服务开启启动：\n    \n\n--------------\n修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。\n\n        # the base path to store data and log files\n        base_path=/server/data/fdfs/storeage\n        # tracker_server can ocur more than once, and tracker_server format is\n        #  \"host:port\", host can be hostname or ip address\n        tracker_server=192.168.1.36:22122\n        # store_path#, based 0, if store_path0 not exists, it's value is base_path\n        # the paths must be exist\n        store_path0=/server/data/fdfs/storeage\n        #store_path1=/home/yuqing/fastdfs2\n        \n启动：\n    \n    #start the storage server:\n    /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n    #in Linux, you can start fdfs_storaged as a service:\n    /sbin/service fdfs_storaged start  \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_storaged `  \n    \n停止:\n\n    `/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n    \n设置storage服务开机启动  \n\n停止：\n\n`/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop`       \n\n……\n\n## 测试\n更改`/etc/fdfs/下client.conf配置文件。\n\n`base_path=~/dev/fastdfs/data/client`   \n`tracker_server=192.168.147` _不能是`localhost`或者`127.0.0.1`_\n\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \n    This is FastDFS client test program v5.08\n    \n    Copyright (C) 2008, Happy Fish / YuQing\n    \n    FastDFS may be copied only under the terms of the GNU General\n    Public License V3, which may be found in the FastDFS source kit.\n    Please visit the FastDFS Home Page http://www.csource.org/ \n    for more detail.\n    \n    [2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n    \n    tracker_query_storage_store_list_without_group: \n    \tserver 1. group_name=, ip_addr=192.168.1.146, port=23000\n    \n    group_name=group1, ip_addr=192.168.1.146, port=23000\n    storage_upload_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    storage_upload_slave_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n    ####\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \n    group1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ cd\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \n    group1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n    \n\n## ubuntu下搭建\n\n验证过，上面过程适用…… \n\n## 集成nginx模块\n\n参考：https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\n\n1.下载`fastdfs-nginx-module`\n\n`git clone https://github.com/happyfish100/fastdfs-nginx-module.git`\n\n注意：安装的FastDFS版本 >= 5.11\n\n2.安装nginx-1.8.1\n\n下载：http://nginx.org/en/download.html\n\n    > ./configure --prefix=~/nginx \\\n     --add-module=/home/mutian/fastdfs-nginx-module/src\n    \n    > make; make install\n    \n3.更改nginx配置，添加一行。\n\n如果文件分组  \n        \n    location ~/group([0-9])/M00 {\n    \n        ngx_fastdfs_module;\n    \n    }\n\n如果没分组\n\n    location /M00 {\n        root /home/mutian/dev/fastdfs/data/storage/data;\n        ngx_fastdfs_module;\n    }\n    \n> 注意：\n A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。\n B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:\n location ~/group([0-9])/M00 {\n     ngx_fastdfs_module;\n }\n    \n    \n4.拷贝fdfs_storage的文件存储软链接\n\n`ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00`          \n\n5.更改配置`mod_fastdfs.conf`\n\n拷贝到相关目录：\n\n    cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n    \n更改内容：\n\n    connect_timeout=10\n    base_path=/tmp\n    tracker_server=ip01:22122\n    storage_server_port=23000\n    group_name=group1\n    url_have_group_name = true\n    store_path0=/home/mutian/dev/fastdfs/data/storage      \n    \n6.复制FastDFS 的部分配置文件到`/etc/fdfs`目录\n\n    mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\n    mutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\n    anti-steal.jpg  http.conf   storage.conf      tracker.conf\n    client.conf     mime.types  storage_ids.conf\n\n    cp http.conf mime.types /etc/fdfs/   \n    \n7.启动nginx\n\n`~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx` \n\n8.测试\n按上面步骤，上传个文件，然后在浏览器打开：\n\nhttp://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png \n\nor \n\nhttp://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png          ","slug":"fastdfs-start","published":1,"updated":"2019-06-16T14:38:33.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbk0033g4vafl0mi3ah","content":"<p>本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……</p>\n<p>网址：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xyang81/article/details/52837974\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xyang81/article/details/52837974</a><br><a href=\"http://blog.csdn.net/playadota/article/details/78381109\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/playadota/article/details/78381109</a></p>\n<h2 id=\"centos下搭建\"><a href=\"#centos下搭建\" class=\"headerlink\" title=\"centos下搭建\"></a>centos下搭建</h2><h3 id=\"第一步：安装依赖\"><a href=\"#第一步：安装依赖\" class=\"headerlink\" title=\"第一步：安装依赖\"></a>第一步：安装依赖</h3><p>安装fastdfs之前，先要安装相关依赖包libfastcommon。 </p>\n<p>下载地址：<a href=\"https://github.com/happyfish100/libfastcommon.git\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/libfastcommon.git</a></p>\n<p><code>git clone https://github.com/happyfish100/libfastcommon.git</code></p>\n<p>编译安装：</p>\n<pre><code>&gt; cd libfastcommon\n&gt; ./make.sh\n&gt; ./make.sh install\n</code></pre><h3 id=\"第二部：安装fastdfs\"><a href=\"#第二部：安装fastdfs\" class=\"headerlink\" title=\"第二部：安装fastdfs\"></a>第二部：安装fastdfs</h3><p>下载：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<ul>\n<li><p>step 2. download FastDFS source package and unpack it,<br>tar xzf FastDFS_v5.x.tar.gz</p>\n</li>\n<li><p>step 3. enter the FastDFS dir</p>\n<p>  <code>cd FastDFS</code></p>\n</li>\n<li><p>step 4. execute:</p>\n<p>  <code>./make.sh</code></p>\n</li>\n<li><p>step 5. make install</p>\n<p>  ./make.sh install`</p>\n</li>\n<li><p>step 6. edit/modify the config file of tracker and storage</p>\n</li>\n</ul>\n<pre><code>cd /etc/fdfs/\ncp tracker.conf.sample tracker.conf\ncp storage.conf.sample storage.conf\nmkdir -p /server/data/fdfs\n</code></pre><p>首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。</p>\n<p>base_path=/server/data/fdfs/tracker  </p>\n<p>启动：</p>\n<pre><code>#start the tracker server:\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n#in Linux, you can start fdfs_trackerd as a service:\n/sbin/service fdfs_trackerd start \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_trackerd</code>    </p>\n<p>设置tracker服务开启启动：</p>\n<hr>\n<p>修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。</p>\n<pre><code># the base path to store data and log files\nbase_path=/server/data/fdfs/storeage\n# tracker_server can ocur more than once, and tracker_server format is\n#  &quot;host:port&quot;, host can be hostname or ip address\ntracker_server=192.168.1.36:22122\n# store_path#, based 0, if store_path0 not exists, it&apos;s value is base_path\n# the paths must be exist\nstore_path0=/server/data/fdfs/storeage\n#store_path1=/home/yuqing/fastdfs2\n</code></pre><p>启动：</p>\n<pre><code>#start the storage server:\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n#in Linux, you can start fdfs_storaged as a service:\n/sbin/service fdfs_storaged start  \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_storaged</code>  </p>\n<p>停止:</p>\n<pre><code>`/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n</code></pre><p>设置storage服务开机启动  </p>\n<p>停止：</p>\n<p><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop</code>       </p>\n<p>……</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更改`/etc/fdfs/下client.conf配置文件。</p>\n<p><code>base_path=~/dev/fastdfs/data/client</code><br><code>tracker_server=192.168.147</code> <em>不能是<code>localhost</code>或者<code>127.0.0.1</code></em></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \nThis is FastDFS client test program v5.08\n\nCopyright (C) 2008, Happy Fish / YuQing\n\nFastDFS may be copied only under the terms of the GNU General\nPublic License V3, which may be found in the FastDFS source kit.\nPlease visit the FastDFS Home Page http://www.csource.org/ \nfor more detail.\n\n[2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n\ntracker_query_storage_store_list_without_group: \n    server 1. group_name=, ip_addr=192.168.1.146, port=23000\n\ngroup_name=group1, ip_addr=192.168.1.146, port=23000\nstorage_upload_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nstorage_upload_slave_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nmutian@mutian-ThinkPad-T440p:~$ \n\n####\nmutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \ngroup1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\nmutian@mutian-ThinkPad-T440p:~/Pictures$ cd\nmutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \ngroup1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n</code></pre><h2 id=\"ubuntu下搭建\"><a href=\"#ubuntu下搭建\" class=\"headerlink\" title=\"ubuntu下搭建\"></a>ubuntu下搭建</h2><p>验证过，上面过程适用…… </p>\n<h2 id=\"集成nginx模块\"><a href=\"#集成nginx模块\" class=\"headerlink\" title=\"集成nginx模块\"></a>集成nginx模块</h2><p>参考：<a href=\"https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL</a></p>\n<p>1.下载<code>fastdfs-nginx-module</code></p>\n<p><code>git clone https://github.com/happyfish100/fastdfs-nginx-module.git</code></p>\n<p>注意：安装的FastDFS版本 &gt;= 5.11</p>\n<p>2.安装nginx-1.8.1</p>\n<p>下载：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a></p>\n<pre><code>&gt; ./configure --prefix=~/nginx \\\n --add-module=/home/mutian/fastdfs-nginx-module/src\n\n&gt; make; make install\n</code></pre><p>3.更改nginx配置，添加一行。</p>\n<p>如果文件分组  </p>\n<pre><code>location ~/group([0-9])/M00 {\n\n    ngx_fastdfs_module;\n\n}\n</code></pre><p>如果没分组</p>\n<pre><code>location /M00 {\n    root /home/mutian/dev/fastdfs/data/storage/data;\n    ngx_fastdfs_module;\n}\n</code></pre><blockquote>\n<p>注意：<br> A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。<br> B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:<br> location ~/group([0-9])/M00 {<br>     ngx_fastdfs_module;<br> }</p>\n</blockquote>\n<p>4.拷贝fdfs_storage的文件存储软链接</p>\n<p><code>ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00</code>          </p>\n<p>5.更改配置<code>mod_fastdfs.conf</code></p>\n<p>拷贝到相关目录：</p>\n<pre><code>cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n</code></pre><p>更改内容：</p>\n<pre><code>connect_timeout=10\nbase_path=/tmp\ntracker_server=ip01:22122\nstorage_server_port=23000\ngroup_name=group1\nurl_have_group_name = true\nstore_path0=/home/mutian/dev/fastdfs/data/storage      \n</code></pre><p>6.复制FastDFS 的部分配置文件到<code>/etc/fdfs</code>目录</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\nmutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\nanti-steal.jpg  http.conf   storage.conf      tracker.conf\nclient.conf     mime.types  storage_ids.conf\n\ncp http.conf mime.types /etc/fdfs/   \n</code></pre><p>7.启动nginx</p>\n<p><code>~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx</code> </p>\n<p>8.测试<br>按上面步骤，上传个文件，然后在浏览器打开：</p>\n<p><a href=\"http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a> </p>\n<p>or </p>\n<p><a href=\"http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a>          </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……</p>\n<p>网址：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xyang81/article/details/52837974\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xyang81/article/details/52837974</a><br><a href=\"http://blog.csdn.net/playadota/article/details/78381109\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/playadota/article/details/78381109</a></p>\n<h2 id=\"centos下搭建\"><a href=\"#centos下搭建\" class=\"headerlink\" title=\"centos下搭建\"></a>centos下搭建</h2><h3 id=\"第一步：安装依赖\"><a href=\"#第一步：安装依赖\" class=\"headerlink\" title=\"第一步：安装依赖\"></a>第一步：安装依赖</h3><p>安装fastdfs之前，先要安装相关依赖包libfastcommon。 </p>\n<p>下载地址：<a href=\"https://github.com/happyfish100/libfastcommon.git\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/libfastcommon.git</a></p>\n<p><code>git clone https://github.com/happyfish100/libfastcommon.git</code></p>\n<p>编译安装：</p>\n<pre><code>&gt; cd libfastcommon\n&gt; ./make.sh\n&gt; ./make.sh install\n</code></pre><h3 id=\"第二部：安装fastdfs\"><a href=\"#第二部：安装fastdfs\" class=\"headerlink\" title=\"第二部：安装fastdfs\"></a>第二部：安装fastdfs</h3><p>下载：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<ul>\n<li><p>step 2. download FastDFS source package and unpack it,<br>tar xzf FastDFS_v5.x.tar.gz</p>\n</li>\n<li><p>step 3. enter the FastDFS dir</p>\n<p>  <code>cd FastDFS</code></p>\n</li>\n<li><p>step 4. execute:</p>\n<p>  <code>./make.sh</code></p>\n</li>\n<li><p>step 5. make install</p>\n<p>  ./make.sh install`</p>\n</li>\n<li><p>step 6. edit/modify the config file of tracker and storage</p>\n</li>\n</ul>\n<pre><code>cd /etc/fdfs/\ncp tracker.conf.sample tracker.conf\ncp storage.conf.sample storage.conf\nmkdir -p /server/data/fdfs\n</code></pre><p>首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。</p>\n<p>base_path=/server/data/fdfs/tracker  </p>\n<p>启动：</p>\n<pre><code>#start the tracker server:\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n#in Linux, you can start fdfs_trackerd as a service:\n/sbin/service fdfs_trackerd start \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_trackerd</code>    </p>\n<p>设置tracker服务开启启动：</p>\n<hr>\n<p>修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。</p>\n<pre><code># the base path to store data and log files\nbase_path=/server/data/fdfs/storeage\n# tracker_server can ocur more than once, and tracker_server format is\n#  &quot;host:port&quot;, host can be hostname or ip address\ntracker_server=192.168.1.36:22122\n# store_path#, based 0, if store_path0 not exists, it&apos;s value is base_path\n# the paths must be exist\nstore_path0=/server/data/fdfs/storeage\n#store_path1=/home/yuqing/fastdfs2\n</code></pre><p>启动：</p>\n<pre><code>#start the storage server:\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n#in Linux, you can start fdfs_storaged as a service:\n/sbin/service fdfs_storaged start  \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_storaged</code>  </p>\n<p>停止:</p>\n<pre><code>`/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n</code></pre><p>设置storage服务开机启动  </p>\n<p>停止：</p>\n<p><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop</code>       </p>\n<p>……</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更改`/etc/fdfs/下client.conf配置文件。</p>\n<p><code>base_path=~/dev/fastdfs/data/client</code><br><code>tracker_server=192.168.147</code> <em>不能是<code>localhost</code>或者<code>127.0.0.1</code></em></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \nThis is FastDFS client test program v5.08\n\nCopyright (C) 2008, Happy Fish / YuQing\n\nFastDFS may be copied only under the terms of the GNU General\nPublic License V3, which may be found in the FastDFS source kit.\nPlease visit the FastDFS Home Page http://www.csource.org/ \nfor more detail.\n\n[2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n\ntracker_query_storage_store_list_without_group: \n    server 1. group_name=, ip_addr=192.168.1.146, port=23000\n\ngroup_name=group1, ip_addr=192.168.1.146, port=23000\nstorage_upload_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nstorage_upload_slave_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nmutian@mutian-ThinkPad-T440p:~$ \n\n####\nmutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \ngroup1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\nmutian@mutian-ThinkPad-T440p:~/Pictures$ cd\nmutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \ngroup1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n</code></pre><h2 id=\"ubuntu下搭建\"><a href=\"#ubuntu下搭建\" class=\"headerlink\" title=\"ubuntu下搭建\"></a>ubuntu下搭建</h2><p>验证过，上面过程适用…… </p>\n<h2 id=\"集成nginx模块\"><a href=\"#集成nginx模块\" class=\"headerlink\" title=\"集成nginx模块\"></a>集成nginx模块</h2><p>参考：<a href=\"https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL</a></p>\n<p>1.下载<code>fastdfs-nginx-module</code></p>\n<p><code>git clone https://github.com/happyfish100/fastdfs-nginx-module.git</code></p>\n<p>注意：安装的FastDFS版本 &gt;= 5.11</p>\n<p>2.安装nginx-1.8.1</p>\n<p>下载：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a></p>\n<pre><code>&gt; ./configure --prefix=~/nginx \\\n --add-module=/home/mutian/fastdfs-nginx-module/src\n\n&gt; make; make install\n</code></pre><p>3.更改nginx配置，添加一行。</p>\n<p>如果文件分组  </p>\n<pre><code>location ~/group([0-9])/M00 {\n\n    ngx_fastdfs_module;\n\n}\n</code></pre><p>如果没分组</p>\n<pre><code>location /M00 {\n    root /home/mutian/dev/fastdfs/data/storage/data;\n    ngx_fastdfs_module;\n}\n</code></pre><blockquote>\n<p>注意：<br> A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。<br> B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:<br> location ~/group([0-9])/M00 {<br>     ngx_fastdfs_module;<br> }</p>\n</blockquote>\n<p>4.拷贝fdfs_storage的文件存储软链接</p>\n<p><code>ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00</code>          </p>\n<p>5.更改配置<code>mod_fastdfs.conf</code></p>\n<p>拷贝到相关目录：</p>\n<pre><code>cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n</code></pre><p>更改内容：</p>\n<pre><code>connect_timeout=10\nbase_path=/tmp\ntracker_server=ip01:22122\nstorage_server_port=23000\ngroup_name=group1\nurl_have_group_name = true\nstore_path0=/home/mutian/dev/fastdfs/data/storage      \n</code></pre><p>6.复制FastDFS 的部分配置文件到<code>/etc/fdfs</code>目录</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\nmutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\nanti-steal.jpg  http.conf   storage.conf      tracker.conf\nclient.conf     mime.types  storage_ids.conf\n\ncp http.conf mime.types /etc/fdfs/   \n</code></pre><p>7.启动nginx</p>\n<p><code>~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx</code> </p>\n<p>8.测试<br>按上面步骤，上传个文件，然后在浏览器打开：</p>\n<p><a href=\"http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a> </p>\n<p>or </p>\n<p><a href=\"http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a>          </p>\n"},{"title":"分布式事务fescar入门","date":"2019-03-19T06:58:52.000Z","_content":"","source":"_posts/fescar-start.md","raw":"---\ntitle: 分布式事务fescar入门\ndate: 2019-03-19 14:58:52\ncategories: 分布式系统\ntags:\n---\n","slug":"fescar-start","published":1,"updated":"2019-06-16T14:38:33.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbl0036g4vazss5u9cs","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"flutter环境安装","date":"2019-01-26T03:03:12.000Z","_content":"\n## windows环境\n\n","source":"_posts/flutter-start.md","raw":"---\ntitle: flutter环境安装\ndate: 2019-01-26 11:03:12\ncategories: flutter\ntags:\n---\n\n## windows环境\n\n","slug":"flutter-start","published":1,"updated":"2019-06-16T14:38:33.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbn0039g4vaav5gbsls","content":"<h2 id=\"windows环境\"><a href=\"#windows环境\" class=\"headerlink\" title=\"windows环境\"></a>windows环境</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"windows环境\"><a href=\"#windows环境\" class=\"headerlink\" title=\"windows环境\"></a>windows环境</h2>"},{"title":"ftp入门","date":"2018-12-27T01:30:53.000Z","_content":"\n## CentOs7下搭建ftp服务器\n\n### 方式一：docker下安装\n\n1.拉取镜像：\n\n    docker pull fauria/vsftpd\n    \n2.启动容器：\n\n    docker run -d -v /dockers/vsftpd:/home/vsftpd \\\n    -p 20:20 -p 21:21 -p 21100-21110:21100-21110 \\\n    -e FTP_USER=admin -e FTP_PASS=123456 \\\n    -e PASV_ADDRESS=127.0.0.1 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 \\\n    --name vsftpd --restart=always fauria/vsftpd   \n    \n    ------------------------------------\n    docker logs vsftpd","source":"_posts/ftp-start.md","raw":"---\ntitle: ftp入门\ndate: 2018-12-27 09:30:53\ncategories: 文件存储系统\ntags:\n---\n\n## CentOs7下搭建ftp服务器\n\n### 方式一：docker下安装\n\n1.拉取镜像：\n\n    docker pull fauria/vsftpd\n    \n2.启动容器：\n\n    docker run -d -v /dockers/vsftpd:/home/vsftpd \\\n    -p 20:20 -p 21:21 -p 21100-21110:21100-21110 \\\n    -e FTP_USER=admin -e FTP_PASS=123456 \\\n    -e PASV_ADDRESS=127.0.0.1 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 \\\n    --name vsftpd --restart=always fauria/vsftpd   \n    \n    ------------------------------------\n    docker logs vsftpd","slug":"ftp-start","published":1,"updated":"2019-06-16T14:38:33.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbo003cg4valloa58j1","content":"<h2 id=\"CentOs7下搭建ftp服务器\"><a href=\"#CentOs7下搭建ftp服务器\" class=\"headerlink\" title=\"CentOs7下搭建ftp服务器\"></a>CentOs7下搭建ftp服务器</h2><h3 id=\"方式一：docker下安装\"><a href=\"#方式一：docker下安装\" class=\"headerlink\" title=\"方式一：docker下安装\"></a>方式一：docker下安装</h3><p>1.拉取镜像：</p>\n<pre><code>docker pull fauria/vsftpd\n</code></pre><p>2.启动容器：</p>\n<pre><code>docker run -d -v /dockers/vsftpd:/home/vsftpd \\\n-p 20:20 -p 21:21 -p 21100-21110:21100-21110 \\\n-e FTP_USER=admin -e FTP_PASS=123456 \\\n-e PASV_ADDRESS=127.0.0.1 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 \\\n--name vsftpd --restart=always fauria/vsftpd   \n\n------------------------------------\ndocker logs vsftpd\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"CentOs7下搭建ftp服务器\"><a href=\"#CentOs7下搭建ftp服务器\" class=\"headerlink\" title=\"CentOs7下搭建ftp服务器\"></a>CentOs7下搭建ftp服务器</h2><h3 id=\"方式一：docker下安装\"><a href=\"#方式一：docker下安装\" class=\"headerlink\" title=\"方式一：docker下安装\"></a>方式一：docker下安装</h3><p>1.拉取镜像：</p>\n<pre><code>docker pull fauria/vsftpd\n</code></pre><p>2.启动容器：</p>\n<pre><code>docker run -d -v /dockers/vsftpd:/home/vsftpd \\\n-p 20:20 -p 21:21 -p 21100-21110:21100-21110 \\\n-e FTP_USER=admin -e FTP_PASS=123456 \\\n-e PASV_ADDRESS=127.0.0.1 -e PASV_MIN_PORT=21100 -e PASV_MAX_PORT=21110 \\\n--name vsftpd --restart=always fauria/vsftpd   \n\n------------------------------------\ndocker logs vsftpd\n</code></pre>"},{"title":"git分支管理","date":"2018-06-23T07:29:33.000Z","_content":"\n在项目开发过程中，为了更好的开发，管理上需要对代码做版本管理。一般情况下，在开发之前就理应设定开发版本，然后开发人员在对应版本上编写代码，管理者再在某个时刻把分支`branch`代码合并回主分支。在最终稳定一个版本后，再打`tag`做版本永久保存。\n\n首先，要当前目录为`git`仓库。`git`仓库拉取下来默认是`master`分支。\n\n## 创建本地分支\n\n1. 查看有哪些分支\n\n    `git branch`\n\n2. 创建一个分支\n\n    `git branch name1` `name1`为分支名称。不能和`tag`的相同\n    \n3. 切换到分支\n\n    `git checkout name1`\n    \n实际上，2和3步骤也可以一步到位：`git checkout -b name`。创建并切换到分支\n\n下面，就可以在该分支上进行文件操作了。\n\n_注意_:如果用 git checkout master切换到主分支，在当name分支下进行的文件变更的内容无法看到。当切回name分支后，又可以看到了。\n\n## 提交分支到服务器\n\n`git push origin name1`\n\n说明：提交分支到服务器后，在本地分支进行文件变更后，可以执行上面同样命令，将变更信息更新到服务器上的该分支。\n\n## 将分支变更的内容合并到master分支\n\n1. 切换到master分支： `git checkout master`\n\n2. 合并`name1`分支到当前`master`分支： `git merge name1`\n\n_注意_: 这个时候合并到`master`分支上的内容还没提交到服务器的，需要`push`提交。\n\n## 删除分支\n\n1. 删除本地分支：`git branch -d name1`\n2. 删除服务器上的分支： `git push origin :name   (分支名前的冒号代表删除)`  \n\n## clone分支\n\n`git`仓库拉取下来，默认会把所有内容`clone`下来。 \n但是默认只创建`master`分支，需要执行`git branch -r`才能看到所有分支名字。  \n想把其它分支拉取下来，执行： `git checkout 分支名`。这样就把远程的分支拉取下来了。  \n再执行`git branch`，就能看到本地所有的分支了。然后可以切换分支编辑。","source":"_posts/git-branch.md","raw":"---\ntitle: git分支管理\ndate: 2018-06-23 15:29:33\ncategories: git\ntags: git分支、github分支\n---\n\n在项目开发过程中，为了更好的开发，管理上需要对代码做版本管理。一般情况下，在开发之前就理应设定开发版本，然后开发人员在对应版本上编写代码，管理者再在某个时刻把分支`branch`代码合并回主分支。在最终稳定一个版本后，再打`tag`做版本永久保存。\n\n首先，要当前目录为`git`仓库。`git`仓库拉取下来默认是`master`分支。\n\n## 创建本地分支\n\n1. 查看有哪些分支\n\n    `git branch`\n\n2. 创建一个分支\n\n    `git branch name1` `name1`为分支名称。不能和`tag`的相同\n    \n3. 切换到分支\n\n    `git checkout name1`\n    \n实际上，2和3步骤也可以一步到位：`git checkout -b name`。创建并切换到分支\n\n下面，就可以在该分支上进行文件操作了。\n\n_注意_:如果用 git checkout master切换到主分支，在当name分支下进行的文件变更的内容无法看到。当切回name分支后，又可以看到了。\n\n## 提交分支到服务器\n\n`git push origin name1`\n\n说明：提交分支到服务器后，在本地分支进行文件变更后，可以执行上面同样命令，将变更信息更新到服务器上的该分支。\n\n## 将分支变更的内容合并到master分支\n\n1. 切换到master分支： `git checkout master`\n\n2. 合并`name1`分支到当前`master`分支： `git merge name1`\n\n_注意_: 这个时候合并到`master`分支上的内容还没提交到服务器的，需要`push`提交。\n\n## 删除分支\n\n1. 删除本地分支：`git branch -d name1`\n2. 删除服务器上的分支： `git push origin :name   (分支名前的冒号代表删除)`  \n\n## clone分支\n\n`git`仓库拉取下来，默认会把所有内容`clone`下来。 \n但是默认只创建`master`分支，需要执行`git branch -r`才能看到所有分支名字。  \n想把其它分支拉取下来，执行： `git checkout 分支名`。这样就把远程的分支拉取下来了。  \n再执行`git branch`，就能看到本地所有的分支了。然后可以切换分支编辑。","slug":"git-branch","published":1,"updated":"2019-06-16T14:38:33.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbp003eg4vaoqg9t61l","content":"<p>在项目开发过程中，为了更好的开发，管理上需要对代码做版本管理。一般情况下，在开发之前就理应设定开发版本，然后开发人员在对应版本上编写代码，管理者再在某个时刻把分支<code>branch</code>代码合并回主分支。在最终稳定一个版本后，再打<code>tag</code>做版本永久保存。</p>\n<p>首先，要当前目录为<code>git</code>仓库。<code>git</code>仓库拉取下来默认是<code>master</code>分支。</p>\n<h2 id=\"创建本地分支\"><a href=\"#创建本地分支\" class=\"headerlink\" title=\"创建本地分支\"></a>创建本地分支</h2><ol>\n<li><p>查看有哪些分支</p>\n<p> <code>git branch</code></p>\n</li>\n<li><p>创建一个分支</p>\n<p> <code>git branch name1</code> <code>name1</code>为分支名称。不能和<code>tag</code>的相同</p>\n</li>\n<li><p>切换到分支</p>\n<p> <code>git checkout name1</code></p>\n</li>\n</ol>\n<p>实际上，2和3步骤也可以一步到位：<code>git checkout -b name</code>。创建并切换到分支</p>\n<p>下面，就可以在该分支上进行文件操作了。</p>\n<p>_注意_:如果用 git checkout master切换到主分支，在当name分支下进行的文件变更的内容无法看到。当切回name分支后，又可以看到了。</p>\n<h2 id=\"提交分支到服务器\"><a href=\"#提交分支到服务器\" class=\"headerlink\" title=\"提交分支到服务器\"></a>提交分支到服务器</h2><p><code>git push origin name1</code></p>\n<p>说明：提交分支到服务器后，在本地分支进行文件变更后，可以执行上面同样命令，将变更信息更新到服务器上的该分支。</p>\n<h2 id=\"将分支变更的内容合并到master分支\"><a href=\"#将分支变更的内容合并到master分支\" class=\"headerlink\" title=\"将分支变更的内容合并到master分支\"></a>将分支变更的内容合并到master分支</h2><ol>\n<li><p>切换到master分支： <code>git checkout master</code></p>\n</li>\n<li><p>合并<code>name1</code>分支到当前<code>master</code>分支： <code>git merge name1</code></p>\n</li>\n</ol>\n<p>_注意_: 这个时候合并到<code>master</code>分支上的内容还没提交到服务器的，需要<code>push</code>提交。</p>\n<h2 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h2><ol>\n<li>删除本地分支：<code>git branch -d name1</code></li>\n<li>删除服务器上的分支： <code>git push origin :name   (分支名前的冒号代表删除)</code>  </li>\n</ol>\n<h2 id=\"clone分支\"><a href=\"#clone分支\" class=\"headerlink\" title=\"clone分支\"></a>clone分支</h2><p><code>git</code>仓库拉取下来，默认会把所有内容<code>clone</code>下来。<br>但是默认只创建<code>master</code>分支，需要执行<code>git branch -r</code>才能看到所有分支名字。<br>想把其它分支拉取下来，执行： <code>git checkout 分支名</code>。这样就把远程的分支拉取下来了。<br>再执行<code>git branch</code>，就能看到本地所有的分支了。然后可以切换分支编辑。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在项目开发过程中，为了更好的开发，管理上需要对代码做版本管理。一般情况下，在开发之前就理应设定开发版本，然后开发人员在对应版本上编写代码，管理者再在某个时刻把分支<code>branch</code>代码合并回主分支。在最终稳定一个版本后，再打<code>tag</code>做版本永久保存。</p>\n<p>首先，要当前目录为<code>git</code>仓库。<code>git</code>仓库拉取下来默认是<code>master</code>分支。</p>\n<h2 id=\"创建本地分支\"><a href=\"#创建本地分支\" class=\"headerlink\" title=\"创建本地分支\"></a>创建本地分支</h2><ol>\n<li><p>查看有哪些分支</p>\n<p> <code>git branch</code></p>\n</li>\n<li><p>创建一个分支</p>\n<p> <code>git branch name1</code> <code>name1</code>为分支名称。不能和<code>tag</code>的相同</p>\n</li>\n<li><p>切换到分支</p>\n<p> <code>git checkout name1</code></p>\n</li>\n</ol>\n<p>实际上，2和3步骤也可以一步到位：<code>git checkout -b name</code>。创建并切换到分支</p>\n<p>下面，就可以在该分支上进行文件操作了。</p>\n<p>_注意_:如果用 git checkout master切换到主分支，在当name分支下进行的文件变更的内容无法看到。当切回name分支后，又可以看到了。</p>\n<h2 id=\"提交分支到服务器\"><a href=\"#提交分支到服务器\" class=\"headerlink\" title=\"提交分支到服务器\"></a>提交分支到服务器</h2><p><code>git push origin name1</code></p>\n<p>说明：提交分支到服务器后，在本地分支进行文件变更后，可以执行上面同样命令，将变更信息更新到服务器上的该分支。</p>\n<h2 id=\"将分支变更的内容合并到master分支\"><a href=\"#将分支变更的内容合并到master分支\" class=\"headerlink\" title=\"将分支变更的内容合并到master分支\"></a>将分支变更的内容合并到master分支</h2><ol>\n<li><p>切换到master分支： <code>git checkout master</code></p>\n</li>\n<li><p>合并<code>name1</code>分支到当前<code>master</code>分支： <code>git merge name1</code></p>\n</li>\n</ol>\n<p>_注意_: 这个时候合并到<code>master</code>分支上的内容还没提交到服务器的，需要<code>push</code>提交。</p>\n<h2 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h2><ol>\n<li>删除本地分支：<code>git branch -d name1</code></li>\n<li>删除服务器上的分支： <code>git push origin :name   (分支名前的冒号代表删除)</code>  </li>\n</ol>\n<h2 id=\"clone分支\"><a href=\"#clone分支\" class=\"headerlink\" title=\"clone分支\"></a>clone分支</h2><p><code>git</code>仓库拉取下来，默认会把所有内容<code>clone</code>下来。<br>但是默认只创建<code>master</code>分支，需要执行<code>git branch -r</code>才能看到所有分支名字。<br>想把其它分支拉取下来，执行： <code>git checkout 分支名</code>。这样就把远程的分支拉取下来了。<br>再执行<code>git branch</code>，就能看到本地所有的分支了。然后可以切换分支编辑。</p>\n"},{"title":"git服务器使用","date":"2017-10-14T01:58:47.000Z","_content":"搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","source":"_posts/git-server-build.md","raw":"---\ntitle: git服务器使用\ndate: 2017-10-14 09:58:47\ncategories: git\ntags: git-server-build\n---\n搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","slug":"git-server-build","published":1,"updated":"2019-06-16T14:38:33.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbr003ig4va3lr2i5lf","content":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone <a href=\"mailto:git@119.23.78.160\" target=\"_blank\" rel=\"noopener\">git@119.23.78.160</a>:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br><a href=\"mailto:git@119.23.78.160\" target=\"_blank\" rel=\"noopener\">git@119.23.78.160</a>‘s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone <a href=\"mailto:git@119.23.78.160\" target=\"_blank\" rel=\"noopener\">git@119.23.78.160</a>:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br><a href=\"mailto:git@119.23.78.160\" target=\"_blank\" rel=\"noopener\">git@119.23.78.160</a>‘s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n"},{"title":"git在centos7下源码编译安装","date":"2017-10-14T02:04:31.000Z","_content":"\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>  ln -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version #两个横杆\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","source":"_posts/git-install-in-centos7.md","raw":"---\ntitle: git在centos7下源码编译安装\ndate: 2017-10-14 10:04:31\ncategories: git\ntags: git-install-in-centos\n---\n\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>  ln -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version #两个横杆\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","slug":"git-install-in-centos7","published":1,"updated":"2019-06-16T14:38:33.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbs003lg4vajmzqdgks","content":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br> ln -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version #两个横杆</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br> ln -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version #两个横杆</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>"},{"title":"git使用","date":"2018-09-06T10:08:06.000Z","_content":"\n本文介绍git的使用方法以及一些问题……\n\n## 版本控制系统(GIT)分支管理规范\n\nhttps://www.jianshu.com/p/c35b939c5270\n\n## 回滚版本库\n在`git commit`多次后，版本库又会记录，但是在某次提交当中，提交了错误的代码，或者过大的文件，这个时候，就要做撤销，回滚。\n\n方式一：    \n`git log`   #拿到版本库id    \n`git reset 版本库id`\n\n## 清除用户名密码\n\n问题描述：\n\n    xinxiamu@xinxiamu-PC MINGW64 /g/jnyl/src\n    $ git clone http://47.115.39.97:8081/ott-platform-ui/ott-platform-all-ui.git\n    Cloning into 'ott-platform-all-ui'...\n    remote: HTTP Basic: Access denied\n    fatal: Authentication failed for 'http://47.115.39.97:8081/ott-platform-ui/ott-platform-all-ui.git/'\n\n\n解决方案：\n\n    git config --system --unset credential.helper\n    \n之后再进行git操作时，弹出用户名密码窗口，输入即可\n","source":"_posts/git-use.md","raw":"---\ntitle: git使用\ndate: 2018-09-06 18:08:06\ncategories: git\ntags: git问题\n---\n\n本文介绍git的使用方法以及一些问题……\n\n## 版本控制系统(GIT)分支管理规范\n\nhttps://www.jianshu.com/p/c35b939c5270\n\n## 回滚版本库\n在`git commit`多次后，版本库又会记录，但是在某次提交当中，提交了错误的代码，或者过大的文件，这个时候，就要做撤销，回滚。\n\n方式一：    \n`git log`   #拿到版本库id    \n`git reset 版本库id`\n\n## 清除用户名密码\n\n问题描述：\n\n    xinxiamu@xinxiamu-PC MINGW64 /g/jnyl/src\n    $ git clone http://47.115.39.97:8081/ott-platform-ui/ott-platform-all-ui.git\n    Cloning into 'ott-platform-all-ui'...\n    remote: HTTP Basic: Access denied\n    fatal: Authentication failed for 'http://47.115.39.97:8081/ott-platform-ui/ott-platform-all-ui.git/'\n\n\n解决方案：\n\n    git config --system --unset credential.helper\n    \n之后再进行git操作时，弹出用户名密码窗口，输入即可\n","slug":"git-use","published":1,"updated":"2020-05-30T11:28:23.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbu003pg4vaj3cqrx8x","content":"<p>本文介绍git的使用方法以及一些问题……</p>\n<h2 id=\"版本控制系统-GIT-分支管理规范\"><a href=\"#版本控制系统-GIT-分支管理规范\" class=\"headerlink\" title=\"版本控制系统(GIT)分支管理规范\"></a>版本控制系统(GIT)分支管理规范</h2><p><a href=\"https://www.jianshu.com/p/c35b939c5270\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c35b939c5270</a></p>\n<h2 id=\"回滚版本库\"><a href=\"#回滚版本库\" class=\"headerlink\" title=\"回滚版本库\"></a>回滚版本库</h2><p>在<code>git commit</code>多次后，版本库又会记录，但是在某次提交当中，提交了错误的代码，或者过大的文件，这个时候，就要做撤销，回滚。</p>\n<p>方式一：<br><code>git log</code>   #拿到版本库id<br><code>git reset 版本库id</code></p>\n<h2 id=\"清除用户名密码\"><a href=\"#清除用户名密码\" class=\"headerlink\" title=\"清除用户名密码\"></a>清除用户名密码</h2><p>问题描述：</p>\n<pre><code>xinxiamu@xinxiamu-PC MINGW64 /g/jnyl/src\n$ git clone http://47.115.39.97:8081/ott-platform-ui/ott-platform-all-ui.git\nCloning into &apos;ott-platform-all-ui&apos;...\nremote: HTTP Basic: Access denied\nfatal: Authentication failed for &apos;http://47.115.39.97:8081/ott-platform-ui/ott-platform-all-ui.git/&apos;\n</code></pre><p>解决方案：</p>\n<pre><code>git config --system --unset credential.helper\n</code></pre><p>之后再进行git操作时，弹出用户名密码窗口，输入即可</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍git的使用方法以及一些问题……</p>\n<h2 id=\"版本控制系统-GIT-分支管理规范\"><a href=\"#版本控制系统-GIT-分支管理规范\" class=\"headerlink\" title=\"版本控制系统(GIT)分支管理规范\"></a>版本控制系统(GIT)分支管理规范</h2><p><a href=\"https://www.jianshu.com/p/c35b939c5270\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/c35b939c5270</a></p>\n<h2 id=\"回滚版本库\"><a href=\"#回滚版本库\" class=\"headerlink\" title=\"回滚版本库\"></a>回滚版本库</h2><p>在<code>git commit</code>多次后，版本库又会记录，但是在某次提交当中，提交了错误的代码，或者过大的文件，这个时候，就要做撤销，回滚。</p>\n<p>方式一：<br><code>git log</code>   #拿到版本库id<br><code>git reset 版本库id</code></p>\n<h2 id=\"清除用户名密码\"><a href=\"#清除用户名密码\" class=\"headerlink\" title=\"清除用户名密码\"></a>清除用户名密码</h2><p>问题描述：</p>\n<pre><code>xinxiamu@xinxiamu-PC MINGW64 /g/jnyl/src\n$ git clone http://47.115.39.97:8081/ott-platform-ui/ott-platform-all-ui.git\nCloning into &apos;ott-platform-all-ui&apos;...\nremote: HTTP Basic: Access denied\nfatal: Authentication failed for &apos;http://47.115.39.97:8081/ott-platform-ui/ott-platform-all-ui.git/&apos;\n</code></pre><p>解决方案：</p>\n<pre><code>git config --system --unset credential.helper\n</code></pre><p>之后再进行git操作时，弹出用户名密码窗口，输入即可</p>\n"},{"title":"git打标签封存版本","date":"2018-06-23T09:40:01.000Z","_content":"\n在开发项目中，当我们的项目测试通过，并准备发布到生产环境时候，那么这是一个稳定的版本，此时，我们就需要封存该版本代码。做一个版本管理。本文就是介绍git下如何封存版本……\n\n## 创建标签\n\n1. 创建本地标签\n\n    `git tag -a V1.0 -m '版本1.0，基于spring-boot 1.x'`\n    \n2. 查看标签\n\n    `git tag`\n    \n    只看到版本信息`V1.0`，没看到备注信息。可以执行下面命令查看更加详细信息：\n    \n        mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git show V1.0\n        tag V1.0\n        Tagger: xinxiamu <932852117@qq.com>\n        Date:   Sat Jun 23 17:45:17 2018 +0800\n        \n        版本1.0，基于spring-boot 1.x \n        \n            \n## 提交标签到服务器\n\n上面创建的`tag`只是本地`git`仓库。下面把它推送到远程服务器。\n\n    mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin --tags \n    Username for 'https://github.com': xinxiamu\n    Password for 'https://xinxiamu@github.com': \n    Counting objects: 1, done.\n    Writing objects: 100% (1/1), 192 bytes | 0 bytes/s, done.\n    Total 1 (delta 0), reused 0 (delta 0)\n    To https://github.com/xinxiamu/ymu-framework.git\n     * [new tag]         V1.0 -> V1.0\n\n## 回退版本，tag上修复紧急bug\n    \n这个时候，突然发现一个重大bug，需要重新打版本，可以按下面方法来出来：\n\n- 删除本地标签： `git tag -d V1.0`    \n\n- 推送同名的空的标签到远程服务器，达到删除的目的：\n    \n    `git push origin :refs/tags/V1.0`\n    \n\n    mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin :refs/tags/V1.0\n    Username for 'https://github.com': xinxiamu\n    Password for 'https://xinxiamu@github.com': \n    To https://github.com/xinxiamu/ymu-framework.git\n     - [deleted]         V1.0\n\n- 拉取并切换到对应分支，在该分支上修复bug。\n    \n    如果远程服务器没有该分支，则可以基于该`tag`创建分支。并在新建分支上修改bug。\n    \n    `git checkout -B test v0.1.0` 强制创建一个基于指定的tag的分支。\n    \n    `test`为分支名称，`v0.1.0`为标签。\n\n- 按照上面步骤重新打标签并推送到远程服务器封存。\n- 合并该分支修改到主干分支`master`上，否则下次该bug还是存在。\n\n## 获取远程指定的封存版本\n\n更适合运维，拉取指定稳定版本进行发布到生产环境。\n\n`git fetch origin tag V1.0`\n\n## 切换到tag\n\n`git checkout V1.0`\n\n## 删除tag\n\n`git tag -d V1.0`\n\n----------------------------------------------------------------\n\n## 特别提醒（来源网络）\ngit 获取指定的tag处代码\n\ntag是对历史提交的一个id的引用，如果理解这句话就明白了tag的含义\n\n使用git checkout tag即可切换到指定tag，例如：git checkout v0.1.0\n\n切换到tag历史记录 会使当前指针处在分离头指针状态，这个时候的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b test v0.1.0 这个时候就在这个test分支上进行开发，之后可以切换到主线合并。\n\n注意这时候的test分支的代码很多都是tag版本处的，但是test分支head节点在最前面，这时候切换到主线进行合并，要注意合并后的代码冲突问题，不要让旧代码覆盖了主线的新代码。\n\ngit checkout -B\n这个命令，可以强制创建新的分支，为什么加-B呢？如果当前仓库中，已经存在一个跟你新建分支同名的分支，那么使用普通的git checkout -b 这个命令，是会报错的，且同名分支无法创建。如果使用-B参数，那么就可以强制创建新的分支，并会覆盖掉原来的分支。\n\ngit checkout -B test v0.1.0 强制创建一个基于指定的tag的分支。\n\n注：不要切换到tag上修改，否则切换回到`master`，可能造成代码丢失。切记切记……\n\n\n","source":"_posts/git-tag.md","raw":"---\ntitle: git打标签封存版本\ndate: 2018-06-23 17:40:01\ncategories: git\ntags: git-tag\n---\n\n在开发项目中，当我们的项目测试通过，并准备发布到生产环境时候，那么这是一个稳定的版本，此时，我们就需要封存该版本代码。做一个版本管理。本文就是介绍git下如何封存版本……\n\n## 创建标签\n\n1. 创建本地标签\n\n    `git tag -a V1.0 -m '版本1.0，基于spring-boot 1.x'`\n    \n2. 查看标签\n\n    `git tag`\n    \n    只看到版本信息`V1.0`，没看到备注信息。可以执行下面命令查看更加详细信息：\n    \n        mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git show V1.0\n        tag V1.0\n        Tagger: xinxiamu <932852117@qq.com>\n        Date:   Sat Jun 23 17:45:17 2018 +0800\n        \n        版本1.0，基于spring-boot 1.x \n        \n            \n## 提交标签到服务器\n\n上面创建的`tag`只是本地`git`仓库。下面把它推送到远程服务器。\n\n    mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin --tags \n    Username for 'https://github.com': xinxiamu\n    Password for 'https://xinxiamu@github.com': \n    Counting objects: 1, done.\n    Writing objects: 100% (1/1), 192 bytes | 0 bytes/s, done.\n    Total 1 (delta 0), reused 0 (delta 0)\n    To https://github.com/xinxiamu/ymu-framework.git\n     * [new tag]         V1.0 -> V1.0\n\n## 回退版本，tag上修复紧急bug\n    \n这个时候，突然发现一个重大bug，需要重新打版本，可以按下面方法来出来：\n\n- 删除本地标签： `git tag -d V1.0`    \n\n- 推送同名的空的标签到远程服务器，达到删除的目的：\n    \n    `git push origin :refs/tags/V1.0`\n    \n\n    mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin :refs/tags/V1.0\n    Username for 'https://github.com': xinxiamu\n    Password for 'https://xinxiamu@github.com': \n    To https://github.com/xinxiamu/ymu-framework.git\n     - [deleted]         V1.0\n\n- 拉取并切换到对应分支，在该分支上修复bug。\n    \n    如果远程服务器没有该分支，则可以基于该`tag`创建分支。并在新建分支上修改bug。\n    \n    `git checkout -B test v0.1.0` 强制创建一个基于指定的tag的分支。\n    \n    `test`为分支名称，`v0.1.0`为标签。\n\n- 按照上面步骤重新打标签并推送到远程服务器封存。\n- 合并该分支修改到主干分支`master`上，否则下次该bug还是存在。\n\n## 获取远程指定的封存版本\n\n更适合运维，拉取指定稳定版本进行发布到生产环境。\n\n`git fetch origin tag V1.0`\n\n## 切换到tag\n\n`git checkout V1.0`\n\n## 删除tag\n\n`git tag -d V1.0`\n\n----------------------------------------------------------------\n\n## 特别提醒（来源网络）\ngit 获取指定的tag处代码\n\ntag是对历史提交的一个id的引用，如果理解这句话就明白了tag的含义\n\n使用git checkout tag即可切换到指定tag，例如：git checkout v0.1.0\n\n切换到tag历史记录 会使当前指针处在分离头指针状态，这个时候的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b test v0.1.0 这个时候就在这个test分支上进行开发，之后可以切换到主线合并。\n\n注意这时候的test分支的代码很多都是tag版本处的，但是test分支head节点在最前面，这时候切换到主线进行合并，要注意合并后的代码冲突问题，不要让旧代码覆盖了主线的新代码。\n\ngit checkout -B\n这个命令，可以强制创建新的分支，为什么加-B呢？如果当前仓库中，已经存在一个跟你新建分支同名的分支，那么使用普通的git checkout -b 这个命令，是会报错的，且同名分支无法创建。如果使用-B参数，那么就可以强制创建新的分支，并会覆盖掉原来的分支。\n\ngit checkout -B test v0.1.0 强制创建一个基于指定的tag的分支。\n\n注：不要切换到tag上修改，否则切换回到`master`，可能造成代码丢失。切记切记……\n\n\n","slug":"git-tag","published":1,"updated":"2019-06-16T14:38:33.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbv003rg4vaqg9t8gqt","content":"<p>在开发项目中，当我们的项目测试通过，并准备发布到生产环境时候，那么这是一个稳定的版本，此时，我们就需要封存该版本代码。做一个版本管理。本文就是介绍git下如何封存版本……</p>\n<h2 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h2><ol>\n<li><p>创建本地标签</p>\n<p> <code>git tag -a V1.0 -m &#39;版本1.0，基于spring-boot 1.x&#39;</code></p>\n</li>\n<li><p>查看标签</p>\n<p> <code>git tag</code></p>\n<p> 只看到版本信息<code>V1.0</code>，没看到备注信息。可以执行下面命令查看更加详细信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git show V1.0\ntag V1.0\nTagger: xinxiamu &lt;932852117@qq.com&gt;\nDate:   Sat Jun 23 17:45:17 2018 +0800\n\n版本1.0，基于spring-boot 1.x \n</code></pre></li>\n</ol>\n<h2 id=\"提交标签到服务器\"><a href=\"#提交标签到服务器\" class=\"headerlink\" title=\"提交标签到服务器\"></a>提交标签到服务器</h2><p>上面创建的<code>tag</code>只是本地<code>git</code>仓库。下面把它推送到远程服务器。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin --tags \nUsername for &apos;https://github.com&apos;: xinxiamu\nPassword for &apos;https://xinxiamu@github.com&apos;: \nCounting objects: 1, done.\nWriting objects: 100% (1/1), 192 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo https://github.com/xinxiamu/ymu-framework.git\n * [new tag]         V1.0 -&gt; V1.0\n</code></pre><h2 id=\"回退版本，tag上修复紧急bug\"><a href=\"#回退版本，tag上修复紧急bug\" class=\"headerlink\" title=\"回退版本，tag上修复紧急bug\"></a>回退版本，tag上修复紧急bug</h2><p>这个时候，突然发现一个重大bug，需要重新打版本，可以按下面方法来出来：</p>\n<ul>\n<li><p>删除本地标签： <code>git tag -d V1.0</code>    </p>\n</li>\n<li><p>推送同名的空的标签到远程服务器，达到删除的目的：</p>\n<p>  <code>git push origin :refs/tags/V1.0</code></p>\n</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin :refs/tags/V1.0\nUsername for &apos;https://github.com&apos;: xinxiamu\nPassword for &apos;https://xinxiamu@github.com&apos;: \nTo https://github.com/xinxiamu/ymu-framework.git\n - [deleted]         V1.0\n</code></pre><ul>\n<li><p>拉取并切换到对应分支，在该分支上修复bug。</p>\n<p>  如果远程服务器没有该分支，则可以基于该<code>tag</code>创建分支。并在新建分支上修改bug。</p>\n<p>  <code>git checkout -B test v0.1.0</code> 强制创建一个基于指定的tag的分支。</p>\n<p>  <code>test</code>为分支名称，<code>v0.1.0</code>为标签。</p>\n</li>\n<li><p>按照上面步骤重新打标签并推送到远程服务器封存。</p>\n</li>\n<li>合并该分支修改到主干分支<code>master</code>上，否则下次该bug还是存在。</li>\n</ul>\n<h2 id=\"获取远程指定的封存版本\"><a href=\"#获取远程指定的封存版本\" class=\"headerlink\" title=\"获取远程指定的封存版本\"></a>获取远程指定的封存版本</h2><p>更适合运维，拉取指定稳定版本进行发布到生产环境。</p>\n<p><code>git fetch origin tag V1.0</code></p>\n<h2 id=\"切换到tag\"><a href=\"#切换到tag\" class=\"headerlink\" title=\"切换到tag\"></a>切换到tag</h2><p><code>git checkout V1.0</code></p>\n<h2 id=\"删除tag\"><a href=\"#删除tag\" class=\"headerlink\" title=\"删除tag\"></a>删除tag</h2><p><code>git tag -d V1.0</code></p>\n<hr>\n<h2 id=\"特别提醒（来源网络）\"><a href=\"#特别提醒（来源网络）\" class=\"headerlink\" title=\"特别提醒（来源网络）\"></a>特别提醒（来源网络）</h2><p>git 获取指定的tag处代码</p>\n<p>tag是对历史提交的一个id的引用，如果理解这句话就明白了tag的含义</p>\n<p>使用git checkout tag即可切换到指定tag，例如：git checkout v0.1.0</p>\n<p>切换到tag历史记录 会使当前指针处在分离头指针状态，这个时候的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b test v0.1.0 这个时候就在这个test分支上进行开发，之后可以切换到主线合并。</p>\n<p>注意这时候的test分支的代码很多都是tag版本处的，但是test分支head节点在最前面，这时候切换到主线进行合并，要注意合并后的代码冲突问题，不要让旧代码覆盖了主线的新代码。</p>\n<p>git checkout -B<br>这个命令，可以强制创建新的分支，为什么加-B呢？如果当前仓库中，已经存在一个跟你新建分支同名的分支，那么使用普通的git checkout -b 这个命令，是会报错的，且同名分支无法创建。如果使用-B参数，那么就可以强制创建新的分支，并会覆盖掉原来的分支。</p>\n<p>git checkout -B test v0.1.0 强制创建一个基于指定的tag的分支。</p>\n<p>注：不要切换到tag上修改，否则切换回到<code>master</code>，可能造成代码丢失。切记切记……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在开发项目中，当我们的项目测试通过，并准备发布到生产环境时候，那么这是一个稳定的版本，此时，我们就需要封存该版本代码。做一个版本管理。本文就是介绍git下如何封存版本……</p>\n<h2 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h2><ol>\n<li><p>创建本地标签</p>\n<p> <code>git tag -a V1.0 -m &#39;版本1.0，基于spring-boot 1.x&#39;</code></p>\n</li>\n<li><p>查看标签</p>\n<p> <code>git tag</code></p>\n<p> 只看到版本信息<code>V1.0</code>，没看到备注信息。可以执行下面命令查看更加详细信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git show V1.0\ntag V1.0\nTagger: xinxiamu &lt;932852117@qq.com&gt;\nDate:   Sat Jun 23 17:45:17 2018 +0800\n\n版本1.0，基于spring-boot 1.x \n</code></pre></li>\n</ol>\n<h2 id=\"提交标签到服务器\"><a href=\"#提交标签到服务器\" class=\"headerlink\" title=\"提交标签到服务器\"></a>提交标签到服务器</h2><p>上面创建的<code>tag</code>只是本地<code>git</code>仓库。下面把它推送到远程服务器。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin --tags \nUsername for &apos;https://github.com&apos;: xinxiamu\nPassword for &apos;https://xinxiamu@github.com&apos;: \nCounting objects: 1, done.\nWriting objects: 100% (1/1), 192 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo https://github.com/xinxiamu/ymu-framework.git\n * [new tag]         V1.0 -&gt; V1.0\n</code></pre><h2 id=\"回退版本，tag上修复紧急bug\"><a href=\"#回退版本，tag上修复紧急bug\" class=\"headerlink\" title=\"回退版本，tag上修复紧急bug\"></a>回退版本，tag上修复紧急bug</h2><p>这个时候，突然发现一个重大bug，需要重新打版本，可以按下面方法来出来：</p>\n<ul>\n<li><p>删除本地标签： <code>git tag -d V1.0</code>    </p>\n</li>\n<li><p>推送同名的空的标签到远程服务器，达到删除的目的：</p>\n<p>  <code>git push origin :refs/tags/V1.0</code></p>\n</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin :refs/tags/V1.0\nUsername for &apos;https://github.com&apos;: xinxiamu\nPassword for &apos;https://xinxiamu@github.com&apos;: \nTo https://github.com/xinxiamu/ymu-framework.git\n - [deleted]         V1.0\n</code></pre><ul>\n<li><p>拉取并切换到对应分支，在该分支上修复bug。</p>\n<p>  如果远程服务器没有该分支，则可以基于该<code>tag</code>创建分支。并在新建分支上修改bug。</p>\n<p>  <code>git checkout -B test v0.1.0</code> 强制创建一个基于指定的tag的分支。</p>\n<p>  <code>test</code>为分支名称，<code>v0.1.0</code>为标签。</p>\n</li>\n<li><p>按照上面步骤重新打标签并推送到远程服务器封存。</p>\n</li>\n<li>合并该分支修改到主干分支<code>master</code>上，否则下次该bug还是存在。</li>\n</ul>\n<h2 id=\"获取远程指定的封存版本\"><a href=\"#获取远程指定的封存版本\" class=\"headerlink\" title=\"获取远程指定的封存版本\"></a>获取远程指定的封存版本</h2><p>更适合运维，拉取指定稳定版本进行发布到生产环境。</p>\n<p><code>git fetch origin tag V1.0</code></p>\n<h2 id=\"切换到tag\"><a href=\"#切换到tag\" class=\"headerlink\" title=\"切换到tag\"></a>切换到tag</h2><p><code>git checkout V1.0</code></p>\n<h2 id=\"删除tag\"><a href=\"#删除tag\" class=\"headerlink\" title=\"删除tag\"></a>删除tag</h2><p><code>git tag -d V1.0</code></p>\n<hr>\n<h2 id=\"特别提醒（来源网络）\"><a href=\"#特别提醒（来源网络）\" class=\"headerlink\" title=\"特别提醒（来源网络）\"></a>特别提醒（来源网络）</h2><p>git 获取指定的tag处代码</p>\n<p>tag是对历史提交的一个id的引用，如果理解这句话就明白了tag的含义</p>\n<p>使用git checkout tag即可切换到指定tag，例如：git checkout v0.1.0</p>\n<p>切换到tag历史记录 会使当前指针处在分离头指针状态，这个时候的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b test v0.1.0 这个时候就在这个test分支上进行开发，之后可以切换到主线合并。</p>\n<p>注意这时候的test分支的代码很多都是tag版本处的，但是test分支head节点在最前面，这时候切换到主线进行合并，要注意合并后的代码冲突问题，不要让旧代码覆盖了主线的新代码。</p>\n<p>git checkout -B<br>这个命令，可以强制创建新的分支，为什么加-B呢？如果当前仓库中，已经存在一个跟你新建分支同名的分支，那么使用普通的git checkout -b 这个命令，是会报错的，且同名分支无法创建。如果使用-B参数，那么就可以强制创建新的分支，并会覆盖掉原来的分支。</p>\n<p>git checkout -B test v0.1.0 强制创建一个基于指定的tag的分支。</p>\n<p>注：不要切换到tag上修改，否则切换回到<code>master</code>，可能造成代码丢失。切记切记……</p>\n"},{"title":"如何直接在github网站上更新你fork的repo","date":"2017-10-13T01:39:58.000Z","_content":"玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","source":"_posts/github-fork-repo-update.md","raw":"---\ntitle: 如何直接在github网站上更新你fork的repo\ndate: 2017-10-13 09:39:58\ncategories: github\ntags: github-fork-repo-update\n---\n玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","slug":"github-fork-repo-update","published":1,"updated":"2019-06-16T14:38:33.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqbx003vg4vanvou7d8n","content":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>"},{"title":"使用github作为maven仓库发布jar","date":"2018-12-05T06:18:20.000Z","_content":"\n参考：https://blog.csdn.net/hwangfantasy/article/details/69389766","source":"_posts/github-mnv-jar.md","raw":"---\ntitle: 使用github作为maven仓库发布jar\ndate: 2018-12-05 14:18:20\ncategories: github\ntags:\n---\n\n参考：https://blog.csdn.net/hwangfantasy/article/details/69389766","slug":"github-mnv-jar","published":1,"updated":"2019-06-16T14:38:33.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqby003wg4vah4vfxwct","content":"<p>参考：<a href=\"https://blog.csdn.net/hwangfantasy/article/details/69389766\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hwangfantasy/article/details/69389766</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://blog.csdn.net/hwangfantasy/article/details/69389766\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hwangfantasy/article/details/69389766</a></p>\n"},{"title":"gitlab服务器搭建（Centos7系统）","date":"2018-12-11T03:35:15.000Z","_content":"\n参考网址：https://about.gitlab.com/install/#centos-7\n\n## 快速安装gitlab\n\n1.安装相关依赖包：\n\n基础依赖：\n\n    sudo yum install -y curl policycoreutils-python openssh-server\n    sudo systemctl enable sshd\n    sudo systemctl start sshd\n    sudo firewall-cmd --permanent --add-service=http\n    sudo systemctl reload firewalld\n\n发送邮件依赖：\n\n    sudo yum install postfix\n    sudo systemctl enable postfix\n    sudo systemctl start postfix\n\n2.添加gitlab仓库uri并安装：\n\n添加安装包地址：\n\n安装包地址：https://packages.gitlab.com/gitlab/gitlab-ce\n\n    curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash\n    \n 安装：\n \n    sudo EXTERNAL_URL=\"http://gitlab.ymu.com\" yum install -y gitlab-ce\n    \n## 安装包rpm方式：\n\n#### 1.和上面一样，安装依赖包。\n\n#### 2.下载安装包：\n\n1.社区版本地址：https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm/download.rpm\n\n说明：\n```text\nEL是Red Hat Enterprise Linux的简写 \n- EL6软件包用于在Red Hat 6.x, CentOS 6.x, and CloudLinux 6.x进行安装 \n- EL5软件包用于在Red Hat 5.x, CentOS 5.x, CloudLinux 5.x的安装 \n- EL7 软件包用于在Red Hat 7.x, CentOS 7.x, and CloudLinux 7.x的安装\n```\n\n2.执行安装命令：\n\n    [root@xr-server vagrant]# rpm -ivh gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm \n    warning: gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID f27eab47: NOKEY\n    Preparing...                          ################################# [100%]\n    Updating / installing...\n       1:gitlab-ce-11.3.12-ce.0.el7       ################################# [100%]\n    It looks like GitLab has not been configured yet; skipping the upgrade script.\n    \n           *.                  *.\n          ***                 ***\n         *****               *****\n        .******             *******\n        ********            ********\n       ,,,,,,,,,***********,,,,,,,,,\n      ,,,,,,,,,,,*********,,,,,,,,,,,\n      .,,,,,,,,,,,*******,,,,,,,,,,,,\n          ,,,,,,,,,*****,,,,,,,,,.\n             ,,,,,,,****,,,,,,\n                .,,,***,,,,\n                    ,*,.\n      \n    \n    \n         _______ __  __          __\n        / ____(_) /_/ /   ____ _/ /_\n       / / __/ / __/ /   / __ `/ __ \\\n      / /_/ / / /_/ /___/ /_/ / /_/ /\n      \\____/_/\\__/_____/\\__,_/_.___/\n      \n    \n    Thank you for installing GitLab!\n    GitLab was unable to detect a valid hostname for your instance.\n    Please configure a URL for your GitLab instance by setting `external_url`\n    configuration in /etc/gitlab/gitlab.rb file.\n    Then, you can start your GitLab instance by running the following command:\n      sudo gitlab-ctl reconfigure\n    \n    For a comprehensive list of configuration options please see the Omnibus GitLab readme\n    https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md\n\n    \n3.修改Gitlab访问URL配置:\n\n可以使用自定义域名，也可以直接IP地址+端口访问。\n\n编辑文件：\n\n    [root@xr-server ~]# cd /etc/gitlab/\n    [root@xr-server gitlab]# ls\n    gitlab.rb\n    [root@xr-server gitlab]# vim gitlab.rb\n    \n修改：\n\n    #external_url 'http://gitlab.example.com'\n    external_url 'http://192.168.10.31:8080'\n\n这样就以ip+端口方式访问。\n\n4.重置并启动Gitlab\n\n    sudo gitlab-ctl reconfigure\n    sudo gitlab-ctl start\n\n5.停止\n\n    sudo gitlab-ctl stop\n    \n6.重启\n\n    sudo gitlab-ctl restart\n     \n##  docker环境安装gitlab \n\n参考：https://docs.gitlab.com/omnibus/docker/ \n\n### 启动gitlab容器服务\n\n1.查看系统是否开启了SELinux  \n\n    /usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态\n    \n2.启动gitlab ce容器\n\n如果SELinux是开启的，则执行：  \n\n    sudo docker run --detach \\\n    \t--hostname gitlab.example.com \\\n    \t--publish 443:443 --publish 80:80 --publish 10022:22 \\\n    \t--name gitlab \\\n    \t--restart always \\\n    \t--volume /srv/gitlab/config:/etc/gitlab:Z \\\n    \t--volume /srv/gitlab/logs:/var/log/gitlab:Z \\\n    \t--volume /srv/gitlab/data:/var/opt/gitlab:Z \\\n    \tgitlab/gitlab-ce:latest      \n\n这样才能确保容器进程拥有足够权限，在卷上创建相关的配置文件。\n\n如果SELinux是关闭的，则执行：  \n\n    sudo docker run --detach \\\n    \t--hostname gitlab.example.com \\\n    \t--publish 443:443 --publish 80:80 --publish 10022:22 \\\n    \t--name gitlab \\\n    \t--restart always \\\n    \t--volume /srv/gitlab/config:/etc/gitlab \\\n    \t--volume /srv/gitlab/logs:/var/log/gitlab \\\n    \t--volume /srv/gitlab/data:/var/opt/gitlab \\\n    \tgitlab/gitlab-ce:latest\n    \t   \t    \t \t    \t\n_注意：_   \n\n宿主机22端口一般会被占用，所以映射到别的端口，这里映射到10022端口，后面修改配置即可。\n\n映射到宿主机任意端口：\n\n    sudo docker run --detach \\\n      --hostname gitlab.example.com \\\n      --publish 8929:80 --publish 2289:22 \\\n      --name gitlab \\\n      --restart always \\\n      --volume /srv/gitlab/config:/etc/gitlab \\\n      --volume /srv/gitlab/logs:/var/log/gitlab \\\n      --volume /srv/gitlab/data:/var/opt/gitlab \\\n      gitlab/gitlab-ce:latest \n\n### 修改配置    \n\n容器成功执行后面，会在映射目录/srv/gitlab/config/目录下生成一个配置文件gitlab.rb。     \n\n编辑gitlab.rb文件\n\n`vim /srv/gitlab/config/gitlab.rb`\n\n1.设置`external_url`:   \n \n    # 配置http协议所使用的访问地址\n    #external_url 'gitlab.example.com:端口'\n    external_url 'http://172.16.81.81:端口'\n    \n    or\n    \n    # For HTTPS (notice the https)\n    #external_url \"https://gitlab.example.com:端口\"\n    external_url 'https://172.16.81.81:端口'\n    \n2.设置`gitlab_shell_ssh_port`:\n     \n    # 配置ssh协议所使用的访问地址和端口\n    #gitlab_rails['gitlab_ssh_host'] = 'gitlab.example.com'\n    gitlab_rails['gitlab_ssh_host'] = '172.16.81.81'\n    gitlab_rails['gitlab_shell_ssh_port'] = 2289\n    \n配置邮件发送  \n\nhttps://docs.gitlab.com/omnibus/settings/smtp.html\n\n里面有各家邮件配置，包括腾讯qq企业邮箱的配置。\n\n    vim /opt/gitlab/config/gitlab.rb\n    # 这里以新浪的邮箱为例配置smtp服务器\n    gitlab_rails['smtp_enable'] = true\n    gitlab_rails['smtp_address'] = \"smtp.xxx.com\"\n    gitlab_rails['smtp_port'] = 25\n    gitlab_rails['smtp_user_name'] = \"name4mail\"\n    gitlab_rails['smtp_password'] = \"passwd4mail\"\n    gitlab_rails['smtp_domain'] = \"xxx.com\"\n    gitlab_rails['smtp_authentication'] = :login\n    gitlab_rails['smtp_enable_starttls_auto'] = true\n     \n    # 还有个需要注意的地方是指定发送邮件所用的邮箱，这个要和上面配置的邮箱一致\n    gitlab_rails['gitlab_email_from'] = 'name4mail@xxx.com'\n    \n    -----------------------------------------------------------------------------\n    腾讯qq企业邮箱\n    \n    gitlab_rails['smtp_enable'] = true\n    gitlab_rails['smtp_address'] = \"smtp.exmail.qq.com\"\n    gitlab_rails['smtp_port'] = 465\n    gitlab_rails['smtp_user_name'] = \"zhangmutian@xcsqjr.com\"\n    gitlab_rails['smtp_password'] = \"password\"\n    gitlab_rails['smtp_authentication'] = \"login\"\n    gitlab_rails['smtp_enable_starttls_auto'] = true\n    gitlab_rails['smtp_tls'] = true\n    gitlab_rails['gitlab_email_from'] = 'zhangmutian@xcsqjr.com'\n    gitlab_rails['smtp_domain'] = \"exmail.qq.com\"\n    \n           \t      \n修改gitlab.rb配置文件之后，重启容器。\n\n    docker restart gitlab\n    \n    # 进入容器\n    docker exec -it gitlab bash\n     \n    # 重启gitlab\n    gitlab-ctl reconfigure\n\n_提醒：_ \n上面三个步骤不可少，特别是要进入容器重启配置。如果只是重启容器，访问报502。\n        \n### 登录\n\n浏览器打开：http://192.168.33.10/\n\n初始页面要求先改密码，密码改为：a1234567    \n\n修改成功会跳转到登录页面，输入账号密码登录即可：    \n\n用户名：root  密码：a1234567    \n \n登录成功后看到：    \n\n{%asset_img a-1.png%} \n\n### 设置系统语言\n\n切换到官方镜像之后， 中文设置方法： 依次点击工具栏最右侧用户头像 》 Settings 》 Preferred language ， 然后选择 简体中文 即可。\n\n### git参考访问地址\n\n    # HTTP\n    http://172.16.81.81/root/test-docker-gitlab.git \n    # SSH \n    ssh://git@172.16.81.81:10022/root/test-docker-gitlab.git\n    \n### 升级\n\n### 中文社区版安装\n\n参考：https://hub.docker.com/r/beginor/gitlab-ce \n     ","source":"_posts/gitlab-start.md","raw":"---\ntitle: gitlab服务器搭建（Centos7系统）\ndate: 2018-12-11 11:35:15\ncategories: gitlab\ntags:\n---\n\n参考网址：https://about.gitlab.com/install/#centos-7\n\n## 快速安装gitlab\n\n1.安装相关依赖包：\n\n基础依赖：\n\n    sudo yum install -y curl policycoreutils-python openssh-server\n    sudo systemctl enable sshd\n    sudo systemctl start sshd\n    sudo firewall-cmd --permanent --add-service=http\n    sudo systemctl reload firewalld\n\n发送邮件依赖：\n\n    sudo yum install postfix\n    sudo systemctl enable postfix\n    sudo systemctl start postfix\n\n2.添加gitlab仓库uri并安装：\n\n添加安装包地址：\n\n安装包地址：https://packages.gitlab.com/gitlab/gitlab-ce\n\n    curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash\n    \n 安装：\n \n    sudo EXTERNAL_URL=\"http://gitlab.ymu.com\" yum install -y gitlab-ce\n    \n## 安装包rpm方式：\n\n#### 1.和上面一样，安装依赖包。\n\n#### 2.下载安装包：\n\n1.社区版本地址：https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm/download.rpm\n\n说明：\n```text\nEL是Red Hat Enterprise Linux的简写 \n- EL6软件包用于在Red Hat 6.x, CentOS 6.x, and CloudLinux 6.x进行安装 \n- EL5软件包用于在Red Hat 5.x, CentOS 5.x, CloudLinux 5.x的安装 \n- EL7 软件包用于在Red Hat 7.x, CentOS 7.x, and CloudLinux 7.x的安装\n```\n\n2.执行安装命令：\n\n    [root@xr-server vagrant]# rpm -ivh gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm \n    warning: gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID f27eab47: NOKEY\n    Preparing...                          ################################# [100%]\n    Updating / installing...\n       1:gitlab-ce-11.3.12-ce.0.el7       ################################# [100%]\n    It looks like GitLab has not been configured yet; skipping the upgrade script.\n    \n           *.                  *.\n          ***                 ***\n         *****               *****\n        .******             *******\n        ********            ********\n       ,,,,,,,,,***********,,,,,,,,,\n      ,,,,,,,,,,,*********,,,,,,,,,,,\n      .,,,,,,,,,,,*******,,,,,,,,,,,,\n          ,,,,,,,,,*****,,,,,,,,,.\n             ,,,,,,,****,,,,,,\n                .,,,***,,,,\n                    ,*,.\n      \n    \n    \n         _______ __  __          __\n        / ____(_) /_/ /   ____ _/ /_\n       / / __/ / __/ /   / __ `/ __ \\\n      / /_/ / / /_/ /___/ /_/ / /_/ /\n      \\____/_/\\__/_____/\\__,_/_.___/\n      \n    \n    Thank you for installing GitLab!\n    GitLab was unable to detect a valid hostname for your instance.\n    Please configure a URL for your GitLab instance by setting `external_url`\n    configuration in /etc/gitlab/gitlab.rb file.\n    Then, you can start your GitLab instance by running the following command:\n      sudo gitlab-ctl reconfigure\n    \n    For a comprehensive list of configuration options please see the Omnibus GitLab readme\n    https://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md\n\n    \n3.修改Gitlab访问URL配置:\n\n可以使用自定义域名，也可以直接IP地址+端口访问。\n\n编辑文件：\n\n    [root@xr-server ~]# cd /etc/gitlab/\n    [root@xr-server gitlab]# ls\n    gitlab.rb\n    [root@xr-server gitlab]# vim gitlab.rb\n    \n修改：\n\n    #external_url 'http://gitlab.example.com'\n    external_url 'http://192.168.10.31:8080'\n\n这样就以ip+端口方式访问。\n\n4.重置并启动Gitlab\n\n    sudo gitlab-ctl reconfigure\n    sudo gitlab-ctl start\n\n5.停止\n\n    sudo gitlab-ctl stop\n    \n6.重启\n\n    sudo gitlab-ctl restart\n     \n##  docker环境安装gitlab \n\n参考：https://docs.gitlab.com/omnibus/docker/ \n\n### 启动gitlab容器服务\n\n1.查看系统是否开启了SELinux  \n\n    /usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态\n    \n2.启动gitlab ce容器\n\n如果SELinux是开启的，则执行：  \n\n    sudo docker run --detach \\\n    \t--hostname gitlab.example.com \\\n    \t--publish 443:443 --publish 80:80 --publish 10022:22 \\\n    \t--name gitlab \\\n    \t--restart always \\\n    \t--volume /srv/gitlab/config:/etc/gitlab:Z \\\n    \t--volume /srv/gitlab/logs:/var/log/gitlab:Z \\\n    \t--volume /srv/gitlab/data:/var/opt/gitlab:Z \\\n    \tgitlab/gitlab-ce:latest      \n\n这样才能确保容器进程拥有足够权限，在卷上创建相关的配置文件。\n\n如果SELinux是关闭的，则执行：  \n\n    sudo docker run --detach \\\n    \t--hostname gitlab.example.com \\\n    \t--publish 443:443 --publish 80:80 --publish 10022:22 \\\n    \t--name gitlab \\\n    \t--restart always \\\n    \t--volume /srv/gitlab/config:/etc/gitlab \\\n    \t--volume /srv/gitlab/logs:/var/log/gitlab \\\n    \t--volume /srv/gitlab/data:/var/opt/gitlab \\\n    \tgitlab/gitlab-ce:latest\n    \t   \t    \t \t    \t\n_注意：_   \n\n宿主机22端口一般会被占用，所以映射到别的端口，这里映射到10022端口，后面修改配置即可。\n\n映射到宿主机任意端口：\n\n    sudo docker run --detach \\\n      --hostname gitlab.example.com \\\n      --publish 8929:80 --publish 2289:22 \\\n      --name gitlab \\\n      --restart always \\\n      --volume /srv/gitlab/config:/etc/gitlab \\\n      --volume /srv/gitlab/logs:/var/log/gitlab \\\n      --volume /srv/gitlab/data:/var/opt/gitlab \\\n      gitlab/gitlab-ce:latest \n\n### 修改配置    \n\n容器成功执行后面，会在映射目录/srv/gitlab/config/目录下生成一个配置文件gitlab.rb。     \n\n编辑gitlab.rb文件\n\n`vim /srv/gitlab/config/gitlab.rb`\n\n1.设置`external_url`:   \n \n    # 配置http协议所使用的访问地址\n    #external_url 'gitlab.example.com:端口'\n    external_url 'http://172.16.81.81:端口'\n    \n    or\n    \n    # For HTTPS (notice the https)\n    #external_url \"https://gitlab.example.com:端口\"\n    external_url 'https://172.16.81.81:端口'\n    \n2.设置`gitlab_shell_ssh_port`:\n     \n    # 配置ssh协议所使用的访问地址和端口\n    #gitlab_rails['gitlab_ssh_host'] = 'gitlab.example.com'\n    gitlab_rails['gitlab_ssh_host'] = '172.16.81.81'\n    gitlab_rails['gitlab_shell_ssh_port'] = 2289\n    \n配置邮件发送  \n\nhttps://docs.gitlab.com/omnibus/settings/smtp.html\n\n里面有各家邮件配置，包括腾讯qq企业邮箱的配置。\n\n    vim /opt/gitlab/config/gitlab.rb\n    # 这里以新浪的邮箱为例配置smtp服务器\n    gitlab_rails['smtp_enable'] = true\n    gitlab_rails['smtp_address'] = \"smtp.xxx.com\"\n    gitlab_rails['smtp_port'] = 25\n    gitlab_rails['smtp_user_name'] = \"name4mail\"\n    gitlab_rails['smtp_password'] = \"passwd4mail\"\n    gitlab_rails['smtp_domain'] = \"xxx.com\"\n    gitlab_rails['smtp_authentication'] = :login\n    gitlab_rails['smtp_enable_starttls_auto'] = true\n     \n    # 还有个需要注意的地方是指定发送邮件所用的邮箱，这个要和上面配置的邮箱一致\n    gitlab_rails['gitlab_email_from'] = 'name4mail@xxx.com'\n    \n    -----------------------------------------------------------------------------\n    腾讯qq企业邮箱\n    \n    gitlab_rails['smtp_enable'] = true\n    gitlab_rails['smtp_address'] = \"smtp.exmail.qq.com\"\n    gitlab_rails['smtp_port'] = 465\n    gitlab_rails['smtp_user_name'] = \"zhangmutian@xcsqjr.com\"\n    gitlab_rails['smtp_password'] = \"password\"\n    gitlab_rails['smtp_authentication'] = \"login\"\n    gitlab_rails['smtp_enable_starttls_auto'] = true\n    gitlab_rails['smtp_tls'] = true\n    gitlab_rails['gitlab_email_from'] = 'zhangmutian@xcsqjr.com'\n    gitlab_rails['smtp_domain'] = \"exmail.qq.com\"\n    \n           \t      \n修改gitlab.rb配置文件之后，重启容器。\n\n    docker restart gitlab\n    \n    # 进入容器\n    docker exec -it gitlab bash\n     \n    # 重启gitlab\n    gitlab-ctl reconfigure\n\n_提醒：_ \n上面三个步骤不可少，特别是要进入容器重启配置。如果只是重启容器，访问报502。\n        \n### 登录\n\n浏览器打开：http://192.168.33.10/\n\n初始页面要求先改密码，密码改为：a1234567    \n\n修改成功会跳转到登录页面，输入账号密码登录即可：    \n\n用户名：root  密码：a1234567    \n \n登录成功后看到：    \n\n{%asset_img a-1.png%} \n\n### 设置系统语言\n\n切换到官方镜像之后， 中文设置方法： 依次点击工具栏最右侧用户头像 》 Settings 》 Preferred language ， 然后选择 简体中文 即可。\n\n### git参考访问地址\n\n    # HTTP\n    http://172.16.81.81/root/test-docker-gitlab.git \n    # SSH \n    ssh://git@172.16.81.81:10022/root/test-docker-gitlab.git\n    \n### 升级\n\n### 中文社区版安装\n\n参考：https://hub.docker.com/r/beginor/gitlab-ce \n     ","slug":"gitlab-start","published":1,"updated":"2019-08-03T16:12:21.307Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqc10041g4vac2iz44aa","content":"<p>参考网址：<a href=\"https://about.gitlab.com/install/#centos-7\" target=\"_blank\" rel=\"noopener\">https://about.gitlab.com/install/#centos-7</a></p>\n<h2 id=\"快速安装gitlab\"><a href=\"#快速安装gitlab\" class=\"headerlink\" title=\"快速安装gitlab\"></a>快速安装gitlab</h2><p>1.安装相关依赖包：</p>\n<p>基础依赖：</p>\n<pre><code>sudo yum install -y curl policycoreutils-python openssh-server\nsudo systemctl enable sshd\nsudo systemctl start sshd\nsudo firewall-cmd --permanent --add-service=http\nsudo systemctl reload firewalld\n</code></pre><p>发送邮件依赖：</p>\n<pre><code>sudo yum install postfix\nsudo systemctl enable postfix\nsudo systemctl start postfix\n</code></pre><p>2.添加gitlab仓库uri并安装：</p>\n<p>添加安装包地址：</p>\n<p>安装包地址：<a href=\"https://packages.gitlab.com/gitlab/gitlab-ce\" target=\"_blank\" rel=\"noopener\">https://packages.gitlab.com/gitlab/gitlab-ce</a></p>\n<pre><code>curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash\n</code></pre><p> 安装：</p>\n<pre><code>sudo EXTERNAL_URL=&quot;http://gitlab.ymu.com&quot; yum install -y gitlab-ce\n</code></pre><h2 id=\"安装包rpm方式：\"><a href=\"#安装包rpm方式：\" class=\"headerlink\" title=\"安装包rpm方式：\"></a>安装包rpm方式：</h2><h4 id=\"1-和上面一样，安装依赖包。\"><a href=\"#1-和上面一样，安装依赖包。\" class=\"headerlink\" title=\"1.和上面一样，安装依赖包。\"></a>1.和上面一样，安装依赖包。</h4><h4 id=\"2-下载安装包：\"><a href=\"#2-下载安装包：\" class=\"headerlink\" title=\"2.下载安装包：\"></a>2.下载安装包：</h4><p>1.社区版本地址：<a href=\"https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm/download.rpm\" target=\"_blank\" rel=\"noopener\">https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm/download.rpm</a></p>\n<p>说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EL是Red Hat Enterprise Linux的简写 </span><br><span class=\"line\">- EL6软件包用于在Red Hat 6.x, CentOS 6.x, and CloudLinux 6.x进行安装 </span><br><span class=\"line\">- EL5软件包用于在Red Hat 5.x, CentOS 5.x, CloudLinux 5.x的安装 </span><br><span class=\"line\">- EL7 软件包用于在Red Hat 7.x, CentOS 7.x, and CloudLinux 7.x的安装</span><br></pre></td></tr></table></figure></p>\n<p>2.执行安装命令：</p>\n<pre><code>[root@xr-server vagrant]# rpm -ivh gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm \nwarning: gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID f27eab47: NOKEY\nPreparing...                          ################################# [100%]\nUpdating / installing...\n   1:gitlab-ce-11.3.12-ce.0.el7       ################################# [100%]\nIt looks like GitLab has not been configured yet; skipping the upgrade script.\n\n       *.                  *.\n      ***                 ***\n     *****               *****\n    .******             *******\n    ********            ********\n   ,,,,,,,,,***********,,,,,,,,,\n  ,,,,,,,,,,,*********,,,,,,,,,,,\n  .,,,,,,,,,,,*******,,,,,,,,,,,,\n      ,,,,,,,,,*****,,,,,,,,,.\n         ,,,,,,,****,,,,,,\n            .,,,***,,,,\n                ,*,.\n\n\n\n     _______ __  __          __\n    / ____(_) /_/ /   ____ _/ /_\n   / / __/ / __/ /   / __ `/ __ \\\n  / /_/ / / /_/ /___/ /_/ / /_/ /\n  \\____/_/\\__/_____/\\__,_/_.___/\n\n\nThank you for installing GitLab!\nGitLab was unable to detect a valid hostname for your instance.\nPlease configure a URL for your GitLab instance by setting `external_url`\nconfiguration in /etc/gitlab/gitlab.rb file.\nThen, you can start your GitLab instance by running the following command:\n  sudo gitlab-ctl reconfigure\n\nFor a comprehensive list of configuration options please see the Omnibus GitLab readme\nhttps://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md\n</code></pre><p>3.修改Gitlab访问URL配置:</p>\n<p>可以使用自定义域名，也可以直接IP地址+端口访问。</p>\n<p>编辑文件：</p>\n<pre><code>[root@xr-server ~]# cd /etc/gitlab/\n[root@xr-server gitlab]# ls\ngitlab.rb\n[root@xr-server gitlab]# vim gitlab.rb\n</code></pre><p>修改：</p>\n<pre><code>#external_url &apos;http://gitlab.example.com&apos;\nexternal_url &apos;http://192.168.10.31:8080&apos;\n</code></pre><p>这样就以ip+端口方式访问。</p>\n<p>4.重置并启动Gitlab</p>\n<pre><code>sudo gitlab-ctl reconfigure\nsudo gitlab-ctl start\n</code></pre><p>5.停止</p>\n<pre><code>sudo gitlab-ctl stop\n</code></pre><p>6.重启</p>\n<pre><code>sudo gitlab-ctl restart\n</code></pre><h2 id=\"docker环境安装gitlab\"><a href=\"#docker环境安装gitlab\" class=\"headerlink\" title=\"docker环境安装gitlab\"></a>docker环境安装gitlab</h2><p>参考：<a href=\"https://docs.gitlab.com/omnibus/docker/\" target=\"_blank\" rel=\"noopener\">https://docs.gitlab.com/omnibus/docker/</a> </p>\n<h3 id=\"启动gitlab容器服务\"><a href=\"#启动gitlab容器服务\" class=\"headerlink\" title=\"启动gitlab容器服务\"></a>启动gitlab容器服务</h3><p>1.查看系统是否开启了SELinux  </p>\n<pre><code>/usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态\n</code></pre><p>2.启动gitlab ce容器</p>\n<p>如果SELinux是开启的，则执行：  </p>\n<pre><code>sudo docker run --detach \\\n    --hostname gitlab.example.com \\\n    --publish 443:443 --publish 80:80 --publish 10022:22 \\\n    --name gitlab \\\n    --restart always \\\n    --volume /srv/gitlab/config:/etc/gitlab:Z \\\n    --volume /srv/gitlab/logs:/var/log/gitlab:Z \\\n    --volume /srv/gitlab/data:/var/opt/gitlab:Z \\\n    gitlab/gitlab-ce:latest      \n</code></pre><p>这样才能确保容器进程拥有足够权限，在卷上创建相关的配置文件。</p>\n<p>如果SELinux是关闭的，则执行：  </p>\n<pre><code>sudo docker run --detach \\\n    --hostname gitlab.example.com \\\n    --publish 443:443 --publish 80:80 --publish 10022:22 \\\n    --name gitlab \\\n    --restart always \\\n    --volume /srv/gitlab/config:/etc/gitlab \\\n    --volume /srv/gitlab/logs:/var/log/gitlab \\\n    --volume /srv/gitlab/data:/var/opt/gitlab \\\n    gitlab/gitlab-ce:latest\n</code></pre><p><em>注意：</em>   </p>\n<p>宿主机22端口一般会被占用，所以映射到别的端口，这里映射到10022端口，后面修改配置即可。</p>\n<p>映射到宿主机任意端口：</p>\n<pre><code>sudo docker run --detach \\\n  --hostname gitlab.example.com \\\n  --publish 8929:80 --publish 2289:22 \\\n  --name gitlab \\\n  --restart always \\\n  --volume /srv/gitlab/config:/etc/gitlab \\\n  --volume /srv/gitlab/logs:/var/log/gitlab \\\n  --volume /srv/gitlab/data:/var/opt/gitlab \\\n  gitlab/gitlab-ce:latest \n</code></pre><h3 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h3><p>容器成功执行后面，会在映射目录/srv/gitlab/config/目录下生成一个配置文件gitlab.rb。     </p>\n<p>编辑gitlab.rb文件</p>\n<p><code>vim /srv/gitlab/config/gitlab.rb</code></p>\n<p>1.设置<code>external_url</code>:   </p>\n<pre><code># 配置http协议所使用的访问地址\n#external_url &apos;gitlab.example.com:端口&apos;\nexternal_url &apos;http://172.16.81.81:端口&apos;\n\nor\n\n# For HTTPS (notice the https)\n#external_url &quot;https://gitlab.example.com:端口&quot;\nexternal_url &apos;https://172.16.81.81:端口&apos;\n</code></pre><p>2.设置<code>gitlab_shell_ssh_port</code>:</p>\n<pre><code># 配置ssh协议所使用的访问地址和端口\n#gitlab_rails[&apos;gitlab_ssh_host&apos;] = &apos;gitlab.example.com&apos;\ngitlab_rails[&apos;gitlab_ssh_host&apos;] = &apos;172.16.81.81&apos;\ngitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 2289\n</code></pre><p>配置邮件发送  </p>\n<p><a href=\"https://docs.gitlab.com/omnibus/settings/smtp.html\" target=\"_blank\" rel=\"noopener\">https://docs.gitlab.com/omnibus/settings/smtp.html</a></p>\n<p>里面有各家邮件配置，包括腾讯qq企业邮箱的配置。</p>\n<pre><code>vim /opt/gitlab/config/gitlab.rb\n# 这里以新浪的邮箱为例配置smtp服务器\ngitlab_rails[&apos;smtp_enable&apos;] = true\ngitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.xxx.com&quot;\ngitlab_rails[&apos;smtp_port&apos;] = 25\ngitlab_rails[&apos;smtp_user_name&apos;] = &quot;name4mail&quot;\ngitlab_rails[&apos;smtp_password&apos;] = &quot;passwd4mail&quot;\ngitlab_rails[&apos;smtp_domain&apos;] = &quot;xxx.com&quot;\ngitlab_rails[&apos;smtp_authentication&apos;] = :login\ngitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true\n\n# 还有个需要注意的地方是指定发送邮件所用的邮箱，这个要和上面配置的邮箱一致\ngitlab_rails[&apos;gitlab_email_from&apos;] = &apos;name4mail@xxx.com&apos;\n\n-----------------------------------------------------------------------------\n腾讯qq企业邮箱\n\ngitlab_rails[&apos;smtp_enable&apos;] = true\ngitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.exmail.qq.com&quot;\ngitlab_rails[&apos;smtp_port&apos;] = 465\ngitlab_rails[&apos;smtp_user_name&apos;] = &quot;zhangmutian@xcsqjr.com&quot;\ngitlab_rails[&apos;smtp_password&apos;] = &quot;password&quot;\ngitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;\ngitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true\ngitlab_rails[&apos;smtp_tls&apos;] = true\ngitlab_rails[&apos;gitlab_email_from&apos;] = &apos;zhangmutian@xcsqjr.com&apos;\ngitlab_rails[&apos;smtp_domain&apos;] = &quot;exmail.qq.com&quot;\n</code></pre><p>修改gitlab.rb配置文件之后，重启容器。</p>\n<pre><code>docker restart gitlab\n\n# 进入容器\ndocker exec -it gitlab bash\n\n# 重启gitlab\ngitlab-ctl reconfigure\n</code></pre><p><em>提醒：</em><br>上面三个步骤不可少，特别是要进入容器重启配置。如果只是重启容器，访问报502。</p>\n<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><p>浏览器打开：<a href=\"http://192.168.33.10/\" target=\"_blank\" rel=\"noopener\">http://192.168.33.10/</a></p>\n<p>初始页面要求先改密码，密码改为：a1234567    </p>\n<p>修改成功会跳转到登录页面，输入账号密码登录即可：    </p>\n<p>用户名：root  密码：a1234567    </p>\n<p>登录成功后看到：    </p>\n<img src=\"/2018/12/11/gitlab-start/a-1.png\"> \n<h3 id=\"设置系统语言\"><a href=\"#设置系统语言\" class=\"headerlink\" title=\"设置系统语言\"></a>设置系统语言</h3><p>切换到官方镜像之后， 中文设置方法： 依次点击工具栏最右侧用户头像 》 Settings 》 Preferred language ， 然后选择 简体中文 即可。</p>\n<h3 id=\"git参考访问地址\"><a href=\"#git参考访问地址\" class=\"headerlink\" title=\"git参考访问地址\"></a>git参考访问地址</h3><pre><code># HTTP\nhttp://172.16.81.81/root/test-docker-gitlab.git \n# SSH \nssh://git@172.16.81.81:10022/root/test-docker-gitlab.git\n</code></pre><h3 id=\"升级\"><a href=\"#升级\" class=\"headerlink\" title=\"升级\"></a>升级</h3><h3 id=\"中文社区版安装\"><a href=\"#中文社区版安装\" class=\"headerlink\" title=\"中文社区版安装\"></a>中文社区版安装</h3><p>参考：<a href=\"https://hub.docker.com/r/beginor/gitlab-ce\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/r/beginor/gitlab-ce</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考网址：<a href=\"https://about.gitlab.com/install/#centos-7\" target=\"_blank\" rel=\"noopener\">https://about.gitlab.com/install/#centos-7</a></p>\n<h2 id=\"快速安装gitlab\"><a href=\"#快速安装gitlab\" class=\"headerlink\" title=\"快速安装gitlab\"></a>快速安装gitlab</h2><p>1.安装相关依赖包：</p>\n<p>基础依赖：</p>\n<pre><code>sudo yum install -y curl policycoreutils-python openssh-server\nsudo systemctl enable sshd\nsudo systemctl start sshd\nsudo firewall-cmd --permanent --add-service=http\nsudo systemctl reload firewalld\n</code></pre><p>发送邮件依赖：</p>\n<pre><code>sudo yum install postfix\nsudo systemctl enable postfix\nsudo systemctl start postfix\n</code></pre><p>2.添加gitlab仓库uri并安装：</p>\n<p>添加安装包地址：</p>\n<p>安装包地址：<a href=\"https://packages.gitlab.com/gitlab/gitlab-ce\" target=\"_blank\" rel=\"noopener\">https://packages.gitlab.com/gitlab/gitlab-ce</a></p>\n<pre><code>curl -s https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.rpm.sh | sudo bash\n</code></pre><p> 安装：</p>\n<pre><code>sudo EXTERNAL_URL=&quot;http://gitlab.ymu.com&quot; yum install -y gitlab-ce\n</code></pre><h2 id=\"安装包rpm方式：\"><a href=\"#安装包rpm方式：\" class=\"headerlink\" title=\"安装包rpm方式：\"></a>安装包rpm方式：</h2><h4 id=\"1-和上面一样，安装依赖包。\"><a href=\"#1-和上面一样，安装依赖包。\" class=\"headerlink\" title=\"1.和上面一样，安装依赖包。\"></a>1.和上面一样，安装依赖包。</h4><h4 id=\"2-下载安装包：\"><a href=\"#2-下载安装包：\" class=\"headerlink\" title=\"2.下载安装包：\"></a>2.下载安装包：</h4><p>1.社区版本地址：<a href=\"https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm/download.rpm\" target=\"_blank\" rel=\"noopener\">https://packages.gitlab.com/gitlab/gitlab-ce/packages/el/7/gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm/download.rpm</a></p>\n<p>说明：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EL是Red Hat Enterprise Linux的简写 </span><br><span class=\"line\">- EL6软件包用于在Red Hat 6.x, CentOS 6.x, and CloudLinux 6.x进行安装 </span><br><span class=\"line\">- EL5软件包用于在Red Hat 5.x, CentOS 5.x, CloudLinux 5.x的安装 </span><br><span class=\"line\">- EL7 软件包用于在Red Hat 7.x, CentOS 7.x, and CloudLinux 7.x的安装</span><br></pre></td></tr></table></figure></p>\n<p>2.执行安装命令：</p>\n<pre><code>[root@xr-server vagrant]# rpm -ivh gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm \nwarning: gitlab-ce-11.3.12-ce.0.el7.x86_64.rpm: Header V4 RSA/SHA1 Signature, key ID f27eab47: NOKEY\nPreparing...                          ################################# [100%]\nUpdating / installing...\n   1:gitlab-ce-11.3.12-ce.0.el7       ################################# [100%]\nIt looks like GitLab has not been configured yet; skipping the upgrade script.\n\n       *.                  *.\n      ***                 ***\n     *****               *****\n    .******             *******\n    ********            ********\n   ,,,,,,,,,***********,,,,,,,,,\n  ,,,,,,,,,,,*********,,,,,,,,,,,\n  .,,,,,,,,,,,*******,,,,,,,,,,,,\n      ,,,,,,,,,*****,,,,,,,,,.\n         ,,,,,,,****,,,,,,\n            .,,,***,,,,\n                ,*,.\n\n\n\n     _______ __  __          __\n    / ____(_) /_/ /   ____ _/ /_\n   / / __/ / __/ /   / __ `/ __ \\\n  / /_/ / / /_/ /___/ /_/ / /_/ /\n  \\____/_/\\__/_____/\\__,_/_.___/\n\n\nThank you for installing GitLab!\nGitLab was unable to detect a valid hostname for your instance.\nPlease configure a URL for your GitLab instance by setting `external_url`\nconfiguration in /etc/gitlab/gitlab.rb file.\nThen, you can start your GitLab instance by running the following command:\n  sudo gitlab-ctl reconfigure\n\nFor a comprehensive list of configuration options please see the Omnibus GitLab readme\nhttps://gitlab.com/gitlab-org/omnibus-gitlab/blob/master/README.md\n</code></pre><p>3.修改Gitlab访问URL配置:</p>\n<p>可以使用自定义域名，也可以直接IP地址+端口访问。</p>\n<p>编辑文件：</p>\n<pre><code>[root@xr-server ~]# cd /etc/gitlab/\n[root@xr-server gitlab]# ls\ngitlab.rb\n[root@xr-server gitlab]# vim gitlab.rb\n</code></pre><p>修改：</p>\n<pre><code>#external_url &apos;http://gitlab.example.com&apos;\nexternal_url &apos;http://192.168.10.31:8080&apos;\n</code></pre><p>这样就以ip+端口方式访问。</p>\n<p>4.重置并启动Gitlab</p>\n<pre><code>sudo gitlab-ctl reconfigure\nsudo gitlab-ctl start\n</code></pre><p>5.停止</p>\n<pre><code>sudo gitlab-ctl stop\n</code></pre><p>6.重启</p>\n<pre><code>sudo gitlab-ctl restart\n</code></pre><h2 id=\"docker环境安装gitlab\"><a href=\"#docker环境安装gitlab\" class=\"headerlink\" title=\"docker环境安装gitlab\"></a>docker环境安装gitlab</h2><p>参考：<a href=\"https://docs.gitlab.com/omnibus/docker/\" target=\"_blank\" rel=\"noopener\">https://docs.gitlab.com/omnibus/docker/</a> </p>\n<h3 id=\"启动gitlab容器服务\"><a href=\"#启动gitlab容器服务\" class=\"headerlink\" title=\"启动gitlab容器服务\"></a>启动gitlab容器服务</h3><p>1.查看系统是否开启了SELinux  </p>\n<pre><code>/usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态\n</code></pre><p>2.启动gitlab ce容器</p>\n<p>如果SELinux是开启的，则执行：  </p>\n<pre><code>sudo docker run --detach \\\n    --hostname gitlab.example.com \\\n    --publish 443:443 --publish 80:80 --publish 10022:22 \\\n    --name gitlab \\\n    --restart always \\\n    --volume /srv/gitlab/config:/etc/gitlab:Z \\\n    --volume /srv/gitlab/logs:/var/log/gitlab:Z \\\n    --volume /srv/gitlab/data:/var/opt/gitlab:Z \\\n    gitlab/gitlab-ce:latest      \n</code></pre><p>这样才能确保容器进程拥有足够权限，在卷上创建相关的配置文件。</p>\n<p>如果SELinux是关闭的，则执行：  </p>\n<pre><code>sudo docker run --detach \\\n    --hostname gitlab.example.com \\\n    --publish 443:443 --publish 80:80 --publish 10022:22 \\\n    --name gitlab \\\n    --restart always \\\n    --volume /srv/gitlab/config:/etc/gitlab \\\n    --volume /srv/gitlab/logs:/var/log/gitlab \\\n    --volume /srv/gitlab/data:/var/opt/gitlab \\\n    gitlab/gitlab-ce:latest\n</code></pre><p><em>注意：</em>   </p>\n<p>宿主机22端口一般会被占用，所以映射到别的端口，这里映射到10022端口，后面修改配置即可。</p>\n<p>映射到宿主机任意端口：</p>\n<pre><code>sudo docker run --detach \\\n  --hostname gitlab.example.com \\\n  --publish 8929:80 --publish 2289:22 \\\n  --name gitlab \\\n  --restart always \\\n  --volume /srv/gitlab/config:/etc/gitlab \\\n  --volume /srv/gitlab/logs:/var/log/gitlab \\\n  --volume /srv/gitlab/data:/var/opt/gitlab \\\n  gitlab/gitlab-ce:latest \n</code></pre><h3 id=\"修改配置\"><a href=\"#修改配置\" class=\"headerlink\" title=\"修改配置\"></a>修改配置</h3><p>容器成功执行后面，会在映射目录/srv/gitlab/config/目录下生成一个配置文件gitlab.rb。     </p>\n<p>编辑gitlab.rb文件</p>\n<p><code>vim /srv/gitlab/config/gitlab.rb</code></p>\n<p>1.设置<code>external_url</code>:   </p>\n<pre><code># 配置http协议所使用的访问地址\n#external_url &apos;gitlab.example.com:端口&apos;\nexternal_url &apos;http://172.16.81.81:端口&apos;\n\nor\n\n# For HTTPS (notice the https)\n#external_url &quot;https://gitlab.example.com:端口&quot;\nexternal_url &apos;https://172.16.81.81:端口&apos;\n</code></pre><p>2.设置<code>gitlab_shell_ssh_port</code>:</p>\n<pre><code># 配置ssh协议所使用的访问地址和端口\n#gitlab_rails[&apos;gitlab_ssh_host&apos;] = &apos;gitlab.example.com&apos;\ngitlab_rails[&apos;gitlab_ssh_host&apos;] = &apos;172.16.81.81&apos;\ngitlab_rails[&apos;gitlab_shell_ssh_port&apos;] = 2289\n</code></pre><p>配置邮件发送  </p>\n<p><a href=\"https://docs.gitlab.com/omnibus/settings/smtp.html\" target=\"_blank\" rel=\"noopener\">https://docs.gitlab.com/omnibus/settings/smtp.html</a></p>\n<p>里面有各家邮件配置，包括腾讯qq企业邮箱的配置。</p>\n<pre><code>vim /opt/gitlab/config/gitlab.rb\n# 这里以新浪的邮箱为例配置smtp服务器\ngitlab_rails[&apos;smtp_enable&apos;] = true\ngitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.xxx.com&quot;\ngitlab_rails[&apos;smtp_port&apos;] = 25\ngitlab_rails[&apos;smtp_user_name&apos;] = &quot;name4mail&quot;\ngitlab_rails[&apos;smtp_password&apos;] = &quot;passwd4mail&quot;\ngitlab_rails[&apos;smtp_domain&apos;] = &quot;xxx.com&quot;\ngitlab_rails[&apos;smtp_authentication&apos;] = :login\ngitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true\n\n# 还有个需要注意的地方是指定发送邮件所用的邮箱，这个要和上面配置的邮箱一致\ngitlab_rails[&apos;gitlab_email_from&apos;] = &apos;name4mail@xxx.com&apos;\n\n-----------------------------------------------------------------------------\n腾讯qq企业邮箱\n\ngitlab_rails[&apos;smtp_enable&apos;] = true\ngitlab_rails[&apos;smtp_address&apos;] = &quot;smtp.exmail.qq.com&quot;\ngitlab_rails[&apos;smtp_port&apos;] = 465\ngitlab_rails[&apos;smtp_user_name&apos;] = &quot;zhangmutian@xcsqjr.com&quot;\ngitlab_rails[&apos;smtp_password&apos;] = &quot;password&quot;\ngitlab_rails[&apos;smtp_authentication&apos;] = &quot;login&quot;\ngitlab_rails[&apos;smtp_enable_starttls_auto&apos;] = true\ngitlab_rails[&apos;smtp_tls&apos;] = true\ngitlab_rails[&apos;gitlab_email_from&apos;] = &apos;zhangmutian@xcsqjr.com&apos;\ngitlab_rails[&apos;smtp_domain&apos;] = &quot;exmail.qq.com&quot;\n</code></pre><p>修改gitlab.rb配置文件之后，重启容器。</p>\n<pre><code>docker restart gitlab\n\n# 进入容器\ndocker exec -it gitlab bash\n\n# 重启gitlab\ngitlab-ctl reconfigure\n</code></pre><p><em>提醒：</em><br>上面三个步骤不可少，特别是要进入容器重启配置。如果只是重启容器，访问报502。</p>\n<h3 id=\"登录\"><a href=\"#登录\" class=\"headerlink\" title=\"登录\"></a>登录</h3><p>浏览器打开：<a href=\"http://192.168.33.10/\" target=\"_blank\" rel=\"noopener\">http://192.168.33.10/</a></p>\n<p>初始页面要求先改密码，密码改为：a1234567    </p>\n<p>修改成功会跳转到登录页面，输入账号密码登录即可：    </p>\n<p>用户名：root  密码：a1234567    </p>\n<p>登录成功后看到：    </p>\n<img src=\"/2018/12/11/gitlab-start/a-1.png\"> \n<h3 id=\"设置系统语言\"><a href=\"#设置系统语言\" class=\"headerlink\" title=\"设置系统语言\"></a>设置系统语言</h3><p>切换到官方镜像之后， 中文设置方法： 依次点击工具栏最右侧用户头像 》 Settings 》 Preferred language ， 然后选择 简体中文 即可。</p>\n<h3 id=\"git参考访问地址\"><a href=\"#git参考访问地址\" class=\"headerlink\" title=\"git参考访问地址\"></a>git参考访问地址</h3><pre><code># HTTP\nhttp://172.16.81.81/root/test-docker-gitlab.git \n# SSH \nssh://git@172.16.81.81:10022/root/test-docker-gitlab.git\n</code></pre><h3 id=\"升级\"><a href=\"#升级\" class=\"headerlink\" title=\"升级\"></a>升级</h3><h3 id=\"中文社区版安装\"><a href=\"#中文社区版安装\" class=\"headerlink\" title=\"中文社区版安装\"></a>中文社区版安装</h3><p>参考：<a href=\"https://hub.docker.com/r/beginor/gitlab-ce\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/r/beginor/gitlab-ce</a> </p>\n"},{"title":"文件存储系统glusterfs入门","date":"2018-12-26T07:33:44.000Z","_content":"    \n参考地址：https://www.gluster.org \n\nhttps://my.oschina.net/hncscwc/blog/210072\n\n## 原理\n\n\n## 准备工作\n\n用三个节点搭建一个glusterfs集群，一个节点作为客户端使用。新建四个虚拟机(centos7)：   \n并编辑`etc/hosts`\n\n     glusterfs服务器节点：  \n     192.168.200.10  server-node1   # 主节点\n     192.168.200.11  server-node2   # 从节点\n     192.168.200.12  server-node3   # 从节点 \n    \n     client节点：   \n     172.29.41.163 phn centos7\n\n然后在每个机子互相ping，确保网络通畅：\n\n在server-node1服务器执行： \n\n       # ping server-node2\n       # ping server-node3 \n       \n其它机子同理，都ping下，保证互相通讯。\n\n\n### 开始安装GlusterFS\n\n####　安装服务\n\n1.在每个服务节点安装：\n\n    $ yum install -y centos-release-gluster\n    $ yum install -y glusterfs glusterfs-server \n    $ yum install -y glusterfs-fuse glusterfs-rdma\n    \n2.设置服务开机自启动：  \n\n    $ systemctl start glusterd.service && systemctl enable glusterd.service\n    \n    \n#### 配置集群\n\n1.首先启动服务（每个节点都启动）\n\n    systemctl start glusterd.service \n    systemctl enable glusterd.service\n    \n2.关闭每个节点服务器的防火墙 \n\n    systemctl stop firewalld.service \n    systemctl disable firewalld.service\n    \n3.在主节点中把另外两个从节点添加到集群    \n\n    gluster peer probe server-node1 \n    gluster peer probe server-node2\n    \n4.从集群中删除节点（在主节点服务器执行）\n\n    $ gluster peer detach 192.168.200.12\n    \n可以从任意GFS Server节点上删除集群中的其它节点，但不能删除执行命令时的当前节点。\n\n6.查看集群状态\n\n在任意服务节点执行：  \n\n    [root@server-node1 ~]# gluster peer status\n    Number of Peers: 2\n    \n    Hostname: server-node2\n    Uuid: 34bddd2b-4f4c-4b4b-afcd-786a6ba2c13d\n    State: Peer in Cluster (Connected)\n    \n    Hostname: server-node3\n    Uuid: 81101ab4-bcdc-467a-9fae-96d997a75fdc\n    State: Peer in Cluster (Connected)\n\n    ---------------------------------------------\n\n    [root@server-node2 ~]# gluster peer status\n    Number of Peers: 2\n    \n    Hostname: server-node1\n    Uuid: d34a54a8-24bc-43ff-95fc-fe0b6d5c52fa\n    State: Peer in Cluster (Connected)\n    Other names:\n    192.168.200.10\n    \n    Hostname: server-node3\n    Uuid: 81101ab4-bcdc-467a-9fae-96d997a75fdc\n    State: Peer in Cluster (Connected)\n    \n    ----------------------------------------------\n    \n    [root@server-node3 ~]# gluster peer status\n    Number of Peers: 2\n    \n    Hostname: server-node1\n    Uuid: d34a54a8-24bc-43ff-95fc-fe0b6d5c52fa\n    State: Peer in Cluster (Connected)\n    Other names:\n    server-node1\n    \n    Hostname: server-node2\n    Uuid: 34bddd2b-4f4c-4b4b-afcd-786a6ba2c13d\n    State: Peer in Cluster (Connected)\n    \n在每个节点，可以看到另外的另个节点。\n\n7.创建数据存储目录（每个节点服务都要创建）\n\n    mkdir -p /data/gluster/exp1\n    \n8.创建卷，GFS Volume\n  \n在任意服务节点上执行如下命令：   \n\n    gluster volume create models replica 3 server-node1:/data/gluster/exp1 server-node2:/data/gluster/exp1 server-node3:/data/gluster/exp1 force    \n    \n    ------------------------------------------\n    [root@server-node1 gluster]# gluster volume create models replica 3 server-node1:/data/gluster/exp1 server-node2:/data/gluster/exp1 server-node3:/data/gluster/exp1 force\n    volume create: models: success: please start the volume to access data\n    \n> _说明_:   \nmodels: 卷的名称    \nreplica 3: 表明存储3个备份，后面指定服务器的存储目录    \n    \n- 查看volume 状态    \n在任意服务节点执行：  \n\n\n    gluster volume info     \n    \n    ------------------------------------------------------------\n    \n    [root@server-node2 ~]# gluster volume info\n     \n    Volume Name: models\n    Type: Replicate\n    Volume ID: 45d12287-2dfa-42be-954b-97c014d189c4\n    Status: Created\n    Snapshot Count: 0\n    Number of Bricks: 1 x 3 = 3\n    Transport-type: tcp\n    Bricks:\n    Brick1: server-node1:/data/gluster/exp1\n    Brick2: server-node2:/data/gluster/exp1\n    Brick3: server-node3:/data/gluster/exp1\n    Options Reconfigured:\n    transport.address-family: inet\n    nfs.disable: on\n    performance.client-io-threads: off\n    \n8.启动卷   \n启动名为models的数据卷，在任意一个服务节点上执行即可：   \n  \n    gluster volume start models    \n    \n重新查看卷信息，会看到卷的状态status变为Started。代表卷已经启动成功。   \n\n## 配置 GFS Client\n\nhttps://docs.gluster.org/en/latest/Administrator%20Guide/Setting%20Up%20Clients/\n\nGFS客户端的节点必须和各个服务节点网络连通。ping命令检查。\n\n1.安装客户端\n\n    $ yum install -y glusterfs glusterfs-fuse glusterfs-rdma\n    \n2.将客户端目录挂载到GFS服务的volume \n\n- 在gluster客户节点创建本地目录：   \n\n        $ mkdir -p /data/gluster/dt1\n  \n- 将本地目录挂载到GFS Volume：\n\n        mount -t glusterfs 192.168.200.10:models /data/gluster/dt1\n        \n>参数说明：   \n192.168.200.10： 指的是GFS服务主节点的ip，一定是主节点。\nmodels： 指上面创建的GFS每个服务上的卷（volume）名称。   \n/data/gluster/dt1: 客户端的本地目录，要挂载的目录。        \n\n_注意_:   \n上面挂载客户端目录到服务卷的命令可能不成功，这是因为用的是ip的原因，得把主节点的ip改成域名才行。因此，现在客户节点配置hosts。     \n编辑`/etc/hosts`： \n\n    192.168.200.10  server-node1  #GFS Server主节点\n    \n然后重新挂载：\n\n      mount -t glusterfs server-node1:models /data/gluster/dt1      \n\n挂载成功。\n\n3.查看挂载\n\n    [root@gluster-client1 dt1]# df -h\n    Filesystem                       Size  Used Avail Use% Mounted on\n    /dev/mapper/VolGroup00-LogVol00   38G  3.3G   35G   9% /\n    devtmpfs                         910M     0  910M   0% /dev\n    tmpfs                            920M     0  920M   0% /dev/shm\n    tmpfs                            920M  8.6M  911M   1% /run\n    tmpfs                            920M     0  920M   0% /sys/fs/cgroup\n    /dev/sda2                       1014M   63M  952M   7% /boot\n    tmpfs                            184M     0  184M   0% /run/user/1000\n    tmpfs                            184M     0  184M   0% /run/user/0\n    server-node1:models               40G  3.4G   35G   9% /data/gluster/dt1\n    \n可以看到，最后一个文件系统，就是我们挂载的。\n        \n4.测试上传文件    \n在客户机执行上传文件命令：   \n\n    [root@gluster-client1 dt1]# time dd if=/dev/zero of=/data/gluster/dt1/hello bs=100M count=1\n    1+0 records in\n    1+0 records out\n    104857600 bytes (105 MB) copied, 5.37804 s, 19.5 MB/s\n    \n    real\t0m5.395s\n    user\t0m0.001s\n    sys\t0m0.182s\n    [root@gluster-client1 dt1]# ls\n    [root@gluster-client1 dt1]#    \n \n查看GFS Server各个节点对应的卷，以及客户节点的本地目录：\n\n    [root@server-node1 exp1]# pwd\n    /data/gluster/exp1\n    [root@server-node1 exp1]# ls\n    hello\n    \n都能看到一个hello的文件。说明的确按我们预期，有三份的文件数据，分别在三个服务节点上存储了。同时在客户端节点也有一份。    \n    \n5.继续测试  \n随便在客户节点本地目录下，创建文件`touch a`，然后查看各个服务节点，会发现，客户节点的a文件已经同步到三个服务的对应卷下了，编辑客户节点的a文件，各个服务节点对应的a文件也会相应改变。这说明了它们是一直同步的。      \n\n\n## GFS性能调优\n\n- 开启指定volume的配额： (models为volume名称)\n\n \n    gluster volume quota models enable\n    \n- 限制models中 / (既总目录)最大使用80GB空间  \n\n   \n    gluster volume quota models limit-usage / 80GB   \n    \n- 设置 cache 大小(此处要根据实际情况，如果设置太大可能导致后面客户端挂载失败) \n\n\n    gluster volume set models performance.cache-size 512MB\n    \n- 开启异步，后台操作  \n\n    \n    gluster volume set models performance.flush-behind on\n    \n- 设置 io 线程 32 \n\n\n    gluster volume set models performance.io-thread-count 32\n    \n- 设置 回写 (写数据时间，先写入缓存内，再写入硬盘)\n\n    \n    gluster volume set models performance.write-behind on\n    \n- 调优之后的volume信息\n\n\n    gluster volume info\n    \n然后试下再上传文件，看是否快很多呢。                      \n\n## 其它命令\n\n### 查看所volume（卷）\n\n    gluster volume list\n    \n### 删除volume（卷）\n\n    gluster volume stop models //停止名字为 models 的磁盘 \n    gluster volume delete models //删除名字为 models 的磁盘   \n\n\n### 卸载GlusterFS磁盘\n\n    -->gluster peer detach glusterfs4\n    \n### ACL访问控制\n\n    -->gluster volume set models auth.allow 192.168.56.*,10.0.1.*\n\n    volume set: success\n\n\n### 添加GlusterFS节点\n    -->gluster peer probe sc2-log5\n    -->gluster peer probe sc2-log6\n    -->gluster volume add-brick models sc2-log5:/data/gluster sc2-log6:/data/gluster\n\n### 迁移GlusterFS数据\n\n    -->gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models start\n    -->gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models status\n    -->gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models commit\n\n### 修复GlusterFS数据(在节点1宕机的情况下)\n\n    -->gluster volume replace-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models commit -force\n    -->gluster volume heal models full                      ","source":"_posts/glusterfs-start-install.md","raw":"---\ntitle: 文件存储系统glusterfs入门\ndate: 2018-12-26 15:33:44\ncategories: 文件存储系统\ntags: \n---\n    \n参考地址：https://www.gluster.org \n\nhttps://my.oschina.net/hncscwc/blog/210072\n\n## 原理\n\n\n## 准备工作\n\n用三个节点搭建一个glusterfs集群，一个节点作为客户端使用。新建四个虚拟机(centos7)：   \n并编辑`etc/hosts`\n\n     glusterfs服务器节点：  \n     192.168.200.10  server-node1   # 主节点\n     192.168.200.11  server-node2   # 从节点\n     192.168.200.12  server-node3   # 从节点 \n    \n     client节点：   \n     172.29.41.163 phn centos7\n\n然后在每个机子互相ping，确保网络通畅：\n\n在server-node1服务器执行： \n\n       # ping server-node2\n       # ping server-node3 \n       \n其它机子同理，都ping下，保证互相通讯。\n\n\n### 开始安装GlusterFS\n\n####　安装服务\n\n1.在每个服务节点安装：\n\n    $ yum install -y centos-release-gluster\n    $ yum install -y glusterfs glusterfs-server \n    $ yum install -y glusterfs-fuse glusterfs-rdma\n    \n2.设置服务开机自启动：  \n\n    $ systemctl start glusterd.service && systemctl enable glusterd.service\n    \n    \n#### 配置集群\n\n1.首先启动服务（每个节点都启动）\n\n    systemctl start glusterd.service \n    systemctl enable glusterd.service\n    \n2.关闭每个节点服务器的防火墙 \n\n    systemctl stop firewalld.service \n    systemctl disable firewalld.service\n    \n3.在主节点中把另外两个从节点添加到集群    \n\n    gluster peer probe server-node1 \n    gluster peer probe server-node2\n    \n4.从集群中删除节点（在主节点服务器执行）\n\n    $ gluster peer detach 192.168.200.12\n    \n可以从任意GFS Server节点上删除集群中的其它节点，但不能删除执行命令时的当前节点。\n\n6.查看集群状态\n\n在任意服务节点执行：  \n\n    [root@server-node1 ~]# gluster peer status\n    Number of Peers: 2\n    \n    Hostname: server-node2\n    Uuid: 34bddd2b-4f4c-4b4b-afcd-786a6ba2c13d\n    State: Peer in Cluster (Connected)\n    \n    Hostname: server-node3\n    Uuid: 81101ab4-bcdc-467a-9fae-96d997a75fdc\n    State: Peer in Cluster (Connected)\n\n    ---------------------------------------------\n\n    [root@server-node2 ~]# gluster peer status\n    Number of Peers: 2\n    \n    Hostname: server-node1\n    Uuid: d34a54a8-24bc-43ff-95fc-fe0b6d5c52fa\n    State: Peer in Cluster (Connected)\n    Other names:\n    192.168.200.10\n    \n    Hostname: server-node3\n    Uuid: 81101ab4-bcdc-467a-9fae-96d997a75fdc\n    State: Peer in Cluster (Connected)\n    \n    ----------------------------------------------\n    \n    [root@server-node3 ~]# gluster peer status\n    Number of Peers: 2\n    \n    Hostname: server-node1\n    Uuid: d34a54a8-24bc-43ff-95fc-fe0b6d5c52fa\n    State: Peer in Cluster (Connected)\n    Other names:\n    server-node1\n    \n    Hostname: server-node2\n    Uuid: 34bddd2b-4f4c-4b4b-afcd-786a6ba2c13d\n    State: Peer in Cluster (Connected)\n    \n在每个节点，可以看到另外的另个节点。\n\n7.创建数据存储目录（每个节点服务都要创建）\n\n    mkdir -p /data/gluster/exp1\n    \n8.创建卷，GFS Volume\n  \n在任意服务节点上执行如下命令：   \n\n    gluster volume create models replica 3 server-node1:/data/gluster/exp1 server-node2:/data/gluster/exp1 server-node3:/data/gluster/exp1 force    \n    \n    ------------------------------------------\n    [root@server-node1 gluster]# gluster volume create models replica 3 server-node1:/data/gluster/exp1 server-node2:/data/gluster/exp1 server-node3:/data/gluster/exp1 force\n    volume create: models: success: please start the volume to access data\n    \n> _说明_:   \nmodels: 卷的名称    \nreplica 3: 表明存储3个备份，后面指定服务器的存储目录    \n    \n- 查看volume 状态    \n在任意服务节点执行：  \n\n\n    gluster volume info     \n    \n    ------------------------------------------------------------\n    \n    [root@server-node2 ~]# gluster volume info\n     \n    Volume Name: models\n    Type: Replicate\n    Volume ID: 45d12287-2dfa-42be-954b-97c014d189c4\n    Status: Created\n    Snapshot Count: 0\n    Number of Bricks: 1 x 3 = 3\n    Transport-type: tcp\n    Bricks:\n    Brick1: server-node1:/data/gluster/exp1\n    Brick2: server-node2:/data/gluster/exp1\n    Brick3: server-node3:/data/gluster/exp1\n    Options Reconfigured:\n    transport.address-family: inet\n    nfs.disable: on\n    performance.client-io-threads: off\n    \n8.启动卷   \n启动名为models的数据卷，在任意一个服务节点上执行即可：   \n  \n    gluster volume start models    \n    \n重新查看卷信息，会看到卷的状态status变为Started。代表卷已经启动成功。   \n\n## 配置 GFS Client\n\nhttps://docs.gluster.org/en/latest/Administrator%20Guide/Setting%20Up%20Clients/\n\nGFS客户端的节点必须和各个服务节点网络连通。ping命令检查。\n\n1.安装客户端\n\n    $ yum install -y glusterfs glusterfs-fuse glusterfs-rdma\n    \n2.将客户端目录挂载到GFS服务的volume \n\n- 在gluster客户节点创建本地目录：   \n\n        $ mkdir -p /data/gluster/dt1\n  \n- 将本地目录挂载到GFS Volume：\n\n        mount -t glusterfs 192.168.200.10:models /data/gluster/dt1\n        \n>参数说明：   \n192.168.200.10： 指的是GFS服务主节点的ip，一定是主节点。\nmodels： 指上面创建的GFS每个服务上的卷（volume）名称。   \n/data/gluster/dt1: 客户端的本地目录，要挂载的目录。        \n\n_注意_:   \n上面挂载客户端目录到服务卷的命令可能不成功，这是因为用的是ip的原因，得把主节点的ip改成域名才行。因此，现在客户节点配置hosts。     \n编辑`/etc/hosts`： \n\n    192.168.200.10  server-node1  #GFS Server主节点\n    \n然后重新挂载：\n\n      mount -t glusterfs server-node1:models /data/gluster/dt1      \n\n挂载成功。\n\n3.查看挂载\n\n    [root@gluster-client1 dt1]# df -h\n    Filesystem                       Size  Used Avail Use% Mounted on\n    /dev/mapper/VolGroup00-LogVol00   38G  3.3G   35G   9% /\n    devtmpfs                         910M     0  910M   0% /dev\n    tmpfs                            920M     0  920M   0% /dev/shm\n    tmpfs                            920M  8.6M  911M   1% /run\n    tmpfs                            920M     0  920M   0% /sys/fs/cgroup\n    /dev/sda2                       1014M   63M  952M   7% /boot\n    tmpfs                            184M     0  184M   0% /run/user/1000\n    tmpfs                            184M     0  184M   0% /run/user/0\n    server-node1:models               40G  3.4G   35G   9% /data/gluster/dt1\n    \n可以看到，最后一个文件系统，就是我们挂载的。\n        \n4.测试上传文件    \n在客户机执行上传文件命令：   \n\n    [root@gluster-client1 dt1]# time dd if=/dev/zero of=/data/gluster/dt1/hello bs=100M count=1\n    1+0 records in\n    1+0 records out\n    104857600 bytes (105 MB) copied, 5.37804 s, 19.5 MB/s\n    \n    real\t0m5.395s\n    user\t0m0.001s\n    sys\t0m0.182s\n    [root@gluster-client1 dt1]# ls\n    [root@gluster-client1 dt1]#    \n \n查看GFS Server各个节点对应的卷，以及客户节点的本地目录：\n\n    [root@server-node1 exp1]# pwd\n    /data/gluster/exp1\n    [root@server-node1 exp1]# ls\n    hello\n    \n都能看到一个hello的文件。说明的确按我们预期，有三份的文件数据，分别在三个服务节点上存储了。同时在客户端节点也有一份。    \n    \n5.继续测试  \n随便在客户节点本地目录下，创建文件`touch a`，然后查看各个服务节点，会发现，客户节点的a文件已经同步到三个服务的对应卷下了，编辑客户节点的a文件，各个服务节点对应的a文件也会相应改变。这说明了它们是一直同步的。      \n\n\n## GFS性能调优\n\n- 开启指定volume的配额： (models为volume名称)\n\n \n    gluster volume quota models enable\n    \n- 限制models中 / (既总目录)最大使用80GB空间  \n\n   \n    gluster volume quota models limit-usage / 80GB   \n    \n- 设置 cache 大小(此处要根据实际情况，如果设置太大可能导致后面客户端挂载失败) \n\n\n    gluster volume set models performance.cache-size 512MB\n    \n- 开启异步，后台操作  \n\n    \n    gluster volume set models performance.flush-behind on\n    \n- 设置 io 线程 32 \n\n\n    gluster volume set models performance.io-thread-count 32\n    \n- 设置 回写 (写数据时间，先写入缓存内，再写入硬盘)\n\n    \n    gluster volume set models performance.write-behind on\n    \n- 调优之后的volume信息\n\n\n    gluster volume info\n    \n然后试下再上传文件，看是否快很多呢。                      \n\n## 其它命令\n\n### 查看所volume（卷）\n\n    gluster volume list\n    \n### 删除volume（卷）\n\n    gluster volume stop models //停止名字为 models 的磁盘 \n    gluster volume delete models //删除名字为 models 的磁盘   \n\n\n### 卸载GlusterFS磁盘\n\n    -->gluster peer detach glusterfs4\n    \n### ACL访问控制\n\n    -->gluster volume set models auth.allow 192.168.56.*,10.0.1.*\n\n    volume set: success\n\n\n### 添加GlusterFS节点\n    -->gluster peer probe sc2-log5\n    -->gluster peer probe sc2-log6\n    -->gluster volume add-brick models sc2-log5:/data/gluster sc2-log6:/data/gluster\n\n### 迁移GlusterFS数据\n\n    -->gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models start\n    -->gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models status\n    -->gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models commit\n\n### 修复GlusterFS数据(在节点1宕机的情况下)\n\n    -->gluster volume replace-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models commit -force\n    -->gluster volume heal models full                      ","slug":"glusterfs-start-install","published":1,"updated":"2019-06-16T14:38:33.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqc20042g4va7qqc9imp","content":"<p>参考地址：<a href=\"https://www.gluster.org\" target=\"_blank\" rel=\"noopener\">https://www.gluster.org</a> </p>\n<p><a href=\"https://my.oschina.net/hncscwc/blog/210072\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/hncscwc/blog/210072</a></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>用三个节点搭建一个glusterfs集群，一个节点作为客户端使用。新建四个虚拟机(centos7)：<br>并编辑<code>etc/hosts</code></p>\n<pre><code>glusterfs服务器节点：  \n192.168.200.10  server-node1   # 主节点\n192.168.200.11  server-node2   # 从节点\n192.168.200.12  server-node3   # 从节点 \n\nclient节点：   \n172.29.41.163 phn centos7\n</code></pre><p>然后在每个机子互相ping，确保网络通畅：</p>\n<p>在server-node1服务器执行： </p>\n<pre><code># ping server-node2\n# ping server-node3 \n</code></pre><p>其它机子同理，都ping下，保证互相通讯。</p>\n<h3 id=\"开始安装GlusterFS\"><a href=\"#开始安装GlusterFS\" class=\"headerlink\" title=\"开始安装GlusterFS\"></a>开始安装GlusterFS</h3><p>####　安装服务</p>\n<p>1.在每个服务节点安装：</p>\n<pre><code>$ yum install -y centos-release-gluster\n$ yum install -y glusterfs glusterfs-server \n$ yum install -y glusterfs-fuse glusterfs-rdma\n</code></pre><p>2.设置服务开机自启动：  </p>\n<pre><code>$ systemctl start glusterd.service &amp;&amp; systemctl enable glusterd.service\n</code></pre><h4 id=\"配置集群\"><a href=\"#配置集群\" class=\"headerlink\" title=\"配置集群\"></a>配置集群</h4><p>1.首先启动服务（每个节点都启动）</p>\n<pre><code>systemctl start glusterd.service \nsystemctl enable glusterd.service\n</code></pre><p>2.关闭每个节点服务器的防火墙 </p>\n<pre><code>systemctl stop firewalld.service \nsystemctl disable firewalld.service\n</code></pre><p>3.在主节点中把另外两个从节点添加到集群    </p>\n<pre><code>gluster peer probe server-node1 \ngluster peer probe server-node2\n</code></pre><p>4.从集群中删除节点（在主节点服务器执行）</p>\n<pre><code>$ gluster peer detach 192.168.200.12\n</code></pre><p>可以从任意GFS Server节点上删除集群中的其它节点，但不能删除执行命令时的当前节点。</p>\n<p>6.查看集群状态</p>\n<p>在任意服务节点执行：  </p>\n<pre><code>[root@server-node1 ~]# gluster peer status\nNumber of Peers: 2\n\nHostname: server-node2\nUuid: 34bddd2b-4f4c-4b4b-afcd-786a6ba2c13d\nState: Peer in Cluster (Connected)\n\nHostname: server-node3\nUuid: 81101ab4-bcdc-467a-9fae-96d997a75fdc\nState: Peer in Cluster (Connected)\n\n---------------------------------------------\n\n[root@server-node2 ~]# gluster peer status\nNumber of Peers: 2\n\nHostname: server-node1\nUuid: d34a54a8-24bc-43ff-95fc-fe0b6d5c52fa\nState: Peer in Cluster (Connected)\nOther names:\n192.168.200.10\n\nHostname: server-node3\nUuid: 81101ab4-bcdc-467a-9fae-96d997a75fdc\nState: Peer in Cluster (Connected)\n\n----------------------------------------------\n\n[root@server-node3 ~]# gluster peer status\nNumber of Peers: 2\n\nHostname: server-node1\nUuid: d34a54a8-24bc-43ff-95fc-fe0b6d5c52fa\nState: Peer in Cluster (Connected)\nOther names:\nserver-node1\n\nHostname: server-node2\nUuid: 34bddd2b-4f4c-4b4b-afcd-786a6ba2c13d\nState: Peer in Cluster (Connected)\n</code></pre><p>在每个节点，可以看到另外的另个节点。</p>\n<p>7.创建数据存储目录（每个节点服务都要创建）</p>\n<pre><code>mkdir -p /data/gluster/exp1\n</code></pre><p>8.创建卷，GFS Volume</p>\n<p>在任意服务节点上执行如下命令：   </p>\n<pre><code>gluster volume create models replica 3 server-node1:/data/gluster/exp1 server-node2:/data/gluster/exp1 server-node3:/data/gluster/exp1 force    \n\n------------------------------------------\n[root@server-node1 gluster]# gluster volume create models replica 3 server-node1:/data/gluster/exp1 server-node2:/data/gluster/exp1 server-node3:/data/gluster/exp1 force\nvolume create: models: success: please start the volume to access data\n</code></pre><blockquote>\n<p>_说明_:<br>models: 卷的名称<br>replica 3: 表明存储3个备份，后面指定服务器的存储目录    </p>\n</blockquote>\n<ul>\n<li>查看volume 状态<br>在任意服务节点执行：  </li>\n</ul>\n<pre><code>gluster volume info     \n\n------------------------------------------------------------\n\n[root@server-node2 ~]# gluster volume info\n\nVolume Name: models\nType: Replicate\nVolume ID: 45d12287-2dfa-42be-954b-97c014d189c4\nStatus: Created\nSnapshot Count: 0\nNumber of Bricks: 1 x 3 = 3\nTransport-type: tcp\nBricks:\nBrick1: server-node1:/data/gluster/exp1\nBrick2: server-node2:/data/gluster/exp1\nBrick3: server-node3:/data/gluster/exp1\nOptions Reconfigured:\ntransport.address-family: inet\nnfs.disable: on\nperformance.client-io-threads: off\n</code></pre><p>8.启动卷<br>启动名为models的数据卷，在任意一个服务节点上执行即可：   </p>\n<pre><code>gluster volume start models    \n</code></pre><p>重新查看卷信息，会看到卷的状态status变为Started。代表卷已经启动成功。   </p>\n<h2 id=\"配置-GFS-Client\"><a href=\"#配置-GFS-Client\" class=\"headerlink\" title=\"配置 GFS Client\"></a>配置 GFS Client</h2><p><a href=\"https://docs.gluster.org/en/latest/Administrator%20Guide/Setting%20Up%20Clients/\" target=\"_blank\" rel=\"noopener\">https://docs.gluster.org/en/latest/Administrator%20Guide/Setting%20Up%20Clients/</a></p>\n<p>GFS客户端的节点必须和各个服务节点网络连通。ping命令检查。</p>\n<p>1.安装客户端</p>\n<pre><code>$ yum install -y glusterfs glusterfs-fuse glusterfs-rdma\n</code></pre><p>2.将客户端目录挂载到GFS服务的volume </p>\n<ul>\n<li><p>在gluster客户节点创建本地目录：   </p>\n<pre><code>$ mkdir -p /data/gluster/dt1\n</code></pre></li>\n<li><p>将本地目录挂载到GFS Volume：</p>\n<pre><code>mount -t glusterfs 192.168.200.10:models /data/gluster/dt1\n</code></pre></li>\n</ul>\n<blockquote>\n<p>参数说明：<br>192.168.200.10： 指的是GFS服务主节点的ip，一定是主节点。<br>models： 指上面创建的GFS每个服务上的卷（volume）名称。<br>/data/gluster/dt1: 客户端的本地目录，要挂载的目录。        </p>\n</blockquote>\n<p>_注意_:<br>上面挂载客户端目录到服务卷的命令可能不成功，这是因为用的是ip的原因，得把主节点的ip改成域名才行。因此，现在客户节点配置hosts。<br>编辑<code>/etc/hosts</code>： </p>\n<pre><code>192.168.200.10  server-node1  #GFS Server主节点\n</code></pre><p>然后重新挂载：</p>\n<pre><code>mount -t glusterfs server-node1:models /data/gluster/dt1      \n</code></pre><p>挂载成功。</p>\n<p>3.查看挂载</p>\n<pre><code>[root@gluster-client1 dt1]# df -h\nFilesystem                       Size  Used Avail Use% Mounted on\n/dev/mapper/VolGroup00-LogVol00   38G  3.3G   35G   9% /\ndevtmpfs                         910M     0  910M   0% /dev\ntmpfs                            920M     0  920M   0% /dev/shm\ntmpfs                            920M  8.6M  911M   1% /run\ntmpfs                            920M     0  920M   0% /sys/fs/cgroup\n/dev/sda2                       1014M   63M  952M   7% /boot\ntmpfs                            184M     0  184M   0% /run/user/1000\ntmpfs                            184M     0  184M   0% /run/user/0\nserver-node1:models               40G  3.4G   35G   9% /data/gluster/dt1\n</code></pre><p>可以看到，最后一个文件系统，就是我们挂载的。</p>\n<p>4.测试上传文件<br>在客户机执行上传文件命令：   </p>\n<pre><code>[root@gluster-client1 dt1]# time dd if=/dev/zero of=/data/gluster/dt1/hello bs=100M count=1\n1+0 records in\n1+0 records out\n104857600 bytes (105 MB) copied, 5.37804 s, 19.5 MB/s\n\nreal    0m5.395s\nuser    0m0.001s\nsys    0m0.182s\n[root@gluster-client1 dt1]# ls\n[root@gluster-client1 dt1]#    \n</code></pre><p>查看GFS Server各个节点对应的卷，以及客户节点的本地目录：</p>\n<pre><code>[root@server-node1 exp1]# pwd\n/data/gluster/exp1\n[root@server-node1 exp1]# ls\nhello\n</code></pre><p>都能看到一个hello的文件。说明的确按我们预期，有三份的文件数据，分别在三个服务节点上存储了。同时在客户端节点也有一份。    </p>\n<p>5.继续测试<br>随便在客户节点本地目录下，创建文件<code>touch a</code>，然后查看各个服务节点，会发现，客户节点的a文件已经同步到三个服务的对应卷下了，编辑客户节点的a文件，各个服务节点对应的a文件也会相应改变。这说明了它们是一直同步的。      </p>\n<h2 id=\"GFS性能调优\"><a href=\"#GFS性能调优\" class=\"headerlink\" title=\"GFS性能调优\"></a>GFS性能调优</h2><ul>\n<li>开启指定volume的配额： (models为volume名称)</li>\n</ul>\n<pre><code>gluster volume quota models enable\n</code></pre><ul>\n<li>限制models中 / (既总目录)最大使用80GB空间  </li>\n</ul>\n<pre><code>gluster volume quota models limit-usage / 80GB   \n</code></pre><ul>\n<li>设置 cache 大小(此处要根据实际情况，如果设置太大可能导致后面客户端挂载失败) </li>\n</ul>\n<pre><code>gluster volume set models performance.cache-size 512MB\n</code></pre><ul>\n<li>开启异步，后台操作  </li>\n</ul>\n<pre><code>gluster volume set models performance.flush-behind on\n</code></pre><ul>\n<li>设置 io 线程 32 </li>\n</ul>\n<pre><code>gluster volume set models performance.io-thread-count 32\n</code></pre><ul>\n<li>设置 回写 (写数据时间，先写入缓存内，再写入硬盘)</li>\n</ul>\n<pre><code>gluster volume set models performance.write-behind on\n</code></pre><ul>\n<li>调优之后的volume信息</li>\n</ul>\n<pre><code>gluster volume info\n</code></pre><p>然后试下再上传文件，看是否快很多呢。                      </p>\n<h2 id=\"其它命令\"><a href=\"#其它命令\" class=\"headerlink\" title=\"其它命令\"></a>其它命令</h2><h3 id=\"查看所volume（卷）\"><a href=\"#查看所volume（卷）\" class=\"headerlink\" title=\"查看所volume（卷）\"></a>查看所volume（卷）</h3><pre><code>gluster volume list\n</code></pre><h3 id=\"删除volume（卷）\"><a href=\"#删除volume（卷）\" class=\"headerlink\" title=\"删除volume（卷）\"></a>删除volume（卷）</h3><pre><code>gluster volume stop models //停止名字为 models 的磁盘 \ngluster volume delete models //删除名字为 models 的磁盘   \n</code></pre><h3 id=\"卸载GlusterFS磁盘\"><a href=\"#卸载GlusterFS磁盘\" class=\"headerlink\" title=\"卸载GlusterFS磁盘\"></a>卸载GlusterFS磁盘</h3><pre><code>--&gt;gluster peer detach glusterfs4\n</code></pre><h3 id=\"ACL访问控制\"><a href=\"#ACL访问控制\" class=\"headerlink\" title=\"ACL访问控制\"></a>ACL访问控制</h3><pre><code>--&gt;gluster volume set models auth.allow 192.168.56.*,10.0.1.*\n\nvolume set: success\n</code></pre><h3 id=\"添加GlusterFS节点\"><a href=\"#添加GlusterFS节点\" class=\"headerlink\" title=\"添加GlusterFS节点\"></a>添加GlusterFS节点</h3><pre><code>--&gt;gluster peer probe sc2-log5\n--&gt;gluster peer probe sc2-log6\n--&gt;gluster volume add-brick models sc2-log5:/data/gluster sc2-log6:/data/gluster\n</code></pre><h3 id=\"迁移GlusterFS数据\"><a href=\"#迁移GlusterFS数据\" class=\"headerlink\" title=\"迁移GlusterFS数据\"></a>迁移GlusterFS数据</h3><pre><code>--&gt;gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models start\n--&gt;gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models status\n--&gt;gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models commit\n</code></pre><h3 id=\"修复GlusterFS数据-在节点1宕机的情况下\"><a href=\"#修复GlusterFS数据-在节点1宕机的情况下\" class=\"headerlink\" title=\"修复GlusterFS数据(在节点1宕机的情况下)\"></a>修复GlusterFS数据(在节点1宕机的情况下)</h3><pre><code>--&gt;gluster volume replace-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models commit -force\n--&gt;gluster volume heal models full                      \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>参考地址：<a href=\"https://www.gluster.org\" target=\"_blank\" rel=\"noopener\">https://www.gluster.org</a> </p>\n<p><a href=\"https://my.oschina.net/hncscwc/blog/210072\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/hncscwc/blog/210072</a></p>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><p>用三个节点搭建一个glusterfs集群，一个节点作为客户端使用。新建四个虚拟机(centos7)：<br>并编辑<code>etc/hosts</code></p>\n<pre><code>glusterfs服务器节点：  \n192.168.200.10  server-node1   # 主节点\n192.168.200.11  server-node2   # 从节点\n192.168.200.12  server-node3   # 从节点 \n\nclient节点：   \n172.29.41.163 phn centos7\n</code></pre><p>然后在每个机子互相ping，确保网络通畅：</p>\n<p>在server-node1服务器执行： </p>\n<pre><code># ping server-node2\n# ping server-node3 \n</code></pre><p>其它机子同理，都ping下，保证互相通讯。</p>\n<h3 id=\"开始安装GlusterFS\"><a href=\"#开始安装GlusterFS\" class=\"headerlink\" title=\"开始安装GlusterFS\"></a>开始安装GlusterFS</h3><p>####　安装服务</p>\n<p>1.在每个服务节点安装：</p>\n<pre><code>$ yum install -y centos-release-gluster\n$ yum install -y glusterfs glusterfs-server \n$ yum install -y glusterfs-fuse glusterfs-rdma\n</code></pre><p>2.设置服务开机自启动：  </p>\n<pre><code>$ systemctl start glusterd.service &amp;&amp; systemctl enable glusterd.service\n</code></pre><h4 id=\"配置集群\"><a href=\"#配置集群\" class=\"headerlink\" title=\"配置集群\"></a>配置集群</h4><p>1.首先启动服务（每个节点都启动）</p>\n<pre><code>systemctl start glusterd.service \nsystemctl enable glusterd.service\n</code></pre><p>2.关闭每个节点服务器的防火墙 </p>\n<pre><code>systemctl stop firewalld.service \nsystemctl disable firewalld.service\n</code></pre><p>3.在主节点中把另外两个从节点添加到集群    </p>\n<pre><code>gluster peer probe server-node1 \ngluster peer probe server-node2\n</code></pre><p>4.从集群中删除节点（在主节点服务器执行）</p>\n<pre><code>$ gluster peer detach 192.168.200.12\n</code></pre><p>可以从任意GFS Server节点上删除集群中的其它节点，但不能删除执行命令时的当前节点。</p>\n<p>6.查看集群状态</p>\n<p>在任意服务节点执行：  </p>\n<pre><code>[root@server-node1 ~]# gluster peer status\nNumber of Peers: 2\n\nHostname: server-node2\nUuid: 34bddd2b-4f4c-4b4b-afcd-786a6ba2c13d\nState: Peer in Cluster (Connected)\n\nHostname: server-node3\nUuid: 81101ab4-bcdc-467a-9fae-96d997a75fdc\nState: Peer in Cluster (Connected)\n\n---------------------------------------------\n\n[root@server-node2 ~]# gluster peer status\nNumber of Peers: 2\n\nHostname: server-node1\nUuid: d34a54a8-24bc-43ff-95fc-fe0b6d5c52fa\nState: Peer in Cluster (Connected)\nOther names:\n192.168.200.10\n\nHostname: server-node3\nUuid: 81101ab4-bcdc-467a-9fae-96d997a75fdc\nState: Peer in Cluster (Connected)\n\n----------------------------------------------\n\n[root@server-node3 ~]# gluster peer status\nNumber of Peers: 2\n\nHostname: server-node1\nUuid: d34a54a8-24bc-43ff-95fc-fe0b6d5c52fa\nState: Peer in Cluster (Connected)\nOther names:\nserver-node1\n\nHostname: server-node2\nUuid: 34bddd2b-4f4c-4b4b-afcd-786a6ba2c13d\nState: Peer in Cluster (Connected)\n</code></pre><p>在每个节点，可以看到另外的另个节点。</p>\n<p>7.创建数据存储目录（每个节点服务都要创建）</p>\n<pre><code>mkdir -p /data/gluster/exp1\n</code></pre><p>8.创建卷，GFS Volume</p>\n<p>在任意服务节点上执行如下命令：   </p>\n<pre><code>gluster volume create models replica 3 server-node1:/data/gluster/exp1 server-node2:/data/gluster/exp1 server-node3:/data/gluster/exp1 force    \n\n------------------------------------------\n[root@server-node1 gluster]# gluster volume create models replica 3 server-node1:/data/gluster/exp1 server-node2:/data/gluster/exp1 server-node3:/data/gluster/exp1 force\nvolume create: models: success: please start the volume to access data\n</code></pre><blockquote>\n<p>_说明_:<br>models: 卷的名称<br>replica 3: 表明存储3个备份，后面指定服务器的存储目录    </p>\n</blockquote>\n<ul>\n<li>查看volume 状态<br>在任意服务节点执行：  </li>\n</ul>\n<pre><code>gluster volume info     \n\n------------------------------------------------------------\n\n[root@server-node2 ~]# gluster volume info\n\nVolume Name: models\nType: Replicate\nVolume ID: 45d12287-2dfa-42be-954b-97c014d189c4\nStatus: Created\nSnapshot Count: 0\nNumber of Bricks: 1 x 3 = 3\nTransport-type: tcp\nBricks:\nBrick1: server-node1:/data/gluster/exp1\nBrick2: server-node2:/data/gluster/exp1\nBrick3: server-node3:/data/gluster/exp1\nOptions Reconfigured:\ntransport.address-family: inet\nnfs.disable: on\nperformance.client-io-threads: off\n</code></pre><p>8.启动卷<br>启动名为models的数据卷，在任意一个服务节点上执行即可：   </p>\n<pre><code>gluster volume start models    \n</code></pre><p>重新查看卷信息，会看到卷的状态status变为Started。代表卷已经启动成功。   </p>\n<h2 id=\"配置-GFS-Client\"><a href=\"#配置-GFS-Client\" class=\"headerlink\" title=\"配置 GFS Client\"></a>配置 GFS Client</h2><p><a href=\"https://docs.gluster.org/en/latest/Administrator%20Guide/Setting%20Up%20Clients/\" target=\"_blank\" rel=\"noopener\">https://docs.gluster.org/en/latest/Administrator%20Guide/Setting%20Up%20Clients/</a></p>\n<p>GFS客户端的节点必须和各个服务节点网络连通。ping命令检查。</p>\n<p>1.安装客户端</p>\n<pre><code>$ yum install -y glusterfs glusterfs-fuse glusterfs-rdma\n</code></pre><p>2.将客户端目录挂载到GFS服务的volume </p>\n<ul>\n<li><p>在gluster客户节点创建本地目录：   </p>\n<pre><code>$ mkdir -p /data/gluster/dt1\n</code></pre></li>\n<li><p>将本地目录挂载到GFS Volume：</p>\n<pre><code>mount -t glusterfs 192.168.200.10:models /data/gluster/dt1\n</code></pre></li>\n</ul>\n<blockquote>\n<p>参数说明：<br>192.168.200.10： 指的是GFS服务主节点的ip，一定是主节点。<br>models： 指上面创建的GFS每个服务上的卷（volume）名称。<br>/data/gluster/dt1: 客户端的本地目录，要挂载的目录。        </p>\n</blockquote>\n<p>_注意_:<br>上面挂载客户端目录到服务卷的命令可能不成功，这是因为用的是ip的原因，得把主节点的ip改成域名才行。因此，现在客户节点配置hosts。<br>编辑<code>/etc/hosts</code>： </p>\n<pre><code>192.168.200.10  server-node1  #GFS Server主节点\n</code></pre><p>然后重新挂载：</p>\n<pre><code>mount -t glusterfs server-node1:models /data/gluster/dt1      \n</code></pre><p>挂载成功。</p>\n<p>3.查看挂载</p>\n<pre><code>[root@gluster-client1 dt1]# df -h\nFilesystem                       Size  Used Avail Use% Mounted on\n/dev/mapper/VolGroup00-LogVol00   38G  3.3G   35G   9% /\ndevtmpfs                         910M     0  910M   0% /dev\ntmpfs                            920M     0  920M   0% /dev/shm\ntmpfs                            920M  8.6M  911M   1% /run\ntmpfs                            920M     0  920M   0% /sys/fs/cgroup\n/dev/sda2                       1014M   63M  952M   7% /boot\ntmpfs                            184M     0  184M   0% /run/user/1000\ntmpfs                            184M     0  184M   0% /run/user/0\nserver-node1:models               40G  3.4G   35G   9% /data/gluster/dt1\n</code></pre><p>可以看到，最后一个文件系统，就是我们挂载的。</p>\n<p>4.测试上传文件<br>在客户机执行上传文件命令：   </p>\n<pre><code>[root@gluster-client1 dt1]# time dd if=/dev/zero of=/data/gluster/dt1/hello bs=100M count=1\n1+0 records in\n1+0 records out\n104857600 bytes (105 MB) copied, 5.37804 s, 19.5 MB/s\n\nreal    0m5.395s\nuser    0m0.001s\nsys    0m0.182s\n[root@gluster-client1 dt1]# ls\n[root@gluster-client1 dt1]#    \n</code></pre><p>查看GFS Server各个节点对应的卷，以及客户节点的本地目录：</p>\n<pre><code>[root@server-node1 exp1]# pwd\n/data/gluster/exp1\n[root@server-node1 exp1]# ls\nhello\n</code></pre><p>都能看到一个hello的文件。说明的确按我们预期，有三份的文件数据，分别在三个服务节点上存储了。同时在客户端节点也有一份。    </p>\n<p>5.继续测试<br>随便在客户节点本地目录下，创建文件<code>touch a</code>，然后查看各个服务节点，会发现，客户节点的a文件已经同步到三个服务的对应卷下了，编辑客户节点的a文件，各个服务节点对应的a文件也会相应改变。这说明了它们是一直同步的。      </p>\n<h2 id=\"GFS性能调优\"><a href=\"#GFS性能调优\" class=\"headerlink\" title=\"GFS性能调优\"></a>GFS性能调优</h2><ul>\n<li>开启指定volume的配额： (models为volume名称)</li>\n</ul>\n<pre><code>gluster volume quota models enable\n</code></pre><ul>\n<li>限制models中 / (既总目录)最大使用80GB空间  </li>\n</ul>\n<pre><code>gluster volume quota models limit-usage / 80GB   \n</code></pre><ul>\n<li>设置 cache 大小(此处要根据实际情况，如果设置太大可能导致后面客户端挂载失败) </li>\n</ul>\n<pre><code>gluster volume set models performance.cache-size 512MB\n</code></pre><ul>\n<li>开启异步，后台操作  </li>\n</ul>\n<pre><code>gluster volume set models performance.flush-behind on\n</code></pre><ul>\n<li>设置 io 线程 32 </li>\n</ul>\n<pre><code>gluster volume set models performance.io-thread-count 32\n</code></pre><ul>\n<li>设置 回写 (写数据时间，先写入缓存内，再写入硬盘)</li>\n</ul>\n<pre><code>gluster volume set models performance.write-behind on\n</code></pre><ul>\n<li>调优之后的volume信息</li>\n</ul>\n<pre><code>gluster volume info\n</code></pre><p>然后试下再上传文件，看是否快很多呢。                      </p>\n<h2 id=\"其它命令\"><a href=\"#其它命令\" class=\"headerlink\" title=\"其它命令\"></a>其它命令</h2><h3 id=\"查看所volume（卷）\"><a href=\"#查看所volume（卷）\" class=\"headerlink\" title=\"查看所volume（卷）\"></a>查看所volume（卷）</h3><pre><code>gluster volume list\n</code></pre><h3 id=\"删除volume（卷）\"><a href=\"#删除volume（卷）\" class=\"headerlink\" title=\"删除volume（卷）\"></a>删除volume（卷）</h3><pre><code>gluster volume stop models //停止名字为 models 的磁盘 \ngluster volume delete models //删除名字为 models 的磁盘   \n</code></pre><h3 id=\"卸载GlusterFS磁盘\"><a href=\"#卸载GlusterFS磁盘\" class=\"headerlink\" title=\"卸载GlusterFS磁盘\"></a>卸载GlusterFS磁盘</h3><pre><code>--&gt;gluster peer detach glusterfs4\n</code></pre><h3 id=\"ACL访问控制\"><a href=\"#ACL访问控制\" class=\"headerlink\" title=\"ACL访问控制\"></a>ACL访问控制</h3><pre><code>--&gt;gluster volume set models auth.allow 192.168.56.*,10.0.1.*\n\nvolume set: success\n</code></pre><h3 id=\"添加GlusterFS节点\"><a href=\"#添加GlusterFS节点\" class=\"headerlink\" title=\"添加GlusterFS节点\"></a>添加GlusterFS节点</h3><pre><code>--&gt;gluster peer probe sc2-log5\n--&gt;gluster peer probe sc2-log6\n--&gt;gluster volume add-brick models sc2-log5:/data/gluster sc2-log6:/data/gluster\n</code></pre><h3 id=\"迁移GlusterFS数据\"><a href=\"#迁移GlusterFS数据\" class=\"headerlink\" title=\"迁移GlusterFS数据\"></a>迁移GlusterFS数据</h3><pre><code>--&gt;gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models start\n--&gt;gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models status\n--&gt;gluster volume remove-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models commit\n</code></pre><h3 id=\"修复GlusterFS数据-在节点1宕机的情况下\"><a href=\"#修复GlusterFS数据-在节点1宕机的情况下\" class=\"headerlink\" title=\"修复GlusterFS数据(在节点1宕机的情况下)\"></a>修复GlusterFS数据(在节点1宕机的情况下)</h3><pre><code>--&gt;gluster volume replace-brick models sc2-log1:/usr/local/share/models sc2-log5:/usr/local/share/models commit -force\n--&gt;gluster volume heal models full                      \n</code></pre>"},{"title":"HashiCorp Vault使用　","date":"2017-09-30T15:40:58.000Z","_content":"## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","source":"_posts/hashicorp-vault.md","raw":"---\ntitle: HashiCorp Vault使用　\ndate: 2017-09-30 23:40:58\ncategories: security\ntags: hashicorp-vault\n---\n## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","slug":"hashicorp-vault","published":1,"updated":"2019-06-16T14:38:33.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqc40046g4vads0tvoyg","content":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"noopener\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"noopener\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n"},{"title":"http协议概述(学习笔记)","date":"2017-10-17T13:45:50.000Z","_content":"\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","source":"_posts/http-protocol-overview.md","raw":"---\ntitle: http协议概述(学习笔记)\ndate: 2017-10-17 21:45:50\ncategories: http协议\ntags: http-overview\n---\n\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","slug":"http-protocol-overview","published":1,"updated":"2019-06-16T14:38:33.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqc50048g4vawkm4vtrh","content":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>","site":{"data":{}},"excerpt":"","more":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>"},{"title":"idea集成XRebel分析web应用性能","date":"2017-12-04T07:50:14.000Z","_content":"XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。\n\nXRebel官方简明教程在这里 http://zeroturnaround.com/software/xrebel/quick-start/\n\n官方下载地址在这里 https://zeroturnaround.com/software/xrebel/download/#!/have-license","source":"_posts/idea-XRebel.md","raw":"---\ntitle: idea集成XRebel分析web应用性能\ndate: 2017-12-04 15:50:14\ncategories: idea\ntags:\n---\nXRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。\n\nXRebel官方简明教程在这里 http://zeroturnaround.com/software/xrebel/quick-start/\n\n官方下载地址在这里 https://zeroturnaround.com/software/xrebel/download/#!/have-license","slug":"idea-XRebel","published":1,"updated":"2020-05-30T11:28:23.359Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqc6004cg4va9x145nfd","content":"<p>XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。</p>\n<p>XRebel官方简明教程在这里 <a href=\"http://zeroturnaround.com/software/xrebel/quick-start/\" target=\"_blank\" rel=\"noopener\">http://zeroturnaround.com/software/xrebel/quick-start/</a></p>\n<p>官方下载地址在这里 <a href=\"https://zeroturnaround.com/software/xrebel/download/#!/have-license\" target=\"_blank\" rel=\"noopener\">https://zeroturnaround.com/software/xrebel/download/#!/have-license</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。</p>\n<p>XRebel官方简明教程在这里 <a href=\"http://zeroturnaround.com/software/xrebel/quick-start/\" target=\"_blank\" rel=\"noopener\">http://zeroturnaround.com/software/xrebel/quick-start/</a></p>\n<p>官方下载地址在这里 <a href=\"https://zeroturnaround.com/software/xrebel/download/#!/have-license\" target=\"_blank\" rel=\"noopener\">https://zeroturnaround.com/software/xrebel/download/#!/have-license</a></p>\n"},{"title":"idea创建类，方法注解提示模板","date":"2018-02-10T06:30:29.000Z","_content":"\n为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……\n\n## java类的注解模板\n\n1. 首先，打开设计：\n`File->Settings->file and code template` \n\n{% asset_img a.png %}\n\n`#parse(\"File Header.java\")` \n这句：include 名字为File Header的模板进来。 \n\n2. 定义如图： \n\n{% asset_img b.png %}\n\n模板内容：\n\n       /**\n        * 功能简述:<br> \n        * \n        *\n        * @author zmt\n        * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n        * @updateTime \n        * @since 1.0.0\n        */\n        \n## java方法模板\n\n在File->Settings->Editor->Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template\n\n- 创建mygroup的Template,并定义名为/**的template。如下图：\n\n{% asset_img c.png %}\n\n模板内容：\n\n    /**\n     * 功能描述: <br>\n     * 〈$END$〉\n     *\n     $param$\n     * @return: $return$\n     * @since: 1.0.0\n     * @author: $user$\n     * @date: $DATE$ $TIME$\n     */\n     \n- 编辑模板的变量内容：\n\n点击右边的Edit Variables: \n\n{% asset_img e.png %}\n\n添加变量内容，如图： \n\n{% asset_img f.png %}\n\n注意：$param$这么添加，否则无效：\n\n    groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i < params.size(); i++) {result+='* @param ' + params[i] + ((i < params.size() - 1) ? '\\\\n ' : '')}; return result\", methodParameters())\n\n- 选定作用域：\n\n是应用在类上，还是方法上\n\n{% asset_img g.png %}\n\n- 测试：\n\n在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。\n\n`注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效`\n\n{% asset_img j.png %}\n\n\n     \n\n","source":"_posts/idea-file-template.md","raw":"---\ntitle: idea创建类，方法注解提示模板\ndate: 2018-02-10 14:30:29\ncategories: idea\ntags:\n---\n\n为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……\n\n## java类的注解模板\n\n1. 首先，打开设计：\n`File->Settings->file and code template` \n\n{% asset_img a.png %}\n\n`#parse(\"File Header.java\")` \n这句：include 名字为File Header的模板进来。 \n\n2. 定义如图： \n\n{% asset_img b.png %}\n\n模板内容：\n\n       /**\n        * 功能简述:<br> \n        * \n        *\n        * @author zmt\n        * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n        * @updateTime \n        * @since 1.0.0\n        */\n        \n## java方法模板\n\n在File->Settings->Editor->Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template\n\n- 创建mygroup的Template,并定义名为/**的template。如下图：\n\n{% asset_img c.png %}\n\n模板内容：\n\n    /**\n     * 功能描述: <br>\n     * 〈$END$〉\n     *\n     $param$\n     * @return: $return$\n     * @since: 1.0.0\n     * @author: $user$\n     * @date: $DATE$ $TIME$\n     */\n     \n- 编辑模板的变量内容：\n\n点击右边的Edit Variables: \n\n{% asset_img e.png %}\n\n添加变量内容，如图： \n\n{% asset_img f.png %}\n\n注意：$param$这么添加，否则无效：\n\n    groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i < params.size(); i++) {result+='* @param ' + params[i] + ((i < params.size() - 1) ? '\\\\n ' : '')}; return result\", methodParameters())\n\n- 选定作用域：\n\n是应用在类上，还是方法上\n\n{% asset_img g.png %}\n\n- 测试：\n\n在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。\n\n`注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效`\n\n{% asset_img j.png %}\n\n\n     \n\n","slug":"idea-file-template","published":1,"updated":"2020-05-30T11:28:23.360Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqc8004eg4va2tswtcmi","content":"<p>为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……</p>\n<h2 id=\"java类的注解模板\"><a href=\"#java类的注解模板\" class=\"headerlink\" title=\"java类的注解模板\"></a>java类的注解模板</h2><ol>\n<li>首先，打开设计：<br><code>File-&gt;Settings-&gt;file and code template</code> </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/a.png\">\n<p><code>#parse(&quot;File Header.java&quot;)</code><br>这句：include 名字为File Header的模板进来。 </p>\n<ol start=\"2\">\n<li>定义如图： </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/b.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能简述:&lt;br&gt; \n * \n *\n * @author zmt\n * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n * @updateTime \n * @since 1.0.0\n */\n</code></pre><h2 id=\"java方法模板\"><a href=\"#java方法模板\" class=\"headerlink\" title=\"java方法模板\"></a>java方法模板</h2><p>在File-&gt;Settings-&gt;Editor-&gt;Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template</p>\n<ul>\n<li>创建mygroup的Template,并定义名为/**的template。如下图：</li>\n</ul>\n<img src=\"/2018/02/10/idea-file-template/c.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能描述: &lt;br&gt;\n * 〈$END$〉\n *\n $param$\n * @return: $return$\n * @since: 1.0.0\n * @author: $user$\n * @date: $DATE$ $TIME$\n */\n</code></pre><ul>\n<li>编辑模板的变量内容：</li>\n</ul>\n<p>点击右边的Edit Variables: </p>\n<img src=\"/2018/02/10/idea-file-template/e.png\">\n<p>添加变量内容，如图： </p>\n<img src=\"/2018/02/10/idea-file-template/f.png\">\n<p>注意：$param$这么添加，否则无效：</p>\n<pre><code>groovyScript(&quot;def result=&apos;&apos;; def params=\\&quot;${_1}\\&quot;.replaceAll(&apos;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) {result+=&apos;* @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\\\n &apos; : &apos;&apos;)}; return result&quot;, methodParameters())\n</code></pre><ul>\n<li>选定作用域：</li>\n</ul>\n<p>是应用在类上，还是方法上</p>\n<img src=\"/2018/02/10/idea-file-template/g.png\">\n<ul>\n<li>测试：</li>\n</ul>\n<p>在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。</p>\n<p><code>注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效</code></p>\n<img src=\"/2018/02/10/idea-file-template/j.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……</p>\n<h2 id=\"java类的注解模板\"><a href=\"#java类的注解模板\" class=\"headerlink\" title=\"java类的注解模板\"></a>java类的注解模板</h2><ol>\n<li>首先，打开设计：<br><code>File-&gt;Settings-&gt;file and code template</code> </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/a.png\">\n<p><code>#parse(&quot;File Header.java&quot;)</code><br>这句：include 名字为File Header的模板进来。 </p>\n<ol start=\"2\">\n<li>定义如图： </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/b.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能简述:&lt;br&gt; \n * \n *\n * @author zmt\n * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n * @updateTime \n * @since 1.0.0\n */\n</code></pre><h2 id=\"java方法模板\"><a href=\"#java方法模板\" class=\"headerlink\" title=\"java方法模板\"></a>java方法模板</h2><p>在File-&gt;Settings-&gt;Editor-&gt;Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template</p>\n<ul>\n<li>创建mygroup的Template,并定义名为/**的template。如下图：</li>\n</ul>\n<img src=\"/2018/02/10/idea-file-template/c.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能描述: &lt;br&gt;\n * 〈$END$〉\n *\n $param$\n * @return: $return$\n * @since: 1.0.0\n * @author: $user$\n * @date: $DATE$ $TIME$\n */\n</code></pre><ul>\n<li>编辑模板的变量内容：</li>\n</ul>\n<p>点击右边的Edit Variables: </p>\n<img src=\"/2018/02/10/idea-file-template/e.png\">\n<p>添加变量内容，如图： </p>\n<img src=\"/2018/02/10/idea-file-template/f.png\">\n<p>注意：$param$这么添加，否则无效：</p>\n<pre><code>groovyScript(&quot;def result=&apos;&apos;; def params=\\&quot;${_1}\\&quot;.replaceAll(&apos;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) {result+=&apos;* @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\\\n &apos; : &apos;&apos;)}; return result&quot;, methodParameters())\n</code></pre><ul>\n<li>选定作用域：</li>\n</ul>\n<p>是应用在类上，还是方法上</p>\n<img src=\"/2018/02/10/idea-file-template/g.png\">\n<ul>\n<li>测试：</li>\n</ul>\n<p>在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。</p>\n<p><code>注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效</code></p>\n<img src=\"/2018/02/10/idea-file-template/j.png\">\n"},{"title":"hibernate表关系映射示例","date":"2017-11-01T09:18:44.000Z","_content":"\n## 1. OneToOne\n一对一关系，存在n+1问题。\n\n#### 1.1 单向 @OneToOne\n- 实体：\n\n\n        @Entity(name = \"Phone\")\n        public static class Phone {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            @Column(name = \"`number`\")\n            private String number;\n        \n            @OneToOne\n            @JoinColumn(name = \"details_id\")\n            private PhoneDetails details;\n        \n            public Phone() {\n            }\n        \n            public Phone(String number) {\n                this.number = number;\n            }\n        \n            public Long getId() {\n                return id;\n            }\n        \n            public String getNumber() {\n                return number;\n            }\n        \n            public PhoneDetails getDetails() {\n                return details;\n            }\n        \n            public void setDetails(PhoneDetails details) {\n                this.details = details;\n            }\n        }\n\t\n---\t\n        @Entity(name = \"PhoneDetails\")\n        public static class PhoneDetails {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            private String provider;\n        \n            private String technology;\n        \n            public PhoneDetails() {\n            }\n        \n            public PhoneDetails(String provider, String technology) {\n                this.provider = provider;\n                this.technology = technology;\n            }\n        \n            public String getProvider() {\n                return provider;\n            }\n        \n            public String getTechnology() {\n                return technology;\n            }\n        \n            public void setTechnology(String technology) {\n                this.technology = technology;\n            }\n        }\n\t\n- *生成sql*：\n\n        CREATE TABLE Phone (\n            id BIGINT NOT NULL ,\n            number VARCHAR(255) ,\n            details_id BIGINT ,\n            PRIMARY KEY ( id )\n        )\n        \n        CREATE TABLE PhoneDetails (\n            id BIGINT NOT NULL ,\n            provider VARCHAR(255) ,\n            technology VARCHAR(255) ,\n            PRIMARY KEY ( id )\n        )\n        \n        ALTER TABLE Phone\n        ADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\n        FOREIGN KEY (details_id) REFERENCES PhoneDetails\n\t\n\t\n- *操作*：\n\t作为外键，相当于ManyToOne作为外键操作\n\n---\n\t\n#### 1.2 双向 @OneToOne\n\n- 实体：\n\n\n    @Entity(name = \"Phone\")\n    public static class Phone {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n    \n        @Column(name = \"`number`\")\n        private String number;\n    \n        @OneToOne(mappedBy = \"phone\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n        private PhoneDetails details;\n    \n        public Phone() {\n        }\n    \n        public Phone(String number) {\n            this.number = number;\n        }\n    \n        public Long getId() {\n            return id;\n        }\n    \n        public String getNumber() {\n            return number;\n        }\n    \n        public PhoneDetails getDetails() {\n            return details;\n        }\n    \n        public void addDetails(PhoneDetails details) {\n            details.setPhone( this );\n            this.details = details;\n        }\n    \n        public void removeDetails() {\n            if ( details != null ) {\n                details.setPhone( null );\n                this.details = null;\n            }\n        }\n    }\n\t\n---\n\t\n\t@Entity(name = \"PhoneDetails\")\n\tpublic static class PhoneDetails {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String provider;\n\t\n\t    private String technology;\n\t\n\t    @OneToOne(fetch = FetchType.LAZY)\n\t    @JoinColumn(name = \"phone_id\")\n\t    private Phone phone;\n\t\n\t    public PhoneDetails() {\n\t    }\n\t\n\t    public PhoneDetails(String provider, String technology) {\n\t        this.provider = provider;\n\t        this.technology = technology;\n\t    }\n\t\n\t    public String getProvider() {\n\t        return provider;\n\t    }\n\t\n\t    public String getTechnology() {\n\t        return technology;\n\t    }\n\t\n\t    public void setTechnology(String technology) {\n\t        this.technology = technology;\n\t    }\n\t\n\t    public Phone getPhone() {\n\t        return phone;\n\t    }\n\t\n\t    public void setPhone(Phone phone) {\n\t        this.phone = phone;\n\t    }\n\t}\n\n- *生成sql*：\n\n\n    CREATE TABLE Phone (\n        id BIGINT NOT NULL ,\n        number VARCHAR(255) ,\n        PRIMARY KEY ( id )\n    )\n    \n    CREATE TABLE PhoneDetails (\n        id BIGINT NOT NULL ,\n        provider VARCHAR(255) ,\n        technology VARCHAR(255) ,\n        phone_id BIGINT ,\n        PRIMARY KEY ( id )\n    )\n    \n    ALTER TABLE PhoneDetails\n    ADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\n    FOREIGN KEY (phone_id) REFERENCES Phone\n\n- *操作*：\n\n\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tPhoneDetails details = new PhoneDetails( \"T-Mobile\", \"GSM\" );\n\t\n\tphone.addDetails( details );\n\tentityManager.persist( phone );\n\t\n\t-------------------------------------\n\tINSERT INTO Phone ( number, id )\n\tVALUES ( '123 - 456 - 7890', 1 )\n\t\n\tINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\n\tVALUES ( 1, 'T - Mobile, GSM', 2 )\n\t\n\n---\n## 2. OneToMany\n一对多关系，一般在多的一段维护，也可双边维护关系。\n\n#### 2.1 单向 @OneToMany association\n\n- 实体:\n\n\n    @Entity(name = \"Person\")\n    public static class Person {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n        @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n        private List<Phone> phones = new ArrayList<>();\n    \n        public Person() {\n        }\n    \n        public List<Phone> getPhones() {\n            return phones;\n        }\n    }\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\n\tCREATE TABLE Person_Phone (\n\t    Person_id BIGINT NOT NULL ,\n\t    phones_id BIGINT NOT NULL\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\n\tUNIQUE (phones_id)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\n\tFOREIGN KEY (phones_id) REFERENCES Phone\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\n- *操作代码*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.getPhones().add( phone1 );\n\tperson.getPhones().add( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.getPhones().remove( phone1 );\n\t\n\t-----------------------------------------------\n\tINSERT INTO Person\n       ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '123 - 456 - 7890', 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '321 - 654 - 0987', 3 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Person_Phone\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n#### 2.2 双向@OneToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<Phone> phones = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(Long id) {\n\t        this.id = id;\n\t    }\n\t\n\t    public List<Phone> getPhones() {\n\t        return phones;\n\t    }\n\t\n\t    public void addPhone(Phone phone) {\n\t        phones.add( phone );\n\t        phone.setPerson( this );\n\t    }\n\t\n\t    public void removePhone(Phone phone) {\n\t        phones.remove( phone );\n\t        phone.setPerson( null );\n\t    }\n\t}\t\t\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    @Column(name = \"`number`\", unique = true)\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Phone phone = (Phone) o;\n\t        return Objects.equals( number, phone.number );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( number );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\n\tUNIQUE (number)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\n\tFOREIGN KEY (person_id) REFERENCES Person\n\n- *操作*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.addPhone( phone1 );\n\tperson.addPhone( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.removePhone( phone1 );\t\n\t\n\t-----------------------------------------\n\t\n\tINSERT INTO Phone\n       ( number, person_id, id )\n\tVALUES ( '123-456-7890', NULL, 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, person_id, id )\n\tVALUES ( '321-654-0987', NULL, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n---\n## 3. ManyToOne\n多对一关系\n\n#### 3.1 @ManyToOne association\n相当于外键\n\n- 实体\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t\t@Id\n\t\t@GeneratedValue\n\t\tprivate Long id;\n\t\t\n\t\tpublic Person() {\n\t\t\n\t\t}\n\t}\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    @JoinColumn(name = \"person_id\",\n\t            foreignKey = @ForeignKey(name = \"PERSON_ID_FK\")\n\t    )\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT PERSON_ID_FK\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n- *生命周期*:\n\n\n\tPerson person = new Person();\n\tentityManager.persist( person );\n\t\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tphone.setPerson( person );\n\tentityManager.persist( phone );\n\t\n\tentityManager.flush();\n\tphone.setPerson( null );\n\t\n\t实际sql：\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone ( number, person_id, id )\n\tVALUES ( '123-456-7890', 1, 2 )\n\t\n\tUPDATE Phone\n\tSET    number = '123-456-7890',\n\t       person_id = NULL\n\tWHERE  id = 2\n\n---\t\n## 4. ManyToMany\n多对多关系，两边都要维护。\n\n#### 4.1 单向 @ManyToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number) {\n\t        this.street = street;\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    Person_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person();\n\tPerson person2 = new Person();\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\" );\n\t\n\tperson1.getAddresses().add( address1 );\n\tperson1.getAddresses().add( address2 );\n\t\n\tperson2.getAddresses().add( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.getAddresses().remove( address1 );\n\t\n\t-------------------------------------------\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '12A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '18B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( id )\n\tVALUES ( 4 )\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 2 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.2 双向 @ManyToMany\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        addresses.add( address );\n\t        address.getOwners().add( this );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        addresses.remove( address );\n\t        address.getOwners().remove( this );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @ManyToMany(mappedBy = \"addresses\")\n\t    private List<Person> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<Person> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    owners_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\n\tFOREIGN KEY (owners_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.removeAddress( address1 );\n\t\n\t------------------------------------------\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'ABC-123', 1 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '12A', '4005A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '18B', '4007B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'DEF-456', 4 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  owners_id = 1\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.3 双向 many-to-many with a link entity\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public List<PersonAddress> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        addresses.add( personAddress );\n\t        address.getOwners().add( personAddress );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        address.getOwners().remove( personAddress );\n\t        addresses.remove( personAddress );\n\t        personAddress.setPerson( null );\n\t        personAddress.setAddress( null );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"PersonAddress\")\n\tpublic static class PersonAddress implements Serializable {\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Address address;\n\t\n\t    public PersonAddress() {\n\t    }\n\t\n\t    public PersonAddress(Person person, Address address) {\n\t        this.person = person;\n\t        this.address = address;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    public Address getAddress() {\n\t        return address;\n\t    }\n\t\n\t    public void setAddress(Address address) {\n\t        this.address = address;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        PersonAddress that = (PersonAddress) o;\n\t        return Objects.equals( person, that.person ) &&\n\t                Objects.equals( address, that.address );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( person, address );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @OneToMany(mappedBy = \"address\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<PersonAddress> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE PersonAddress (\n\t    person_id BIGINT NOT NULL ,\n\t    address_id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( person_id, address_id )\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\n\tFOREIGN KEY (address_id) REFERENCES Address\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.persist( address1 );\n\tentityManager.persist( address2 );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.flush();\n\t\n\tlog.info( \"Removing address\" );\n\tperson1.removeAddress( address1 );\n\t---------------------------------------------------\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'ABC-123', 1 )\n\t\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'DEF-456', 2 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '12A', '4005A', '12th Avenue', 3 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '18B', '4007B', '18th Avenue', 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 3 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 2, 3 )\n\t\n\tDELETE  FROM PersonAddress\n\tWHERE   person_id = 1 AND address_id = 3\n\t\n\n\t","source":"_posts/hibernate-relation-mapping.md","raw":"---\ntitle: hibernate表关系映射示例\ndate: 2017-11-01 17:18:44\ncategories: jpa/hibernate\ntags: hibernate-relation\n---\n\n## 1. OneToOne\n一对一关系，存在n+1问题。\n\n#### 1.1 单向 @OneToOne\n- 实体：\n\n\n        @Entity(name = \"Phone\")\n        public static class Phone {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            @Column(name = \"`number`\")\n            private String number;\n        \n            @OneToOne\n            @JoinColumn(name = \"details_id\")\n            private PhoneDetails details;\n        \n            public Phone() {\n            }\n        \n            public Phone(String number) {\n                this.number = number;\n            }\n        \n            public Long getId() {\n                return id;\n            }\n        \n            public String getNumber() {\n                return number;\n            }\n        \n            public PhoneDetails getDetails() {\n                return details;\n            }\n        \n            public void setDetails(PhoneDetails details) {\n                this.details = details;\n            }\n        }\n\t\n---\t\n        @Entity(name = \"PhoneDetails\")\n        public static class PhoneDetails {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            private String provider;\n        \n            private String technology;\n        \n            public PhoneDetails() {\n            }\n        \n            public PhoneDetails(String provider, String technology) {\n                this.provider = provider;\n                this.technology = technology;\n            }\n        \n            public String getProvider() {\n                return provider;\n            }\n        \n            public String getTechnology() {\n                return technology;\n            }\n        \n            public void setTechnology(String technology) {\n                this.technology = technology;\n            }\n        }\n\t\n- *生成sql*：\n\n        CREATE TABLE Phone (\n            id BIGINT NOT NULL ,\n            number VARCHAR(255) ,\n            details_id BIGINT ,\n            PRIMARY KEY ( id )\n        )\n        \n        CREATE TABLE PhoneDetails (\n            id BIGINT NOT NULL ,\n            provider VARCHAR(255) ,\n            technology VARCHAR(255) ,\n            PRIMARY KEY ( id )\n        )\n        \n        ALTER TABLE Phone\n        ADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\n        FOREIGN KEY (details_id) REFERENCES PhoneDetails\n\t\n\t\n- *操作*：\n\t作为外键，相当于ManyToOne作为外键操作\n\n---\n\t\n#### 1.2 双向 @OneToOne\n\n- 实体：\n\n\n    @Entity(name = \"Phone\")\n    public static class Phone {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n    \n        @Column(name = \"`number`\")\n        private String number;\n    \n        @OneToOne(mappedBy = \"phone\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n        private PhoneDetails details;\n    \n        public Phone() {\n        }\n    \n        public Phone(String number) {\n            this.number = number;\n        }\n    \n        public Long getId() {\n            return id;\n        }\n    \n        public String getNumber() {\n            return number;\n        }\n    \n        public PhoneDetails getDetails() {\n            return details;\n        }\n    \n        public void addDetails(PhoneDetails details) {\n            details.setPhone( this );\n            this.details = details;\n        }\n    \n        public void removeDetails() {\n            if ( details != null ) {\n                details.setPhone( null );\n                this.details = null;\n            }\n        }\n    }\n\t\n---\n\t\n\t@Entity(name = \"PhoneDetails\")\n\tpublic static class PhoneDetails {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String provider;\n\t\n\t    private String technology;\n\t\n\t    @OneToOne(fetch = FetchType.LAZY)\n\t    @JoinColumn(name = \"phone_id\")\n\t    private Phone phone;\n\t\n\t    public PhoneDetails() {\n\t    }\n\t\n\t    public PhoneDetails(String provider, String technology) {\n\t        this.provider = provider;\n\t        this.technology = technology;\n\t    }\n\t\n\t    public String getProvider() {\n\t        return provider;\n\t    }\n\t\n\t    public String getTechnology() {\n\t        return technology;\n\t    }\n\t\n\t    public void setTechnology(String technology) {\n\t        this.technology = technology;\n\t    }\n\t\n\t    public Phone getPhone() {\n\t        return phone;\n\t    }\n\t\n\t    public void setPhone(Phone phone) {\n\t        this.phone = phone;\n\t    }\n\t}\n\n- *生成sql*：\n\n\n    CREATE TABLE Phone (\n        id BIGINT NOT NULL ,\n        number VARCHAR(255) ,\n        PRIMARY KEY ( id )\n    )\n    \n    CREATE TABLE PhoneDetails (\n        id BIGINT NOT NULL ,\n        provider VARCHAR(255) ,\n        technology VARCHAR(255) ,\n        phone_id BIGINT ,\n        PRIMARY KEY ( id )\n    )\n    \n    ALTER TABLE PhoneDetails\n    ADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\n    FOREIGN KEY (phone_id) REFERENCES Phone\n\n- *操作*：\n\n\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tPhoneDetails details = new PhoneDetails( \"T-Mobile\", \"GSM\" );\n\t\n\tphone.addDetails( details );\n\tentityManager.persist( phone );\n\t\n\t-------------------------------------\n\tINSERT INTO Phone ( number, id )\n\tVALUES ( '123 - 456 - 7890', 1 )\n\t\n\tINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\n\tVALUES ( 1, 'T - Mobile, GSM', 2 )\n\t\n\n---\n## 2. OneToMany\n一对多关系，一般在多的一段维护，也可双边维护关系。\n\n#### 2.1 单向 @OneToMany association\n\n- 实体:\n\n\n    @Entity(name = \"Person\")\n    public static class Person {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n        @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n        private List<Phone> phones = new ArrayList<>();\n    \n        public Person() {\n        }\n    \n        public List<Phone> getPhones() {\n            return phones;\n        }\n    }\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\n\tCREATE TABLE Person_Phone (\n\t    Person_id BIGINT NOT NULL ,\n\t    phones_id BIGINT NOT NULL\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\n\tUNIQUE (phones_id)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\n\tFOREIGN KEY (phones_id) REFERENCES Phone\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\n- *操作代码*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.getPhones().add( phone1 );\n\tperson.getPhones().add( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.getPhones().remove( phone1 );\n\t\n\t-----------------------------------------------\n\tINSERT INTO Person\n       ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '123 - 456 - 7890', 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '321 - 654 - 0987', 3 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Person_Phone\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n#### 2.2 双向@OneToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<Phone> phones = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(Long id) {\n\t        this.id = id;\n\t    }\n\t\n\t    public List<Phone> getPhones() {\n\t        return phones;\n\t    }\n\t\n\t    public void addPhone(Phone phone) {\n\t        phones.add( phone );\n\t        phone.setPerson( this );\n\t    }\n\t\n\t    public void removePhone(Phone phone) {\n\t        phones.remove( phone );\n\t        phone.setPerson( null );\n\t    }\n\t}\t\t\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    @Column(name = \"`number`\", unique = true)\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Phone phone = (Phone) o;\n\t        return Objects.equals( number, phone.number );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( number );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\n\tUNIQUE (number)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\n\tFOREIGN KEY (person_id) REFERENCES Person\n\n- *操作*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.addPhone( phone1 );\n\tperson.addPhone( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.removePhone( phone1 );\t\n\t\n\t-----------------------------------------\n\t\n\tINSERT INTO Phone\n       ( number, person_id, id )\n\tVALUES ( '123-456-7890', NULL, 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, person_id, id )\n\tVALUES ( '321-654-0987', NULL, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n---\n## 3. ManyToOne\n多对一关系\n\n#### 3.1 @ManyToOne association\n相当于外键\n\n- 实体\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t\t@Id\n\t\t@GeneratedValue\n\t\tprivate Long id;\n\t\t\n\t\tpublic Person() {\n\t\t\n\t\t}\n\t}\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    @JoinColumn(name = \"person_id\",\n\t            foreignKey = @ForeignKey(name = \"PERSON_ID_FK\")\n\t    )\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT PERSON_ID_FK\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n- *生命周期*:\n\n\n\tPerson person = new Person();\n\tentityManager.persist( person );\n\t\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tphone.setPerson( person );\n\tentityManager.persist( phone );\n\t\n\tentityManager.flush();\n\tphone.setPerson( null );\n\t\n\t实际sql：\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone ( number, person_id, id )\n\tVALUES ( '123-456-7890', 1, 2 )\n\t\n\tUPDATE Phone\n\tSET    number = '123-456-7890',\n\t       person_id = NULL\n\tWHERE  id = 2\n\n---\t\n## 4. ManyToMany\n多对多关系，两边都要维护。\n\n#### 4.1 单向 @ManyToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number) {\n\t        this.street = street;\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    Person_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person();\n\tPerson person2 = new Person();\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\" );\n\t\n\tperson1.getAddresses().add( address1 );\n\tperson1.getAddresses().add( address2 );\n\t\n\tperson2.getAddresses().add( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.getAddresses().remove( address1 );\n\t\n\t-------------------------------------------\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '12A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '18B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( id )\n\tVALUES ( 4 )\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 2 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.2 双向 @ManyToMany\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        addresses.add( address );\n\t        address.getOwners().add( this );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        addresses.remove( address );\n\t        address.getOwners().remove( this );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @ManyToMany(mappedBy = \"addresses\")\n\t    private List<Person> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<Person> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    owners_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\n\tFOREIGN KEY (owners_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.removeAddress( address1 );\n\t\n\t------------------------------------------\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'ABC-123', 1 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '12A', '4005A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '18B', '4007B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'DEF-456', 4 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  owners_id = 1\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.3 双向 many-to-many with a link entity\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public List<PersonAddress> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        addresses.add( personAddress );\n\t        address.getOwners().add( personAddress );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        address.getOwners().remove( personAddress );\n\t        addresses.remove( personAddress );\n\t        personAddress.setPerson( null );\n\t        personAddress.setAddress( null );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"PersonAddress\")\n\tpublic static class PersonAddress implements Serializable {\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Address address;\n\t\n\t    public PersonAddress() {\n\t    }\n\t\n\t    public PersonAddress(Person person, Address address) {\n\t        this.person = person;\n\t        this.address = address;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    public Address getAddress() {\n\t        return address;\n\t    }\n\t\n\t    public void setAddress(Address address) {\n\t        this.address = address;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        PersonAddress that = (PersonAddress) o;\n\t        return Objects.equals( person, that.person ) &&\n\t                Objects.equals( address, that.address );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( person, address );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @OneToMany(mappedBy = \"address\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<PersonAddress> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE PersonAddress (\n\t    person_id BIGINT NOT NULL ,\n\t    address_id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( person_id, address_id )\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\n\tFOREIGN KEY (address_id) REFERENCES Address\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.persist( address1 );\n\tentityManager.persist( address2 );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.flush();\n\t\n\tlog.info( \"Removing address\" );\n\tperson1.removeAddress( address1 );\n\t---------------------------------------------------\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'ABC-123', 1 )\n\t\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'DEF-456', 2 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '12A', '4005A', '12th Avenue', 3 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '18B', '4007B', '18th Avenue', 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 3 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 2, 3 )\n\t\n\tDELETE  FROM PersonAddress\n\tWHERE   person_id = 1 AND address_id = 3\n\t\n\n\t","slug":"hibernate-relation-mapping","published":1,"updated":"2019-06-16T14:38:33.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqc9004ig4va6dj3xm1u","content":"<h2 id=\"1-OneToOne\"><a href=\"#1-OneToOne\" class=\"headerlink\" title=\"1. OneToOne\"></a>1. OneToOne</h2><p>一对一关系，存在n+1问题。</p>\n<h4 id=\"1-1-单向-OneToOne\"><a href=\"#1-1-单向-OneToOne\" class=\"headerlink\" title=\"1.1 单向 @OneToOne\"></a>1.1 单向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne\n    @JoinColumn(name = &quot;details_id&quot;)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void setDetails(PhoneDetails details) {\n        this.details = details;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n}\n</code></pre><ul>\n<li><p><em>生成sql</em>：</p>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    details_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\nFOREIGN KEY (details_id) REFERENCES PhoneDetails\n</code></pre></li>\n</ul>\n<ul>\n<li><em>操作</em>：<br>  作为外键，相当于ManyToOne作为外键操作</li>\n</ul>\n<hr>\n<h4 id=\"1-2-双向-OneToOne\"><a href=\"#1-2-双向-OneToOne\" class=\"headerlink\" title=\"1.2 双向 @OneToOne\"></a>1.2 双向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne(mappedBy = &quot;phone&quot;, cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void addDetails(PhoneDetails details) {\n        details.setPhone( this );\n        this.details = details;\n    }\n\n    public void removeDetails() {\n        if ( details != null ) {\n            details.setPhone( null );\n            this.details = null;\n        }\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    @OneToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;phone_id&quot;)\n    private Phone phone;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    phone_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE PhoneDetails\nADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\nFOREIGN KEY (phone_id) REFERENCES Phone\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Phone phone = new Phone( &quot;123-456-7890&quot; );\nPhoneDetails details = new PhoneDetails( &quot;T-Mobile&quot;, &quot;GSM&quot; );\n\nphone.addDetails( details );\nentityManager.persist( phone );\n\n-------------------------------------\nINSERT INTO Phone ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 1 )\n\nINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\nVALUES ( 1, &apos;T - Mobile, GSM&apos;, 2 )\n</code></pre><hr>\n<h2 id=\"2-OneToMany\"><a href=\"#2-OneToMany\" class=\"headerlink\" title=\"2. OneToMany\"></a>2. OneToMany</h2><p>一对多关系，一般在多的一段维护，也可双边维护关系。</p>\n<h4 id=\"2-1-单向-OneToMany-association\"><a href=\"#2-1-单向-OneToMany-association\" class=\"headerlink\" title=\"2.1 单向 @OneToMany association\"></a>2.1 单向 @OneToMany association</h4><ul>\n<li>实体:</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Phone (\n    Person_id BIGINT NOT NULL ,\n    phones_id BIGINT NOT NULL\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\nUNIQUE (phones_id)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\nFOREIGN KEY (phones_id) REFERENCES Phone\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作代码</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.getPhones().add( phone1 );\nperson.getPhones().add( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.getPhones().remove( phone1 );\n\n-----------------------------------------------\nINSERT INTO Person\n   ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 2 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;321 - 654 - 0987&apos;, 3 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Person_Phone\nWHERE  Person_id = 1\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><h4 id=\"2-2-双向-OneToMany\"><a href=\"#2-2-双向-OneToMany\" class=\"headerlink\" title=\"2.2 双向@OneToMany\"></a>2.2 双向@OneToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(Long id) {\n        this.id = id;\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n\n    public void addPhone(Phone phone) {\n        phones.add( phone );\n        phone.setPerson( this );\n    }\n\n    public void removePhone(Phone phone) {\n        phones.remove( phone );\n        phone.setPerson( null );\n    }\n}        \n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    @Column(name = &quot;`number`&quot;, unique = true)\n    private String number;\n\n    @ManyToOne\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Phone phone = (Phone) o;\n        return Objects.equals( number, phone.number );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( number );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\nUNIQUE (number)\n\nALTER TABLE Phone\nADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.addPhone( phone1 );\nperson.addPhone( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.removePhone( phone1 );    \n\n-----------------------------------------\n\nINSERT INTO Phone\n   ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, NULL, 2 )\n\nINSERT INTO Phone\n       ( number, person_id, id )\nVALUES ( &apos;321-654-0987&apos;, NULL, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"3-ManyToOne\"><a href=\"#3-ManyToOne\" class=\"headerlink\" title=\"3. ManyToOne\"></a>3. ManyToOne</h2><p>多对一关系</p>\n<h4 id=\"3-1-ManyToOne-association\"><a href=\"#3-1-ManyToOne-association\" class=\"headerlink\" title=\"3.1 @ManyToOne association\"></a>3.1 @ManyToOne association</h4><p>相当于外键</p>\n<ul>\n<li>实体</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    public Person() {\n\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;person_id&quot;,\n            foreignKey = @ForeignKey(name = &quot;PERSON_ID_FK&quot;)\n    )\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT PERSON_ID_FK\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>生命周期</em>:</li>\n</ul>\n<pre><code>Person person = new Person();\nentityManager.persist( person );\n\nPhone phone = new Phone( &quot;123-456-7890&quot; );\nphone.setPerson( person );\nentityManager.persist( phone );\n\nentityManager.flush();\nphone.setPerson( null );\n\n实际sql：\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, 1, 2 )\n\nUPDATE Phone\nSET    number = &apos;123-456-7890&apos;,\n       person_id = NULL\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"4-ManyToMany\"><a href=\"#4-ManyToMany\" class=\"headerlink\" title=\"4. ManyToMany\"></a>4. ManyToMany</h2><p>多对多关系，两边都要维护。</p>\n<h4 id=\"4-1-单向-ManyToMany\"><a href=\"#4-1-单向-ManyToMany\" class=\"headerlink\" title=\"4.1 单向 @ManyToMany\"></a>4.1 单向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Address() {\n    }\n\n    public Address(String street, String number) {\n        this.street = street;\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    Person_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person();\nPerson person2 = new Person();\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot; );\n\nperson1.getAddresses().add( address1 );\nperson1.getAddresses().add( address2 );\n\nperson2.getAddresses().add( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.getAddresses().remove( address1 );\n\n-------------------------------------------\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;12A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;18B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( id )\nVALUES ( 4 )\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 2 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  Person_id = 1\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-2-双向-ManyToMany\"><a href=\"#4-2-双向-ManyToMany\" class=\"headerlink\" title=\"4.2 双向 @ManyToMany\"></a>4.2 双向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        addresses.add( address );\n        address.getOwners().add( this );\n    }\n\n    public void removeAddress(Address address) {\n        addresses.remove( address );\n        address.getOwners().remove( this );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @ManyToMany(mappedBy = &quot;addresses&quot;)\n    private List&lt;Person&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;Person&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    owners_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\nFOREIGN KEY (owners_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.removeAddress( address1 );\n\n------------------------------------------\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;ABC-123&apos;, 1 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;DEF-456&apos;, 4 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  owners_id = 1\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-3-双向-many-to-many-with-a-link-entity\"><a href=\"#4-3-双向-many-to-many-with-a-link-entity\" class=\"headerlink\" title=\"4.3 双向 many-to-many with a link entity\"></a>4.3 双向 many-to-many with a link entity</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public List&lt;PersonAddress&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        addresses.add( personAddress );\n        address.getOwners().add( personAddress );\n    }\n\n    public void removeAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        address.getOwners().remove( personAddress );\n        addresses.remove( personAddress );\n        personAddress.setPerson( null );\n        personAddress.setAddress( null );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PersonAddress&quot;)\npublic static class PersonAddress implements Serializable {\n\n    @Id\n    @ManyToOne\n    private Person person;\n\n    @Id\n    @ManyToOne\n    private Address address;\n\n    public PersonAddress() {\n    }\n\n    public PersonAddress(Person person, Address address) {\n        this.person = person;\n        this.address = address;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        PersonAddress that = (PersonAddress) o;\n        return Objects.equals( person, that.person ) &amp;&amp;\n                Objects.equals( address, that.address );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( person, address );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @OneToMany(mappedBy = &quot;address&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;PersonAddress&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PersonAddress (\n    person_id BIGINT NOT NULL ,\n    address_id BIGINT NOT NULL ,\n    PRIMARY KEY ( person_id, address_id )\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\nFOREIGN KEY (person_id) REFERENCES Person\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\nFOREIGN KEY (address_id) REFERENCES Address\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.persist( address1 );\nentityManager.persist( address2 );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.flush();\n\nlog.info( &quot;Removing address&quot; );\nperson1.removeAddress( address1 );\n---------------------------------------------------\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;ABC-123&apos;, 1 )\n\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;DEF-456&apos;, 2 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 3 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 3 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 2, 3 )\n\nDELETE  FROM PersonAddress\nWHERE   person_id = 1 AND address_id = 3\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-OneToOne\"><a href=\"#1-OneToOne\" class=\"headerlink\" title=\"1. OneToOne\"></a>1. OneToOne</h2><p>一对一关系，存在n+1问题。</p>\n<h4 id=\"1-1-单向-OneToOne\"><a href=\"#1-1-单向-OneToOne\" class=\"headerlink\" title=\"1.1 单向 @OneToOne\"></a>1.1 单向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne\n    @JoinColumn(name = &quot;details_id&quot;)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void setDetails(PhoneDetails details) {\n        this.details = details;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n}\n</code></pre><ul>\n<li><p><em>生成sql</em>：</p>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    details_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\nFOREIGN KEY (details_id) REFERENCES PhoneDetails\n</code></pre></li>\n</ul>\n<ul>\n<li><em>操作</em>：<br>  作为外键，相当于ManyToOne作为外键操作</li>\n</ul>\n<hr>\n<h4 id=\"1-2-双向-OneToOne\"><a href=\"#1-2-双向-OneToOne\" class=\"headerlink\" title=\"1.2 双向 @OneToOne\"></a>1.2 双向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne(mappedBy = &quot;phone&quot;, cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void addDetails(PhoneDetails details) {\n        details.setPhone( this );\n        this.details = details;\n    }\n\n    public void removeDetails() {\n        if ( details != null ) {\n            details.setPhone( null );\n            this.details = null;\n        }\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    @OneToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;phone_id&quot;)\n    private Phone phone;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    phone_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE PhoneDetails\nADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\nFOREIGN KEY (phone_id) REFERENCES Phone\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Phone phone = new Phone( &quot;123-456-7890&quot; );\nPhoneDetails details = new PhoneDetails( &quot;T-Mobile&quot;, &quot;GSM&quot; );\n\nphone.addDetails( details );\nentityManager.persist( phone );\n\n-------------------------------------\nINSERT INTO Phone ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 1 )\n\nINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\nVALUES ( 1, &apos;T - Mobile, GSM&apos;, 2 )\n</code></pre><hr>\n<h2 id=\"2-OneToMany\"><a href=\"#2-OneToMany\" class=\"headerlink\" title=\"2. OneToMany\"></a>2. OneToMany</h2><p>一对多关系，一般在多的一段维护，也可双边维护关系。</p>\n<h4 id=\"2-1-单向-OneToMany-association\"><a href=\"#2-1-单向-OneToMany-association\" class=\"headerlink\" title=\"2.1 单向 @OneToMany association\"></a>2.1 单向 @OneToMany association</h4><ul>\n<li>实体:</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Phone (\n    Person_id BIGINT NOT NULL ,\n    phones_id BIGINT NOT NULL\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\nUNIQUE (phones_id)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\nFOREIGN KEY (phones_id) REFERENCES Phone\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作代码</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.getPhones().add( phone1 );\nperson.getPhones().add( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.getPhones().remove( phone1 );\n\n-----------------------------------------------\nINSERT INTO Person\n   ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 2 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;321 - 654 - 0987&apos;, 3 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Person_Phone\nWHERE  Person_id = 1\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><h4 id=\"2-2-双向-OneToMany\"><a href=\"#2-2-双向-OneToMany\" class=\"headerlink\" title=\"2.2 双向@OneToMany\"></a>2.2 双向@OneToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(Long id) {\n        this.id = id;\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n\n    public void addPhone(Phone phone) {\n        phones.add( phone );\n        phone.setPerson( this );\n    }\n\n    public void removePhone(Phone phone) {\n        phones.remove( phone );\n        phone.setPerson( null );\n    }\n}        \n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    @Column(name = &quot;`number`&quot;, unique = true)\n    private String number;\n\n    @ManyToOne\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Phone phone = (Phone) o;\n        return Objects.equals( number, phone.number );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( number );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\nUNIQUE (number)\n\nALTER TABLE Phone\nADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.addPhone( phone1 );\nperson.addPhone( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.removePhone( phone1 );    \n\n-----------------------------------------\n\nINSERT INTO Phone\n   ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, NULL, 2 )\n\nINSERT INTO Phone\n       ( number, person_id, id )\nVALUES ( &apos;321-654-0987&apos;, NULL, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"3-ManyToOne\"><a href=\"#3-ManyToOne\" class=\"headerlink\" title=\"3. ManyToOne\"></a>3. ManyToOne</h2><p>多对一关系</p>\n<h4 id=\"3-1-ManyToOne-association\"><a href=\"#3-1-ManyToOne-association\" class=\"headerlink\" title=\"3.1 @ManyToOne association\"></a>3.1 @ManyToOne association</h4><p>相当于外键</p>\n<ul>\n<li>实体</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    public Person() {\n\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;person_id&quot;,\n            foreignKey = @ForeignKey(name = &quot;PERSON_ID_FK&quot;)\n    )\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT PERSON_ID_FK\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>生命周期</em>:</li>\n</ul>\n<pre><code>Person person = new Person();\nentityManager.persist( person );\n\nPhone phone = new Phone( &quot;123-456-7890&quot; );\nphone.setPerson( person );\nentityManager.persist( phone );\n\nentityManager.flush();\nphone.setPerson( null );\n\n实际sql：\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, 1, 2 )\n\nUPDATE Phone\nSET    number = &apos;123-456-7890&apos;,\n       person_id = NULL\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"4-ManyToMany\"><a href=\"#4-ManyToMany\" class=\"headerlink\" title=\"4. ManyToMany\"></a>4. ManyToMany</h2><p>多对多关系，两边都要维护。</p>\n<h4 id=\"4-1-单向-ManyToMany\"><a href=\"#4-1-单向-ManyToMany\" class=\"headerlink\" title=\"4.1 单向 @ManyToMany\"></a>4.1 单向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Address() {\n    }\n\n    public Address(String street, String number) {\n        this.street = street;\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    Person_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person();\nPerson person2 = new Person();\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot; );\n\nperson1.getAddresses().add( address1 );\nperson1.getAddresses().add( address2 );\n\nperson2.getAddresses().add( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.getAddresses().remove( address1 );\n\n-------------------------------------------\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;12A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;18B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( id )\nVALUES ( 4 )\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 2 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  Person_id = 1\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-2-双向-ManyToMany\"><a href=\"#4-2-双向-ManyToMany\" class=\"headerlink\" title=\"4.2 双向 @ManyToMany\"></a>4.2 双向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        addresses.add( address );\n        address.getOwners().add( this );\n    }\n\n    public void removeAddress(Address address) {\n        addresses.remove( address );\n        address.getOwners().remove( this );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @ManyToMany(mappedBy = &quot;addresses&quot;)\n    private List&lt;Person&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;Person&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    owners_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\nFOREIGN KEY (owners_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.removeAddress( address1 );\n\n------------------------------------------\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;ABC-123&apos;, 1 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;DEF-456&apos;, 4 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  owners_id = 1\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-3-双向-many-to-many-with-a-link-entity\"><a href=\"#4-3-双向-many-to-many-with-a-link-entity\" class=\"headerlink\" title=\"4.3 双向 many-to-many with a link entity\"></a>4.3 双向 many-to-many with a link entity</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public List&lt;PersonAddress&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        addresses.add( personAddress );\n        address.getOwners().add( personAddress );\n    }\n\n    public void removeAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        address.getOwners().remove( personAddress );\n        addresses.remove( personAddress );\n        personAddress.setPerson( null );\n        personAddress.setAddress( null );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PersonAddress&quot;)\npublic static class PersonAddress implements Serializable {\n\n    @Id\n    @ManyToOne\n    private Person person;\n\n    @Id\n    @ManyToOne\n    private Address address;\n\n    public PersonAddress() {\n    }\n\n    public PersonAddress(Person person, Address address) {\n        this.person = person;\n        this.address = address;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        PersonAddress that = (PersonAddress) o;\n        return Objects.equals( person, that.person ) &amp;&amp;\n                Objects.equals( address, that.address );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( person, address );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @OneToMany(mappedBy = &quot;address&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;PersonAddress&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PersonAddress (\n    person_id BIGINT NOT NULL ,\n    address_id BIGINT NOT NULL ,\n    PRIMARY KEY ( person_id, address_id )\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\nFOREIGN KEY (person_id) REFERENCES Person\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\nFOREIGN KEY (address_id) REFERENCES Address\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.persist( address1 );\nentityManager.persist( address2 );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.flush();\n\nlog.info( &quot;Removing address&quot; );\nperson1.removeAddress( address1 );\n---------------------------------------------------\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;ABC-123&apos;, 1 )\n\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;DEF-456&apos;, 2 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 3 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 3 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 2, 3 )\n\nDELETE  FROM PersonAddress\nWHERE   person_id = 1 AND address_id = 3\n</code></pre>"},{"title":"idea插件利器","date":"2017-11-10T01:55:50.000Z","_content":"\n## GsonFormat\n1. 作用：json字符串自动生成javabean工具。\n2. 使用：\n\n\n\n## web开发利器emmet\n\n官网：https://emmet.io/\n\n## 热部署神器JRebel\n\n### JRebel插件的安装以及破解\n\nidea版本： IntelliJ IDEA 2019.2 x64\n\n参考：      \nhttps://blog.csdn.net/qq_41570658/article/details/96280146      \nhttps://github.com/ilanyu/ReverseProxy/releases/tag/v1.4\n\n1.第一步，idea在线安装JRebel插件。     \n2.第二步，激活JRebel：\n     \n- 下载https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4，并运行exe文件。       \n- 安装下图方式进行激活，   \nLicense Server: http://127.0.0.1:8888/88414687-3b91-4286-89ba-2dc813b107ce      \nemail: 932852117@qq.com \n\n{%asset_img c-1.png%}\n\n- 设置离线模式        \n\n{%asset_img c-2.png%}\n\n- 激活成功后，你应该看到如下图：\n\n{%asset_img c-3.png%}\n\n### JRebel使用\n\n","source":"_posts/idea-good-plug.md","raw":"---\ntitle: idea插件利器\ndate: 2017-11-10 09:55:50\ncategories: idea\ntags:\n---\n\n## GsonFormat\n1. 作用：json字符串自动生成javabean工具。\n2. 使用：\n\n\n\n## web开发利器emmet\n\n官网：https://emmet.io/\n\n## 热部署神器JRebel\n\n### JRebel插件的安装以及破解\n\nidea版本： IntelliJ IDEA 2019.2 x64\n\n参考：      \nhttps://blog.csdn.net/qq_41570658/article/details/96280146      \nhttps://github.com/ilanyu/ReverseProxy/releases/tag/v1.4\n\n1.第一步，idea在线安装JRebel插件。     \n2.第二步，激活JRebel：\n     \n- 下载https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4，并运行exe文件。       \n- 安装下图方式进行激活，   \nLicense Server: http://127.0.0.1:8888/88414687-3b91-4286-89ba-2dc813b107ce      \nemail: 932852117@qq.com \n\n{%asset_img c-1.png%}\n\n- 设置离线模式        \n\n{%asset_img c-2.png%}\n\n- 激活成功后，你应该看到如下图：\n\n{%asset_img c-3.png%}\n\n### JRebel使用\n\n","slug":"idea-good-plug","published":1,"updated":"2020-05-30T11:28:23.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqca004kg4vahfq1obga","content":"<h2 id=\"GsonFormat\"><a href=\"#GsonFormat\" class=\"headerlink\" title=\"GsonFormat\"></a>GsonFormat</h2><ol>\n<li>作用：json字符串自动生成javabean工具。</li>\n<li>使用：</li>\n</ol>\n<h2 id=\"web开发利器emmet\"><a href=\"#web开发利器emmet\" class=\"headerlink\" title=\"web开发利器emmet\"></a>web开发利器emmet</h2><p>官网：<a href=\"https://emmet.io/\" target=\"_blank\" rel=\"noopener\">https://emmet.io/</a></p>\n<h2 id=\"热部署神器JRebel\"><a href=\"#热部署神器JRebel\" class=\"headerlink\" title=\"热部署神器JRebel\"></a>热部署神器JRebel</h2><h3 id=\"JRebel插件的安装以及破解\"><a href=\"#JRebel插件的安装以及破解\" class=\"headerlink\" title=\"JRebel插件的安装以及破解\"></a>JRebel插件的安装以及破解</h3><p>idea版本： IntelliJ IDEA 2019.2 x64</p>\n<p>参考：<br><a href=\"https://blog.csdn.net/qq_41570658/article/details/96280146\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_41570658/article/details/96280146</a><br><a href=\"https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4\" target=\"_blank\" rel=\"noopener\">https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4</a></p>\n<p>1.第一步，idea在线安装JRebel插件。<br>2.第二步，激活JRebel：</p>\n<ul>\n<li>下载<a href=\"https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4，并运行exe文件。\" target=\"_blank\" rel=\"noopener\">https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4，并运行exe文件。</a>       </li>\n<li>安装下图方式进行激活，<br>License Server: <a href=\"http://127.0.0.1:8888/88414687-3b91-4286-89ba-2dc813b107ce\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8888/88414687-3b91-4286-89ba-2dc813b107ce</a><br>email: <a href=\"mailto:932852117@qq.com\" target=\"_blank\" rel=\"noopener\">932852117@qq.com</a> </li>\n</ul>\n<img src=\"/2017/11/10/idea-good-plug/c-1.png\">\n<ul>\n<li>设置离线模式        </li>\n</ul>\n<img src=\"/2017/11/10/idea-good-plug/c-2.png\">\n<ul>\n<li>激活成功后，你应该看到如下图：</li>\n</ul>\n<img src=\"/2017/11/10/idea-good-plug/c-3.png\">\n<h3 id=\"JRebel使用\"><a href=\"#JRebel使用\" class=\"headerlink\" title=\"JRebel使用\"></a>JRebel使用</h3>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"GsonFormat\"><a href=\"#GsonFormat\" class=\"headerlink\" title=\"GsonFormat\"></a>GsonFormat</h2><ol>\n<li>作用：json字符串自动生成javabean工具。</li>\n<li>使用：</li>\n</ol>\n<h2 id=\"web开发利器emmet\"><a href=\"#web开发利器emmet\" class=\"headerlink\" title=\"web开发利器emmet\"></a>web开发利器emmet</h2><p>官网：<a href=\"https://emmet.io/\" target=\"_blank\" rel=\"noopener\">https://emmet.io/</a></p>\n<h2 id=\"热部署神器JRebel\"><a href=\"#热部署神器JRebel\" class=\"headerlink\" title=\"热部署神器JRebel\"></a>热部署神器JRebel</h2><h3 id=\"JRebel插件的安装以及破解\"><a href=\"#JRebel插件的安装以及破解\" class=\"headerlink\" title=\"JRebel插件的安装以及破解\"></a>JRebel插件的安装以及破解</h3><p>idea版本： IntelliJ IDEA 2019.2 x64</p>\n<p>参考：<br><a href=\"https://blog.csdn.net/qq_41570658/article/details/96280146\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/qq_41570658/article/details/96280146</a><br><a href=\"https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4\" target=\"_blank\" rel=\"noopener\">https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4</a></p>\n<p>1.第一步，idea在线安装JRebel插件。<br>2.第二步，激活JRebel：</p>\n<ul>\n<li>下载<a href=\"https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4，并运行exe文件。\" target=\"_blank\" rel=\"noopener\">https://github.com/ilanyu/ReverseProxy/releases/tag/v1.4，并运行exe文件。</a>       </li>\n<li>安装下图方式进行激活，<br>License Server: <a href=\"http://127.0.0.1:8888/88414687-3b91-4286-89ba-2dc813b107ce\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8888/88414687-3b91-4286-89ba-2dc813b107ce</a><br>email: <a href=\"mailto:932852117@qq.com\" target=\"_blank\" rel=\"noopener\">932852117@qq.com</a> </li>\n</ul>\n<img src=\"/2017/11/10/idea-good-plug/c-1.png\">\n<ul>\n<li>设置离线模式        </li>\n</ul>\n<img src=\"/2017/11/10/idea-good-plug/c-2.png\">\n<ul>\n<li>激活成功后，你应该看到如下图：</li>\n</ul>\n<img src=\"/2017/11/10/idea-good-plug/c-3.png\">\n<h3 id=\"JRebel使用\"><a href=\"#JRebel使用\" class=\"headerlink\" title=\"JRebel使用\"></a>JRebel使用</h3>"},{"title":"idea 使用问题收集","date":"2017-11-10T01:52:52.000Z","_content":"\n## maven控制台输出乱码\n\n问题描述：\n\n执行maven命令，控制台输出中文乱码。\n\n解决方案：\n\n解决：maven默认环境为jdk,只需要改如下即可：\n在IDEA中，打开File | Settings | Build, Execution, Deployment | Build Tools | Maven | Runner在VM Options中\n添加-Dfile.encoding=GBK，切记一定是GBK。即使用UTF-8的话，依然是乱码，这是因为Maven的默认平台编码是GBK，\n如果你在命令行中输入mvn -version的话，会得到如下信息，根据Default locale可以看出","source":"_posts/idea-use-ofen.md","raw":"---\ntitle: idea 使用问题收集\ndate: 2017-11-10 09:52:52\ncategories: idea\ntags:\n---\n\n## maven控制台输出乱码\n\n问题描述：\n\n执行maven命令，控制台输出中文乱码。\n\n解决方案：\n\n解决：maven默认环境为jdk,只需要改如下即可：\n在IDEA中，打开File | Settings | Build, Execution, Deployment | Build Tools | Maven | Runner在VM Options中\n添加-Dfile.encoding=GBK，切记一定是GBK。即使用UTF-8的话，依然是乱码，这是因为Maven的默认平台编码是GBK，\n如果你在命令行中输入mvn -version的话，会得到如下信息，根据Default locale可以看出","slug":"idea-use-ofen","published":1,"updated":"2020-05-30T11:28:23.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcc004ng4vap97dr7j3","content":"<h2 id=\"maven控制台输出乱码\"><a href=\"#maven控制台输出乱码\" class=\"headerlink\" title=\"maven控制台输出乱码\"></a>maven控制台输出乱码</h2><p>问题描述：</p>\n<p>执行maven命令，控制台输出中文乱码。</p>\n<p>解决方案：</p>\n<p>解决：maven默认环境为jdk,只需要改如下即可：<br>在IDEA中，打开File | Settings | Build, Execution, Deployment | Build Tools | Maven | Runner在VM Options中<br>添加-Dfile.encoding=GBK，切记一定是GBK。即使用UTF-8的话，依然是乱码，这是因为Maven的默认平台编码是GBK，<br>如果你在命令行中输入mvn -version的话，会得到如下信息，根据Default locale可以看出</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"maven控制台输出乱码\"><a href=\"#maven控制台输出乱码\" class=\"headerlink\" title=\"maven控制台输出乱码\"></a>maven控制台输出乱码</h2><p>问题描述：</p>\n<p>执行maven命令，控制台输出中文乱码。</p>\n<p>解决方案：</p>\n<p>解决：maven默认环境为jdk,只需要改如下即可：<br>在IDEA中，打开File | Settings | Build, Execution, Deployment | Build Tools | Maven | Runner在VM Options中<br>添加-Dfile.encoding=GBK，切记一定是GBK。即使用UTF-8的话，依然是乱码，这是因为Maven的默认平台编码是GBK，<br>如果你在命令行中输入mvn -version的话，会得到如下信息，根据Default locale可以看出</p>\n"},{"title":"jackson使用录","date":"2017-10-01T01:07:36.000Z","_content":"## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","source":"_posts/jackson-show-time.md","raw":"---\ntitle: jackson使用录\ndate: 2017-10-01 09:07:36\ncategories: json\ntags: jackson\n---\n## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","slug":"jackson-show-time","published":1,"updated":"2019-06-16T14:38:33.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcd004qg4van5g0eamk","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>"},{"title":"服务网格istio入门","date":"2018-03-13T00:57:27.000Z","_content":"\n参考网址： http://www.servicemesher.com/blog/istio-service-mesh-tutorial/\n","source":"_posts/istio-start.md","raw":"---\ntitle: 服务网格istio入门\ndate: 2018-03-13 08:57:27\ncategories: 服务网格\ntags: istio\n---\n\n参考网址： http://www.servicemesher.com/blog/istio-service-mesh-tutorial/\n","slug":"istio-start","published":1,"updated":"2019-06-16T14:38:33.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqce004tg4vaajbvolkr","content":"<p>参考网址： <a href=\"http://www.servicemesher.com/blog/istio-service-mesh-tutorial/\" target=\"_blank\" rel=\"noopener\">http://www.servicemesher.com/blog/istio-service-mesh-tutorial/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考网址： <a href=\"http://www.servicemesher.com/blog/istio-service-mesh-tutorial/\" target=\"_blank\" rel=\"noopener\">http://www.servicemesher.com/blog/istio-service-mesh-tutorial/</a></p>\n"},{"title":"计算机基础-java二进制编码","date":"2017-10-27T06:57:22.000Z","_content":"","source":"_posts/java-bit.md","raw":"---\ntitle: 计算机基础-java二进制编码\ndate: 2017-10-27 14:57:22\ncategories: java\ntags:\n---\n","slug":"java-bit","published":1,"updated":"2019-06-16T14:38:33.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcf004vg4va0yvbervm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"计算机基础-字符集","date":"2017-10-26T06:57:22.000Z","_content":"\nhttps://blog.csdn.net/lzm18064126848/article/details/50484936\n","source":"_posts/java-charset.md","raw":"---\ntitle: 计算机基础-字符集\ndate: 2017-10-26 14:57:22\ncategories: java\ntags:\n---\n\nhttps://blog.csdn.net/lzm18064126848/article/details/50484936\n","slug":"java-charset","published":1,"updated":"2019-06-16T14:38:33.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqch004zg4vadmr6289q","content":"<p><a href=\"https://blog.csdn.net/lzm18064126848/article/details/50484936\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lzm18064126848/article/details/50484936</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://blog.csdn.net/lzm18064126848/article/details/50484936\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/lzm18064126848/article/details/50484936</a></p>\n"},{"title":"Java代码规范插件Checkstyle","date":"2018-12-03T14:54:03.000Z","_content":"\n系统开发一段时间下来，看到各个组员写的代码风格各自，参差不齐。甚至连空格，换行，缩进，基本命名都有问题，此时，心堵！  \n为了以后避免这种情况，那就只能在项目伊始就要加入代码规范约束，统一代码风格。而Checkstyle作为Java家族中有名的一员，就是要干那么一件事情的。    \n下面我们就来介绍Checkstyle的使用，以及结合谷歌java代码风格或者阿里巴巴的java代码风格的使用。 \n\n官网：https://checkstyle.org/\n\n参考：https://www.cnblogs.com/SummerinShire/p/6237440.htm","source":"_posts/java-checkstyle.md","raw":"---\ntitle: Java代码规范插件Checkstyle\ndate: 2018-12-03 22:54:03\ncategories: java\ntags:\n---\n\n系统开发一段时间下来，看到各个组员写的代码风格各自，参差不齐。甚至连空格，换行，缩进，基本命名都有问题，此时，心堵！  \n为了以后避免这种情况，那就只能在项目伊始就要加入代码规范约束，统一代码风格。而Checkstyle作为Java家族中有名的一员，就是要干那么一件事情的。    \n下面我们就来介绍Checkstyle的使用，以及结合谷歌java代码风格或者阿里巴巴的java代码风格的使用。 \n\n官网：https://checkstyle.org/\n\n参考：https://www.cnblogs.com/SummerinShire/p/6237440.htm","slug":"java-checkstyle","published":1,"updated":"2019-06-16T14:38:33.382Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqci0051g4vai3vr0fi5","content":"<p>系统开发一段时间下来，看到各个组员写的代码风格各自，参差不齐。甚至连空格，换行，缩进，基本命名都有问题，此时，心堵！<br>为了以后避免这种情况，那就只能在项目伊始就要加入代码规范约束，统一代码风格。而Checkstyle作为Java家族中有名的一员，就是要干那么一件事情的。<br>下面我们就来介绍Checkstyle的使用，以及结合谷歌java代码风格或者阿里巴巴的java代码风格的使用。 </p>\n<p>官网：<a href=\"https://checkstyle.org/\" target=\"_blank\" rel=\"noopener\">https://checkstyle.org/</a></p>\n<p>参考：<a href=\"https://www.cnblogs.com/SummerinShire/p/6237440.htm\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/SummerinShire/p/6237440.htm</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>系统开发一段时间下来，看到各个组员写的代码风格各自，参差不齐。甚至连空格，换行，缩进，基本命名都有问题，此时，心堵！<br>为了以后避免这种情况，那就只能在项目伊始就要加入代码规范约束，统一代码风格。而Checkstyle作为Java家族中有名的一员，就是要干那么一件事情的。<br>下面我们就来介绍Checkstyle的使用，以及结合谷歌java代码风格或者阿里巴巴的java代码风格的使用。 </p>\n<p>官网：<a href=\"https://checkstyle.org/\" target=\"_blank\" rel=\"noopener\">https://checkstyle.org/</a></p>\n<p>参考：<a href=\"https://www.cnblogs.com/SummerinShire/p/6237440.htm\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/SummerinShire/p/6237440.htm</a></p>\n"},{"title":"java代码优化收藏","date":"2017-10-27T06:57:24.000Z","_content":"\n收集java代码优雅的写法……\n\n\n\n\n\n\n## 收集\n\n1.https://www.infoq.cn/article/dwA5RVr96s1VtA75ltwz","source":"_posts/java-code-optimization.md","raw":"---\ntitle: java代码优化收藏\ndate: 2017-10-27 14:57:24\ncategories: java\ntags:\n---\n\n收集java代码优雅的写法……\n\n\n\n\n\n\n## 收集\n\n1.https://www.infoq.cn/article/dwA5RVr96s1VtA75ltwz","slug":"java-code-optimization","published":1,"updated":"2019-09-22T00:56:26.574Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcl0055g4va84p158zo","content":"<p>收集java代码优雅的写法……</p>\n<h2 id=\"收集\"><a href=\"#收集\" class=\"headerlink\" title=\"收集\"></a>收集</h2><p>1.<a href=\"https://www.infoq.cn/article/dwA5RVr96s1VtA75ltwz\" target=\"_blank\" rel=\"noopener\">https://www.infoq.cn/article/dwA5RVr96s1VtA75ltwz</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>收集java代码优雅的写法……</p>\n<h2 id=\"收集\"><a href=\"#收集\" class=\"headerlink\" title=\"收集\"></a>收集</h2><p>1.<a href=\"https://www.infoq.cn/article/dwA5RVr96s1VtA75ltwz\" target=\"_blank\" rel=\"noopener\">https://www.infoq.cn/article/dwA5RVr96s1VtA75ltwz</a></p>\n"},{"title":"Java IO 缓存流","date":"2019-10-11T00:41:11.000Z","_content":"\n前两节我们看到的例子都没有使用缓存，使用的都是底层的I/O，每次的读写都是直接有操作系统来做的。这会导致很低效，每次的读写操作都是触发磁盘、网络或者其它的资源访问，频繁的访问这些资源是很昂贵的。\n\n为了减少对这些底层资源的频繁访问，java设计了一套缓存API，它把读写数据都放到内存缓冲区里面，当缓存区为空的时候才调用系统底层读API取读取数据到内存，当缓冲区满的时候才调用底层系统输出API去刷新输出缓冲数据。这样，就大大的减少了调用操作系统接口操作硬件资源的次数。\n\n## 把普通输出输出流包装成缓冲流\n\n通过程序，我们可以把没有缓冲的输入输出流向上包装到缓冲输入输出流中。如下：\n\n    inputStream = new BufferedReader(new FileReader(\"xanadu.txt\"));\n    outputStream = new BufferedWriter(new FileWriter(\"characteroutput.txt\"));\n    \n有四个缓冲流用来包装普通的流，`BufferedInputStream` 和 `BufferedOutputStream`，用来包装字节流。 `BufferedReader`和`BufferedWriter`用来包装字符流。\n\n## 刷新缓冲流\n\n在关键的点写出缓冲区，不必等到每次缓冲区都满了再写出，这叫做刷新缓冲区。    \n\n有些类支持自动缓冲，不必调用手动调用。比如`PrintWriter`类，每当调用`println` 或者 `format`，都会自动刷新一次缓冲区。\n\n手动刷新缓冲区，直接调用方法`flush`，将会调用操作系统方法从缓冲区一次性把缓冲数据写入到对应媒介。该方法在所有的输出缓冲流中都有效。\n\n## Java BufferedInputStream\n\n包装输入字节流成缓冲字节流。一块一块的从缓冲区读取字节数据，不必逐个逐个调用操作系统API。\n\n{%asset_img a-1.png%}\n\n1.例如，把文件输入字节流包装成缓冲流：\n\n    BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                          new FileInputStream(\"c:\\\\data\\\\input-file.txt\"));\n                          \n`BufferedInputStream`会在内部构造一个字节数组，用来填充字节，然后调用底层方法`InputStream.read(byte[])`来读入。\n\n2.设置缓冲区的长度\n\n如下代码：\n\n    int bufferSize = 8 * 1024; //8KB\n        \n    BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                          new FileInputStream(\"c:\\\\data\\\\input-file.txt\"),\n                          bufferSize); \n\n一般的，缓冲区的长度要是`1024 bytes`的倍数，整除。\n\n3.设置最佳的缓冲区长度\n\n很多时候，我们都有经验要问，缓冲区的长度到底要设置大小多少才是最佳性能的表现呢？        \n\n实际上，这个问题，首先是要弄清楚你的硬盘缓冲区，每次刷新读取的大小的。如果你的硬盘缓冲区就4KB，那么，你设置缓冲流的大小小于4KB,或者大于4KB都是不明智的，小于4KB，那每次刷新，都浪费空间，大于，就要刷新两次。\n\n所以，一般的，设置成和硬盘缓冲区一样的大小就好了。要通过各种长度测试，找出硬盘读取大小来确定。\n\n4.mark() and reset()\n\n`BufferInputStream`支持`mark()`和`reset()`方法。其继承自类`FilterInputStream`，类`FilterInputStream`是支持这两个方法的。   \n\n并非所有InputStream子类都支持这些方法。       \n\n可以调用方法`markSupported()`查看是否支持`mark()`和`reset()`。\n\n4.关闭BufferedInputStream\n\n确保关闭流，避免耗尽系统资源。关闭流，同时会刷出数据。\n\n    BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                          new FileInputStream(\"c:\\\\data\\\\input-file.txt\"));\n    \n    int data = bufferedInputStream.read();\n    while(data != -1) {\n      data = bufferedInputStream.read();\n    }\n    bufferedInputStream.close();\n    \n以上代码不能保证百分百关闭流，因为如果上面代码抛出异常，将无法执行`bufferedInputStream.close()`,此时，需要捕捉异常，保证不管何时，都能正确关闭流。下面利用`try-with-resources`保证总能准确关闭。    \n\n    try(BufferedInputStream bufferedInputStream =\n            new BufferedInputStream( new FileInputStream(\"c:\\\\data\\\\input-file.txt\") ) ) {\n    \n        int data = bufferedInputStream.read();\n        while(data != -1){\n            data = bufferedInputStream.read();\n        }\n    }\n    \n一旦执行线程退出try块，就关闭BufferedInputStream。如果从try块内部引发了异常，则将捕获该异常，并关闭BufferedInputStream，然后重新引发该异常。因此，可以保证在try-with-resources块中使用BufferedInputStream时将其关闭。    \n\n## Java BufferedOutputStream   \n\n捕获缓冲区中写入`BufferedOutputStream`中的数据，批量的读入到底层的`OutputStream`中，提高IO的速度。\n\n1.创建BufferedOutputStream\n\n为`OutputStream`添加缓冲，只需要将其包装下即可，如下：\n\n    OutputStream output = new BufferedOutputStream(\n                          new FileOutputStream(\"c:\\\\data\\\\output-file.txt\"));\n                          \n2.设置`BufferedOutputStream`缓冲区的大小\n\n    int bufferSize = 8 * 1024;\n    OutputStream output = new BufferedOutputStream(\n                          new FileOutputStream(\"c:\\\\data\\\\output-file.txt\"),\n                              bufferSize\n    );\n    \n设置的大小，最好是1024的倍数，这与硬盘中的大多数内置缓冲效果最佳。\n\n3.如何选择最佳的缓冲区大小\n\n缓冲区大小的设置，与io硬件设备息息相关。\n\n设置不同的bufferSize实验，找出哪种缓冲区大小似乎可以在您的具体硬件上提供最佳性能。    \n\n如果硬盘一次至少写入4kb，那么设置缓冲区小于4kb是不合理的，设置成6kb也是愚蠢的，这会造成硬盘碎片化，浪费存储空间。最好设置成4kb的倍数。\n\n即使你的硬盘一次写入4kb，也不应该设置缓冲区大小为4kb，硬盘擅长按顺序写入数据，这意昧着它擅长写入相连的多个块。因此，设置缓冲区大小大于4kb比如16kb，32kb或者更大，性能更好。\n\n要找到最佳的缓冲区大小，先要找到硬盘写入的块的大小，然后把缓冲区设置成块的倍数。最后实验不同倍数写入数据，看哪个倍数的大小写入速度最快，就用那个。\n\n4.写入\n\n使用`write()`方法写入数据到缓冲区。\n\n    BufferedOutputStream bufferedOutputStream =\n        new BufferedOutputStream(new FileOutputStream(\"c:\\\\data\\\\output-text.txt\"));\n    \n    bufferedOutputStream.write(123);\n    \n上面例子，把`123`写入到给定的缓冲区。\n\n5.以字节数组形式写入\n\n由于Java BufferedOutputStream是OutputStream的子类，因此您也可以将字节数组写入BufferedOutputStream，而不是一次只写入一个字节。\n\n    BufferedOutputStream bufferedOutputStream =\n        new BufferedOutputStream(new FileOutputStream(\"c:\\\\data\\\\output-text.txt\"));\n    \n    byte bytes =  new byte[]{1,2,3,4,5};\n    \n    outputStream.write(bytes);                              \n\n6.刷新缓冲区flush()\n\n当您将数据写入Java BufferedOutputStream时，数据会在内部缓存在字节缓冲区中，直到字节缓冲区已满为止，这时整个缓冲区都将写入底层的OutputStream中。\n\n调用`flush()`方法刷新确保缓冲区的数据输出到硬盘等io设备。而不必等缓冲区满了，自动关闭再输出。\n\n    OutputStream outputStream =\n        new BufferedOutputStream(new FileOutputStream(\"c:\\\\data\\\\output-text.txt\"));\n    \n    byte bytes =  new byte[]{1,2,3,4,5};\n    \n    outputStream.write(bytes);\n    \n    outputStream.flush() \n\n7.关闭缓冲输出流BufferedOutputStream\n\n使用缓冲区记得关闭，底层的输出流也会自动关闭。否则会极大浪费操作系统资源。\n\n    BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(\n                          new FileOutputStream(\"c:\\\\data\\\\output-file.txt\"));\n    \n    while(hasMoreData()) {\n        int data = getMoreData();\n        bufferedOutputStream.write(data);\n    }\n    bufferedOutputStream.close();        \n    \njava1.7以上使用方式：\n\n放到try块里面，会自动会关闭资源。\n\n    try( BufferedOutputStream bufferedOutputStream =\n            new BufferedOutputStream(new FileOutputStream(\"c:\\\\data\\\\output-text.txt\"))) {\n    \n        while(hasMoreData()) {\n            int data = getMoreData();\n            output.write(data);\n        }\n    }                                            \n","source":"_posts/java-core-io-buffered.md","raw":"---\ntitle: Java IO 缓存流\ndate: 2019-10-11 08:41:11\ncategories: java-io\ntags:\n---\n\n前两节我们看到的例子都没有使用缓存，使用的都是底层的I/O，每次的读写都是直接有操作系统来做的。这会导致很低效，每次的读写操作都是触发磁盘、网络或者其它的资源访问，频繁的访问这些资源是很昂贵的。\n\n为了减少对这些底层资源的频繁访问，java设计了一套缓存API，它把读写数据都放到内存缓冲区里面，当缓存区为空的时候才调用系统底层读API取读取数据到内存，当缓冲区满的时候才调用底层系统输出API去刷新输出缓冲数据。这样，就大大的减少了调用操作系统接口操作硬件资源的次数。\n\n## 把普通输出输出流包装成缓冲流\n\n通过程序，我们可以把没有缓冲的输入输出流向上包装到缓冲输入输出流中。如下：\n\n    inputStream = new BufferedReader(new FileReader(\"xanadu.txt\"));\n    outputStream = new BufferedWriter(new FileWriter(\"characteroutput.txt\"));\n    \n有四个缓冲流用来包装普通的流，`BufferedInputStream` 和 `BufferedOutputStream`，用来包装字节流。 `BufferedReader`和`BufferedWriter`用来包装字符流。\n\n## 刷新缓冲流\n\n在关键的点写出缓冲区，不必等到每次缓冲区都满了再写出，这叫做刷新缓冲区。    \n\n有些类支持自动缓冲，不必调用手动调用。比如`PrintWriter`类，每当调用`println` 或者 `format`，都会自动刷新一次缓冲区。\n\n手动刷新缓冲区，直接调用方法`flush`，将会调用操作系统方法从缓冲区一次性把缓冲数据写入到对应媒介。该方法在所有的输出缓冲流中都有效。\n\n## Java BufferedInputStream\n\n包装输入字节流成缓冲字节流。一块一块的从缓冲区读取字节数据，不必逐个逐个调用操作系统API。\n\n{%asset_img a-1.png%}\n\n1.例如，把文件输入字节流包装成缓冲流：\n\n    BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                          new FileInputStream(\"c:\\\\data\\\\input-file.txt\"));\n                          \n`BufferedInputStream`会在内部构造一个字节数组，用来填充字节，然后调用底层方法`InputStream.read(byte[])`来读入。\n\n2.设置缓冲区的长度\n\n如下代码：\n\n    int bufferSize = 8 * 1024; //8KB\n        \n    BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                          new FileInputStream(\"c:\\\\data\\\\input-file.txt\"),\n                          bufferSize); \n\n一般的，缓冲区的长度要是`1024 bytes`的倍数，整除。\n\n3.设置最佳的缓冲区长度\n\n很多时候，我们都有经验要问，缓冲区的长度到底要设置大小多少才是最佳性能的表现呢？        \n\n实际上，这个问题，首先是要弄清楚你的硬盘缓冲区，每次刷新读取的大小的。如果你的硬盘缓冲区就4KB，那么，你设置缓冲流的大小小于4KB,或者大于4KB都是不明智的，小于4KB，那每次刷新，都浪费空间，大于，就要刷新两次。\n\n所以，一般的，设置成和硬盘缓冲区一样的大小就好了。要通过各种长度测试，找出硬盘读取大小来确定。\n\n4.mark() and reset()\n\n`BufferInputStream`支持`mark()`和`reset()`方法。其继承自类`FilterInputStream`，类`FilterInputStream`是支持这两个方法的。   \n\n并非所有InputStream子类都支持这些方法。       \n\n可以调用方法`markSupported()`查看是否支持`mark()`和`reset()`。\n\n4.关闭BufferedInputStream\n\n确保关闭流，避免耗尽系统资源。关闭流，同时会刷出数据。\n\n    BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                          new FileInputStream(\"c:\\\\data\\\\input-file.txt\"));\n    \n    int data = bufferedInputStream.read();\n    while(data != -1) {\n      data = bufferedInputStream.read();\n    }\n    bufferedInputStream.close();\n    \n以上代码不能保证百分百关闭流，因为如果上面代码抛出异常，将无法执行`bufferedInputStream.close()`,此时，需要捕捉异常，保证不管何时，都能正确关闭流。下面利用`try-with-resources`保证总能准确关闭。    \n\n    try(BufferedInputStream bufferedInputStream =\n            new BufferedInputStream( new FileInputStream(\"c:\\\\data\\\\input-file.txt\") ) ) {\n    \n        int data = bufferedInputStream.read();\n        while(data != -1){\n            data = bufferedInputStream.read();\n        }\n    }\n    \n一旦执行线程退出try块，就关闭BufferedInputStream。如果从try块内部引发了异常，则将捕获该异常，并关闭BufferedInputStream，然后重新引发该异常。因此，可以保证在try-with-resources块中使用BufferedInputStream时将其关闭。    \n\n## Java BufferedOutputStream   \n\n捕获缓冲区中写入`BufferedOutputStream`中的数据，批量的读入到底层的`OutputStream`中，提高IO的速度。\n\n1.创建BufferedOutputStream\n\n为`OutputStream`添加缓冲，只需要将其包装下即可，如下：\n\n    OutputStream output = new BufferedOutputStream(\n                          new FileOutputStream(\"c:\\\\data\\\\output-file.txt\"));\n                          \n2.设置`BufferedOutputStream`缓冲区的大小\n\n    int bufferSize = 8 * 1024;\n    OutputStream output = new BufferedOutputStream(\n                          new FileOutputStream(\"c:\\\\data\\\\output-file.txt\"),\n                              bufferSize\n    );\n    \n设置的大小，最好是1024的倍数，这与硬盘中的大多数内置缓冲效果最佳。\n\n3.如何选择最佳的缓冲区大小\n\n缓冲区大小的设置，与io硬件设备息息相关。\n\n设置不同的bufferSize实验，找出哪种缓冲区大小似乎可以在您的具体硬件上提供最佳性能。    \n\n如果硬盘一次至少写入4kb，那么设置缓冲区小于4kb是不合理的，设置成6kb也是愚蠢的，这会造成硬盘碎片化，浪费存储空间。最好设置成4kb的倍数。\n\n即使你的硬盘一次写入4kb，也不应该设置缓冲区大小为4kb，硬盘擅长按顺序写入数据，这意昧着它擅长写入相连的多个块。因此，设置缓冲区大小大于4kb比如16kb，32kb或者更大，性能更好。\n\n要找到最佳的缓冲区大小，先要找到硬盘写入的块的大小，然后把缓冲区设置成块的倍数。最后实验不同倍数写入数据，看哪个倍数的大小写入速度最快，就用那个。\n\n4.写入\n\n使用`write()`方法写入数据到缓冲区。\n\n    BufferedOutputStream bufferedOutputStream =\n        new BufferedOutputStream(new FileOutputStream(\"c:\\\\data\\\\output-text.txt\"));\n    \n    bufferedOutputStream.write(123);\n    \n上面例子，把`123`写入到给定的缓冲区。\n\n5.以字节数组形式写入\n\n由于Java BufferedOutputStream是OutputStream的子类，因此您也可以将字节数组写入BufferedOutputStream，而不是一次只写入一个字节。\n\n    BufferedOutputStream bufferedOutputStream =\n        new BufferedOutputStream(new FileOutputStream(\"c:\\\\data\\\\output-text.txt\"));\n    \n    byte bytes =  new byte[]{1,2,3,4,5};\n    \n    outputStream.write(bytes);                              \n\n6.刷新缓冲区flush()\n\n当您将数据写入Java BufferedOutputStream时，数据会在内部缓存在字节缓冲区中，直到字节缓冲区已满为止，这时整个缓冲区都将写入底层的OutputStream中。\n\n调用`flush()`方法刷新确保缓冲区的数据输出到硬盘等io设备。而不必等缓冲区满了，自动关闭再输出。\n\n    OutputStream outputStream =\n        new BufferedOutputStream(new FileOutputStream(\"c:\\\\data\\\\output-text.txt\"));\n    \n    byte bytes =  new byte[]{1,2,3,4,5};\n    \n    outputStream.write(bytes);\n    \n    outputStream.flush() \n\n7.关闭缓冲输出流BufferedOutputStream\n\n使用缓冲区记得关闭，底层的输出流也会自动关闭。否则会极大浪费操作系统资源。\n\n    BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(\n                          new FileOutputStream(\"c:\\\\data\\\\output-file.txt\"));\n    \n    while(hasMoreData()) {\n        int data = getMoreData();\n        bufferedOutputStream.write(data);\n    }\n    bufferedOutputStream.close();        \n    \njava1.7以上使用方式：\n\n放到try块里面，会自动会关闭资源。\n\n    try( BufferedOutputStream bufferedOutputStream =\n            new BufferedOutputStream(new FileOutputStream(\"c:\\\\data\\\\output-text.txt\"))) {\n    \n        while(hasMoreData()) {\n            int data = getMoreData();\n            output.write(data);\n        }\n    }                                            \n","slug":"java-core-io-buffered","published":1,"updated":"2019-11-16T06:19:36.236Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcm0058g4va79tq6nbk","content":"<p>前两节我们看到的例子都没有使用缓存，使用的都是底层的I/O，每次的读写都是直接有操作系统来做的。这会导致很低效，每次的读写操作都是触发磁盘、网络或者其它的资源访问，频繁的访问这些资源是很昂贵的。</p>\n<p>为了减少对这些底层资源的频繁访问，java设计了一套缓存API，它把读写数据都放到内存缓冲区里面，当缓存区为空的时候才调用系统底层读API取读取数据到内存，当缓冲区满的时候才调用底层系统输出API去刷新输出缓冲数据。这样，就大大的减少了调用操作系统接口操作硬件资源的次数。</p>\n<h2 id=\"把普通输出输出流包装成缓冲流\"><a href=\"#把普通输出输出流包装成缓冲流\" class=\"headerlink\" title=\"把普通输出输出流包装成缓冲流\"></a>把普通输出输出流包装成缓冲流</h2><p>通过程序，我们可以把没有缓冲的输入输出流向上包装到缓冲输入输出流中。如下：</p>\n<pre><code>inputStream = new BufferedReader(new FileReader(&quot;xanadu.txt&quot;));\noutputStream = new BufferedWriter(new FileWriter(&quot;characteroutput.txt&quot;));\n</code></pre><p>有四个缓冲流用来包装普通的流，<code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>，用来包装字节流。 <code>BufferedReader</code>和<code>BufferedWriter</code>用来包装字符流。</p>\n<h2 id=\"刷新缓冲流\"><a href=\"#刷新缓冲流\" class=\"headerlink\" title=\"刷新缓冲流\"></a>刷新缓冲流</h2><p>在关键的点写出缓冲区，不必等到每次缓冲区都满了再写出，这叫做刷新缓冲区。    </p>\n<p>有些类支持自动缓冲，不必调用手动调用。比如<code>PrintWriter</code>类，每当调用<code>println</code> 或者 <code>format</code>，都会自动刷新一次缓冲区。</p>\n<p>手动刷新缓冲区，直接调用方法<code>flush</code>，将会调用操作系统方法从缓冲区一次性把缓冲数据写入到对应媒介。该方法在所有的输出缓冲流中都有效。</p>\n<h2 id=\"Java-BufferedInputStream\"><a href=\"#Java-BufferedInputStream\" class=\"headerlink\" title=\"Java BufferedInputStream\"></a>Java BufferedInputStream</h2><p>包装输入字节流成缓冲字节流。一块一块的从缓冲区读取字节数据，不必逐个逐个调用操作系统API。</p>\n<img src=\"/2019/10/11/java-core-io-buffered/a-1.png\">\n<p>1.例如，把文件输入字节流包装成缓冲流：</p>\n<pre><code>BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                      new FileInputStream(&quot;c:\\\\data\\\\input-file.txt&quot;));\n</code></pre><p><code>BufferedInputStream</code>会在内部构造一个字节数组，用来填充字节，然后调用底层方法<code>InputStream.read(byte[])</code>来读入。</p>\n<p>2.设置缓冲区的长度</p>\n<p>如下代码：</p>\n<pre><code>int bufferSize = 8 * 1024; //8KB\n\nBufferedInputStream bufferedInputStream = new BufferedInputStream(\n                      new FileInputStream(&quot;c:\\\\data\\\\input-file.txt&quot;),\n                      bufferSize); \n</code></pre><p>一般的，缓冲区的长度要是<code>1024 bytes</code>的倍数，整除。</p>\n<p>3.设置最佳的缓冲区长度</p>\n<p>很多时候，我们都有经验要问，缓冲区的长度到底要设置大小多少才是最佳性能的表现呢？        </p>\n<p>实际上，这个问题，首先是要弄清楚你的硬盘缓冲区，每次刷新读取的大小的。如果你的硬盘缓冲区就4KB，那么，你设置缓冲流的大小小于4KB,或者大于4KB都是不明智的，小于4KB，那每次刷新，都浪费空间，大于，就要刷新两次。</p>\n<p>所以，一般的，设置成和硬盘缓冲区一样的大小就好了。要通过各种长度测试，找出硬盘读取大小来确定。</p>\n<p>4.mark() and reset()</p>\n<p><code>BufferInputStream</code>支持<code>mark()</code>和<code>reset()</code>方法。其继承自类<code>FilterInputStream</code>，类<code>FilterInputStream</code>是支持这两个方法的。   </p>\n<p>并非所有InputStream子类都支持这些方法。       </p>\n<p>可以调用方法<code>markSupported()</code>查看是否支持<code>mark()</code>和<code>reset()</code>。</p>\n<p>4.关闭BufferedInputStream</p>\n<p>确保关闭流，避免耗尽系统资源。关闭流，同时会刷出数据。</p>\n<pre><code>BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                      new FileInputStream(&quot;c:\\\\data\\\\input-file.txt&quot;));\n\nint data = bufferedInputStream.read();\nwhile(data != -1) {\n  data = bufferedInputStream.read();\n}\nbufferedInputStream.close();\n</code></pre><p>以上代码不能保证百分百关闭流，因为如果上面代码抛出异常，将无法执行<code>bufferedInputStream.close()</code>,此时，需要捕捉异常，保证不管何时，都能正确关闭流。下面利用<code>try-with-resources</code>保证总能准确关闭。    </p>\n<pre><code>try(BufferedInputStream bufferedInputStream =\n        new BufferedInputStream( new FileInputStream(&quot;c:\\\\data\\\\input-file.txt&quot;) ) ) {\n\n    int data = bufferedInputStream.read();\n    while(data != -1){\n        data = bufferedInputStream.read();\n    }\n}\n</code></pre><p>一旦执行线程退出try块，就关闭BufferedInputStream。如果从try块内部引发了异常，则将捕获该异常，并关闭BufferedInputStream，然后重新引发该异常。因此，可以保证在try-with-resources块中使用BufferedInputStream时将其关闭。    </p>\n<h2 id=\"Java-BufferedOutputStream\"><a href=\"#Java-BufferedOutputStream\" class=\"headerlink\" title=\"Java BufferedOutputStream\"></a>Java BufferedOutputStream</h2><p>捕获缓冲区中写入<code>BufferedOutputStream</code>中的数据，批量的读入到底层的<code>OutputStream</code>中，提高IO的速度。</p>\n<p>1.创建BufferedOutputStream</p>\n<p>为<code>OutputStream</code>添加缓冲，只需要将其包装下即可，如下：</p>\n<pre><code>OutputStream output = new BufferedOutputStream(\n                      new FileOutputStream(&quot;c:\\\\data\\\\output-file.txt&quot;));\n</code></pre><p>2.设置<code>BufferedOutputStream</code>缓冲区的大小</p>\n<pre><code>int bufferSize = 8 * 1024;\nOutputStream output = new BufferedOutputStream(\n                      new FileOutputStream(&quot;c:\\\\data\\\\output-file.txt&quot;),\n                          bufferSize\n);\n</code></pre><p>设置的大小，最好是1024的倍数，这与硬盘中的大多数内置缓冲效果最佳。</p>\n<p>3.如何选择最佳的缓冲区大小</p>\n<p>缓冲区大小的设置，与io硬件设备息息相关。</p>\n<p>设置不同的bufferSize实验，找出哪种缓冲区大小似乎可以在您的具体硬件上提供最佳性能。    </p>\n<p>如果硬盘一次至少写入4kb，那么设置缓冲区小于4kb是不合理的，设置成6kb也是愚蠢的，这会造成硬盘碎片化，浪费存储空间。最好设置成4kb的倍数。</p>\n<p>即使你的硬盘一次写入4kb，也不应该设置缓冲区大小为4kb，硬盘擅长按顺序写入数据，这意昧着它擅长写入相连的多个块。因此，设置缓冲区大小大于4kb比如16kb，32kb或者更大，性能更好。</p>\n<p>要找到最佳的缓冲区大小，先要找到硬盘写入的块的大小，然后把缓冲区设置成块的倍数。最后实验不同倍数写入数据，看哪个倍数的大小写入速度最快，就用那个。</p>\n<p>4.写入</p>\n<p>使用<code>write()</code>方法写入数据到缓冲区。</p>\n<pre><code>BufferedOutputStream bufferedOutputStream =\n    new BufferedOutputStream(new FileOutputStream(&quot;c:\\\\data\\\\output-text.txt&quot;));\n\nbufferedOutputStream.write(123);\n</code></pre><p>上面例子，把<code>123</code>写入到给定的缓冲区。</p>\n<p>5.以字节数组形式写入</p>\n<p>由于Java BufferedOutputStream是OutputStream的子类，因此您也可以将字节数组写入BufferedOutputStream，而不是一次只写入一个字节。</p>\n<pre><code>BufferedOutputStream bufferedOutputStream =\n    new BufferedOutputStream(new FileOutputStream(&quot;c:\\\\data\\\\output-text.txt&quot;));\n\nbyte bytes =  new byte[]{1,2,3,4,5};\n\noutputStream.write(bytes);                              \n</code></pre><p>6.刷新缓冲区flush()</p>\n<p>当您将数据写入Java BufferedOutputStream时，数据会在内部缓存在字节缓冲区中，直到字节缓冲区已满为止，这时整个缓冲区都将写入底层的OutputStream中。</p>\n<p>调用<code>flush()</code>方法刷新确保缓冲区的数据输出到硬盘等io设备。而不必等缓冲区满了，自动关闭再输出。</p>\n<pre><code>OutputStream outputStream =\n    new BufferedOutputStream(new FileOutputStream(&quot;c:\\\\data\\\\output-text.txt&quot;));\n\nbyte bytes =  new byte[]{1,2,3,4,5};\n\noutputStream.write(bytes);\n\noutputStream.flush() \n</code></pre><p>7.关闭缓冲输出流BufferedOutputStream</p>\n<p>使用缓冲区记得关闭，底层的输出流也会自动关闭。否则会极大浪费操作系统资源。</p>\n<pre><code>BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(\n                      new FileOutputStream(&quot;c:\\\\data\\\\output-file.txt&quot;));\n\nwhile(hasMoreData()) {\n    int data = getMoreData();\n    bufferedOutputStream.write(data);\n}\nbufferedOutputStream.close();        \n</code></pre><p>java1.7以上使用方式：</p>\n<p>放到try块里面，会自动会关闭资源。</p>\n<pre><code>try( BufferedOutputStream bufferedOutputStream =\n        new BufferedOutputStream(new FileOutputStream(&quot;c:\\\\data\\\\output-text.txt&quot;))) {\n\n    while(hasMoreData()) {\n        int data = getMoreData();\n        output.write(data);\n    }\n}                                            \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>前两节我们看到的例子都没有使用缓存，使用的都是底层的I/O，每次的读写都是直接有操作系统来做的。这会导致很低效，每次的读写操作都是触发磁盘、网络或者其它的资源访问，频繁的访问这些资源是很昂贵的。</p>\n<p>为了减少对这些底层资源的频繁访问，java设计了一套缓存API，它把读写数据都放到内存缓冲区里面，当缓存区为空的时候才调用系统底层读API取读取数据到内存，当缓冲区满的时候才调用底层系统输出API去刷新输出缓冲数据。这样，就大大的减少了调用操作系统接口操作硬件资源的次数。</p>\n<h2 id=\"把普通输出输出流包装成缓冲流\"><a href=\"#把普通输出输出流包装成缓冲流\" class=\"headerlink\" title=\"把普通输出输出流包装成缓冲流\"></a>把普通输出输出流包装成缓冲流</h2><p>通过程序，我们可以把没有缓冲的输入输出流向上包装到缓冲输入输出流中。如下：</p>\n<pre><code>inputStream = new BufferedReader(new FileReader(&quot;xanadu.txt&quot;));\noutputStream = new BufferedWriter(new FileWriter(&quot;characteroutput.txt&quot;));\n</code></pre><p>有四个缓冲流用来包装普通的流，<code>BufferedInputStream</code> 和 <code>BufferedOutputStream</code>，用来包装字节流。 <code>BufferedReader</code>和<code>BufferedWriter</code>用来包装字符流。</p>\n<h2 id=\"刷新缓冲流\"><a href=\"#刷新缓冲流\" class=\"headerlink\" title=\"刷新缓冲流\"></a>刷新缓冲流</h2><p>在关键的点写出缓冲区，不必等到每次缓冲区都满了再写出，这叫做刷新缓冲区。    </p>\n<p>有些类支持自动缓冲，不必调用手动调用。比如<code>PrintWriter</code>类，每当调用<code>println</code> 或者 <code>format</code>，都会自动刷新一次缓冲区。</p>\n<p>手动刷新缓冲区，直接调用方法<code>flush</code>，将会调用操作系统方法从缓冲区一次性把缓冲数据写入到对应媒介。该方法在所有的输出缓冲流中都有效。</p>\n<h2 id=\"Java-BufferedInputStream\"><a href=\"#Java-BufferedInputStream\" class=\"headerlink\" title=\"Java BufferedInputStream\"></a>Java BufferedInputStream</h2><p>包装输入字节流成缓冲字节流。一块一块的从缓冲区读取字节数据，不必逐个逐个调用操作系统API。</p>\n<img src=\"/2019/10/11/java-core-io-buffered/a-1.png\">\n<p>1.例如，把文件输入字节流包装成缓冲流：</p>\n<pre><code>BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                      new FileInputStream(&quot;c:\\\\data\\\\input-file.txt&quot;));\n</code></pre><p><code>BufferedInputStream</code>会在内部构造一个字节数组，用来填充字节，然后调用底层方法<code>InputStream.read(byte[])</code>来读入。</p>\n<p>2.设置缓冲区的长度</p>\n<p>如下代码：</p>\n<pre><code>int bufferSize = 8 * 1024; //8KB\n\nBufferedInputStream bufferedInputStream = new BufferedInputStream(\n                      new FileInputStream(&quot;c:\\\\data\\\\input-file.txt&quot;),\n                      bufferSize); \n</code></pre><p>一般的，缓冲区的长度要是<code>1024 bytes</code>的倍数，整除。</p>\n<p>3.设置最佳的缓冲区长度</p>\n<p>很多时候，我们都有经验要问，缓冲区的长度到底要设置大小多少才是最佳性能的表现呢？        </p>\n<p>实际上，这个问题，首先是要弄清楚你的硬盘缓冲区，每次刷新读取的大小的。如果你的硬盘缓冲区就4KB，那么，你设置缓冲流的大小小于4KB,或者大于4KB都是不明智的，小于4KB，那每次刷新，都浪费空间，大于，就要刷新两次。</p>\n<p>所以，一般的，设置成和硬盘缓冲区一样的大小就好了。要通过各种长度测试，找出硬盘读取大小来确定。</p>\n<p>4.mark() and reset()</p>\n<p><code>BufferInputStream</code>支持<code>mark()</code>和<code>reset()</code>方法。其继承自类<code>FilterInputStream</code>，类<code>FilterInputStream</code>是支持这两个方法的。   </p>\n<p>并非所有InputStream子类都支持这些方法。       </p>\n<p>可以调用方法<code>markSupported()</code>查看是否支持<code>mark()</code>和<code>reset()</code>。</p>\n<p>4.关闭BufferedInputStream</p>\n<p>确保关闭流，避免耗尽系统资源。关闭流，同时会刷出数据。</p>\n<pre><code>BufferedInputStream bufferedInputStream = new BufferedInputStream(\n                      new FileInputStream(&quot;c:\\\\data\\\\input-file.txt&quot;));\n\nint data = bufferedInputStream.read();\nwhile(data != -1) {\n  data = bufferedInputStream.read();\n}\nbufferedInputStream.close();\n</code></pre><p>以上代码不能保证百分百关闭流，因为如果上面代码抛出异常，将无法执行<code>bufferedInputStream.close()</code>,此时，需要捕捉异常，保证不管何时，都能正确关闭流。下面利用<code>try-with-resources</code>保证总能准确关闭。    </p>\n<pre><code>try(BufferedInputStream bufferedInputStream =\n        new BufferedInputStream( new FileInputStream(&quot;c:\\\\data\\\\input-file.txt&quot;) ) ) {\n\n    int data = bufferedInputStream.read();\n    while(data != -1){\n        data = bufferedInputStream.read();\n    }\n}\n</code></pre><p>一旦执行线程退出try块，就关闭BufferedInputStream。如果从try块内部引发了异常，则将捕获该异常，并关闭BufferedInputStream，然后重新引发该异常。因此，可以保证在try-with-resources块中使用BufferedInputStream时将其关闭。    </p>\n<h2 id=\"Java-BufferedOutputStream\"><a href=\"#Java-BufferedOutputStream\" class=\"headerlink\" title=\"Java BufferedOutputStream\"></a>Java BufferedOutputStream</h2><p>捕获缓冲区中写入<code>BufferedOutputStream</code>中的数据，批量的读入到底层的<code>OutputStream</code>中，提高IO的速度。</p>\n<p>1.创建BufferedOutputStream</p>\n<p>为<code>OutputStream</code>添加缓冲，只需要将其包装下即可，如下：</p>\n<pre><code>OutputStream output = new BufferedOutputStream(\n                      new FileOutputStream(&quot;c:\\\\data\\\\output-file.txt&quot;));\n</code></pre><p>2.设置<code>BufferedOutputStream</code>缓冲区的大小</p>\n<pre><code>int bufferSize = 8 * 1024;\nOutputStream output = new BufferedOutputStream(\n                      new FileOutputStream(&quot;c:\\\\data\\\\output-file.txt&quot;),\n                          bufferSize\n);\n</code></pre><p>设置的大小，最好是1024的倍数，这与硬盘中的大多数内置缓冲效果最佳。</p>\n<p>3.如何选择最佳的缓冲区大小</p>\n<p>缓冲区大小的设置，与io硬件设备息息相关。</p>\n<p>设置不同的bufferSize实验，找出哪种缓冲区大小似乎可以在您的具体硬件上提供最佳性能。    </p>\n<p>如果硬盘一次至少写入4kb，那么设置缓冲区小于4kb是不合理的，设置成6kb也是愚蠢的，这会造成硬盘碎片化，浪费存储空间。最好设置成4kb的倍数。</p>\n<p>即使你的硬盘一次写入4kb，也不应该设置缓冲区大小为4kb，硬盘擅长按顺序写入数据，这意昧着它擅长写入相连的多个块。因此，设置缓冲区大小大于4kb比如16kb，32kb或者更大，性能更好。</p>\n<p>要找到最佳的缓冲区大小，先要找到硬盘写入的块的大小，然后把缓冲区设置成块的倍数。最后实验不同倍数写入数据，看哪个倍数的大小写入速度最快，就用那个。</p>\n<p>4.写入</p>\n<p>使用<code>write()</code>方法写入数据到缓冲区。</p>\n<pre><code>BufferedOutputStream bufferedOutputStream =\n    new BufferedOutputStream(new FileOutputStream(&quot;c:\\\\data\\\\output-text.txt&quot;));\n\nbufferedOutputStream.write(123);\n</code></pre><p>上面例子，把<code>123</code>写入到给定的缓冲区。</p>\n<p>5.以字节数组形式写入</p>\n<p>由于Java BufferedOutputStream是OutputStream的子类，因此您也可以将字节数组写入BufferedOutputStream，而不是一次只写入一个字节。</p>\n<pre><code>BufferedOutputStream bufferedOutputStream =\n    new BufferedOutputStream(new FileOutputStream(&quot;c:\\\\data\\\\output-text.txt&quot;));\n\nbyte bytes =  new byte[]{1,2,3,4,5};\n\noutputStream.write(bytes);                              \n</code></pre><p>6.刷新缓冲区flush()</p>\n<p>当您将数据写入Java BufferedOutputStream时，数据会在内部缓存在字节缓冲区中，直到字节缓冲区已满为止，这时整个缓冲区都将写入底层的OutputStream中。</p>\n<p>调用<code>flush()</code>方法刷新确保缓冲区的数据输出到硬盘等io设备。而不必等缓冲区满了，自动关闭再输出。</p>\n<pre><code>OutputStream outputStream =\n    new BufferedOutputStream(new FileOutputStream(&quot;c:\\\\data\\\\output-text.txt&quot;));\n\nbyte bytes =  new byte[]{1,2,3,4,5};\n\noutputStream.write(bytes);\n\noutputStream.flush() \n</code></pre><p>7.关闭缓冲输出流BufferedOutputStream</p>\n<p>使用缓冲区记得关闭，底层的输出流也会自动关闭。否则会极大浪费操作系统资源。</p>\n<pre><code>BufferedOutputStream bufferedOutputStream = new BufferedOutputStream(\n                      new FileOutputStream(&quot;c:\\\\data\\\\output-file.txt&quot;));\n\nwhile(hasMoreData()) {\n    int data = getMoreData();\n    bufferedOutputStream.write(data);\n}\nbufferedOutputStream.close();        \n</code></pre><p>java1.7以上使用方式：</p>\n<p>放到try块里面，会自动会关闭资源。</p>\n<pre><code>try( BufferedOutputStream bufferedOutputStream =\n        new BufferedOutputStream(new FileOutputStream(&quot;c:\\\\data\\\\output-text.txt&quot;))) {\n\n    while(hasMoreData()) {\n        int data = getMoreData();\n        output.write(data);\n    }\n}                                            \n</code></pre>"},{"title":"Java IO：第二节-字节流","date":"2019-09-29T01:47:37.000Z","_content":"\n程序通过字节流去执行8位的字节的输出输入。所有的字节流的类都来自于`InputStream`和`OutputStream`，都继承这两个类。  \n\n本节探索相关字节流的使用……\n\n\n\n## 字节流使用\n\njava io库中有很多的字节流的类。下面我们演示字节流是怎么工作的，这里我们用文件输入输出的字节流类来演示，`FileInputStream`和`FileOutputStream`。其他的字节流类，用法都类似，只是数据构造不同而已。\n\n    public static void copyBytes() throws Exception {\n        FileInputStream in = null;\n        FileOutputStream out = null;\n\n            try {\n            in = new FileInputStream(\"xanadu.txt\");\n            out = new FileOutputStream(\"outagain.txt\");\n            int c;\n\n            while ((c = in.read()) != -1) {\n                out.write(c);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n    \n上面方法，通过文件字节流，把文件内容从一个文件拷贝到另外一个文件。   \n\n通过一个简单的循环，每次一个字节，把文件内容读入输入流，然后通过输出流写入到另外一个文件。如下图：\n\n{% asset_img a-1.png %}    \n\n### 关闭流\n\n当你不再使用流的时候，一定要关闭流，避免严重的资源泄露。上面方法，通过`finally`,总是会关闭流，确保安全。\n\n    finally {\n        if (in != null) {\n            in.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n\n### 什么时候不用字节流\n\n上面方法看起来像是一种通过的流操作方式，但是它实际代表的是一种低层次的I/O操作，应该避免。有用文件中包含的是字符，更恰当的方式应该是使用字符流。有很多适合操作更加复杂数据类型的流。但是字节流是最原始的流，用在操作原始数据类型上更为合适。\n\n这里我们之所以讨论字节流，是因为其它操作更加复杂的类型的流都是建立在字节流之上的。\n\n## `InputStream`和`OutputStream`\n\n`InputStream`是字节输入流的最顶级抽象类，其实现两个接口。类图如下：\n\n{% asset_img b-1.png %}   \n\n`OutputStream`是字节输出流的最顶级抽象类，类图：\n\n{% asset_img b-2.png %} \n\n## ByteArrayInputStream,ByteArrayOutputStream,FilterInputStream,FilterOutputStream\n\n1.ByteArrayInputStream允许你从字节数组中读取字节流数据，代码如下：\n\n    byte[] bytes = new byte[1024];\n    \n    //write data into byte array...\n    \n    InputStream input = new ByteArrayInputStream(bytes);\n    \n    //read first byte\n    int data = input.read();\n    while(data != -1) {\n        //do something with data\n    \n        //read next byte\n        data = input.read();\n    }\n    \n类图：\n\n{% asset_img c-1.png %}     \n\n2.ByteArrayOutputStream允许你以数组的形式获取写入到该输出流中的数据，代码如下：\n\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\n    \n    output.write(\"This text is converted to bytes\".getBytes(\"UTF-8\"));\n    \n    byte[] bytes = output.toByteArray();\n\n类图：\n\n{% asset_img c-2.png %}  \n        \n3.FilterInputStream是实现自定义过滤输入流的基类，基本上它仅仅只是覆盖了InputStream中的所有方法。\n\n就我自己而言，我没发现这个类明显的用途。除了构造函数取一个InputStream变量作为参数之外，我没看到FilterInputStream任何对InputStream新增或者修改的地方。如果你选择继承FilterInputStream实现自定义的类，同样也可以直接继承自InputStream从而避免额外的类层级结构。\n\n4.FilterOutputStream，内容同FilterInputStream，不再赘述。","source":"_posts/java-core-io-byte-stream.md","raw":"---\ntitle: Java IO：第二节-字节流\ndate: 2019-09-29 09:47:37\ncategories: java-io\ntags:\n---\n\n程序通过字节流去执行8位的字节的输出输入。所有的字节流的类都来自于`InputStream`和`OutputStream`，都继承这两个类。  \n\n本节探索相关字节流的使用……\n\n\n\n## 字节流使用\n\njava io库中有很多的字节流的类。下面我们演示字节流是怎么工作的，这里我们用文件输入输出的字节流类来演示，`FileInputStream`和`FileOutputStream`。其他的字节流类，用法都类似，只是数据构造不同而已。\n\n    public static void copyBytes() throws Exception {\n        FileInputStream in = null;\n        FileOutputStream out = null;\n\n            try {\n            in = new FileInputStream(\"xanadu.txt\");\n            out = new FileOutputStream(\"outagain.txt\");\n            int c;\n\n            while ((c = in.read()) != -1) {\n                out.write(c);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n    \n上面方法，通过文件字节流，把文件内容从一个文件拷贝到另外一个文件。   \n\n通过一个简单的循环，每次一个字节，把文件内容读入输入流，然后通过输出流写入到另外一个文件。如下图：\n\n{% asset_img a-1.png %}    \n\n### 关闭流\n\n当你不再使用流的时候，一定要关闭流，避免严重的资源泄露。上面方法，通过`finally`,总是会关闭流，确保安全。\n\n    finally {\n        if (in != null) {\n            in.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n\n### 什么时候不用字节流\n\n上面方法看起来像是一种通过的流操作方式，但是它实际代表的是一种低层次的I/O操作，应该避免。有用文件中包含的是字符，更恰当的方式应该是使用字符流。有很多适合操作更加复杂数据类型的流。但是字节流是最原始的流，用在操作原始数据类型上更为合适。\n\n这里我们之所以讨论字节流，是因为其它操作更加复杂的类型的流都是建立在字节流之上的。\n\n## `InputStream`和`OutputStream`\n\n`InputStream`是字节输入流的最顶级抽象类，其实现两个接口。类图如下：\n\n{% asset_img b-1.png %}   \n\n`OutputStream`是字节输出流的最顶级抽象类，类图：\n\n{% asset_img b-2.png %} \n\n## ByteArrayInputStream,ByteArrayOutputStream,FilterInputStream,FilterOutputStream\n\n1.ByteArrayInputStream允许你从字节数组中读取字节流数据，代码如下：\n\n    byte[] bytes = new byte[1024];\n    \n    //write data into byte array...\n    \n    InputStream input = new ByteArrayInputStream(bytes);\n    \n    //read first byte\n    int data = input.read();\n    while(data != -1) {\n        //do something with data\n    \n        //read next byte\n        data = input.read();\n    }\n    \n类图：\n\n{% asset_img c-1.png %}     \n\n2.ByteArrayOutputStream允许你以数组的形式获取写入到该输出流中的数据，代码如下：\n\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\n    \n    output.write(\"This text is converted to bytes\".getBytes(\"UTF-8\"));\n    \n    byte[] bytes = output.toByteArray();\n\n类图：\n\n{% asset_img c-2.png %}  \n        \n3.FilterInputStream是实现自定义过滤输入流的基类，基本上它仅仅只是覆盖了InputStream中的所有方法。\n\n就我自己而言，我没发现这个类明显的用途。除了构造函数取一个InputStream变量作为参数之外，我没看到FilterInputStream任何对InputStream新增或者修改的地方。如果你选择继承FilterInputStream实现自定义的类，同样也可以直接继承自InputStream从而避免额外的类层级结构。\n\n4.FilterOutputStream，内容同FilterInputStream，不再赘述。","slug":"java-core-io-byte-stream","published":1,"updated":"2020-05-30T11:28:23.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqco005cg4vab6a02j23","content":"<p>程序通过字节流去执行8位的字节的输出输入。所有的字节流的类都来自于<code>InputStream</code>和<code>OutputStream</code>，都继承这两个类。  </p>\n<p>本节探索相关字节流的使用……</p>\n<h2 id=\"字节流使用\"><a href=\"#字节流使用\" class=\"headerlink\" title=\"字节流使用\"></a>字节流使用</h2><p>java io库中有很多的字节流的类。下面我们演示字节流是怎么工作的，这里我们用文件输入输出的字节流类来演示，<code>FileInputStream</code>和<code>FileOutputStream</code>。其他的字节流类，用法都类似，只是数据构造不同而已。</p>\n<pre><code>public static void copyBytes() throws Exception {\n    FileInputStream in = null;\n    FileOutputStream out = null;\n\n        try {\n        in = new FileInputStream(&quot;xanadu.txt&quot;);\n        out = new FileOutputStream(&quot;outagain.txt&quot;);\n        int c;\n\n        while ((c = in.read()) != -1) {\n            out.write(c);\n        }\n    } finally {\n        if (in != null) {\n            in.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n}\n</code></pre><p>上面方法，通过文件字节流，把文件内容从一个文件拷贝到另外一个文件。   </p>\n<p>通过一个简单的循环，每次一个字节，把文件内容读入输入流，然后通过输出流写入到另外一个文件。如下图：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/a-1.png\">    \n<h3 id=\"关闭流\"><a href=\"#关闭流\" class=\"headerlink\" title=\"关闭流\"></a>关闭流</h3><p>当你不再使用流的时候，一定要关闭流，避免严重的资源泄露。上面方法，通过<code>finally</code>,总是会关闭流，确保安全。</p>\n<pre><code>finally {\n    if (in != null) {\n        in.close();\n    }\n    if (out != null) {\n        out.close();\n    }\n}\n</code></pre><h3 id=\"什么时候不用字节流\"><a href=\"#什么时候不用字节流\" class=\"headerlink\" title=\"什么时候不用字节流\"></a>什么时候不用字节流</h3><p>上面方法看起来像是一种通过的流操作方式，但是它实际代表的是一种低层次的I/O操作，应该避免。有用文件中包含的是字符，更恰当的方式应该是使用字符流。有很多适合操作更加复杂数据类型的流。但是字节流是最原始的流，用在操作原始数据类型上更为合适。</p>\n<p>这里我们之所以讨论字节流，是因为其它操作更加复杂的类型的流都是建立在字节流之上的。</p>\n<h2 id=\"InputStream和OutputStream\"><a href=\"#InputStream和OutputStream\" class=\"headerlink\" title=\"InputStream和OutputStream\"></a><code>InputStream</code>和<code>OutputStream</code></h2><p><code>InputStream</code>是字节输入流的最顶级抽象类，其实现两个接口。类图如下：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/b-1.png\">   \n<p><code>OutputStream</code>是字节输出流的最顶级抽象类，类图：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/b-2.png\"> \n<h2 id=\"ByteArrayInputStream-ByteArrayOutputStream-FilterInputStream-FilterOutputStream\"><a href=\"#ByteArrayInputStream-ByteArrayOutputStream-FilterInputStream-FilterOutputStream\" class=\"headerlink\" title=\"ByteArrayInputStream,ByteArrayOutputStream,FilterInputStream,FilterOutputStream\"></a>ByteArrayInputStream,ByteArrayOutputStream,FilterInputStream,FilterOutputStream</h2><p>1.ByteArrayInputStream允许你从字节数组中读取字节流数据，代码如下：</p>\n<pre><code>byte[] bytes = new byte[1024];\n\n//write data into byte array...\n\nInputStream input = new ByteArrayInputStream(bytes);\n\n//read first byte\nint data = input.read();\nwhile(data != -1) {\n    //do something with data\n\n    //read next byte\n    data = input.read();\n}\n</code></pre><p>类图：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/c-1.png\">     \n<p>2.ByteArrayOutputStream允许你以数组的形式获取写入到该输出流中的数据，代码如下：</p>\n<pre><code>ByteArrayOutputStream output = new ByteArrayOutputStream();\n\noutput.write(&quot;This text is converted to bytes&quot;.getBytes(&quot;UTF-8&quot;));\n\nbyte[] bytes = output.toByteArray();\n</code></pre><p>类图：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/c-2.png\">  \n<p>3.FilterInputStream是实现自定义过滤输入流的基类，基本上它仅仅只是覆盖了InputStream中的所有方法。</p>\n<p>就我自己而言，我没发现这个类明显的用途。除了构造函数取一个InputStream变量作为参数之外，我没看到FilterInputStream任何对InputStream新增或者修改的地方。如果你选择继承FilterInputStream实现自定义的类，同样也可以直接继承自InputStream从而避免额外的类层级结构。</p>\n<p>4.FilterOutputStream，内容同FilterInputStream，不再赘述。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>程序通过字节流去执行8位的字节的输出输入。所有的字节流的类都来自于<code>InputStream</code>和<code>OutputStream</code>，都继承这两个类。  </p>\n<p>本节探索相关字节流的使用……</p>\n<h2 id=\"字节流使用\"><a href=\"#字节流使用\" class=\"headerlink\" title=\"字节流使用\"></a>字节流使用</h2><p>java io库中有很多的字节流的类。下面我们演示字节流是怎么工作的，这里我们用文件输入输出的字节流类来演示，<code>FileInputStream</code>和<code>FileOutputStream</code>。其他的字节流类，用法都类似，只是数据构造不同而已。</p>\n<pre><code>public static void copyBytes() throws Exception {\n    FileInputStream in = null;\n    FileOutputStream out = null;\n\n        try {\n        in = new FileInputStream(&quot;xanadu.txt&quot;);\n        out = new FileOutputStream(&quot;outagain.txt&quot;);\n        int c;\n\n        while ((c = in.read()) != -1) {\n            out.write(c);\n        }\n    } finally {\n        if (in != null) {\n            in.close();\n        }\n        if (out != null) {\n            out.close();\n        }\n    }\n}\n</code></pre><p>上面方法，通过文件字节流，把文件内容从一个文件拷贝到另外一个文件。   </p>\n<p>通过一个简单的循环，每次一个字节，把文件内容读入输入流，然后通过输出流写入到另外一个文件。如下图：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/a-1.png\">    \n<h3 id=\"关闭流\"><a href=\"#关闭流\" class=\"headerlink\" title=\"关闭流\"></a>关闭流</h3><p>当你不再使用流的时候，一定要关闭流，避免严重的资源泄露。上面方法，通过<code>finally</code>,总是会关闭流，确保安全。</p>\n<pre><code>finally {\n    if (in != null) {\n        in.close();\n    }\n    if (out != null) {\n        out.close();\n    }\n}\n</code></pre><h3 id=\"什么时候不用字节流\"><a href=\"#什么时候不用字节流\" class=\"headerlink\" title=\"什么时候不用字节流\"></a>什么时候不用字节流</h3><p>上面方法看起来像是一种通过的流操作方式，但是它实际代表的是一种低层次的I/O操作，应该避免。有用文件中包含的是字符，更恰当的方式应该是使用字符流。有很多适合操作更加复杂数据类型的流。但是字节流是最原始的流，用在操作原始数据类型上更为合适。</p>\n<p>这里我们之所以讨论字节流，是因为其它操作更加复杂的类型的流都是建立在字节流之上的。</p>\n<h2 id=\"InputStream和OutputStream\"><a href=\"#InputStream和OutputStream\" class=\"headerlink\" title=\"InputStream和OutputStream\"></a><code>InputStream</code>和<code>OutputStream</code></h2><p><code>InputStream</code>是字节输入流的最顶级抽象类，其实现两个接口。类图如下：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/b-1.png\">   \n<p><code>OutputStream</code>是字节输出流的最顶级抽象类，类图：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/b-2.png\"> \n<h2 id=\"ByteArrayInputStream-ByteArrayOutputStream-FilterInputStream-FilterOutputStream\"><a href=\"#ByteArrayInputStream-ByteArrayOutputStream-FilterInputStream-FilterOutputStream\" class=\"headerlink\" title=\"ByteArrayInputStream,ByteArrayOutputStream,FilterInputStream,FilterOutputStream\"></a>ByteArrayInputStream,ByteArrayOutputStream,FilterInputStream,FilterOutputStream</h2><p>1.ByteArrayInputStream允许你从字节数组中读取字节流数据，代码如下：</p>\n<pre><code>byte[] bytes = new byte[1024];\n\n//write data into byte array...\n\nInputStream input = new ByteArrayInputStream(bytes);\n\n//read first byte\nint data = input.read();\nwhile(data != -1) {\n    //do something with data\n\n    //read next byte\n    data = input.read();\n}\n</code></pre><p>类图：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/c-1.png\">     \n<p>2.ByteArrayOutputStream允许你以数组的形式获取写入到该输出流中的数据，代码如下：</p>\n<pre><code>ByteArrayOutputStream output = new ByteArrayOutputStream();\n\noutput.write(&quot;This text is converted to bytes&quot;.getBytes(&quot;UTF-8&quot;));\n\nbyte[] bytes = output.toByteArray();\n</code></pre><p>类图：</p>\n<img src=\"/2019/09/29/java-core-io-byte-stream/c-2.png\">  \n<p>3.FilterInputStream是实现自定义过滤输入流的基类，基本上它仅仅只是覆盖了InputStream中的所有方法。</p>\n<p>就我自己而言，我没发现这个类明显的用途。除了构造函数取一个InputStream变量作为参数之外，我没看到FilterInputStream任何对InputStream新增或者修改的地方。如果你选择继承FilterInputStream实现自定义的类，同样也可以直接继承自InputStream从而避免额外的类层级结构。</p>\n<p>4.FilterOutputStream，内容同FilterInputStream，不再赘述。</p>\n"},{"title":"Java IO：第六节-Data Stream","date":"2020-04-24T02:31:30.000Z","_content":"\n","source":"_posts/java-core-io-data-stream6.md","raw":"---\ntitle: Java IO：第六节-Data Stream\ndate: 2020-04-24 10:31:30\ncategories: java-io\ntags:\n---\n\n","slug":"java-core-io-data-stream6","published":1,"updated":"2020-05-30T11:28:23.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcp005eg4vaac62b27u","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Java IO：第三节-字符流","date":"2019-09-29T07:36:38.000Z","_content":"\nJava使用统一编码来存储字符，字符流能够根据本地字符集自动的转换格式。英语国家使用的是八位的ASCII超集。\n\n程序中，使用字符流不再像字节流那么复杂，输入输出自动的根据本地字符集转换，国际化支持非常友好。\n\n## 使用字符流\n\n所有的字符流的类都继承自`Reader`和`Writer`,和字节流一样，下面我们演示文件字符流的使用,`FileReader`和`FileWriter`:\n\n    @Test\n    public void copyCharacters() throws IOException {\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n    \n可以debug进去，查看到`c`变量的值，一个汉字，一个字母的`int`值。这里涉及到字符集以及字符编码的知识。\n\n这里类似前面介绍的字节流，最大的不同，字节流用的是`FileInputStream`和`FileOutputStream`,字符流用的是`FileReader`和`FileWriter`。  \n\n字节流的读取，字符流的读取，都用一个`int`变量来表示，来读取和写入。但是，字节流用的是`8 bits`的整型来表示，这里的字符流用的是`16 bits`的整型表示。  \n\n## 字符流与字节流\n\n字符流是字节流更上一层的包装，字符流实际使用的是字节流来处理底层的物流I/O的。如`FileReader`，继承`InputStreamReader`,并在该父类中进行字符和字节之间的转换。同样，`FileWriter`在父类`OutputStreamWriter`进行字符和字节的转换。\n\n## 面向行的 I/O\n\n字符I/O通常的可以比单个字符更大的单位类处理字符，通常可以以一行为单位来读取，以一行作为一个字符串来读取写入。行的终结符通常是(\"\\r\\n\")，单回车(\"\\r\")或者单换行(\"\\n\")。下面例子：\n\n        //逐行读取文本\n        @Test\n        public void copyCharactersLine() throws IOException {\n            BufferedReader inputStream = null;\n            PrintWriter outputStream = null;\n    \n            try {\n                inputStream = new BufferedReader(new FileReader(\"xanadu.txt\"));\n                outputStream = new PrintWriter(new FileWriter(\"characteroutput.txt\"));\n    \n                String l; //表示一行\n                while ((l = inputStream.readLine()) != null) {\n                    outputStream.write(l);\n                }\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        }\n\n## 包装字节流为字符流\n\n把字节流转换成字符流，以字符形式读取。\n\n1.当你有一个字节流`InputStream`,且你想以字符形式读取它，那么你可以把它包装到`InputStreamReader`中，如下构造：\n\n    Reader reader = new InputStreamReader(inputStream);\n    \n其它的构造方式，可以查看`InputStreamReader`类的源码。    \n    \n2.同样的，字节输出流`OutputStream`也可以包装成字符输出流，如下：\n\n    Writer writer = new OutputStreamWriter(outputStream);    \n    \n## 包装字符流\n\n把字符流向上包装，以更大单位比如行字符串方式读取内容。如上面逐行读取。\n\n    Reader reader = new BufferedReader(new FileReader(...));\n    \n    Writer writer = new BufferedWriter(new FileWriter(...));\n\n    ","source":"_posts/java-core-io-character-stream.md","raw":"---\ntitle: Java IO：第三节-字符流\ndate: 2019-09-29 15:36:38\ncategories: java-io\ntags:\n---\n\nJava使用统一编码来存储字符，字符流能够根据本地字符集自动的转换格式。英语国家使用的是八位的ASCII超集。\n\n程序中，使用字符流不再像字节流那么复杂，输入输出自动的根据本地字符集转换，国际化支持非常友好。\n\n## 使用字符流\n\n所有的字符流的类都继承自`Reader`和`Writer`,和字节流一样，下面我们演示文件字符流的使用,`FileReader`和`FileWriter`:\n\n    @Test\n    public void copyCharacters() throws IOException {\n        FileReader inputStream = null;\n        FileWriter outputStream = null;\n\n        try {\n            inputStream = new FileReader(\"xanadu.txt\");\n            outputStream = new FileWriter(\"characteroutput.txt\");\n\n            int c;\n            while ((c = inputStream.read()) != -1) {\n                outputStream.write(c);\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n            if (outputStream != null) {\n                outputStream.close();\n            }\n        }\n    }\n    \n可以debug进去，查看到`c`变量的值，一个汉字，一个字母的`int`值。这里涉及到字符集以及字符编码的知识。\n\n这里类似前面介绍的字节流，最大的不同，字节流用的是`FileInputStream`和`FileOutputStream`,字符流用的是`FileReader`和`FileWriter`。  \n\n字节流的读取，字符流的读取，都用一个`int`变量来表示，来读取和写入。但是，字节流用的是`8 bits`的整型来表示，这里的字符流用的是`16 bits`的整型表示。  \n\n## 字符流与字节流\n\n字符流是字节流更上一层的包装，字符流实际使用的是字节流来处理底层的物流I/O的。如`FileReader`，继承`InputStreamReader`,并在该父类中进行字符和字节之间的转换。同样，`FileWriter`在父类`OutputStreamWriter`进行字符和字节的转换。\n\n## 面向行的 I/O\n\n字符I/O通常的可以比单个字符更大的单位类处理字符，通常可以以一行为单位来读取，以一行作为一个字符串来读取写入。行的终结符通常是(\"\\r\\n\")，单回车(\"\\r\")或者单换行(\"\\n\")。下面例子：\n\n        //逐行读取文本\n        @Test\n        public void copyCharactersLine() throws IOException {\n            BufferedReader inputStream = null;\n            PrintWriter outputStream = null;\n    \n            try {\n                inputStream = new BufferedReader(new FileReader(\"xanadu.txt\"));\n                outputStream = new PrintWriter(new FileWriter(\"characteroutput.txt\"));\n    \n                String l; //表示一行\n                while ((l = inputStream.readLine()) != null) {\n                    outputStream.write(l);\n                }\n            } finally {\n                if (inputStream != null) {\n                    inputStream.close();\n                }\n                if (outputStream != null) {\n                    outputStream.close();\n                }\n            }\n        }\n\n## 包装字节流为字符流\n\n把字节流转换成字符流，以字符形式读取。\n\n1.当你有一个字节流`InputStream`,且你想以字符形式读取它，那么你可以把它包装到`InputStreamReader`中，如下构造：\n\n    Reader reader = new InputStreamReader(inputStream);\n    \n其它的构造方式，可以查看`InputStreamReader`类的源码。    \n    \n2.同样的，字节输出流`OutputStream`也可以包装成字符输出流，如下：\n\n    Writer writer = new OutputStreamWriter(outputStream);    \n    \n## 包装字符流\n\n把字符流向上包装，以更大单位比如行字符串方式读取内容。如上面逐行读取。\n\n    Reader reader = new BufferedReader(new FileReader(...));\n    \n    Writer writer = new BufferedWriter(new FileWriter(...));\n\n    ","slug":"java-core-io-character-stream","published":1,"updated":"2020-05-30T11:28:23.362Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcr005jg4vah8gttqge","content":"<p>Java使用统一编码来存储字符，字符流能够根据本地字符集自动的转换格式。英语国家使用的是八位的ASCII超集。</p>\n<p>程序中，使用字符流不再像字节流那么复杂，输入输出自动的根据本地字符集转换，国际化支持非常友好。</p>\n<h2 id=\"使用字符流\"><a href=\"#使用字符流\" class=\"headerlink\" title=\"使用字符流\"></a>使用字符流</h2><p>所有的字符流的类都继承自<code>Reader</code>和<code>Writer</code>,和字节流一样，下面我们演示文件字符流的使用,<code>FileReader</code>和<code>FileWriter</code>:</p>\n<pre><code>@Test\npublic void copyCharacters() throws IOException {\n    FileReader inputStream = null;\n    FileWriter outputStream = null;\n\n    try {\n        inputStream = new FileReader(&quot;xanadu.txt&quot;);\n        outputStream = new FileWriter(&quot;characteroutput.txt&quot;);\n\n        int c;\n        while ((c = inputStream.read()) != -1) {\n            outputStream.write(c);\n        }\n    } finally {\n        if (inputStream != null) {\n            inputStream.close();\n        }\n        if (outputStream != null) {\n            outputStream.close();\n        }\n    }\n}\n</code></pre><p>可以debug进去，查看到<code>c</code>变量的值，一个汉字，一个字母的<code>int</code>值。这里涉及到字符集以及字符编码的知识。</p>\n<p>这里类似前面介绍的字节流，最大的不同，字节流用的是<code>FileInputStream</code>和<code>FileOutputStream</code>,字符流用的是<code>FileReader</code>和<code>FileWriter</code>。  </p>\n<p>字节流的读取，字符流的读取，都用一个<code>int</code>变量来表示，来读取和写入。但是，字节流用的是<code>8 bits</code>的整型来表示，这里的字符流用的是<code>16 bits</code>的整型表示。  </p>\n<h2 id=\"字符流与字节流\"><a href=\"#字符流与字节流\" class=\"headerlink\" title=\"字符流与字节流\"></a>字符流与字节流</h2><p>字符流是字节流更上一层的包装，字符流实际使用的是字节流来处理底层的物流I/O的。如<code>FileReader</code>，继承<code>InputStreamReader</code>,并在该父类中进行字符和字节之间的转换。同样，<code>FileWriter</code>在父类<code>OutputStreamWriter</code>进行字符和字节的转换。</p>\n<h2 id=\"面向行的-I-O\"><a href=\"#面向行的-I-O\" class=\"headerlink\" title=\"面向行的 I/O\"></a>面向行的 I/O</h2><p>字符I/O通常的可以比单个字符更大的单位类处理字符，通常可以以一行为单位来读取，以一行作为一个字符串来读取写入。行的终结符通常是(“\\r\\n”)，单回车(“\\r”)或者单换行(“\\n”)。下面例子：</p>\n<pre><code>//逐行读取文本\n@Test\npublic void copyCharactersLine() throws IOException {\n    BufferedReader inputStream = null;\n    PrintWriter outputStream = null;\n\n    try {\n        inputStream = new BufferedReader(new FileReader(&quot;xanadu.txt&quot;));\n        outputStream = new PrintWriter(new FileWriter(&quot;characteroutput.txt&quot;));\n\n        String l; //表示一行\n        while ((l = inputStream.readLine()) != null) {\n            outputStream.write(l);\n        }\n    } finally {\n        if (inputStream != null) {\n            inputStream.close();\n        }\n        if (outputStream != null) {\n            outputStream.close();\n        }\n    }\n}\n</code></pre><h2 id=\"包装字节流为字符流\"><a href=\"#包装字节流为字符流\" class=\"headerlink\" title=\"包装字节流为字符流\"></a>包装字节流为字符流</h2><p>把字节流转换成字符流，以字符形式读取。</p>\n<p>1.当你有一个字节流<code>InputStream</code>,且你想以字符形式读取它，那么你可以把它包装到<code>InputStreamReader</code>中，如下构造：</p>\n<pre><code>Reader reader = new InputStreamReader(inputStream);\n</code></pre><p>其它的构造方式，可以查看<code>InputStreamReader</code>类的源码。    </p>\n<p>2.同样的，字节输出流<code>OutputStream</code>也可以包装成字符输出流，如下：</p>\n<pre><code>Writer writer = new OutputStreamWriter(outputStream);    \n</code></pre><h2 id=\"包装字符流\"><a href=\"#包装字符流\" class=\"headerlink\" title=\"包装字符流\"></a>包装字符流</h2><p>把字符流向上包装，以更大单位比如行字符串方式读取内容。如上面逐行读取。</p>\n<pre><code>Reader reader = new BufferedReader(new FileReader(...));\n\nWriter writer = new BufferedWriter(new FileWriter(...));\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>Java使用统一编码来存储字符，字符流能够根据本地字符集自动的转换格式。英语国家使用的是八位的ASCII超集。</p>\n<p>程序中，使用字符流不再像字节流那么复杂，输入输出自动的根据本地字符集转换，国际化支持非常友好。</p>\n<h2 id=\"使用字符流\"><a href=\"#使用字符流\" class=\"headerlink\" title=\"使用字符流\"></a>使用字符流</h2><p>所有的字符流的类都继承自<code>Reader</code>和<code>Writer</code>,和字节流一样，下面我们演示文件字符流的使用,<code>FileReader</code>和<code>FileWriter</code>:</p>\n<pre><code>@Test\npublic void copyCharacters() throws IOException {\n    FileReader inputStream = null;\n    FileWriter outputStream = null;\n\n    try {\n        inputStream = new FileReader(&quot;xanadu.txt&quot;);\n        outputStream = new FileWriter(&quot;characteroutput.txt&quot;);\n\n        int c;\n        while ((c = inputStream.read()) != -1) {\n            outputStream.write(c);\n        }\n    } finally {\n        if (inputStream != null) {\n            inputStream.close();\n        }\n        if (outputStream != null) {\n            outputStream.close();\n        }\n    }\n}\n</code></pre><p>可以debug进去，查看到<code>c</code>变量的值，一个汉字，一个字母的<code>int</code>值。这里涉及到字符集以及字符编码的知识。</p>\n<p>这里类似前面介绍的字节流，最大的不同，字节流用的是<code>FileInputStream</code>和<code>FileOutputStream</code>,字符流用的是<code>FileReader</code>和<code>FileWriter</code>。  </p>\n<p>字节流的读取，字符流的读取，都用一个<code>int</code>变量来表示，来读取和写入。但是，字节流用的是<code>8 bits</code>的整型来表示，这里的字符流用的是<code>16 bits</code>的整型表示。  </p>\n<h2 id=\"字符流与字节流\"><a href=\"#字符流与字节流\" class=\"headerlink\" title=\"字符流与字节流\"></a>字符流与字节流</h2><p>字符流是字节流更上一层的包装，字符流实际使用的是字节流来处理底层的物流I/O的。如<code>FileReader</code>，继承<code>InputStreamReader</code>,并在该父类中进行字符和字节之间的转换。同样，<code>FileWriter</code>在父类<code>OutputStreamWriter</code>进行字符和字节的转换。</p>\n<h2 id=\"面向行的-I-O\"><a href=\"#面向行的-I-O\" class=\"headerlink\" title=\"面向行的 I/O\"></a>面向行的 I/O</h2><p>字符I/O通常的可以比单个字符更大的单位类处理字符，通常可以以一行为单位来读取，以一行作为一个字符串来读取写入。行的终结符通常是(“\\r\\n”)，单回车(“\\r”)或者单换行(“\\n”)。下面例子：</p>\n<pre><code>//逐行读取文本\n@Test\npublic void copyCharactersLine() throws IOException {\n    BufferedReader inputStream = null;\n    PrintWriter outputStream = null;\n\n    try {\n        inputStream = new BufferedReader(new FileReader(&quot;xanadu.txt&quot;));\n        outputStream = new PrintWriter(new FileWriter(&quot;characteroutput.txt&quot;));\n\n        String l; //表示一行\n        while ((l = inputStream.readLine()) != null) {\n            outputStream.write(l);\n        }\n    } finally {\n        if (inputStream != null) {\n            inputStream.close();\n        }\n        if (outputStream != null) {\n            outputStream.close();\n        }\n    }\n}\n</code></pre><h2 id=\"包装字节流为字符流\"><a href=\"#包装字节流为字符流\" class=\"headerlink\" title=\"包装字节流为字符流\"></a>包装字节流为字符流</h2><p>把字节流转换成字符流，以字符形式读取。</p>\n<p>1.当你有一个字节流<code>InputStream</code>,且你想以字符形式读取它，那么你可以把它包装到<code>InputStreamReader</code>中，如下构造：</p>\n<pre><code>Reader reader = new InputStreamReader(inputStream);\n</code></pre><p>其它的构造方式，可以查看<code>InputStreamReader</code>类的源码。    </p>\n<p>2.同样的，字节输出流<code>OutputStream</code>也可以包装成字符输出流，如下：</p>\n<pre><code>Writer writer = new OutputStreamWriter(outputStream);    \n</code></pre><h2 id=\"包装字符流\"><a href=\"#包装字符流\" class=\"headerlink\" title=\"包装字符流\"></a>包装字符流</h2><p>把字符流向上包装，以更大单位比如行字符串方式读取内容。如上面逐行读取。</p>\n<pre><code>Reader reader = new BufferedReader(new FileReader(...));\n\nWriter writer = new BufferedWriter(new FileWriter(...));\n</code></pre>"},{"title":"Java IO：第四节-Scanner And Formatting","date":"2019-11-11T01:34:53.000Z","_content":"\nScanner类型的对象可用于将格式化的输入分解为令牌，并根据其数据类型转换单个令牌。 \n\n把输入流中的数据分解，找到对应的数据类型数据。比如在一个文本流中找出所有的数字类型等。\n\n## Scanner\n\n#### 将输入流分解\n\n默认情况下，扫描仪使用空格分隔令牌（理解为分隔标识）。 （空格字符包括空格，制表符和行终止符。\n\n    public class ScanXan {\n        public static void main(String[] args) throws IOException {\n    \n            Scanner s = null;\n    \n            try {\n                s = new Scanner(new BufferedReader(new FileReader(\"xanadu.txt\")));\n    \n                while (s.hasNext()) {\n                    System.out.println(s.next());\n                }\n            } finally {\n                if (s != null) {\n                    s.close();\n                }\n            }\n        }\n    }\n    \n文本`xanadu.txt`的内容：\n\n    热烈 庆祝中国成立70周年100！！！\n    \n    We warmly celebrate the 70th anniversary of the founding of China!!!\n    \n输出：\n\n    热烈\n    庆祝中国成立70周年100！！！\n    We\n    warmly\n    celebrate\n    the\n    70th\n    anniversary\n    of\n    the\n    founding\n    of\n    China!!!\n\n可以看到，以空格为一个分隔符（令牌）。     \n\n请注意，ScanXan在完成扫描程序对象时会调用Scanner的close方法。即使扫描程序不是流，您也需要关闭它以表明已完成其基础流。\n\n当然，你可以使用不同的分隔符来分隔流，调用`useDelimiter()`方法来实现，传入一个正则表达式。\n\n如：`s.useDelimiter(\",\\\\s*\")`,逗号分隔。\n\n#### 翻译当个分隔值（tokens）\n\nScanXan示例将所有输入标记视为简单的String值。扫描程序还支持所有Java语言原始类型（char除外）以及BigInteger和BigDecimal的令牌。\n\n此外，数值可以使用数千个分隔符。\n因此，在美国语言环境中，扫描程序会正确读取代表整数值的字符串“ 32,767”。\n\n     public static void main(String[] args) throws IOException {\n    \n            Scanner s = null;\n            double sum = 0;\n    \n            try {\n                s = new Scanner(new BufferedReader(new FileReader(\"usnumbers.txt\")));\n                s.useLocale(Locale.US);\n    \n                while (s.hasNext()) {\n                    if (s.hasNextDouble()) {\n                        sum += s.nextDouble();\n                    } else {\n                        s.next();\n                    }   \n                }\n            } finally {\n                s.close();\n            }\n    \n            System.out.println(sum);\n     }\n\n以上代码，会把分隔的数字类型读取出来，并累加计算。\n\n## Formatter\n\nhttps://docs.oracle.com/javase/tutorial/essential/io/formatting.html\n\n格式化输出……\n\n\n","source":"_posts/java-core-io-scanner.md","raw":"---\ntitle: Java IO：第四节-Scanner And Formatting\ndate: 2019-11-11 09:34:53\ncategories: java-io\ntags:\n---\n\nScanner类型的对象可用于将格式化的输入分解为令牌，并根据其数据类型转换单个令牌。 \n\n把输入流中的数据分解，找到对应的数据类型数据。比如在一个文本流中找出所有的数字类型等。\n\n## Scanner\n\n#### 将输入流分解\n\n默认情况下，扫描仪使用空格分隔令牌（理解为分隔标识）。 （空格字符包括空格，制表符和行终止符。\n\n    public class ScanXan {\n        public static void main(String[] args) throws IOException {\n    \n            Scanner s = null;\n    \n            try {\n                s = new Scanner(new BufferedReader(new FileReader(\"xanadu.txt\")));\n    \n                while (s.hasNext()) {\n                    System.out.println(s.next());\n                }\n            } finally {\n                if (s != null) {\n                    s.close();\n                }\n            }\n        }\n    }\n    \n文本`xanadu.txt`的内容：\n\n    热烈 庆祝中国成立70周年100！！！\n    \n    We warmly celebrate the 70th anniversary of the founding of China!!!\n    \n输出：\n\n    热烈\n    庆祝中国成立70周年100！！！\n    We\n    warmly\n    celebrate\n    the\n    70th\n    anniversary\n    of\n    the\n    founding\n    of\n    China!!!\n\n可以看到，以空格为一个分隔符（令牌）。     \n\n请注意，ScanXan在完成扫描程序对象时会调用Scanner的close方法。即使扫描程序不是流，您也需要关闭它以表明已完成其基础流。\n\n当然，你可以使用不同的分隔符来分隔流，调用`useDelimiter()`方法来实现，传入一个正则表达式。\n\n如：`s.useDelimiter(\",\\\\s*\")`,逗号分隔。\n\n#### 翻译当个分隔值（tokens）\n\nScanXan示例将所有输入标记视为简单的String值。扫描程序还支持所有Java语言原始类型（char除外）以及BigInteger和BigDecimal的令牌。\n\n此外，数值可以使用数千个分隔符。\n因此，在美国语言环境中，扫描程序会正确读取代表整数值的字符串“ 32,767”。\n\n     public static void main(String[] args) throws IOException {\n    \n            Scanner s = null;\n            double sum = 0;\n    \n            try {\n                s = new Scanner(new BufferedReader(new FileReader(\"usnumbers.txt\")));\n                s.useLocale(Locale.US);\n    \n                while (s.hasNext()) {\n                    if (s.hasNextDouble()) {\n                        sum += s.nextDouble();\n                    } else {\n                        s.next();\n                    }   \n                }\n            } finally {\n                s.close();\n            }\n    \n            System.out.println(sum);\n     }\n\n以上代码，会把分隔的数字类型读取出来，并累加计算。\n\n## Formatter\n\nhttps://docs.oracle.com/javase/tutorial/essential/io/formatting.html\n\n格式化输出……\n\n\n","slug":"java-core-io-scanner","published":1,"updated":"2020-05-30T11:28:23.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcs005lg4va6h5w05nl","content":"<p>Scanner类型的对象可用于将格式化的输入分解为令牌，并根据其数据类型转换单个令牌。 </p>\n<p>把输入流中的数据分解，找到对应的数据类型数据。比如在一个文本流中找出所有的数字类型等。</p>\n<h2 id=\"Scanner\"><a href=\"#Scanner\" class=\"headerlink\" title=\"Scanner\"></a>Scanner</h2><h4 id=\"将输入流分解\"><a href=\"#将输入流分解\" class=\"headerlink\" title=\"将输入流分解\"></a>将输入流分解</h4><p>默认情况下，扫描仪使用空格分隔令牌（理解为分隔标识）。 （空格字符包括空格，制表符和行终止符。</p>\n<pre><code>public class ScanXan {\n    public static void main(String[] args) throws IOException {\n\n        Scanner s = null;\n\n        try {\n            s = new Scanner(new BufferedReader(new FileReader(&quot;xanadu.txt&quot;)));\n\n            while (s.hasNext()) {\n                System.out.println(s.next());\n            }\n        } finally {\n            if (s != null) {\n                s.close();\n            }\n        }\n    }\n}\n</code></pre><p>文本<code>xanadu.txt</code>的内容：</p>\n<pre><code>热烈 庆祝中国成立70周年100！！！\n\nWe warmly celebrate the 70th anniversary of the founding of China!!!\n</code></pre><p>输出：</p>\n<pre><code>热烈\n庆祝中国成立70周年100！！！\nWe\nwarmly\ncelebrate\nthe\n70th\nanniversary\nof\nthe\nfounding\nof\nChina!!!\n</code></pre><p>可以看到，以空格为一个分隔符（令牌）。     </p>\n<p>请注意，ScanXan在完成扫描程序对象时会调用Scanner的close方法。即使扫描程序不是流，您也需要关闭它以表明已完成其基础流。</p>\n<p>当然，你可以使用不同的分隔符来分隔流，调用<code>useDelimiter()</code>方法来实现，传入一个正则表达式。</p>\n<p>如：<code>s.useDelimiter(&quot;,\\\\s*&quot;)</code>,逗号分隔。</p>\n<h4 id=\"翻译当个分隔值（tokens）\"><a href=\"#翻译当个分隔值（tokens）\" class=\"headerlink\" title=\"翻译当个分隔值（tokens）\"></a>翻译当个分隔值（tokens）</h4><p>ScanXan示例将所有输入标记视为简单的String值。扫描程序还支持所有Java语言原始类型（char除外）以及BigInteger和BigDecimal的令牌。</p>\n<p>此外，数值可以使用数千个分隔符。<br>因此，在美国语言环境中，扫描程序会正确读取代表整数值的字符串“ 32,767”。</p>\n<pre><code>public static void main(String[] args) throws IOException {\n\n       Scanner s = null;\n       double sum = 0;\n\n       try {\n           s = new Scanner(new BufferedReader(new FileReader(&quot;usnumbers.txt&quot;)));\n           s.useLocale(Locale.US);\n\n           while (s.hasNext()) {\n               if (s.hasNextDouble()) {\n                   sum += s.nextDouble();\n               } else {\n                   s.next();\n               }   \n           }\n       } finally {\n           s.close();\n       }\n\n       System.out.println(sum);\n}\n</code></pre><p>以上代码，会把分隔的数字类型读取出来，并累加计算。</p>\n<h2 id=\"Formatter\"><a href=\"#Formatter\" class=\"headerlink\" title=\"Formatter\"></a>Formatter</h2><p><a href=\"https://docs.oracle.com/javase/tutorial/essential/io/formatting.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/essential/io/formatting.html</a></p>\n<p>格式化输出……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Scanner类型的对象可用于将格式化的输入分解为令牌，并根据其数据类型转换单个令牌。 </p>\n<p>把输入流中的数据分解，找到对应的数据类型数据。比如在一个文本流中找出所有的数字类型等。</p>\n<h2 id=\"Scanner\"><a href=\"#Scanner\" class=\"headerlink\" title=\"Scanner\"></a>Scanner</h2><h4 id=\"将输入流分解\"><a href=\"#将输入流分解\" class=\"headerlink\" title=\"将输入流分解\"></a>将输入流分解</h4><p>默认情况下，扫描仪使用空格分隔令牌（理解为分隔标识）。 （空格字符包括空格，制表符和行终止符。</p>\n<pre><code>public class ScanXan {\n    public static void main(String[] args) throws IOException {\n\n        Scanner s = null;\n\n        try {\n            s = new Scanner(new BufferedReader(new FileReader(&quot;xanadu.txt&quot;)));\n\n            while (s.hasNext()) {\n                System.out.println(s.next());\n            }\n        } finally {\n            if (s != null) {\n                s.close();\n            }\n        }\n    }\n}\n</code></pre><p>文本<code>xanadu.txt</code>的内容：</p>\n<pre><code>热烈 庆祝中国成立70周年100！！！\n\nWe warmly celebrate the 70th anniversary of the founding of China!!!\n</code></pre><p>输出：</p>\n<pre><code>热烈\n庆祝中国成立70周年100！！！\nWe\nwarmly\ncelebrate\nthe\n70th\nanniversary\nof\nthe\nfounding\nof\nChina!!!\n</code></pre><p>可以看到，以空格为一个分隔符（令牌）。     </p>\n<p>请注意，ScanXan在完成扫描程序对象时会调用Scanner的close方法。即使扫描程序不是流，您也需要关闭它以表明已完成其基础流。</p>\n<p>当然，你可以使用不同的分隔符来分隔流，调用<code>useDelimiter()</code>方法来实现，传入一个正则表达式。</p>\n<p>如：<code>s.useDelimiter(&quot;,\\\\s*&quot;)</code>,逗号分隔。</p>\n<h4 id=\"翻译当个分隔值（tokens）\"><a href=\"#翻译当个分隔值（tokens）\" class=\"headerlink\" title=\"翻译当个分隔值（tokens）\"></a>翻译当个分隔值（tokens）</h4><p>ScanXan示例将所有输入标记视为简单的String值。扫描程序还支持所有Java语言原始类型（char除外）以及BigInteger和BigDecimal的令牌。</p>\n<p>此外，数值可以使用数千个分隔符。<br>因此，在美国语言环境中，扫描程序会正确读取代表整数值的字符串“ 32,767”。</p>\n<pre><code>public static void main(String[] args) throws IOException {\n\n       Scanner s = null;\n       double sum = 0;\n\n       try {\n           s = new Scanner(new BufferedReader(new FileReader(&quot;usnumbers.txt&quot;)));\n           s.useLocale(Locale.US);\n\n           while (s.hasNext()) {\n               if (s.hasNextDouble()) {\n                   sum += s.nextDouble();\n               } else {\n                   s.next();\n               }   \n           }\n       } finally {\n           s.close();\n       }\n\n       System.out.println(sum);\n}\n</code></pre><p>以上代码，会把分隔的数字类型读取出来，并累加计算。</p>\n<h2 id=\"Formatter\"><a href=\"#Formatter\" class=\"headerlink\" title=\"Formatter\"></a>Formatter</h2><p><a href=\"https://docs.oracle.com/javase/tutorial/essential/io/formatting.html\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/essential/io/formatting.html</a></p>\n<p>格式化输出……</p>\n"},{"title":"Java IO：第一节-概述","date":"2019-09-27T01:40:26.000Z","_content":"\nJava IO是一组API用来读取和写入数据(input and output)。大多数应用程序都需要处理一些输入，并在输入基础上输出一些数据。例如，从文件读取文件内容到内存，经过程序处理然后通过网络传输，或者反过来。       \n该组API在`java.io`下，当你浏览该包时，这些类都有什么作用呢，该如何选择呢，下面我们来不断探索。\n\n## Java.io 包的范围\n\njava.io 包并没有涵盖所有输入输出类型。例如，并不包含GUI或者网页上的输入输出，这些输入和输出在其它地方都涉及，比如Swing工程中的JFC (Java Foundation Classes) 类，或者J2EE里的Servlet和HTTP包。       \n\nJava.io 包主要涉及文件，网络数据流，内存缓冲等的输入输出。\n\n## 输入和输出 – 数据源和目标媒介\n\n术语`输入`,`输出`有时候会让人感到疑惑，实际上其描述的是数据在程序和媒介之间的一个流向问题。简单理解：以应用程序为中心（此时应用程序已经加载到内存形成一系列的指令集，等待执行），输入流可以理解成应用程序从外部媒介如文件读取数据内容到物理内存中，输出流可以理解成应用程序把内存中处理后的数据读出到外部媒介如文件。\n\nJava的IO包主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。以下是最典型的数据源和目标媒介：\n\n- 文件\n- 管道\n- 网络连接\n- 内存缓存 (e.g. arrays)\n- System.in, System.out, System.error(注：Java标准输入、输出、错误输出)\n\n下面图形象描述了程序从数据源读取数据到目标媒介：\n\n{% asset_img a-1.png %}\n\n## I/O 流\n\n在Java IO中，流是一个核心的概念。流从概念上来说是一个连续的数据流。你既可以从流中读取数据，也可以往流中写数据。流与数据源或者数据流向的媒介相关联。在Java IO中流既可以是字节流(以字节为单位进行读写)，也可以是字符流(以字符为单位进行读写)。\n\n一个I/O流代表一个输入源或者一个输出媒介，一个流可以代表各种不同的源和媒介，比如磁盘中的文件、各种设备、其他的程序、内存等。\n\n流支持各种数据类型，包括简单的字节类型，原始数据类型，本地化的字符类型甚至更高级的类型如对象。一些流只是传递数据，然后进行各种转换。\n\n一个流就是一系列的数据，应用程序利用输入流从数据源中读取这些数据到程序内存中：\n\n{% asset_img b-1.png %}\n\n程序利用输出类把内存数据写入到媒介如文件系统中：\n\n{% asset_img b-2.png %}\n\n## InputStream, OutputStream, Reader 和Writer类\n\n程序从数据源读取数据需要依靠`inputStream`或者`Reader`，程序写数据到媒介中时候需要依赖`outputStream`或者`Writer`。下面图形象描述：\n\n{% asset_img a-2.png %}\n\nInputStream和Reader与数据源相关联，OutputStream和writer与目标媒介相关联。\n\n## Java IO的用途和特征\n\nJava IO包中有很多`InputStream`, `OutputStream`, `Reader` and `Writer`的子类，这些子类都具有某些自己的用途，总结如下：\n\n- 文件访问\n- 网络访问\n- 内存缓存访问\n- 线程内部通信（管道）\n- 缓冲\n- 过滤\n- 解析\n- 读写文本 (Readers / Writers)\n- 读写基本类型数据 (long, int etc.)\n- 读写对象\n\n当我通读`java.io`包下相关类后，很容易就知道这些类的特性和其使用场景。\n\n## Java IO类概述表\n\n已经讨论了数据源、目标媒介、输入、输出和各类不同用途的Java IO类，接下来是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格。\n\n{% asset_img a-3.png %}\n\n参考：\n- https://docs.oracle.com/javase/tutorial/essential/io\n- http://tutorials.jenkov.com/java-io\n- http://commons.apache.org/proper/commons-io/\n","source":"_posts/java-core-io-start.md","raw":"---\ntitle: Java IO：第一节-概述\ndate: 2019-09-27 09:40:26\ncategories: java-io\ntags:\n---\n\nJava IO是一组API用来读取和写入数据(input and output)。大多数应用程序都需要处理一些输入，并在输入基础上输出一些数据。例如，从文件读取文件内容到内存，经过程序处理然后通过网络传输，或者反过来。       \n该组API在`java.io`下，当你浏览该包时，这些类都有什么作用呢，该如何选择呢，下面我们来不断探索。\n\n## Java.io 包的范围\n\njava.io 包并没有涵盖所有输入输出类型。例如，并不包含GUI或者网页上的输入输出，这些输入和输出在其它地方都涉及，比如Swing工程中的JFC (Java Foundation Classes) 类，或者J2EE里的Servlet和HTTP包。       \n\nJava.io 包主要涉及文件，网络数据流，内存缓冲等的输入输出。\n\n## 输入和输出 – 数据源和目标媒介\n\n术语`输入`,`输出`有时候会让人感到疑惑，实际上其描述的是数据在程序和媒介之间的一个流向问题。简单理解：以应用程序为中心（此时应用程序已经加载到内存形成一系列的指令集，等待执行），输入流可以理解成应用程序从外部媒介如文件读取数据内容到物理内存中，输出流可以理解成应用程序把内存中处理后的数据读出到外部媒介如文件。\n\nJava的IO包主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。以下是最典型的数据源和目标媒介：\n\n- 文件\n- 管道\n- 网络连接\n- 内存缓存 (e.g. arrays)\n- System.in, System.out, System.error(注：Java标准输入、输出、错误输出)\n\n下面图形象描述了程序从数据源读取数据到目标媒介：\n\n{% asset_img a-1.png %}\n\n## I/O 流\n\n在Java IO中，流是一个核心的概念。流从概念上来说是一个连续的数据流。你既可以从流中读取数据，也可以往流中写数据。流与数据源或者数据流向的媒介相关联。在Java IO中流既可以是字节流(以字节为单位进行读写)，也可以是字符流(以字符为单位进行读写)。\n\n一个I/O流代表一个输入源或者一个输出媒介，一个流可以代表各种不同的源和媒介，比如磁盘中的文件、各种设备、其他的程序、内存等。\n\n流支持各种数据类型，包括简单的字节类型，原始数据类型，本地化的字符类型甚至更高级的类型如对象。一些流只是传递数据，然后进行各种转换。\n\n一个流就是一系列的数据，应用程序利用输入流从数据源中读取这些数据到程序内存中：\n\n{% asset_img b-1.png %}\n\n程序利用输出类把内存数据写入到媒介如文件系统中：\n\n{% asset_img b-2.png %}\n\n## InputStream, OutputStream, Reader 和Writer类\n\n程序从数据源读取数据需要依靠`inputStream`或者`Reader`，程序写数据到媒介中时候需要依赖`outputStream`或者`Writer`。下面图形象描述：\n\n{% asset_img a-2.png %}\n\nInputStream和Reader与数据源相关联，OutputStream和writer与目标媒介相关联。\n\n## Java IO的用途和特征\n\nJava IO包中有很多`InputStream`, `OutputStream`, `Reader` and `Writer`的子类，这些子类都具有某些自己的用途，总结如下：\n\n- 文件访问\n- 网络访问\n- 内存缓存访问\n- 线程内部通信（管道）\n- 缓冲\n- 过滤\n- 解析\n- 读写文本 (Readers / Writers)\n- 读写基本类型数据 (long, int etc.)\n- 读写对象\n\n当我通读`java.io`包下相关类后，很容易就知道这些类的特性和其使用场景。\n\n## Java IO类概述表\n\n已经讨论了数据源、目标媒介、输入、输出和各类不同用途的Java IO类，接下来是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格。\n\n{% asset_img a-3.png %}\n\n参考：\n- https://docs.oracle.com/javase/tutorial/essential/io\n- http://tutorials.jenkov.com/java-io\n- http://commons.apache.org/proper/commons-io/\n","slug":"java-core-io-start","published":1,"updated":"2020-05-30T11:28:23.364Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqct005pg4vazuj8loud","content":"<p>Java IO是一组API用来读取和写入数据(input and output)。大多数应用程序都需要处理一些输入，并在输入基础上输出一些数据。例如，从文件读取文件内容到内存，经过程序处理然后通过网络传输，或者反过来。<br>该组API在<code>java.io</code>下，当你浏览该包时，这些类都有什么作用呢，该如何选择呢，下面我们来不断探索。</p>\n<h2 id=\"Java-io-包的范围\"><a href=\"#Java-io-包的范围\" class=\"headerlink\" title=\"Java.io 包的范围\"></a>Java.io 包的范围</h2><p>java.io 包并没有涵盖所有输入输出类型。例如，并不包含GUI或者网页上的输入输出，这些输入和输出在其它地方都涉及，比如Swing工程中的JFC (Java Foundation Classes) 类，或者J2EE里的Servlet和HTTP包。       </p>\n<p>Java.io 包主要涉及文件，网络数据流，内存缓冲等的输入输出。</p>\n<h2 id=\"输入和输出-–-数据源和目标媒介\"><a href=\"#输入和输出-–-数据源和目标媒介\" class=\"headerlink\" title=\"输入和输出 – 数据源和目标媒介\"></a>输入和输出 – 数据源和目标媒介</h2><p>术语<code>输入</code>,<code>输出</code>有时候会让人感到疑惑，实际上其描述的是数据在程序和媒介之间的一个流向问题。简单理解：以应用程序为中心（此时应用程序已经加载到内存形成一系列的指令集，等待执行），输入流可以理解成应用程序从外部媒介如文件读取数据内容到物理内存中，输出流可以理解成应用程序把内存中处理后的数据读出到外部媒介如文件。</p>\n<p>Java的IO包主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。以下是最典型的数据源和目标媒介：</p>\n<ul>\n<li>文件</li>\n<li>管道</li>\n<li>网络连接</li>\n<li>内存缓存 (e.g. arrays)</li>\n<li>System.in, System.out, System.error(注：Java标准输入、输出、错误输出)</li>\n</ul>\n<p>下面图形象描述了程序从数据源读取数据到目标媒介：</p>\n<img src=\"/2019/09/27/java-core-io-start/a-1.png\">\n<h2 id=\"I-O-流\"><a href=\"#I-O-流\" class=\"headerlink\" title=\"I/O 流\"></a>I/O 流</h2><p>在Java IO中，流是一个核心的概念。流从概念上来说是一个连续的数据流。你既可以从流中读取数据，也可以往流中写数据。流与数据源或者数据流向的媒介相关联。在Java IO中流既可以是字节流(以字节为单位进行读写)，也可以是字符流(以字符为单位进行读写)。</p>\n<p>一个I/O流代表一个输入源或者一个输出媒介，一个流可以代表各种不同的源和媒介，比如磁盘中的文件、各种设备、其他的程序、内存等。</p>\n<p>流支持各种数据类型，包括简单的字节类型，原始数据类型，本地化的字符类型甚至更高级的类型如对象。一些流只是传递数据，然后进行各种转换。</p>\n<p>一个流就是一系列的数据，应用程序利用输入流从数据源中读取这些数据到程序内存中：</p>\n<img src=\"/2019/09/27/java-core-io-start/b-1.png\">\n<p>程序利用输出类把内存数据写入到媒介如文件系统中：</p>\n<img src=\"/2019/09/27/java-core-io-start/b-2.png\">\n<h2 id=\"InputStream-OutputStream-Reader-和Writer类\"><a href=\"#InputStream-OutputStream-Reader-和Writer类\" class=\"headerlink\" title=\"InputStream, OutputStream, Reader 和Writer类\"></a>InputStream, OutputStream, Reader 和Writer类</h2><p>程序从数据源读取数据需要依靠<code>inputStream</code>或者<code>Reader</code>，程序写数据到媒介中时候需要依赖<code>outputStream</code>或者<code>Writer</code>。下面图形象描述：</p>\n<img src=\"/2019/09/27/java-core-io-start/a-2.png\">\n<p>InputStream和Reader与数据源相关联，OutputStream和writer与目标媒介相关联。</p>\n<h2 id=\"Java-IO的用途和特征\"><a href=\"#Java-IO的用途和特征\" class=\"headerlink\" title=\"Java IO的用途和特征\"></a>Java IO的用途和特征</h2><p>Java IO包中有很多<code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code> and <code>Writer</code>的子类，这些子类都具有某些自己的用途，总结如下：</p>\n<ul>\n<li>文件访问</li>\n<li>网络访问</li>\n<li>内存缓存访问</li>\n<li>线程内部通信（管道）</li>\n<li>缓冲</li>\n<li>过滤</li>\n<li>解析</li>\n<li>读写文本 (Readers / Writers)</li>\n<li>读写基本类型数据 (long, int etc.)</li>\n<li>读写对象</li>\n</ul>\n<p>当我通读<code>java.io</code>包下相关类后，很容易就知道这些类的特性和其使用场景。</p>\n<h2 id=\"Java-IO类概述表\"><a href=\"#Java-IO类概述表\" class=\"headerlink\" title=\"Java IO类概述表\"></a>Java IO类概述表</h2><p>已经讨论了数据源、目标媒介、输入、输出和各类不同用途的Java IO类，接下来是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格。</p>\n<img src=\"/2019/09/27/java-core-io-start/a-3.png\">\n<p>参考：</p>\n<ul>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/essential/io\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/essential/io</a></li>\n<li><a href=\"http://tutorials.jenkov.com/java-io\" target=\"_blank\" rel=\"noopener\">http://tutorials.jenkov.com/java-io</a></li>\n<li><a href=\"http://commons.apache.org/proper/commons-io/\" target=\"_blank\" rel=\"noopener\">http://commons.apache.org/proper/commons-io/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Java IO是一组API用来读取和写入数据(input and output)。大多数应用程序都需要处理一些输入，并在输入基础上输出一些数据。例如，从文件读取文件内容到内存，经过程序处理然后通过网络传输，或者反过来。<br>该组API在<code>java.io</code>下，当你浏览该包时，这些类都有什么作用呢，该如何选择呢，下面我们来不断探索。</p>\n<h2 id=\"Java-io-包的范围\"><a href=\"#Java-io-包的范围\" class=\"headerlink\" title=\"Java.io 包的范围\"></a>Java.io 包的范围</h2><p>java.io 包并没有涵盖所有输入输出类型。例如，并不包含GUI或者网页上的输入输出，这些输入和输出在其它地方都涉及，比如Swing工程中的JFC (Java Foundation Classes) 类，或者J2EE里的Servlet和HTTP包。       </p>\n<p>Java.io 包主要涉及文件，网络数据流，内存缓冲等的输入输出。</p>\n<h2 id=\"输入和输出-–-数据源和目标媒介\"><a href=\"#输入和输出-–-数据源和目标媒介\" class=\"headerlink\" title=\"输入和输出 – 数据源和目标媒介\"></a>输入和输出 – 数据源和目标媒介</h2><p>术语<code>输入</code>,<code>输出</code>有时候会让人感到疑惑，实际上其描述的是数据在程序和媒介之间的一个流向问题。简单理解：以应用程序为中心（此时应用程序已经加载到内存形成一系列的指令集，等待执行），输入流可以理解成应用程序从外部媒介如文件读取数据内容到物理内存中，输出流可以理解成应用程序把内存中处理后的数据读出到外部媒介如文件。</p>\n<p>Java的IO包主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。以下是最典型的数据源和目标媒介：</p>\n<ul>\n<li>文件</li>\n<li>管道</li>\n<li>网络连接</li>\n<li>内存缓存 (e.g. arrays)</li>\n<li>System.in, System.out, System.error(注：Java标准输入、输出、错误输出)</li>\n</ul>\n<p>下面图形象描述了程序从数据源读取数据到目标媒介：</p>\n<img src=\"/2019/09/27/java-core-io-start/a-1.png\">\n<h2 id=\"I-O-流\"><a href=\"#I-O-流\" class=\"headerlink\" title=\"I/O 流\"></a>I/O 流</h2><p>在Java IO中，流是一个核心的概念。流从概念上来说是一个连续的数据流。你既可以从流中读取数据，也可以往流中写数据。流与数据源或者数据流向的媒介相关联。在Java IO中流既可以是字节流(以字节为单位进行读写)，也可以是字符流(以字符为单位进行读写)。</p>\n<p>一个I/O流代表一个输入源或者一个输出媒介，一个流可以代表各种不同的源和媒介，比如磁盘中的文件、各种设备、其他的程序、内存等。</p>\n<p>流支持各种数据类型，包括简单的字节类型，原始数据类型，本地化的字符类型甚至更高级的类型如对象。一些流只是传递数据，然后进行各种转换。</p>\n<p>一个流就是一系列的数据，应用程序利用输入流从数据源中读取这些数据到程序内存中：</p>\n<img src=\"/2019/09/27/java-core-io-start/b-1.png\">\n<p>程序利用输出类把内存数据写入到媒介如文件系统中：</p>\n<img src=\"/2019/09/27/java-core-io-start/b-2.png\">\n<h2 id=\"InputStream-OutputStream-Reader-和Writer类\"><a href=\"#InputStream-OutputStream-Reader-和Writer类\" class=\"headerlink\" title=\"InputStream, OutputStream, Reader 和Writer类\"></a>InputStream, OutputStream, Reader 和Writer类</h2><p>程序从数据源读取数据需要依靠<code>inputStream</code>或者<code>Reader</code>，程序写数据到媒介中时候需要依赖<code>outputStream</code>或者<code>Writer</code>。下面图形象描述：</p>\n<img src=\"/2019/09/27/java-core-io-start/a-2.png\">\n<p>InputStream和Reader与数据源相关联，OutputStream和writer与目标媒介相关联。</p>\n<h2 id=\"Java-IO的用途和特征\"><a href=\"#Java-IO的用途和特征\" class=\"headerlink\" title=\"Java IO的用途和特征\"></a>Java IO的用途和特征</h2><p>Java IO包中有很多<code>InputStream</code>, <code>OutputStream</code>, <code>Reader</code> and <code>Writer</code>的子类，这些子类都具有某些自己的用途，总结如下：</p>\n<ul>\n<li>文件访问</li>\n<li>网络访问</li>\n<li>内存缓存访问</li>\n<li>线程内部通信（管道）</li>\n<li>缓冲</li>\n<li>过滤</li>\n<li>解析</li>\n<li>读写文本 (Readers / Writers)</li>\n<li>读写基本类型数据 (long, int etc.)</li>\n<li>读写对象</li>\n</ul>\n<p>当我通读<code>java.io</code>包下相关类后，很容易就知道这些类的特性和其使用场景。</p>\n<h2 id=\"Java-IO类概述表\"><a href=\"#Java-IO类概述表\" class=\"headerlink\" title=\"Java IO类概述表\"></a>Java IO类概述表</h2><p>已经讨论了数据源、目标媒介、输入、输出和各类不同用途的Java IO类，接下来是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格。</p>\n<img src=\"/2019/09/27/java-core-io-start/a-3.png\">\n<p>参考：</p>\n<ul>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/essential/io\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/essential/io</a></li>\n<li><a href=\"http://tutorials.jenkov.com/java-io\" target=\"_blank\" rel=\"noopener\">http://tutorials.jenkov.com/java-io</a></li>\n<li><a href=\"http://commons.apache.org/proper/commons-io/\" target=\"_blank\" rel=\"noopener\">http://commons.apache.org/proper/commons-io/</a></li>\n</ul>\n"},{"title":"Java IO：第五节-System.in, System.out, System.err","date":"2020-04-24T02:08:48.000Z","_content":"\n[原文地址](http://tutorials.jenkov.com/java-io/system-in-out-error.html)\n\nSystem.in, System.out, System.err这3个流同样是常见的数据来源和数据流目的地。使用最多的可能是在控制台程序里利用System.out将输出打印到控制台上。\n\nJVM启动的时候通过Java运行时初始化这3个流，所以你不需要初始化它们(尽管你可以在运行时替换掉它们)。\n\n## System.in\n\nSystem.in是一个典型的连接控制台程序和键盘输入的InputStream流。通常当数据通过命令行参数或者配置文件传递给命令行Java程序的时候，System.in并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的Java IO输入机制。\n\n## System.out\n\nSystem.out是一个PrintStream流。System.out一般会把你写到其中的数据输出到控制台上。System.out通常仅用在类似命令行工具的控制台程序上。System.out也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。\n\n## System.err\n\nSystem.err是一个PrintStream流。System.err与System.out的运行方式类似，但它更多的是用于打印错误文本。一些类似Eclipse的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过System.err输出到控制台上。\n\n## System.out和System.err的简单例子：\n\n这是一个System.out和System.err结合使用的简单示例：\n\n    try {\n    \n        InputStream input = new FileInputStream(\"c:\\\\data\\\\...\");\n    \n        System.out.println(\"File opened...\");\n    \n    } catch (IOException e) {\n    \n        System.err.println(\"File opening failed:\");\n    \n        e.printStackTrace();\n    \n    }\n    \n## 替换系统流\n\n尽管System.in, System.out, System.err这3个流是java.lang.System类中的静态成员(译者注：这3个变量均为final static常量)，并且已经预先在JVM启动的时候初始化完成，你依然可以更改它们。只需要把一个新的InputStream设置给System.in或者一个新的OutputStream设置给System.out或者System.err，之后的数据都将会在新的流中进行读取、写入。\n\n可以使用System.setIn(), System.setOut(), System.setErr()方法设置新的系统流(译者注：这三个方法均为静态方法，内部调用了本地native方法重新设置系统流)。例子如下：\n\n    OutputStream output = new FileOutputStream(\"c:\\\\data\\\\system.out.txt\");\n    \n    PrintStream printOut = new PrintStream(output);\n    \n    System.setOut(printOut);\n    \n现在所有的System.out都将重定向到”c:\\\\data\\\\system.out.txt”文件中。请记住，务必在JVM关闭之前冲刷System.out(译者注：调用flush())，确保System.out把数据输出到了文件中。        ","source":"_posts/java-core-io-system.md","raw":"---\ntitle: Java IO：第五节-System.in, System.out, System.err\ndate: 2020-04-24 10:08:48\ncategories: java-io\ntags:\n---\n\n[原文地址](http://tutorials.jenkov.com/java-io/system-in-out-error.html)\n\nSystem.in, System.out, System.err这3个流同样是常见的数据来源和数据流目的地。使用最多的可能是在控制台程序里利用System.out将输出打印到控制台上。\n\nJVM启动的时候通过Java运行时初始化这3个流，所以你不需要初始化它们(尽管你可以在运行时替换掉它们)。\n\n## System.in\n\nSystem.in是一个典型的连接控制台程序和键盘输入的InputStream流。通常当数据通过命令行参数或者配置文件传递给命令行Java程序的时候，System.in并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的Java IO输入机制。\n\n## System.out\n\nSystem.out是一个PrintStream流。System.out一般会把你写到其中的数据输出到控制台上。System.out通常仅用在类似命令行工具的控制台程序上。System.out也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。\n\n## System.err\n\nSystem.err是一个PrintStream流。System.err与System.out的运行方式类似，但它更多的是用于打印错误文本。一些类似Eclipse的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过System.err输出到控制台上。\n\n## System.out和System.err的简单例子：\n\n这是一个System.out和System.err结合使用的简单示例：\n\n    try {\n    \n        InputStream input = new FileInputStream(\"c:\\\\data\\\\...\");\n    \n        System.out.println(\"File opened...\");\n    \n    } catch (IOException e) {\n    \n        System.err.println(\"File opening failed:\");\n    \n        e.printStackTrace();\n    \n    }\n    \n## 替换系统流\n\n尽管System.in, System.out, System.err这3个流是java.lang.System类中的静态成员(译者注：这3个变量均为final static常量)，并且已经预先在JVM启动的时候初始化完成，你依然可以更改它们。只需要把一个新的InputStream设置给System.in或者一个新的OutputStream设置给System.out或者System.err，之后的数据都将会在新的流中进行读取、写入。\n\n可以使用System.setIn(), System.setOut(), System.setErr()方法设置新的系统流(译者注：这三个方法均为静态方法，内部调用了本地native方法重新设置系统流)。例子如下：\n\n    OutputStream output = new FileOutputStream(\"c:\\\\data\\\\system.out.txt\");\n    \n    PrintStream printOut = new PrintStream(output);\n    \n    System.setOut(printOut);\n    \n现在所有的System.out都将重定向到”c:\\\\data\\\\system.out.txt”文件中。请记住，务必在JVM关闭之前冲刷System.out(译者注：调用flush())，确保System.out把数据输出到了文件中。        ","slug":"java-core-io-system","published":1,"updated":"2020-05-30T15:15:13.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcu005sg4va06pabfm2","content":"<p><a href=\"http://tutorials.jenkov.com/java-io/system-in-out-error.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>System.in, System.out, System.err这3个流同样是常见的数据来源和数据流目的地。使用最多的可能是在控制台程序里利用System.out将输出打印到控制台上。</p>\n<p>JVM启动的时候通过Java运行时初始化这3个流，所以你不需要初始化它们(尽管你可以在运行时替换掉它们)。</p>\n<h2 id=\"System-in\"><a href=\"#System-in\" class=\"headerlink\" title=\"System.in\"></a>System.in</h2><p>System.in是一个典型的连接控制台程序和键盘输入的InputStream流。通常当数据通过命令行参数或者配置文件传递给命令行Java程序的时候，System.in并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的Java IO输入机制。</p>\n<h2 id=\"System-out\"><a href=\"#System-out\" class=\"headerlink\" title=\"System.out\"></a>System.out</h2><p>System.out是一个PrintStream流。System.out一般会把你写到其中的数据输出到控制台上。System.out通常仅用在类似命令行工具的控制台程序上。System.out也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。</p>\n<h2 id=\"System-err\"><a href=\"#System-err\" class=\"headerlink\" title=\"System.err\"></a>System.err</h2><p>System.err是一个PrintStream流。System.err与System.out的运行方式类似，但它更多的是用于打印错误文本。一些类似Eclipse的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过System.err输出到控制台上。</p>\n<h2 id=\"System-out和System-err的简单例子：\"><a href=\"#System-out和System-err的简单例子：\" class=\"headerlink\" title=\"System.out和System.err的简单例子：\"></a>System.out和System.err的简单例子：</h2><p>这是一个System.out和System.err结合使用的简单示例：</p>\n<pre><code>try {\n\n    InputStream input = new FileInputStream(&quot;c:\\\\data\\\\...&quot;);\n\n    System.out.println(&quot;File opened...&quot;);\n\n} catch (IOException e) {\n\n    System.err.println(&quot;File opening failed:&quot;);\n\n    e.printStackTrace();\n\n}\n</code></pre><h2 id=\"替换系统流\"><a href=\"#替换系统流\" class=\"headerlink\" title=\"替换系统流\"></a>替换系统流</h2><p>尽管System.in, System.out, System.err这3个流是java.lang.System类中的静态成员(译者注：这3个变量均为final static常量)，并且已经预先在JVM启动的时候初始化完成，你依然可以更改它们。只需要把一个新的InputStream设置给System.in或者一个新的OutputStream设置给System.out或者System.err，之后的数据都将会在新的流中进行读取、写入。</p>\n<p>可以使用System.setIn(), System.setOut(), System.setErr()方法设置新的系统流(译者注：这三个方法均为静态方法，内部调用了本地native方法重新设置系统流)。例子如下：</p>\n<pre><code>OutputStream output = new FileOutputStream(&quot;c:\\\\data\\\\system.out.txt&quot;);\n\nPrintStream printOut = new PrintStream(output);\n\nSystem.setOut(printOut);\n</code></pre><p>现在所有的System.out都将重定向到”c:\\data\\system.out.txt”文件中。请记住，务必在JVM关闭之前冲刷System.out(译者注：调用flush())，确保System.out把数据输出到了文件中。        </p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://tutorials.jenkov.com/java-io/system-in-out-error.html\" target=\"_blank\" rel=\"noopener\">原文地址</a></p>\n<p>System.in, System.out, System.err这3个流同样是常见的数据来源和数据流目的地。使用最多的可能是在控制台程序里利用System.out将输出打印到控制台上。</p>\n<p>JVM启动的时候通过Java运行时初始化这3个流，所以你不需要初始化它们(尽管你可以在运行时替换掉它们)。</p>\n<h2 id=\"System-in\"><a href=\"#System-in\" class=\"headerlink\" title=\"System.in\"></a>System.in</h2><p>System.in是一个典型的连接控制台程序和键盘输入的InputStream流。通常当数据通过命令行参数或者配置文件传递给命令行Java程序的时候，System.in并不是很常用。图形界面程序通过界面传递参数给程序，这是一块单独的Java IO输入机制。</p>\n<h2 id=\"System-out\"><a href=\"#System-out\" class=\"headerlink\" title=\"System.out\"></a>System.out</h2><p>System.out是一个PrintStream流。System.out一般会把你写到其中的数据输出到控制台上。System.out通常仅用在类似命令行工具的控制台程序上。System.out也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。</p>\n<h2 id=\"System-err\"><a href=\"#System-err\" class=\"headerlink\" title=\"System.err\"></a>System.err</h2><p>System.err是一个PrintStream流。System.err与System.out的运行方式类似，但它更多的是用于打印错误文本。一些类似Eclipse的程序，为了让错误信息更加显眼，会将错误信息以红色文本的形式通过System.err输出到控制台上。</p>\n<h2 id=\"System-out和System-err的简单例子：\"><a href=\"#System-out和System-err的简单例子：\" class=\"headerlink\" title=\"System.out和System.err的简单例子：\"></a>System.out和System.err的简单例子：</h2><p>这是一个System.out和System.err结合使用的简单示例：</p>\n<pre><code>try {\n\n    InputStream input = new FileInputStream(&quot;c:\\\\data\\\\...&quot;);\n\n    System.out.println(&quot;File opened...&quot;);\n\n} catch (IOException e) {\n\n    System.err.println(&quot;File opening failed:&quot;);\n\n    e.printStackTrace();\n\n}\n</code></pre><h2 id=\"替换系统流\"><a href=\"#替换系统流\" class=\"headerlink\" title=\"替换系统流\"></a>替换系统流</h2><p>尽管System.in, System.out, System.err这3个流是java.lang.System类中的静态成员(译者注：这3个变量均为final static常量)，并且已经预先在JVM启动的时候初始化完成，你依然可以更改它们。只需要把一个新的InputStream设置给System.in或者一个新的OutputStream设置给System.out或者System.err，之后的数据都将会在新的流中进行读取、写入。</p>\n<p>可以使用System.setIn(), System.setOut(), System.setErr()方法设置新的系统流(译者注：这三个方法均为静态方法，内部调用了本地native方法重新设置系统流)。例子如下：</p>\n<pre><code>OutputStream output = new FileOutputStream(&quot;c:\\\\data\\\\system.out.txt&quot;);\n\nPrintStream printOut = new PrintStream(output);\n\nSystem.setOut(printOut);\n</code></pre><p>现在所有的System.out都将重定向到”c:\\data\\system.out.txt”文件中。请记住，务必在JVM关闭之前冲刷System.out(译者注：调用flush())，确保System.out把数据输出到了文件中。        </p>\n"},{"title":"Java Nio 缓冲区","date":"2017-10-25T06:57:22.000Z","_content":"\n","source":"_posts/java-core-nio-buffer.md","raw":"---\ntitle: Java Nio 缓冲区\ndate: 2017-10-25 14:57:22\ncategories: java-nio\ntags:\n---\n\n","slug":"java-core-nio-buffer","published":1,"updated":"2020-05-30T11:28:23.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcw005vg4vaejjthsyv","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"java-core-often","date":"2019-10-19T02:40:47.000Z","_content":"\n## java11\n\n#### java11生产jre\n\njava11的jdk下没有jre环境的。想要的话，可以手动生成。    \n\n进入jdk目录下，执行以下命令：\n\n    ## windows\n    bin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre\n    \n    ##linux\n    bin/jlink --module-path jmods --add-modules java.desktop --output jre\n","source":"_posts/java-core-often.md","raw":"---\ntitle: java-core-often\ndate: 2019-10-19 10:40:47\ncategories: java\ntags:\n---\n\n## java11\n\n#### java11生产jre\n\njava11的jdk下没有jre环境的。想要的话，可以手动生成。    \n\n进入jdk目录下，执行以下命令：\n\n    ## windows\n    bin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre\n    \n    ##linux\n    bin/jlink --module-path jmods --add-modules java.desktop --output jre\n","slug":"java-core-often","published":1,"updated":"2019-11-10T14:27:50.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcx005xg4vanlniqb4u","content":"<h2 id=\"java11\"><a href=\"#java11\" class=\"headerlink\" title=\"java11\"></a>java11</h2><h4 id=\"java11生产jre\"><a href=\"#java11生产jre\" class=\"headerlink\" title=\"java11生产jre\"></a>java11生产jre</h4><p>java11的jdk下没有jre环境的。想要的话，可以手动生成。    </p>\n<p>进入jdk目录下，执行以下命令：</p>\n<pre><code>## windows\nbin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre\n\n##linux\nbin/jlink --module-path jmods --add-modules java.desktop --output jre\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"java11\"><a href=\"#java11\" class=\"headerlink\" title=\"java11\"></a>java11</h2><h4 id=\"java11生产jre\"><a href=\"#java11生产jre\" class=\"headerlink\" title=\"java11生产jre\"></a>java11生产jre</h4><p>java11的jdk下没有jre环境的。想要的话，可以手动生成。    </p>\n<p>进入jdk目录下，执行以下命令：</p>\n<pre><code>## windows\nbin\\jlink.exe --module-path jmods --add-modules java.desktop --output jre\n\n##linux\nbin/jlink --module-path jmods --add-modules java.desktop --output jre\n</code></pre>"},{"title":"CGLIB介绍与原理","date":"2017-10-26T07:57:08.000Z","_content":"http://blog.csdn.net/zghwaicsdn/article/details/50957474","source":"_posts/javase-cglib.md","raw":"---\ntitle: CGLIB介绍与原理\ndate: 2017-10-26 15:57:08\ncategories: java\ntags: cglib\n---\nhttp://blog.csdn.net/zghwaicsdn/article/details/50957474","slug":"javase-cglib","published":1,"updated":"2019-06-16T14:38:33.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqcz0060g4vaaf6o7m52","content":"<p><a href=\"http://blog.csdn.net/zghwaicsdn/article/details/50957474\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zghwaicsdn/article/details/50957474</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://blog.csdn.net/zghwaicsdn/article/details/50957474\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zghwaicsdn/article/details/50957474</a></p>\n"},{"title":"javapoet根据编译注解自动生成代码","date":"2018-05-03T12:54:06.000Z","_content":"\n本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……\n\n## 引入相关依赖包和插件\n\n1.依赖包\n\n    <!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service -->\n    <dependency>\n        <groupId>com.google.auto.service</groupId>\n        <artifactId>auto-service</artifactId>\n        <version>1.0-rc4</version>\n    </dependency>\n    <!--优雅生成代码-->\n    <!--https://github.com/square/javapoet-->\n    <dependency>\n        <groupId>com.squareup</groupId>\n        <artifactId>javapoet</artifactId>\n        <version>1.10.0</version>\n        <optional>true</optional>\n    </dependency>\n    \n- javapoet是square公司出品的用来优雅生成代码库。网址： https://github.com/square/javapoet\n\n- google auto-service是google公司的一个库，用来自动注册服务。\n\n2.apt插件\n\n    <plugin>\n        <groupId>com.mysema.maven</groupId>\n        <artifactId>apt-maven-plugin</artifactId>\n        <version>1.1.3</version>\n        <executions>\n            <execution>\n                <goals>\n                    <goal>process</goal>\n                </goals>\n                <phase>generate-sources</phase>\n                <configuration>\n                    <outputDirectory>${project.basedir}/target/generated-sources/java</outputDirectory>\n                    <processor>com.example.demo.HelloProcessor</processor>\n                    <processors>\n                        <processor>com.example.demo.HelloProcessor</processor>\n                    </processors>\n                    <showWarnings>true</showWarnings>\n                </configuration>\n            </execution>\n        </executions>\n    </plugin>\n    \n可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。\n\n## demo演示\n\n{% asset_img a.png %} \n\n1.新建注解类`HelloAnnotation`    \n\n    package com.example.demo;\n    \n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Retention(RetentionPolicy.CLASS)\n    @Target(ElementType.TYPE)\n    public @interface HelloAnnotation {\n    }\n\n\n2.新建注解处理类`HelloProcessor`\n\n    package com.example.demo;\n    \n    import com.google.auto.service.AutoService;\n    import com.squareup.javapoet.JavaFile;\n    import com.squareup.javapoet.MethodSpec;\n    import com.squareup.javapoet.TypeSpec;\n    \n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.Element;\n    import javax.lang.model.element.Modifier;\n    import javax.lang.model.element.Name;\n    import javax.lang.model.element.TypeElement;\n    import java.io.IOException;\n    import java.lang.reflect.Method;\n    import java.util.Collections;\n    import java.util.Set;\n    \n    @AutoService(Processor.class)\n    @SupportedAnnotationTypes(value = {\"com.example.demo.HelloAnnotation\"})\n    @SupportedSourceVersion(SourceVersion.RELEASE_8)\n    public final class HelloProcessor extends AbstractProcessor {\n    \n        private Filer filer;\n    \n        @Override\n        public synchronized void init(ProcessingEnvironment processingEnv) {\n            super.init(processingEnv);\n    \n            filer = processingEnv.getFiler(); // for creating file\n            System.out.println(\">>>processor init:\" + filer.toString());\n        }\n    \n        @Override\n        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n            System.out.println(\">>>> process:\" + annotations.size());\n            for (TypeElement element : annotations) {\n                /*Set<? extends Element> aa = roundEnv.getElementsAnnotatedWith(element);\n                for (Element e:\n                     aa) {\n                    String name = e.getClass().getTypeName();\n                    System.out.println(\">>>name:\" + name);\n                    Name s = e.getSimpleName();\n                    System.out.println(\">>>aa:\" + s.toString());\n    \n                    *//*Method[] m = e.getClass().getMethods();\n                    for (int i = 0; i < m.length; i++) {\n                        Method mm = m[i];\n                        System.out.println(mm.getName());\n                    }*//*\n                }*/\n                System.out.println(\">>>>>> process：\" + element.getQualifiedName().toString());\n                if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                    // main method\n                    MethodSpec main = MethodSpec.methodBuilder(\"main\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                            .returns(void.class)\n                            .addParameter(String[].class, \"args\")\n                            .addStatement(\"$T.out.println($S)\", System.class, \"Hello, JavaPoet!\")\n                            .build();\n                    // HelloWorld class\n                    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                            .addMethod(main)\n                            .build();\n    \n                    try {\n                        // build com.example.HelloWorld.java\n                        JavaFile javaFile = JavaFile.builder(\"com.example\", helloWorld)\n                                .addFileComment(\" This codes are generated automatically. Do not modify!\")\n                                .build();\n                        // write to file\n                        javaFile.writeTo(filer);\n    \n                        javaFile.writeTo(System.out);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            return true;\n        }\n    \n        //采用注解\n        /*@Override\n        public Set<String> getSupportedAnnotationTypes() {\n            return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n        }*/\n    \n        //采用注解\n       /* @Override\n        public SourceVersion getSupportedSourceVersion() {\n            return SourceVersion.latestSupported();\n        }*/\n    }\n\n-  加上注解`@AutoService(Processor.class)`，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。\n\n{%asset_img b.png%}\n\n- 关键，覆盖方法`process`，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在`maven`插件中配置。\n\n3.定义使用类\n\n    package com.example.demo;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    @HelloAnnotation\n    @SpringBootApplication\n    public class DemoApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(DemoApplication.class, args);\n    //        HelloWorld.main(null);\n        }\n    }\n\n在类上添加注解`@HelloAnnotation`。  \n那么用`mvn install`或者运行该类编译代码时，将会调用注解处理类`HelloProcessor`进行代码生成。\n\n----------------------------------------------------------------------------------\n\n_注意_:   \n在引入apt插件后，要去掉java的编译时注解，只能二选其一，否则apt会生成一次代码，java编译时注解还会生成一次代码，将重复报错。  \n- 用apt插件，去掉processor中的`@AutoService(Processor.class)`注解。  \n- 用java编译时注解，在processor引入`@AutoService(Processor.class)`注解，不需要apt插件。\n\n------------------------------------------------------------------------------------------\n\n<<完>>","source":"_posts/javapoet-apt-annotation.md","raw":"---\ntitle: javapoet根据编译注解自动生成代码\ndate: 2018-05-03 20:54:06\ncategories: javapoet\ntags: javapoet-apt-annotation\n---\n\n本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……\n\n## 引入相关依赖包和插件\n\n1.依赖包\n\n    <!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service -->\n    <dependency>\n        <groupId>com.google.auto.service</groupId>\n        <artifactId>auto-service</artifactId>\n        <version>1.0-rc4</version>\n    </dependency>\n    <!--优雅生成代码-->\n    <!--https://github.com/square/javapoet-->\n    <dependency>\n        <groupId>com.squareup</groupId>\n        <artifactId>javapoet</artifactId>\n        <version>1.10.0</version>\n        <optional>true</optional>\n    </dependency>\n    \n- javapoet是square公司出品的用来优雅生成代码库。网址： https://github.com/square/javapoet\n\n- google auto-service是google公司的一个库，用来自动注册服务。\n\n2.apt插件\n\n    <plugin>\n        <groupId>com.mysema.maven</groupId>\n        <artifactId>apt-maven-plugin</artifactId>\n        <version>1.1.3</version>\n        <executions>\n            <execution>\n                <goals>\n                    <goal>process</goal>\n                </goals>\n                <phase>generate-sources</phase>\n                <configuration>\n                    <outputDirectory>${project.basedir}/target/generated-sources/java</outputDirectory>\n                    <processor>com.example.demo.HelloProcessor</processor>\n                    <processors>\n                        <processor>com.example.demo.HelloProcessor</processor>\n                    </processors>\n                    <showWarnings>true</showWarnings>\n                </configuration>\n            </execution>\n        </executions>\n    </plugin>\n    \n可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。\n\n## demo演示\n\n{% asset_img a.png %} \n\n1.新建注解类`HelloAnnotation`    \n\n    package com.example.demo;\n    \n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Retention(RetentionPolicy.CLASS)\n    @Target(ElementType.TYPE)\n    public @interface HelloAnnotation {\n    }\n\n\n2.新建注解处理类`HelloProcessor`\n\n    package com.example.demo;\n    \n    import com.google.auto.service.AutoService;\n    import com.squareup.javapoet.JavaFile;\n    import com.squareup.javapoet.MethodSpec;\n    import com.squareup.javapoet.TypeSpec;\n    \n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.Element;\n    import javax.lang.model.element.Modifier;\n    import javax.lang.model.element.Name;\n    import javax.lang.model.element.TypeElement;\n    import java.io.IOException;\n    import java.lang.reflect.Method;\n    import java.util.Collections;\n    import java.util.Set;\n    \n    @AutoService(Processor.class)\n    @SupportedAnnotationTypes(value = {\"com.example.demo.HelloAnnotation\"})\n    @SupportedSourceVersion(SourceVersion.RELEASE_8)\n    public final class HelloProcessor extends AbstractProcessor {\n    \n        private Filer filer;\n    \n        @Override\n        public synchronized void init(ProcessingEnvironment processingEnv) {\n            super.init(processingEnv);\n    \n            filer = processingEnv.getFiler(); // for creating file\n            System.out.println(\">>>processor init:\" + filer.toString());\n        }\n    \n        @Override\n        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n            System.out.println(\">>>> process:\" + annotations.size());\n            for (TypeElement element : annotations) {\n                /*Set<? extends Element> aa = roundEnv.getElementsAnnotatedWith(element);\n                for (Element e:\n                     aa) {\n                    String name = e.getClass().getTypeName();\n                    System.out.println(\">>>name:\" + name);\n                    Name s = e.getSimpleName();\n                    System.out.println(\">>>aa:\" + s.toString());\n    \n                    *//*Method[] m = e.getClass().getMethods();\n                    for (int i = 0; i < m.length; i++) {\n                        Method mm = m[i];\n                        System.out.println(mm.getName());\n                    }*//*\n                }*/\n                System.out.println(\">>>>>> process：\" + element.getQualifiedName().toString());\n                if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                    // main method\n                    MethodSpec main = MethodSpec.methodBuilder(\"main\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                            .returns(void.class)\n                            .addParameter(String[].class, \"args\")\n                            .addStatement(\"$T.out.println($S)\", System.class, \"Hello, JavaPoet!\")\n                            .build();\n                    // HelloWorld class\n                    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                            .addMethod(main)\n                            .build();\n    \n                    try {\n                        // build com.example.HelloWorld.java\n                        JavaFile javaFile = JavaFile.builder(\"com.example\", helloWorld)\n                                .addFileComment(\" This codes are generated automatically. Do not modify!\")\n                                .build();\n                        // write to file\n                        javaFile.writeTo(filer);\n    \n                        javaFile.writeTo(System.out);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            return true;\n        }\n    \n        //采用注解\n        /*@Override\n        public Set<String> getSupportedAnnotationTypes() {\n            return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n        }*/\n    \n        //采用注解\n       /* @Override\n        public SourceVersion getSupportedSourceVersion() {\n            return SourceVersion.latestSupported();\n        }*/\n    }\n\n-  加上注解`@AutoService(Processor.class)`，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。\n\n{%asset_img b.png%}\n\n- 关键，覆盖方法`process`，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在`maven`插件中配置。\n\n3.定义使用类\n\n    package com.example.demo;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    @HelloAnnotation\n    @SpringBootApplication\n    public class DemoApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(DemoApplication.class, args);\n    //        HelloWorld.main(null);\n        }\n    }\n\n在类上添加注解`@HelloAnnotation`。  \n那么用`mvn install`或者运行该类编译代码时，将会调用注解处理类`HelloProcessor`进行代码生成。\n\n----------------------------------------------------------------------------------\n\n_注意_:   \n在引入apt插件后，要去掉java的编译时注解，只能二选其一，否则apt会生成一次代码，java编译时注解还会生成一次代码，将重复报错。  \n- 用apt插件，去掉processor中的`@AutoService(Processor.class)`注解。  \n- 用java编译时注解，在processor引入`@AutoService(Processor.class)`注解，不需要apt插件。\n\n------------------------------------------------------------------------------------------\n\n<<完>>","slug":"javapoet-apt-annotation","published":1,"updated":"2019-06-16T14:38:33.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqd20061g4vazpfoai8i","content":"<p>本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……</p>\n<h2 id=\"引入相关依赖包和插件\"><a href=\"#引入相关依赖包和插件\" class=\"headerlink\" title=\"引入相关依赖包和插件\"></a>引入相关依赖包和插件</h2><p>1.依赖包</p>\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n    &lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n    &lt;version&gt;1.0-rc4&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--优雅生成代码--&gt;\n&lt;!--https://github.com/square/javapoet--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup&lt;/groupId&gt;\n    &lt;artifactId&gt;javapoet&lt;/artifactId&gt;\n    &lt;version&gt;1.10.0&lt;/version&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><ul>\n<li><p>javapoet是square公司出品的用来优雅生成代码库。网址： <a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">https://github.com/square/javapoet</a></p>\n</li>\n<li><p>google auto-service是google公司的一个库，用来自动注册服务。</p>\n</li>\n</ul>\n<p>2.apt插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;\n    &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.1.3&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;process&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;phase&gt;generate-sources&lt;/phase&gt;\n            &lt;configuration&gt;\n                &lt;outputDirectory&gt;${project.basedir}/target/generated-sources/java&lt;/outputDirectory&gt;\n                &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;processors&gt;\n                    &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;/processors&gt;\n                &lt;showWarnings&gt;true&lt;/showWarnings&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。</p>\n<h2 id=\"demo演示\"><a href=\"#demo演示\" class=\"headerlink\" title=\"demo演示\"></a>demo演示</h2><img src=\"/2018/05/03/javapoet-apt-annotation/a.png\"> \n<p>1.新建注解类<code>HelloAnnotation</code>    </p>\n<pre><code>package com.example.demo;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface HelloAnnotation {\n}\n</code></pre><p>2.新建注解处理类<code>HelloProcessor</code></p>\n<pre><code>package com.example.demo;\n\nimport com.google.auto.service.AutoService;\nimport com.squareup.javapoet.JavaFile;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeSpec;\n\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.TypeElement;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Set;\n\n@AutoService(Processor.class)\n@SupportedAnnotationTypes(value = {&quot;com.example.demo.HelloAnnotation&quot;})\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\npublic final class HelloProcessor extends AbstractProcessor {\n\n    private Filer filer;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n\n        filer = processingEnv.getFiler(); // for creating file\n        System.out.println(&quot;&gt;&gt;&gt;processor init:&quot; + filer.toString());\n    }\n\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n        System.out.println(&quot;&gt;&gt;&gt;&gt; process:&quot; + annotations.size());\n        for (TypeElement element : annotations) {\n            /*Set&lt;? extends Element&gt; aa = roundEnv.getElementsAnnotatedWith(element);\n            for (Element e:\n                 aa) {\n                String name = e.getClass().getTypeName();\n                System.out.println(&quot;&gt;&gt;&gt;name:&quot; + name);\n                Name s = e.getSimpleName();\n                System.out.println(&quot;&gt;&gt;&gt;aa:&quot; + s.toString());\n\n                *//*Method[] m = e.getClass().getMethods();\n                for (int i = 0; i &lt; m.length; i++) {\n                    Method mm = m[i];\n                    System.out.println(mm.getName());\n                }*//*\n            }*/\n            System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt; process：&quot; + element.getQualifiedName().toString());\n            if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                // main method\n                MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                        .returns(void.class)\n                        .addParameter(String[].class, &quot;args&quot;)\n                        .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)\n                        .build();\n                // HelloWorld class\n                TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                        .addMethod(main)\n                        .build();\n\n                try {\n                    // build com.example.HelloWorld.java\n                    JavaFile javaFile = JavaFile.builder(&quot;com.example&quot;, helloWorld)\n                            .addFileComment(&quot; This codes are generated automatically. Do not modify!&quot;)\n                            .build();\n                    // write to file\n                    javaFile.writeTo(filer);\n\n                    javaFile.writeTo(System.out);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    //采用注解\n    /*@Override\n    public Set&lt;String&gt; getSupportedAnnotationTypes() {\n        return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n    }*/\n\n    //采用注解\n   /* @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }*/\n}\n</code></pre><ul>\n<li>加上注解<code>@AutoService(Processor.class)</code>，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。</li>\n</ul>\n<img src=\"/2018/05/03/javapoet-apt-annotation/b.png\">\n<ul>\n<li>关键，覆盖方法<code>process</code>，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在<code>maven</code>插件中配置。</li>\n</ul>\n<p>3.定义使用类</p>\n<pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@HelloAnnotation\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n//        HelloWorld.main(null);\n    }\n}\n</code></pre><p>在类上添加注解<code>@HelloAnnotation</code>。<br>那么用<code>mvn install</code>或者运行该类编译代码时，将会调用注解处理类<code>HelloProcessor</code>进行代码生成。</p>\n<hr>\n<p>_注意_:<br>在引入apt插件后，要去掉java的编译时注解，只能二选其一，否则apt会生成一次代码，java编译时注解还会生成一次代码，将重复报错。  </p>\n<ul>\n<li>用apt插件，去掉processor中的<code>@AutoService(Processor.class)</code>注解。  </li>\n<li>用java编译时注解，在processor引入<code>@AutoService(Processor.class)</code>注解，不需要apt插件。</li>\n</ul>\n<hr>\n<p>&lt;&lt;完&gt;&gt;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……</p>\n<h2 id=\"引入相关依赖包和插件\"><a href=\"#引入相关依赖包和插件\" class=\"headerlink\" title=\"引入相关依赖包和插件\"></a>引入相关依赖包和插件</h2><p>1.依赖包</p>\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n    &lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n    &lt;version&gt;1.0-rc4&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--优雅生成代码--&gt;\n&lt;!--https://github.com/square/javapoet--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup&lt;/groupId&gt;\n    &lt;artifactId&gt;javapoet&lt;/artifactId&gt;\n    &lt;version&gt;1.10.0&lt;/version&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><ul>\n<li><p>javapoet是square公司出品的用来优雅生成代码库。网址： <a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">https://github.com/square/javapoet</a></p>\n</li>\n<li><p>google auto-service是google公司的一个库，用来自动注册服务。</p>\n</li>\n</ul>\n<p>2.apt插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;\n    &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.1.3&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;process&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;phase&gt;generate-sources&lt;/phase&gt;\n            &lt;configuration&gt;\n                &lt;outputDirectory&gt;${project.basedir}/target/generated-sources/java&lt;/outputDirectory&gt;\n                &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;processors&gt;\n                    &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;/processors&gt;\n                &lt;showWarnings&gt;true&lt;/showWarnings&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。</p>\n<h2 id=\"demo演示\"><a href=\"#demo演示\" class=\"headerlink\" title=\"demo演示\"></a>demo演示</h2><img src=\"/2018/05/03/javapoet-apt-annotation/a.png\"> \n<p>1.新建注解类<code>HelloAnnotation</code>    </p>\n<pre><code>package com.example.demo;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface HelloAnnotation {\n}\n</code></pre><p>2.新建注解处理类<code>HelloProcessor</code></p>\n<pre><code>package com.example.demo;\n\nimport com.google.auto.service.AutoService;\nimport com.squareup.javapoet.JavaFile;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeSpec;\n\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.TypeElement;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Set;\n\n@AutoService(Processor.class)\n@SupportedAnnotationTypes(value = {&quot;com.example.demo.HelloAnnotation&quot;})\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\npublic final class HelloProcessor extends AbstractProcessor {\n\n    private Filer filer;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n\n        filer = processingEnv.getFiler(); // for creating file\n        System.out.println(&quot;&gt;&gt;&gt;processor init:&quot; + filer.toString());\n    }\n\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n        System.out.println(&quot;&gt;&gt;&gt;&gt; process:&quot; + annotations.size());\n        for (TypeElement element : annotations) {\n            /*Set&lt;? extends Element&gt; aa = roundEnv.getElementsAnnotatedWith(element);\n            for (Element e:\n                 aa) {\n                String name = e.getClass().getTypeName();\n                System.out.println(&quot;&gt;&gt;&gt;name:&quot; + name);\n                Name s = e.getSimpleName();\n                System.out.println(&quot;&gt;&gt;&gt;aa:&quot; + s.toString());\n\n                *//*Method[] m = e.getClass().getMethods();\n                for (int i = 0; i &lt; m.length; i++) {\n                    Method mm = m[i];\n                    System.out.println(mm.getName());\n                }*//*\n            }*/\n            System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt; process：&quot; + element.getQualifiedName().toString());\n            if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                // main method\n                MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                        .returns(void.class)\n                        .addParameter(String[].class, &quot;args&quot;)\n                        .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)\n                        .build();\n                // HelloWorld class\n                TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                        .addMethod(main)\n                        .build();\n\n                try {\n                    // build com.example.HelloWorld.java\n                    JavaFile javaFile = JavaFile.builder(&quot;com.example&quot;, helloWorld)\n                            .addFileComment(&quot; This codes are generated automatically. Do not modify!&quot;)\n                            .build();\n                    // write to file\n                    javaFile.writeTo(filer);\n\n                    javaFile.writeTo(System.out);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    //采用注解\n    /*@Override\n    public Set&lt;String&gt; getSupportedAnnotationTypes() {\n        return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n    }*/\n\n    //采用注解\n   /* @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }*/\n}\n</code></pre><ul>\n<li>加上注解<code>@AutoService(Processor.class)</code>，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。</li>\n</ul>\n<img src=\"/2018/05/03/javapoet-apt-annotation/b.png\">\n<ul>\n<li>关键，覆盖方法<code>process</code>，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在<code>maven</code>插件中配置。</li>\n</ul>\n<p>3.定义使用类</p>\n<pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@HelloAnnotation\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n//        HelloWorld.main(null);\n    }\n}\n</code></pre><p>在类上添加注解<code>@HelloAnnotation</code>。<br>那么用<code>mvn install</code>或者运行该类编译代码时，将会调用注解处理类<code>HelloProcessor</code>进行代码生成。</p>\n<hr>\n<p>_注意_:<br>在引入apt插件后，要去掉java的编译时注解，只能二选其一，否则apt会生成一次代码，java编译时注解还会生成一次代码，将重复报错。  </p>\n<ul>\n<li>用apt插件，去掉processor中的<code>@AutoService(Processor.class)</code>注解。  </li>\n<li>用java编译时注解，在processor引入<code>@AutoService(Processor.class)</code>注解，不需要apt插件。</li>\n</ul>\n<hr>\n<p>&lt;&lt;完&gt;&gt;</p>\n"},{"title":"jenkins-java-maven持续集成（CentOs7）","date":"2017-11-28T01:15:26.000Z","_content":"\n传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。\n\n参考：  \nhttp://www.jianshu.com/p/a7d7df97fe4b\n\n## 1. 安装并运行jenkins-war\n- [下载](https://jenkins.io/download/)\n- 运行 `java -jar jenkins.war --httpPort=8080.`\n- 在浏览器访问 http://localhost:8080. 记得开防火墙。\n\n图一：\n{% asset_img a.png %}\n\n## 2. 初次访问配置\n- 按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。\n- 按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。\n- 创建管理员账号，按照页面设置即可。\n\n这样，下面就可以开始使用jenkins了。\n\n\n## 3. maven，svn,springboot下持续构建java应用\n- 安装maven环境。[下载maven](http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz)\n\n### 3.1 配置jenkins\n\n{% asset_img b.png %}\n\n点击`系统管理`。\n\n{% asset_img c.png %}\n\n配置各种环境：\n\n- maven setting.xml\n\n{% asset_img e.png %}\n\n- jdk,取消自动安装\n\n{% asset_img f.png %}\n\n- maven,取消自动安装\n\n{% asset_img g.png %}\n\n### 3.2 安装maven插件\n\n{% asset_img h.png %}\n\n-------\n\n{% asset_img i.png %}\n\n点击直接安装即可。\n\n### 3.3 创建新项目\n\n{% asset_img 1.png %}\n\n选定。\n\n{% asset_img 2.png %}\n\n点击ok。\n\n### 3.4 配置项目各种信息\n{% asset_img 3.png %}\n\n------------\n{% asset_img 4.png %}\n\n### 3.5 开始构建项目\n\n{% asset_img 5.png %}\n\n查看构建结果\n\n{% asset_img 6.png %}\n\n然后再服务器相关目录下就能看到构建后的jar包:\n{% asset_img 7.png %}\n\n### 3.6 构建后配置\n构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。\n\n#### 3.6.1 直接执行jar\n修改项目配置：\n{% asset_img 8.png %}\n\n添加成功构建后要执行的脚本：\n{% asset_img 8_1.png %}\n\n> 注意脚本写法，如果是后台执行：\n    `BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`\n\n#### 3.6.2 发布jar到远程服务器，并执行\n - 下载相关插件：\n {% asset_img 10.png %}\n \n- 在系统设置中添加远程服务器：\n {% asset_img 11.png %}\n\n- 在项目中设置，选定远程服务器：\n{% asset_img 12.png %}\n\n*注意：*\n{% asset_img 13.png %}\n\n- 备份，执行远程服务器上的jar包\n\n1. 在远程服务器上设置脚本，放在目录：`server/bin`：\n\n>停止应用脚本`stop.sh`：\n    # 将应用停止\n    #stop.sh\n    #!/bin/bash\n    echo \"Stopping SpringBoot Application\"\n    pid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk '{print $2}'`\n    if [ -n \"$pid\" ]\n    then\n       kill -9 $pid\n    fi\n---    \n> 备份应用脚本`replace.sh`:\n    #replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n    #!/bin/bash\n    # 先判断文件是否存在，如果存在，则备份\n    file=\"/server/java/apps/jenkins-demo.jar\"\n    if [ -f \"$file\" ]\n    then\n       mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\n    fi\n    mv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n---\n> 启动应用包脚本`start.sh`:\n    # startup.sh 启动项目\n    #!/bin/bash\n    echo \"授予当前用户权限\"\n    chmod 777 /server/java/apps/jenkins-demo.jar\n    echo \"执行.....\"\n    java -jar /server/java/apps/jenkins-demo.jar\n   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行`nohub java -jar /server/java/apps/jenkins-demo.jar &`不起作用，所在要在jenkins上这样配置`BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`  \n   如果是远程服务器，就可以改成：\n       # startup.sh 启动项目\n       #!/bin/bash\n       echo \"授予当前用户权限\"\n       chmod 777 /server/java/apps/jenkins-demo.jar\n       echo \"执行.....\"\n       nohup java -jar /server/java/apps/jenkins-demo.jar > jenkins-demo.out 2>& 1 &\n    \n---\n2. 设置远程服务器执行脚本： \n\n{% asset_img 14.png %}   \n\n如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。\n\n{% asset_img 15.png %}   \n\n## 备注：\n\n1.替换jar包中的文件\n\n`jar -uvf rpds.jar BOOT-INF/classes/db.properties `\n\n2.启动jar应用程序shell脚本\n\n    #!/bin/sh\n    # chkconfig: 2345 64 36\n    ## java env \n    #################### zhengjianyan #######################\n    export JAVA_HOME=/server/java/jdk\n    export JRE_HOME=$JAVA_HOME/jre\n    \n    BASE_PATH=/server/java/service/com.xcsqjr.scf.service\n    VERSION=1.0.0\n    ## service name\n    APP_NAME=all\n    \n    SERVICE_DIR=$BASE_PATH/com.xcsqjr.scf.service.$APP_NAME\n    SERVICE_NAME=com.xcsqjr.scf.service.$APP_NAME-$VERSION\n    #JAR_NAME=$SERVICE_DIR/$SERVICE_NAME/target\\.jar\n    JAR_NAME=$SERVICE_DIR/target/$SERVICE_NAME.jar\n    PID=$SERVICE_NAME\\.pid\n    \n    rm -rf $SERVICE_DIR/target/*.tmp\n    cd $BASE_PATH\n    cd ..\n    \n    $JAVA_HOME/bin/jar uvf $SERVICE_DIR/target/$SERVICE_NAME.jar application.properties\n    \n    cd $SERVICE_DIR\n    case \"$1\" in\n    \n        start)\n            nohup $JRE_HOME/bin/java -Xms128m -Xmx256m -jar $JAR_NAME >/dev/null 2>&1 &\n            echo $! > $SERVICE_DIR/target/$PID\n            echo \"=== start $SERVICE_NAME\"\n            ;;\n    \n        stop)\n            kill `cat $SERVICE_DIR/target/$PID`\n            rm -rf $SERVICE_DIR/target/$PID\n            echo \"=== stop $SERVICE_NAME\"\n    \n            sleep 5\n            P_ID=`ps -ef | grep -w \"$SERVICE_NAME\" | grep -v \"grep\" | awk '{print $2}'`\n            if [ \"$P_ID\" == \"\" ]; then\n                echo \"=== $SERVICE_NAME process not exists or stop success\"\n            else\n                echo \"=== $SERVICE_NAME process pid is:$P_ID\"\n                echo \"=== begin kill $SERVICE_NAME process, pid is:$P_ID\"\n                kill -9 $P_ID\n            fi\n            ;;\n    \n        restart)\n            $0 stop\n            sleep 2\n            $0 start\n            echo \"=== restart $SERVICE_NAME\"\n            ;;\n    \n        *)\n    \t\techo \"==== restart =====\"\n            ## restart\n            $0 stop\n            sleep 5\n            $0 start\n            ;;\n    esac\n    exit 0\n\n\n\n","source":"_posts/jenkins-java-maven.md","raw":"---\ntitle: jenkins-java-maven持续集成（CentOs7）\ndate: 2017-11-28 09:15:26\ncategories: 持续集成\ntags: jenkins-java-maven\n---\n\n传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。\n\n参考：  \nhttp://www.jianshu.com/p/a7d7df97fe4b\n\n## 1. 安装并运行jenkins-war\n- [下载](https://jenkins.io/download/)\n- 运行 `java -jar jenkins.war --httpPort=8080.`\n- 在浏览器访问 http://localhost:8080. 记得开防火墙。\n\n图一：\n{% asset_img a.png %}\n\n## 2. 初次访问配置\n- 按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。\n- 按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。\n- 创建管理员账号，按照页面设置即可。\n\n这样，下面就可以开始使用jenkins了。\n\n\n## 3. maven，svn,springboot下持续构建java应用\n- 安装maven环境。[下载maven](http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz)\n\n### 3.1 配置jenkins\n\n{% asset_img b.png %}\n\n点击`系统管理`。\n\n{% asset_img c.png %}\n\n配置各种环境：\n\n- maven setting.xml\n\n{% asset_img e.png %}\n\n- jdk,取消自动安装\n\n{% asset_img f.png %}\n\n- maven,取消自动安装\n\n{% asset_img g.png %}\n\n### 3.2 安装maven插件\n\n{% asset_img h.png %}\n\n-------\n\n{% asset_img i.png %}\n\n点击直接安装即可。\n\n### 3.3 创建新项目\n\n{% asset_img 1.png %}\n\n选定。\n\n{% asset_img 2.png %}\n\n点击ok。\n\n### 3.4 配置项目各种信息\n{% asset_img 3.png %}\n\n------------\n{% asset_img 4.png %}\n\n### 3.5 开始构建项目\n\n{% asset_img 5.png %}\n\n查看构建结果\n\n{% asset_img 6.png %}\n\n然后再服务器相关目录下就能看到构建后的jar包:\n{% asset_img 7.png %}\n\n### 3.6 构建后配置\n构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。\n\n#### 3.6.1 直接执行jar\n修改项目配置：\n{% asset_img 8.png %}\n\n添加成功构建后要执行的脚本：\n{% asset_img 8_1.png %}\n\n> 注意脚本写法，如果是后台执行：\n    `BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`\n\n#### 3.6.2 发布jar到远程服务器，并执行\n - 下载相关插件：\n {% asset_img 10.png %}\n \n- 在系统设置中添加远程服务器：\n {% asset_img 11.png %}\n\n- 在项目中设置，选定远程服务器：\n{% asset_img 12.png %}\n\n*注意：*\n{% asset_img 13.png %}\n\n- 备份，执行远程服务器上的jar包\n\n1. 在远程服务器上设置脚本，放在目录：`server/bin`：\n\n>停止应用脚本`stop.sh`：\n    # 将应用停止\n    #stop.sh\n    #!/bin/bash\n    echo \"Stopping SpringBoot Application\"\n    pid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk '{print $2}'`\n    if [ -n \"$pid\" ]\n    then\n       kill -9 $pid\n    fi\n---    \n> 备份应用脚本`replace.sh`:\n    #replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n    #!/bin/bash\n    # 先判断文件是否存在，如果存在，则备份\n    file=\"/server/java/apps/jenkins-demo.jar\"\n    if [ -f \"$file\" ]\n    then\n       mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\n    fi\n    mv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n---\n> 启动应用包脚本`start.sh`:\n    # startup.sh 启动项目\n    #!/bin/bash\n    echo \"授予当前用户权限\"\n    chmod 777 /server/java/apps/jenkins-demo.jar\n    echo \"执行.....\"\n    java -jar /server/java/apps/jenkins-demo.jar\n   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行`nohub java -jar /server/java/apps/jenkins-demo.jar &`不起作用，所在要在jenkins上这样配置`BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`  \n   如果是远程服务器，就可以改成：\n       # startup.sh 启动项目\n       #!/bin/bash\n       echo \"授予当前用户权限\"\n       chmod 777 /server/java/apps/jenkins-demo.jar\n       echo \"执行.....\"\n       nohup java -jar /server/java/apps/jenkins-demo.jar > jenkins-demo.out 2>& 1 &\n    \n---\n2. 设置远程服务器执行脚本： \n\n{% asset_img 14.png %}   \n\n如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。\n\n{% asset_img 15.png %}   \n\n## 备注：\n\n1.替换jar包中的文件\n\n`jar -uvf rpds.jar BOOT-INF/classes/db.properties `\n\n2.启动jar应用程序shell脚本\n\n    #!/bin/sh\n    # chkconfig: 2345 64 36\n    ## java env \n    #################### zhengjianyan #######################\n    export JAVA_HOME=/server/java/jdk\n    export JRE_HOME=$JAVA_HOME/jre\n    \n    BASE_PATH=/server/java/service/com.xcsqjr.scf.service\n    VERSION=1.0.0\n    ## service name\n    APP_NAME=all\n    \n    SERVICE_DIR=$BASE_PATH/com.xcsqjr.scf.service.$APP_NAME\n    SERVICE_NAME=com.xcsqjr.scf.service.$APP_NAME-$VERSION\n    #JAR_NAME=$SERVICE_DIR/$SERVICE_NAME/target\\.jar\n    JAR_NAME=$SERVICE_DIR/target/$SERVICE_NAME.jar\n    PID=$SERVICE_NAME\\.pid\n    \n    rm -rf $SERVICE_DIR/target/*.tmp\n    cd $BASE_PATH\n    cd ..\n    \n    $JAVA_HOME/bin/jar uvf $SERVICE_DIR/target/$SERVICE_NAME.jar application.properties\n    \n    cd $SERVICE_DIR\n    case \"$1\" in\n    \n        start)\n            nohup $JRE_HOME/bin/java -Xms128m -Xmx256m -jar $JAR_NAME >/dev/null 2>&1 &\n            echo $! > $SERVICE_DIR/target/$PID\n            echo \"=== start $SERVICE_NAME\"\n            ;;\n    \n        stop)\n            kill `cat $SERVICE_DIR/target/$PID`\n            rm -rf $SERVICE_DIR/target/$PID\n            echo \"=== stop $SERVICE_NAME\"\n    \n            sleep 5\n            P_ID=`ps -ef | grep -w \"$SERVICE_NAME\" | grep -v \"grep\" | awk '{print $2}'`\n            if [ \"$P_ID\" == \"\" ]; then\n                echo \"=== $SERVICE_NAME process not exists or stop success\"\n            else\n                echo \"=== $SERVICE_NAME process pid is:$P_ID\"\n                echo \"=== begin kill $SERVICE_NAME process, pid is:$P_ID\"\n                kill -9 $P_ID\n            fi\n            ;;\n    \n        restart)\n            $0 stop\n            sleep 2\n            $0 start\n            echo \"=== restart $SERVICE_NAME\"\n            ;;\n    \n        *)\n    \t\techo \"==== restart =====\"\n            ## restart\n            $0 stop\n            sleep 5\n            $0 start\n            ;;\n    esac\n    exit 0\n\n\n\n","slug":"jenkins-java-maven","published":1,"updated":"2019-06-16T14:38:33.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqd40065g4vah0vx23qw","content":"<p>传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。</p>\n<p>参考：<br><a href=\"http://www.jianshu.com/p/a7d7df97fe4b\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/a7d7df97fe4b</a></p>\n<h2 id=\"1-安装并运行jenkins-war\"><a href=\"#1-安装并运行jenkins-war\" class=\"headerlink\" title=\"1. 安装并运行jenkins-war\"></a>1. 安装并运行jenkins-war</h2><ul>\n<li><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li>运行 <code>java -jar jenkins.war --httpPort=8080.</code></li>\n<li>在浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>. 记得开防火墙。</li>\n</ul>\n<p>图一：<br><img src=\"/2017/11/28/jenkins-java-maven/a.png\"></p>\n<h2 id=\"2-初次访问配置\"><a href=\"#2-初次访问配置\" class=\"headerlink\" title=\"2. 初次访问配置\"></a>2. 初次访问配置</h2><ul>\n<li>按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。</li>\n<li>按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。</li>\n<li>创建管理员账号，按照页面设置即可。</li>\n</ul>\n<p>这样，下面就可以开始使用jenkins了。</p>\n<h2 id=\"3-maven，svn-springboot下持续构建java应用\"><a href=\"#3-maven，svn-springboot下持续构建java应用\" class=\"headerlink\" title=\"3. maven，svn,springboot下持续构建java应用\"></a>3. maven，svn,springboot下持续构建java应用</h2><ul>\n<li>安装maven环境。<a href=\"http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">下载maven</a></li>\n</ul>\n<h3 id=\"3-1-配置jenkins\"><a href=\"#3-1-配置jenkins\" class=\"headerlink\" title=\"3.1 配置jenkins\"></a>3.1 配置jenkins</h3><img src=\"/2017/11/28/jenkins-java-maven/b.png\">\n<p>点击<code>系统管理</code>。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/c.png\">\n<p>配置各种环境：</p>\n<ul>\n<li>maven setting.xml</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/e.png\">\n<ul>\n<li>jdk,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/f.png\">\n<ul>\n<li>maven,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/g.png\">\n<h3 id=\"3-2-安装maven插件\"><a href=\"#3-2-安装maven插件\" class=\"headerlink\" title=\"3.2 安装maven插件\"></a>3.2 安装maven插件</h3><img src=\"/2017/11/28/jenkins-java-maven/h.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/i.png\">\n<p>点击直接安装即可。</p>\n<h3 id=\"3-3-创建新项目\"><a href=\"#3-3-创建新项目\" class=\"headerlink\" title=\"3.3 创建新项目\"></a>3.3 创建新项目</h3><img src=\"/2017/11/28/jenkins-java-maven/1.png\">\n<p>选定。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/2.png\">\n<p>点击ok。</p>\n<h3 id=\"3-4-配置项目各种信息\"><a href=\"#3-4-配置项目各种信息\" class=\"headerlink\" title=\"3.4 配置项目各种信息\"></a>3.4 配置项目各种信息</h3><img src=\"/2017/11/28/jenkins-java-maven/3.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/4.png\">\n<h3 id=\"3-5-开始构建项目\"><a href=\"#3-5-开始构建项目\" class=\"headerlink\" title=\"3.5 开始构建项目\"></a>3.5 开始构建项目</h3><img src=\"/2017/11/28/jenkins-java-maven/5.png\">\n<p>查看构建结果</p>\n<img src=\"/2017/11/28/jenkins-java-maven/6.png\">\n<p>然后再服务器相关目录下就能看到构建后的jar包:<br><img src=\"/2017/11/28/jenkins-java-maven/7.png\"></p>\n<h3 id=\"3-6-构建后配置\"><a href=\"#3-6-构建后配置\" class=\"headerlink\" title=\"3.6 构建后配置\"></a>3.6 构建后配置</h3><p>构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。</p>\n<h4 id=\"3-6-1-直接执行jar\"><a href=\"#3-6-1-直接执行jar\" class=\"headerlink\" title=\"3.6.1 直接执行jar\"></a>3.6.1 直接执行jar</h4><p>修改项目配置：<br><img src=\"/2017/11/28/jenkins-java-maven/8.png\"></p>\n<p>添加成功构建后要执行的脚本：<br><img src=\"/2017/11/28/jenkins-java-maven/8_1.png\"></p>\n<blockquote>\n<p>注意脚本写法，如果是后台执行：<br>    <code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code></p>\n</blockquote>\n<h4 id=\"3-6-2-发布jar到远程服务器，并执行\"><a href=\"#3-6-2-发布jar到远程服务器，并执行\" class=\"headerlink\" title=\"3.6.2 发布jar到远程服务器，并执行\"></a>3.6.2 发布jar到远程服务器，并执行</h4><ul>\n<li>下载相关插件：<img src=\"/2017/11/28/jenkins-java-maven/10.png\">\n</li>\n</ul>\n<ul>\n<li><p>在系统设置中添加远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/11.png\">\n</li>\n<li><p>在项目中设置，选定远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/12.png\">\n</li>\n</ul>\n<p><em>注意：</em><br><img src=\"/2017/11/28/jenkins-java-maven/13.png\"></p>\n<ul>\n<li>备份，执行远程服务器上的jar包</li>\n</ul>\n<ol>\n<li>在远程服务器上设置脚本，放在目录：<code>server/bin</code>：</li>\n</ol>\n<blockquote>\n<p>停止应用脚本<code>stop.sh</code>：</p>\n</blockquote>\n<pre><code># 将应用停止\n#stop.sh\n#!/bin/bash\necho &quot;Stopping SpringBoot Application&quot;\npid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk &apos;{print $2}&apos;`\nif [ -n &quot;$pid&quot; ]\nthen\n   kill -9 $pid\nfi\n</code></pre><hr>\n<blockquote>\n<p>备份应用脚本<code>replace.sh</code>:</p>\n</blockquote>\n<pre><code>#replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n#!/bin/bash\n# 先判断文件是否存在，如果存在，则备份\nfile=&quot;/server/java/apps/jenkins-demo.jar&quot;\nif [ -f &quot;$file&quot; ]\nthen\n   mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\nfi\nmv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n</code></pre><hr>\n<blockquote>\n<p>启动应用包脚本<code>start.sh</code>:</p>\n</blockquote>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\njava -jar /server/java/apps/jenkins-demo.jar\n</code></pre><p>   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行<code>nohub java -jar /server/java/apps/jenkins-demo.jar &amp;</code>不起作用，所在要在jenkins上这样配置<code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code><br>   如果是远程服务器，就可以改成：</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\nnohup java -jar /server/java/apps/jenkins-demo.jar &gt; jenkins-demo.out 2&gt;&amp; 1 &amp;\n</code></pre><hr>\n<ol start=\"2\">\n<li>设置远程服务器执行脚本： </li>\n</ol>\n<img src=\"/2017/11/28/jenkins-java-maven/14.png\">   \n<p>如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/15.png\">   \n<h2 id=\"备注：\"><a href=\"#备注：\" class=\"headerlink\" title=\"备注：\"></a>备注：</h2><p>1.替换jar包中的文件</p>\n<p><code>jar -uvf rpds.jar BOOT-INF/classes/db.properties</code></p>\n<p>2.启动jar应用程序shell脚本</p>\n<pre><code>#!/bin/sh\n# chkconfig: 2345 64 36\n## java env \n#################### zhengjianyan #######################\nexport JAVA_HOME=/server/java/jdk\nexport JRE_HOME=$JAVA_HOME/jre\n\nBASE_PATH=/server/java/service/com.xcsqjr.scf.service\nVERSION=1.0.0\n## service name\nAPP_NAME=all\n\nSERVICE_DIR=$BASE_PATH/com.xcsqjr.scf.service.$APP_NAME\nSERVICE_NAME=com.xcsqjr.scf.service.$APP_NAME-$VERSION\n#JAR_NAME=$SERVICE_DIR/$SERVICE_NAME/target\\.jar\nJAR_NAME=$SERVICE_DIR/target/$SERVICE_NAME.jar\nPID=$SERVICE_NAME\\.pid\n\nrm -rf $SERVICE_DIR/target/*.tmp\ncd $BASE_PATH\ncd ..\n\n$JAVA_HOME/bin/jar uvf $SERVICE_DIR/target/$SERVICE_NAME.jar application.properties\n\ncd $SERVICE_DIR\ncase &quot;$1&quot; in\n\n    start)\n        nohup $JRE_HOME/bin/java -Xms128m -Xmx256m -jar $JAR_NAME &gt;/dev/null 2&gt;&amp;1 &amp;\n        echo $! &gt; $SERVICE_DIR/target/$PID\n        echo &quot;=== start $SERVICE_NAME&quot;\n        ;;\n\n    stop)\n        kill `cat $SERVICE_DIR/target/$PID`\n        rm -rf $SERVICE_DIR/target/$PID\n        echo &quot;=== stop $SERVICE_NAME&quot;\n\n        sleep 5\n        P_ID=`ps -ef | grep -w &quot;$SERVICE_NAME&quot; | grep -v &quot;grep&quot; | awk &apos;{print $2}&apos;`\n        if [ &quot;$P_ID&quot; == &quot;&quot; ]; then\n            echo &quot;=== $SERVICE_NAME process not exists or stop success&quot;\n        else\n            echo &quot;=== $SERVICE_NAME process pid is:$P_ID&quot;\n            echo &quot;=== begin kill $SERVICE_NAME process, pid is:$P_ID&quot;\n            kill -9 $P_ID\n        fi\n        ;;\n\n    restart)\n        $0 stop\n        sleep 2\n        $0 start\n        echo &quot;=== restart $SERVICE_NAME&quot;\n        ;;\n\n    *)\n        echo &quot;==== restart =====&quot;\n        ## restart\n        $0 stop\n        sleep 5\n        $0 start\n        ;;\nesac\nexit 0\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。</p>\n<p>参考：<br><a href=\"http://www.jianshu.com/p/a7d7df97fe4b\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/a7d7df97fe4b</a></p>\n<h2 id=\"1-安装并运行jenkins-war\"><a href=\"#1-安装并运行jenkins-war\" class=\"headerlink\" title=\"1. 安装并运行jenkins-war\"></a>1. 安装并运行jenkins-war</h2><ul>\n<li><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li>运行 <code>java -jar jenkins.war --httpPort=8080.</code></li>\n<li>在浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>. 记得开防火墙。</li>\n</ul>\n<p>图一：<br><img src=\"/2017/11/28/jenkins-java-maven/a.png\"></p>\n<h2 id=\"2-初次访问配置\"><a href=\"#2-初次访问配置\" class=\"headerlink\" title=\"2. 初次访问配置\"></a>2. 初次访问配置</h2><ul>\n<li>按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。</li>\n<li>按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。</li>\n<li>创建管理员账号，按照页面设置即可。</li>\n</ul>\n<p>这样，下面就可以开始使用jenkins了。</p>\n<h2 id=\"3-maven，svn-springboot下持续构建java应用\"><a href=\"#3-maven，svn-springboot下持续构建java应用\" class=\"headerlink\" title=\"3. maven，svn,springboot下持续构建java应用\"></a>3. maven，svn,springboot下持续构建java应用</h2><ul>\n<li>安装maven环境。<a href=\"http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">下载maven</a></li>\n</ul>\n<h3 id=\"3-1-配置jenkins\"><a href=\"#3-1-配置jenkins\" class=\"headerlink\" title=\"3.1 配置jenkins\"></a>3.1 配置jenkins</h3><img src=\"/2017/11/28/jenkins-java-maven/b.png\">\n<p>点击<code>系统管理</code>。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/c.png\">\n<p>配置各种环境：</p>\n<ul>\n<li>maven setting.xml</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/e.png\">\n<ul>\n<li>jdk,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/f.png\">\n<ul>\n<li>maven,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/g.png\">\n<h3 id=\"3-2-安装maven插件\"><a href=\"#3-2-安装maven插件\" class=\"headerlink\" title=\"3.2 安装maven插件\"></a>3.2 安装maven插件</h3><img src=\"/2017/11/28/jenkins-java-maven/h.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/i.png\">\n<p>点击直接安装即可。</p>\n<h3 id=\"3-3-创建新项目\"><a href=\"#3-3-创建新项目\" class=\"headerlink\" title=\"3.3 创建新项目\"></a>3.3 创建新项目</h3><img src=\"/2017/11/28/jenkins-java-maven/1.png\">\n<p>选定。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/2.png\">\n<p>点击ok。</p>\n<h3 id=\"3-4-配置项目各种信息\"><a href=\"#3-4-配置项目各种信息\" class=\"headerlink\" title=\"3.4 配置项目各种信息\"></a>3.4 配置项目各种信息</h3><img src=\"/2017/11/28/jenkins-java-maven/3.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/4.png\">\n<h3 id=\"3-5-开始构建项目\"><a href=\"#3-5-开始构建项目\" class=\"headerlink\" title=\"3.5 开始构建项目\"></a>3.5 开始构建项目</h3><img src=\"/2017/11/28/jenkins-java-maven/5.png\">\n<p>查看构建结果</p>\n<img src=\"/2017/11/28/jenkins-java-maven/6.png\">\n<p>然后再服务器相关目录下就能看到构建后的jar包:<br><img src=\"/2017/11/28/jenkins-java-maven/7.png\"></p>\n<h3 id=\"3-6-构建后配置\"><a href=\"#3-6-构建后配置\" class=\"headerlink\" title=\"3.6 构建后配置\"></a>3.6 构建后配置</h3><p>构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。</p>\n<h4 id=\"3-6-1-直接执行jar\"><a href=\"#3-6-1-直接执行jar\" class=\"headerlink\" title=\"3.6.1 直接执行jar\"></a>3.6.1 直接执行jar</h4><p>修改项目配置：<br><img src=\"/2017/11/28/jenkins-java-maven/8.png\"></p>\n<p>添加成功构建后要执行的脚本：<br><img src=\"/2017/11/28/jenkins-java-maven/8_1.png\"></p>\n<blockquote>\n<p>注意脚本写法，如果是后台执行：<br>    <code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code></p>\n</blockquote>\n<h4 id=\"3-6-2-发布jar到远程服务器，并执行\"><a href=\"#3-6-2-发布jar到远程服务器，并执行\" class=\"headerlink\" title=\"3.6.2 发布jar到远程服务器，并执行\"></a>3.6.2 发布jar到远程服务器，并执行</h4><ul>\n<li>下载相关插件：<img src=\"/2017/11/28/jenkins-java-maven/10.png\">\n</li>\n</ul>\n<ul>\n<li><p>在系统设置中添加远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/11.png\">\n</li>\n<li><p>在项目中设置，选定远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/12.png\">\n</li>\n</ul>\n<p><em>注意：</em><br><img src=\"/2017/11/28/jenkins-java-maven/13.png\"></p>\n<ul>\n<li>备份，执行远程服务器上的jar包</li>\n</ul>\n<ol>\n<li>在远程服务器上设置脚本，放在目录：<code>server/bin</code>：</li>\n</ol>\n<blockquote>\n<p>停止应用脚本<code>stop.sh</code>：</p>\n</blockquote>\n<pre><code># 将应用停止\n#stop.sh\n#!/bin/bash\necho &quot;Stopping SpringBoot Application&quot;\npid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk &apos;{print $2}&apos;`\nif [ -n &quot;$pid&quot; ]\nthen\n   kill -9 $pid\nfi\n</code></pre><hr>\n<blockquote>\n<p>备份应用脚本<code>replace.sh</code>:</p>\n</blockquote>\n<pre><code>#replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n#!/bin/bash\n# 先判断文件是否存在，如果存在，则备份\nfile=&quot;/server/java/apps/jenkins-demo.jar&quot;\nif [ -f &quot;$file&quot; ]\nthen\n   mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\nfi\nmv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n</code></pre><hr>\n<blockquote>\n<p>启动应用包脚本<code>start.sh</code>:</p>\n</blockquote>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\njava -jar /server/java/apps/jenkins-demo.jar\n</code></pre><p>   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行<code>nohub java -jar /server/java/apps/jenkins-demo.jar &amp;</code>不起作用，所在要在jenkins上这样配置<code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code><br>   如果是远程服务器，就可以改成：</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\nnohup java -jar /server/java/apps/jenkins-demo.jar &gt; jenkins-demo.out 2&gt;&amp; 1 &amp;\n</code></pre><hr>\n<ol start=\"2\">\n<li>设置远程服务器执行脚本： </li>\n</ol>\n<img src=\"/2017/11/28/jenkins-java-maven/14.png\">   \n<p>如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/15.png\">   \n<h2 id=\"备注：\"><a href=\"#备注：\" class=\"headerlink\" title=\"备注：\"></a>备注：</h2><p>1.替换jar包中的文件</p>\n<p><code>jar -uvf rpds.jar BOOT-INF/classes/db.properties</code></p>\n<p>2.启动jar应用程序shell脚本</p>\n<pre><code>#!/bin/sh\n# chkconfig: 2345 64 36\n## java env \n#################### zhengjianyan #######################\nexport JAVA_HOME=/server/java/jdk\nexport JRE_HOME=$JAVA_HOME/jre\n\nBASE_PATH=/server/java/service/com.xcsqjr.scf.service\nVERSION=1.0.0\n## service name\nAPP_NAME=all\n\nSERVICE_DIR=$BASE_PATH/com.xcsqjr.scf.service.$APP_NAME\nSERVICE_NAME=com.xcsqjr.scf.service.$APP_NAME-$VERSION\n#JAR_NAME=$SERVICE_DIR/$SERVICE_NAME/target\\.jar\nJAR_NAME=$SERVICE_DIR/target/$SERVICE_NAME.jar\nPID=$SERVICE_NAME\\.pid\n\nrm -rf $SERVICE_DIR/target/*.tmp\ncd $BASE_PATH\ncd ..\n\n$JAVA_HOME/bin/jar uvf $SERVICE_DIR/target/$SERVICE_NAME.jar application.properties\n\ncd $SERVICE_DIR\ncase &quot;$1&quot; in\n\n    start)\n        nohup $JRE_HOME/bin/java -Xms128m -Xmx256m -jar $JAR_NAME &gt;/dev/null 2&gt;&amp;1 &amp;\n        echo $! &gt; $SERVICE_DIR/target/$PID\n        echo &quot;=== start $SERVICE_NAME&quot;\n        ;;\n\n    stop)\n        kill `cat $SERVICE_DIR/target/$PID`\n        rm -rf $SERVICE_DIR/target/$PID\n        echo &quot;=== stop $SERVICE_NAME&quot;\n\n        sleep 5\n        P_ID=`ps -ef | grep -w &quot;$SERVICE_NAME&quot; | grep -v &quot;grep&quot; | awk &apos;{print $2}&apos;`\n        if [ &quot;$P_ID&quot; == &quot;&quot; ]; then\n            echo &quot;=== $SERVICE_NAME process not exists or stop success&quot;\n        else\n            echo &quot;=== $SERVICE_NAME process pid is:$P_ID&quot;\n            echo &quot;=== begin kill $SERVICE_NAME process, pid is:$P_ID&quot;\n            kill -9 $P_ID\n        fi\n        ;;\n\n    restart)\n        $0 stop\n        sleep 2\n        $0 start\n        echo &quot;=== restart $SERVICE_NAME&quot;\n        ;;\n\n    *)\n        echo &quot;==== restart =====&quot;\n        ## restart\n        $0 stop\n        sleep 5\n        $0 start\n        ;;\nesac\nexit 0\n</code></pre>"},{"title":"jvm优化-垃圾回收机制","date":"2017-10-20T04:51:08.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1548866","source":"_posts/jvm-gc.md","raw":"---\ntitle: jvm优化-垃圾回收机制\ndate: 2017-10-20 12:51:08\ncategories: jvm\ntags: gc垃圾回收\n---\n\nhttps://my.oschina.net/u/1859679/blog/1548866","slug":"jvm-gc","published":1,"updated":"2019-06-16T14:38:33.405Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqd50067g4va6voqa5w5","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n"},{"title":"jvm优化-监控工具","date":"2017-10-20T04:52:40.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1552290","source":"_posts/jvm-look-tools.md","raw":"---\ntitle: jvm优化-监控工具\ndate: 2017-10-20 12:52:40\ncategories: jvm\ntags: jvm监控工具\n---\n\nhttps://my.oschina.net/u/1859679/blog/1552290","slug":"jvm-look-tools","published":1,"updated":"2019-06-16T14:38:33.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqd6006ag4valfpzal9q","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n"},{"title":"k8s入门","date":"2018-03-13T00:56:45.000Z","_content":"","source":"_posts/k8s-start.md","raw":"---\ntitle: k8s入门\ndate: 2018-03-13 08:56:45\ncategories: Kubernetes\ntags: k8s\n---\n","slug":"k8s-start","published":1,"updated":"2019-06-16T14:38:33.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqd9006eg4vatygda84v","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"centos常用命令收藏","date":"2018-06-11T09:37:52.000Z","_content":"\n本文主要记录常用的命令……  \n\n以备查询使用……\n\n## 查看各种硬件信息\n\nhttps://blog.csdn.net/dream_broken/article/details/52883883\n\n## 日志\n\n    /var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一 \n    /var/log/secure 与安全相关的日志信息 \n    /var/log/maillog 与邮件相关的日志信息 \n    /var/log/cron 与定时任务相关的日志信息 \n    /var/log/spooler 与UUCP和news设备相关的日志信息\n    /var/log/boot.log 守护进程启动和停止相关的日志消息\n    \n## 磁盘和分区\n\n    # mount | column -t  # 查看挂接的分区状态 \n    # fdisk -l   # 查看所有分区 \n    # swapon -s   # 查看所有交换分区 \n    # hdparm -i /dev/hda  # 查看磁盘参数(仅适用于IDE设备) \n    # dmesg | grep IDE  # 查看启动时IDE设备检测状况 \n    \n## 网络\n\n    # ifconfig   # 查看所有网络接口的属性 \n    # iptables -L   # 查看防火墙设置 \n    # route -n   # 查看路由表 \n    # netstat -lntp   # 查看所有监听端口 \n    # netstat -antp   # 查看所有已经建立的连接 \n    # netstat -s   # 查看网络统计信息 \n    \n## 用户\n\n    # w    # 查看活动用户 \n    # id <用户名>   # 查看指定用户信息 \n    # last    # 查看用户登录日志 \n    # cut -d: -f1 /etc/passwd # 查看系统所有用户 \n    # cut -d: -f1 /etc/group # 查看系统所有组\n    # crontab -l   # 查看当前用户的计划任务 \n    \n## 服务\n\n    # chkconfig –list  # 列出所有系统服务 \n    # chkconfig –list | grep on # 列出所有启动的系统服务                 \n\n## 查看系统信息\n\n    # uname -a   # 查看内核/操作系统/CPU信息 \n    # cat /etc/issue \n    # cat /etc/redhat-release # 查看操作系统版本 \n    # cat /proc/cpuinfo  # 查看CPU信息 \n    # hostname   # 查看计算机名 \n    # lspci -tv   # 列出所有PCI设备 \n    # lsusb -tv   # 列出所有USB设备 \n    # lsmod    # 列出加载的内核模块\n    # env    # 查看环境变量 \n\n### 查看端口占用\n\n`netstat -lnp|grep 8000`\n\n## 设置自启动\n\n在生产环境，一些基础应用环境需要系统启动的时候自动启动……\n\n### 服务自启动设置\n\n执行命令`systemctl enable *`即可。\n\n例如设置`docker`服务自启动：  \n`systemctl enable docker.service`\n\n### 脚本自启动\n\n### 参考：\n\n    一、添加开机自启服务\n    \n    在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：\n    systemctl enable jenkins.service #设置jenkins服务为自启动服务\n    sysstemctl start  jenkins.service #启动jenkins服务\n    \n    二、添加开机自启脚本\n    \n    在centos7中增加脚本有两种常用的方法，以脚本autostart.sh为例：\n    #!/bin/bash\n    #description:开机自启脚本\n    /usr/local/tomcat/bin/startup.sh  #启动tomcat\n    \n    方法一\n    \n    1、赋予脚本可执行权限（/opt/script/autostart.sh是你的脚本路径）\n    chmod +x /opt/script/autostart.sh\n    \n    2、打开/etc/rc.d/rc/local文件，在末尾增加如下内容\n    /opt/script/autostart.sh\n    \n    3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\n    chmod +x /etc/rc.d/rc.local\n    \n    方法二\n    \n    1、将脚本移动到/etc/rc.d/init.d目录下\n    mv  /opt/script/autostart.sh /etc/rc.d/init.d\n    \n    2、增加脚本的可执行权限\n    chmod +x  /etc/rc.d/init.d/autostart.sh\n    \n    3、添加脚本到开机自动启动项目中\n    cd /etc/rc.d/init.d\n    chkconfig --add autostart.sh\n    chkconfig autostart.sh on\n    \n## 系统进程管理\n\n### 查看进程信息\n\n#### 1.根据端口，查看进程信息\n\n    # lsof -i:8011  //查看端口，找到进程pid\n    # cd /proc/pid\n    # ll\n    \n    ---------------------------------------------------------\n    \n    [root@izwz9bwlp4pyxy4mnxaycez 1113]# ll\n    total 0\n    dr-xr-xr-x  2 root root 0 10月 31 17:30 attr\n    -rw-r--r--  1 root root 0 11月  5 10:24 autogroup\n    -r--------  1 root root 0 11月  5 10:24 auxv\n    -r--r--r--  1 root root 0 11月  5 10:24 cgroup\n    --w-------  1 root root 0 11月  5 10:24 clear_refs\n    -r--r--r--  1 root root 0 10月  8 21:02 cmdline\n    -rw-r--r--  1 root root 0 11月  5 10:24 comm\n    -rw-r--r--  1 root root 0 11月  5 10:24 coredump_filter\n    -r--r--r--  1 root root 0 11月  5 10:24 cpuset\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 cwd -> /\n    -r--------  1 root root 0 11月  1 15:13 environ\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 exe -> /server/java/jdk/bin/java\n    dr-x------  2 root root 0 10月 31 17:30 fd\n    dr-x------  2 root root 0 11月  1 11:53 fdinfo\n    -rw-r--r--  1 root root 0 11月  5 10:24 gid_map\n    -r--------  1 root root 0 11月  5 10:24 io\n    -r--r--r--  1 root root 0 11月  5 10:24 limits\n    -rw-r--r--  1 root root 0 11月  5 10:24 loginuid\n    dr-x------  2 root root 0 11月  5 10:24 map_files\n    -r--r--r--  1 root root 0 11月  5 10:24 maps\n    -rw-------  1 root root 0 11月  5 10:24 mem\n    -r--r--r--  1 root root 0 11月  5 10:24 mountinfo\n    -r--r--r--  1 root root 0 11月  5 10:24 mounts\n    -r--------  1 root root 0 11月  5 10:24 mountstats\n    dr-xr-xr-x  5 root root 0 11月  5 10:24 net\n    dr-x--x--x  2 root root 0 11月  5 10:24 ns\n    -r--r--r--  1 root root 0 11月  5 10:24 numa_maps\n    -rw-r--r--  1 root root 0 11月  5 10:24 oom_adj\n    -r--r--r--  1 root root 0 11月  5 10:24 oom_score\n    -rw-r--r--  1 root root 0 11月  5 10:24 oom_score_adj\n    -r--r--r--  1 root root 0 11月  5 10:24 pagemap\n    -r--------  1 root root 0 11月  5 10:24 patch_state\n    -r--r--r--  1 root root 0 11月  5 10:24 personality\n    -rw-r--r--  1 root root 0 11月  5 10:24 projid_map\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 root -> /\n    -rw-r--r--  1 root root 0 11月  5 10:24 sched\n    -r--r--r--  1 root root 0 11月  5 10:24 schedstat\n    -r--r--r--  1 root root 0 11月  5 10:24 sessionid\n    -rw-r--r--  1 root root 0 11月  5 10:24 setgroups\n    -r--r--r--  1 root root 0 11月  5 10:24 smaps\n    -r--r--r--  1 root root 0 11月  5 10:24 stack\n    -r--r--r--  1 root root 0 10月  8 21:02 stat\n    -r--r--r--  1 root root 0 11月  5 10:24 statm\n    -r--r--r--  1 root root 0 10月  8 21:02 status\n    -r--r--r--  1 root root 0 11月  5 10:24 syscall\n    dr-xr-xr-x 30 root root 0 11月  5 10:24 task\n    -r--r--r--  1 root root 0 11月  5 10:24 timers\n    -rw-r--r--  1 root root 0 11月  5 10:24 uid_map\n    -r--r--r--  1 root root 0 11月  5 10:24 wchan\n\n#### 2.查看进程\n\n    # ps aux | less  --查看所有运行中的进程\n    # ps -A --查看系统中的每个进程。\n    # ps -u vivek --查看用户vivek运行的进程\n    \n#### 3.动态显示进程\n\n    # top\n按q退出，按h进入帮助\n\n#### 4.树状显示进程\n\n    [root@izwz9bwlp4pyxy4mnxaycez ~]# pstree\n    systemd─┬─aliyun-service\n            ├─atd\n            ├─auditd───{auditd}\n            ├─crond\n            ├─dbus-daemon\n            ├─dhclient\n            ├─irqbalance\n            ├─26*[java───27*[{java}]]\n            ├─java───26*[{java}]\n            ├─2*[java───32*[{java}]]\n            ├─java───23*[{java}]\n            ├─java───21*[{java}]\n            ├─java───61*[{java}]\n            ├─java───247*[{java}]\n            ├─java───57*[{java}]\n            ├─java───49*[{java}]\n            ├─login───bash\n            ├─mysqld_safe───mysqld───128*[{mysqld}]\n            ├─mysqld_safe───mysqld───194*[{mysqld}]\n            ├─10*[nginx───nginx]\n            ├─ntpd\n            ├─polkitd───5*[{polkitd}]\n            ├─redis-server───2*[{redis-server}]\n            ├─rsyslogd───2*[{rsyslogd}]\n            ├─sshd─┬─3*[sshd───bash]\n            │      ├─2*[sshd───bash───2*[tail]]\n            │      ├─sshd───bash───pstree\n            │      └─sshd───sshd\n            ├─systemd-journal\n            ├─systemd-logind\n            ├─systemd-udevd\n            ├─tuned───4*[{tuned}]\n            └─wrapper─┬─java───53*[{java}]\n                      └─{wrapper}\n\n### 将进程快照储存到文件中\n\n输入下列命令：\n    \t\n    # top -b -n1 > /tmp/process.log\n\n你也可以将结果通过邮件发给自己：\n\n    # top -b -n1 | mail -s 'Process snapshot' you@example.com\n    \n## 查看服务器情况\n\n### 1.查看服务器CPU型号  \n\n    grep \"model name\" /proc/cpuinfo | cut -f2 -d:  \n    \n### 2.查看服务器内存容量\n\n    grep MemTotal /proc/meminfo\n    grep MemTotal /proc/meminfo | cut -f2 -d:\n    free -m |grep \"Mem\" | awk '{print $2}' \n    \n### 3.查看服务器的CPU是32位还是64位\n\n    getconf LONG_BIT\n    \n### 4.查看当前Linux的版本\n\n    more /etc/redhat-release cat /etc/redhat-release\n    \n### 5.查看Linux内核版本\n\n    uname -r\n    uname -a\n    \n### 6.查看服务器当前时间\n\n    date\n    \n### 7.查看服务器硬盘和分区\n\n    df -h\n    fdisk -l\n    \n### 8.查看挂载情况\n\n    mount\n    \n### 9.查看目录大小\n\n    du /etc -sh  \n    \n### 10.查看服务器初始安装的软件包\n\n    cat -n /root/install.log\n    more /root/install.log | wc -l\n    \n### 11.查看已经安装的软件包\n\n    rpm -qa\n    rpm -qa | wc -l\n    yum list installed | wc -l\n    \n### 12.查看服务器键盘布局\n\n    cat /etc/sysconfig/keyboard\n    cat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d=\n    \n### 13.查看Selinux状态\n\n    sestatus\n    sestatus | cut -f2 -d:\n    cat /etc/sysconfig/selinux\n    \n### 14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。\n    \n    ifconfig\n    cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR\n    cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2 -d=\n    ifconfig eth0 |grep \"inet addr:\" |awk '{print $2}'|cut -c 6-\n    ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'\n    \n### 15.查看服务器默认网关\n\n    cat /etc/sysconfig/network\n    \n### 16.查看服务器的默认DNS\n\n    cat /etc/resolv.conf\n    \n### 17.查看服务器默认语言\n\n    echo $LANG $LANGUAGE\n    cat /etc/sysconfig/i18n\n    \n### 18.查看服务器所属时区和UTC时间\n\n    cat /etc/sysconfig/clock\n    \n### 19.查看服务器主机名\n\n    hostname\n    cat /etc/sysconfig/network\n    \n### 20.查看文件大小  \n\n    ll -h a.txt    \n    \n## CentOS挂载新硬盘                                        \n参考：http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html \n1.查看当前硬盘使用状况：\n\n    df -h\n2.查看新硬盘\n \n    fdisk -l \n新添加的硬盘的编号为 `/dev/xvdb    /dev/xvde  /dev/vdb`\n\n3.硬盘分区   \n 1)进入fdisk模式     \n    `/sbin/fdisk /dev/vdb`  \n 2)输入n进行分区  \n 3)选择分区类型   \n \n  这里有两个选项：   \n- p: 主分区 linux上主分区最多能有4个    \n- e: 扩展分区 linux上扩展分区只能有1个，扩展分区创建后不能直接使用，还要在扩展分区上创建逻辑分区。     \n\n这里我选择的p。\n\n 4)选择分区个数  \n 可以选择4个分区，这里我只分成1个分区    \n 5)设置柱面，这里选择默认值就可以  \n 6)输入w，写入分区表，进行分区   \n \n4.格式化分区 \n\n将新分区格式化为ext4文件系统     \n1)如果创建的是主分区 \n`mkfs -t ext4  /dev/vdb1 `\n\n5.挂载硬盘  \n1)创建挂载点     \n在根目录下创建sqjr目录   \n`mkdir /server /sqjr `\n2)将/dev/vdb1挂载到/sqjr下    \n `mount /dev/vdb1 /server  /sqjr`\n \n6.设置开机启动自动挂载    \n新创建的分区不能开机自动挂载，每次重启机器都要手动挂载。    \n设置开机自动挂载需要修改/etc/fstab文件    \n`vi /etc/fstab `    \n在文件的最后增加一行  \n`/dev/vdb1 /server ext4 defaults 1 2 `\n\n7.取消挂载 /dev/xvdb1   \n`umount /dev/vdb1`\n\n8.重启    \n`reboot -n `                        \n\n           \n## 清理缓存，释放内存\n\n1.清理yum缓存使用yum clean 命令，yum clean 的参数有headers, packages, metadata, dbcache, plugins, expire-cache, rpmdb, all\n\n    yum clean headers  #清理/var/cache/yum的headers\n    yum clean packages #清理/var/cache/yum下的软件包\n    yum clean metadata\n    ...\n    \n        \n2.Linux释放内存\n\n释放网页缓存(To free pagecache):    \n\n    sync; echo 1 > /proc/sys/vm/drop_caches\n    \n释放目录项和索引(To free dentries and inodes):\n\n    sync; echo 2 > /proc/sys/vm/drop_caches\n    \n释放网页缓存，目录项和索引（To free pagecache, dentries and inodes）:\n\n    sync; echo 3 > /proc/sys/vm/drop_caches \n    \n## 利用curl获取本机的外网ip\n\n    #oray国内地址，返回速度快\n    curl -s http://ddns.oray.com/checkip | awk -F \": \" '{print $2}' | awk -F \"\\<\" '{print $1}'\n    #返回快\n    curl ident.me\n    curl myip.dnsomatic.com\n    #返回较快\n    curl whatismyip.akamai.com\n    curl https://tnx.nl/ip\n    #返回慢，不推荐\n    curl ifconfig.me\n    curl icanhazip.com\n    curl ipecho.net/plain  ","source":"_posts/linux-centos-command.md","raw":"---\ntitle: centos常用命令收藏\ndate: 2018-06-11 17:37:52\ncategories: CentOs\ntags:\n---\n\n本文主要记录常用的命令……  \n\n以备查询使用……\n\n## 查看各种硬件信息\n\nhttps://blog.csdn.net/dream_broken/article/details/52883883\n\n## 日志\n\n    /var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一 \n    /var/log/secure 与安全相关的日志信息 \n    /var/log/maillog 与邮件相关的日志信息 \n    /var/log/cron 与定时任务相关的日志信息 \n    /var/log/spooler 与UUCP和news设备相关的日志信息\n    /var/log/boot.log 守护进程启动和停止相关的日志消息\n    \n## 磁盘和分区\n\n    # mount | column -t  # 查看挂接的分区状态 \n    # fdisk -l   # 查看所有分区 \n    # swapon -s   # 查看所有交换分区 \n    # hdparm -i /dev/hda  # 查看磁盘参数(仅适用于IDE设备) \n    # dmesg | grep IDE  # 查看启动时IDE设备检测状况 \n    \n## 网络\n\n    # ifconfig   # 查看所有网络接口的属性 \n    # iptables -L   # 查看防火墙设置 \n    # route -n   # 查看路由表 \n    # netstat -lntp   # 查看所有监听端口 \n    # netstat -antp   # 查看所有已经建立的连接 \n    # netstat -s   # 查看网络统计信息 \n    \n## 用户\n\n    # w    # 查看活动用户 \n    # id <用户名>   # 查看指定用户信息 \n    # last    # 查看用户登录日志 \n    # cut -d: -f1 /etc/passwd # 查看系统所有用户 \n    # cut -d: -f1 /etc/group # 查看系统所有组\n    # crontab -l   # 查看当前用户的计划任务 \n    \n## 服务\n\n    # chkconfig –list  # 列出所有系统服务 \n    # chkconfig –list | grep on # 列出所有启动的系统服务                 \n\n## 查看系统信息\n\n    # uname -a   # 查看内核/操作系统/CPU信息 \n    # cat /etc/issue \n    # cat /etc/redhat-release # 查看操作系统版本 \n    # cat /proc/cpuinfo  # 查看CPU信息 \n    # hostname   # 查看计算机名 \n    # lspci -tv   # 列出所有PCI设备 \n    # lsusb -tv   # 列出所有USB设备 \n    # lsmod    # 列出加载的内核模块\n    # env    # 查看环境变量 \n\n### 查看端口占用\n\n`netstat -lnp|grep 8000`\n\n## 设置自启动\n\n在生产环境，一些基础应用环境需要系统启动的时候自动启动……\n\n### 服务自启动设置\n\n执行命令`systemctl enable *`即可。\n\n例如设置`docker`服务自启动：  \n`systemctl enable docker.service`\n\n### 脚本自启动\n\n### 参考：\n\n    一、添加开机自启服务\n    \n    在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：\n    systemctl enable jenkins.service #设置jenkins服务为自启动服务\n    sysstemctl start  jenkins.service #启动jenkins服务\n    \n    二、添加开机自启脚本\n    \n    在centos7中增加脚本有两种常用的方法，以脚本autostart.sh为例：\n    #!/bin/bash\n    #description:开机自启脚本\n    /usr/local/tomcat/bin/startup.sh  #启动tomcat\n    \n    方法一\n    \n    1、赋予脚本可执行权限（/opt/script/autostart.sh是你的脚本路径）\n    chmod +x /opt/script/autostart.sh\n    \n    2、打开/etc/rc.d/rc/local文件，在末尾增加如下内容\n    /opt/script/autostart.sh\n    \n    3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\n    chmod +x /etc/rc.d/rc.local\n    \n    方法二\n    \n    1、将脚本移动到/etc/rc.d/init.d目录下\n    mv  /opt/script/autostart.sh /etc/rc.d/init.d\n    \n    2、增加脚本的可执行权限\n    chmod +x  /etc/rc.d/init.d/autostart.sh\n    \n    3、添加脚本到开机自动启动项目中\n    cd /etc/rc.d/init.d\n    chkconfig --add autostart.sh\n    chkconfig autostart.sh on\n    \n## 系统进程管理\n\n### 查看进程信息\n\n#### 1.根据端口，查看进程信息\n\n    # lsof -i:8011  //查看端口，找到进程pid\n    # cd /proc/pid\n    # ll\n    \n    ---------------------------------------------------------\n    \n    [root@izwz9bwlp4pyxy4mnxaycez 1113]# ll\n    total 0\n    dr-xr-xr-x  2 root root 0 10月 31 17:30 attr\n    -rw-r--r--  1 root root 0 11月  5 10:24 autogroup\n    -r--------  1 root root 0 11月  5 10:24 auxv\n    -r--r--r--  1 root root 0 11月  5 10:24 cgroup\n    --w-------  1 root root 0 11月  5 10:24 clear_refs\n    -r--r--r--  1 root root 0 10月  8 21:02 cmdline\n    -rw-r--r--  1 root root 0 11月  5 10:24 comm\n    -rw-r--r--  1 root root 0 11月  5 10:24 coredump_filter\n    -r--r--r--  1 root root 0 11月  5 10:24 cpuset\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 cwd -> /\n    -r--------  1 root root 0 11月  1 15:13 environ\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 exe -> /server/java/jdk/bin/java\n    dr-x------  2 root root 0 10月 31 17:30 fd\n    dr-x------  2 root root 0 11月  1 11:53 fdinfo\n    -rw-r--r--  1 root root 0 11月  5 10:24 gid_map\n    -r--------  1 root root 0 11月  5 10:24 io\n    -r--r--r--  1 root root 0 11月  5 10:24 limits\n    -rw-r--r--  1 root root 0 11月  5 10:24 loginuid\n    dr-x------  2 root root 0 11月  5 10:24 map_files\n    -r--r--r--  1 root root 0 11月  5 10:24 maps\n    -rw-------  1 root root 0 11月  5 10:24 mem\n    -r--r--r--  1 root root 0 11月  5 10:24 mountinfo\n    -r--r--r--  1 root root 0 11月  5 10:24 mounts\n    -r--------  1 root root 0 11月  5 10:24 mountstats\n    dr-xr-xr-x  5 root root 0 11月  5 10:24 net\n    dr-x--x--x  2 root root 0 11月  5 10:24 ns\n    -r--r--r--  1 root root 0 11月  5 10:24 numa_maps\n    -rw-r--r--  1 root root 0 11月  5 10:24 oom_adj\n    -r--r--r--  1 root root 0 11月  5 10:24 oom_score\n    -rw-r--r--  1 root root 0 11月  5 10:24 oom_score_adj\n    -r--r--r--  1 root root 0 11月  5 10:24 pagemap\n    -r--------  1 root root 0 11月  5 10:24 patch_state\n    -r--r--r--  1 root root 0 11月  5 10:24 personality\n    -rw-r--r--  1 root root 0 11月  5 10:24 projid_map\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 root -> /\n    -rw-r--r--  1 root root 0 11月  5 10:24 sched\n    -r--r--r--  1 root root 0 11月  5 10:24 schedstat\n    -r--r--r--  1 root root 0 11月  5 10:24 sessionid\n    -rw-r--r--  1 root root 0 11月  5 10:24 setgroups\n    -r--r--r--  1 root root 0 11月  5 10:24 smaps\n    -r--r--r--  1 root root 0 11月  5 10:24 stack\n    -r--r--r--  1 root root 0 10月  8 21:02 stat\n    -r--r--r--  1 root root 0 11月  5 10:24 statm\n    -r--r--r--  1 root root 0 10月  8 21:02 status\n    -r--r--r--  1 root root 0 11月  5 10:24 syscall\n    dr-xr-xr-x 30 root root 0 11月  5 10:24 task\n    -r--r--r--  1 root root 0 11月  5 10:24 timers\n    -rw-r--r--  1 root root 0 11月  5 10:24 uid_map\n    -r--r--r--  1 root root 0 11月  5 10:24 wchan\n\n#### 2.查看进程\n\n    # ps aux | less  --查看所有运行中的进程\n    # ps -A --查看系统中的每个进程。\n    # ps -u vivek --查看用户vivek运行的进程\n    \n#### 3.动态显示进程\n\n    # top\n按q退出，按h进入帮助\n\n#### 4.树状显示进程\n\n    [root@izwz9bwlp4pyxy4mnxaycez ~]# pstree\n    systemd─┬─aliyun-service\n            ├─atd\n            ├─auditd───{auditd}\n            ├─crond\n            ├─dbus-daemon\n            ├─dhclient\n            ├─irqbalance\n            ├─26*[java───27*[{java}]]\n            ├─java───26*[{java}]\n            ├─2*[java───32*[{java}]]\n            ├─java───23*[{java}]\n            ├─java───21*[{java}]\n            ├─java───61*[{java}]\n            ├─java───247*[{java}]\n            ├─java───57*[{java}]\n            ├─java───49*[{java}]\n            ├─login───bash\n            ├─mysqld_safe───mysqld───128*[{mysqld}]\n            ├─mysqld_safe───mysqld───194*[{mysqld}]\n            ├─10*[nginx───nginx]\n            ├─ntpd\n            ├─polkitd───5*[{polkitd}]\n            ├─redis-server───2*[{redis-server}]\n            ├─rsyslogd───2*[{rsyslogd}]\n            ├─sshd─┬─3*[sshd───bash]\n            │      ├─2*[sshd───bash───2*[tail]]\n            │      ├─sshd───bash───pstree\n            │      └─sshd───sshd\n            ├─systemd-journal\n            ├─systemd-logind\n            ├─systemd-udevd\n            ├─tuned───4*[{tuned}]\n            └─wrapper─┬─java───53*[{java}]\n                      └─{wrapper}\n\n### 将进程快照储存到文件中\n\n输入下列命令：\n    \t\n    # top -b -n1 > /tmp/process.log\n\n你也可以将结果通过邮件发给自己：\n\n    # top -b -n1 | mail -s 'Process snapshot' you@example.com\n    \n## 查看服务器情况\n\n### 1.查看服务器CPU型号  \n\n    grep \"model name\" /proc/cpuinfo | cut -f2 -d:  \n    \n### 2.查看服务器内存容量\n\n    grep MemTotal /proc/meminfo\n    grep MemTotal /proc/meminfo | cut -f2 -d:\n    free -m |grep \"Mem\" | awk '{print $2}' \n    \n### 3.查看服务器的CPU是32位还是64位\n\n    getconf LONG_BIT\n    \n### 4.查看当前Linux的版本\n\n    more /etc/redhat-release cat /etc/redhat-release\n    \n### 5.查看Linux内核版本\n\n    uname -r\n    uname -a\n    \n### 6.查看服务器当前时间\n\n    date\n    \n### 7.查看服务器硬盘和分区\n\n    df -h\n    fdisk -l\n    \n### 8.查看挂载情况\n\n    mount\n    \n### 9.查看目录大小\n\n    du /etc -sh  \n    \n### 10.查看服务器初始安装的软件包\n\n    cat -n /root/install.log\n    more /root/install.log | wc -l\n    \n### 11.查看已经安装的软件包\n\n    rpm -qa\n    rpm -qa | wc -l\n    yum list installed | wc -l\n    \n### 12.查看服务器键盘布局\n\n    cat /etc/sysconfig/keyboard\n    cat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d=\n    \n### 13.查看Selinux状态\n\n    sestatus\n    sestatus | cut -f2 -d:\n    cat /etc/sysconfig/selinux\n    \n### 14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。\n    \n    ifconfig\n    cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR\n    cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2 -d=\n    ifconfig eth0 |grep \"inet addr:\" |awk '{print $2}'|cut -c 6-\n    ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'\n    \n### 15.查看服务器默认网关\n\n    cat /etc/sysconfig/network\n    \n### 16.查看服务器的默认DNS\n\n    cat /etc/resolv.conf\n    \n### 17.查看服务器默认语言\n\n    echo $LANG $LANGUAGE\n    cat /etc/sysconfig/i18n\n    \n### 18.查看服务器所属时区和UTC时间\n\n    cat /etc/sysconfig/clock\n    \n### 19.查看服务器主机名\n\n    hostname\n    cat /etc/sysconfig/network\n    \n### 20.查看文件大小  \n\n    ll -h a.txt    \n    \n## CentOS挂载新硬盘                                        \n参考：http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html \n1.查看当前硬盘使用状况：\n\n    df -h\n2.查看新硬盘\n \n    fdisk -l \n新添加的硬盘的编号为 `/dev/xvdb    /dev/xvde  /dev/vdb`\n\n3.硬盘分区   \n 1)进入fdisk模式     \n    `/sbin/fdisk /dev/vdb`  \n 2)输入n进行分区  \n 3)选择分区类型   \n \n  这里有两个选项：   \n- p: 主分区 linux上主分区最多能有4个    \n- e: 扩展分区 linux上扩展分区只能有1个，扩展分区创建后不能直接使用，还要在扩展分区上创建逻辑分区。     \n\n这里我选择的p。\n\n 4)选择分区个数  \n 可以选择4个分区，这里我只分成1个分区    \n 5)设置柱面，这里选择默认值就可以  \n 6)输入w，写入分区表，进行分区   \n \n4.格式化分区 \n\n将新分区格式化为ext4文件系统     \n1)如果创建的是主分区 \n`mkfs -t ext4  /dev/vdb1 `\n\n5.挂载硬盘  \n1)创建挂载点     \n在根目录下创建sqjr目录   \n`mkdir /server /sqjr `\n2)将/dev/vdb1挂载到/sqjr下    \n `mount /dev/vdb1 /server  /sqjr`\n \n6.设置开机启动自动挂载    \n新创建的分区不能开机自动挂载，每次重启机器都要手动挂载。    \n设置开机自动挂载需要修改/etc/fstab文件    \n`vi /etc/fstab `    \n在文件的最后增加一行  \n`/dev/vdb1 /server ext4 defaults 1 2 `\n\n7.取消挂载 /dev/xvdb1   \n`umount /dev/vdb1`\n\n8.重启    \n`reboot -n `                        \n\n           \n## 清理缓存，释放内存\n\n1.清理yum缓存使用yum clean 命令，yum clean 的参数有headers, packages, metadata, dbcache, plugins, expire-cache, rpmdb, all\n\n    yum clean headers  #清理/var/cache/yum的headers\n    yum clean packages #清理/var/cache/yum下的软件包\n    yum clean metadata\n    ...\n    \n        \n2.Linux释放内存\n\n释放网页缓存(To free pagecache):    \n\n    sync; echo 1 > /proc/sys/vm/drop_caches\n    \n释放目录项和索引(To free dentries and inodes):\n\n    sync; echo 2 > /proc/sys/vm/drop_caches\n    \n释放网页缓存，目录项和索引（To free pagecache, dentries and inodes）:\n\n    sync; echo 3 > /proc/sys/vm/drop_caches \n    \n## 利用curl获取本机的外网ip\n\n    #oray国内地址，返回速度快\n    curl -s http://ddns.oray.com/checkip | awk -F \": \" '{print $2}' | awk -F \"\\<\" '{print $1}'\n    #返回快\n    curl ident.me\n    curl myip.dnsomatic.com\n    #返回较快\n    curl whatismyip.akamai.com\n    curl https://tnx.nl/ip\n    #返回慢，不推荐\n    curl ifconfig.me\n    curl icanhazip.com\n    curl ipecho.net/plain  ","slug":"linux-centos-command","published":1,"updated":"2019-09-22T01:43:57.581Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqda006hg4varkqvsaue","content":"<p>本文主要记录常用的命令……  </p>\n<p>以备查询使用……</p>\n<h2 id=\"查看各种硬件信息\"><a href=\"#查看各种硬件信息\" class=\"headerlink\" title=\"查看各种硬件信息\"></a>查看各种硬件信息</h2><p><a href=\"https://blog.csdn.net/dream_broken/article/details/52883883\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/dream_broken/article/details/52883883</a></p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><pre><code>/var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一 \n/var/log/secure 与安全相关的日志信息 \n/var/log/maillog 与邮件相关的日志信息 \n/var/log/cron 与定时任务相关的日志信息 \n/var/log/spooler 与UUCP和news设备相关的日志信息\n/var/log/boot.log 守护进程启动和停止相关的日志消息\n</code></pre><h2 id=\"磁盘和分区\"><a href=\"#磁盘和分区\" class=\"headerlink\" title=\"磁盘和分区\"></a>磁盘和分区</h2><pre><code># mount | column -t  # 查看挂接的分区状态 \n# fdisk -l   # 查看所有分区 \n# swapon -s   # 查看所有交换分区 \n# hdparm -i /dev/hda  # 查看磁盘参数(仅适用于IDE设备) \n# dmesg | grep IDE  # 查看启动时IDE设备检测状况 \n</code></pre><h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><pre><code># ifconfig   # 查看所有网络接口的属性 \n# iptables -L   # 查看防火墙设置 \n# route -n   # 查看路由表 \n# netstat -lntp   # 查看所有监听端口 \n# netstat -antp   # 查看所有已经建立的连接 \n# netstat -s   # 查看网络统计信息 \n</code></pre><h2 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h2><pre><code># w    # 查看活动用户 \n# id &lt;用户名&gt;   # 查看指定用户信息 \n# last    # 查看用户登录日志 \n# cut -d: -f1 /etc/passwd # 查看系统所有用户 \n# cut -d: -f1 /etc/group # 查看系统所有组\n# crontab -l   # 查看当前用户的计划任务 \n</code></pre><h2 id=\"服务\"><a href=\"#服务\" class=\"headerlink\" title=\"服务\"></a>服务</h2><pre><code># chkconfig –list  # 列出所有系统服务 \n# chkconfig –list | grep on # 列出所有启动的系统服务                 \n</code></pre><h2 id=\"查看系统信息\"><a href=\"#查看系统信息\" class=\"headerlink\" title=\"查看系统信息\"></a>查看系统信息</h2><pre><code># uname -a   # 查看内核/操作系统/CPU信息 \n# cat /etc/issue \n# cat /etc/redhat-release # 查看操作系统版本 \n# cat /proc/cpuinfo  # 查看CPU信息 \n# hostname   # 查看计算机名 \n# lspci -tv   # 列出所有PCI设备 \n# lsusb -tv   # 列出所有USB设备 \n# lsmod    # 列出加载的内核模块\n# env    # 查看环境变量 \n</code></pre><h3 id=\"查看端口占用\"><a href=\"#查看端口占用\" class=\"headerlink\" title=\"查看端口占用\"></a>查看端口占用</h3><p><code>netstat -lnp|grep 8000</code></p>\n<h2 id=\"设置自启动\"><a href=\"#设置自启动\" class=\"headerlink\" title=\"设置自启动\"></a>设置自启动</h2><p>在生产环境，一些基础应用环境需要系统启动的时候自动启动……</p>\n<h3 id=\"服务自启动设置\"><a href=\"#服务自启动设置\" class=\"headerlink\" title=\"服务自启动设置\"></a>服务自启动设置</h3><p>执行命令<code>systemctl enable *</code>即可。</p>\n<p>例如设置<code>docker</code>服务自启动：<br><code>systemctl enable docker.service</code></p>\n<h3 id=\"脚本自启动\"><a href=\"#脚本自启动\" class=\"headerlink\" title=\"脚本自启动\"></a>脚本自启动</h3><h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><pre><code>一、添加开机自启服务\n\n在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：\nsystemctl enable jenkins.service #设置jenkins服务为自启动服务\nsysstemctl start  jenkins.service #启动jenkins服务\n\n二、添加开机自启脚本\n\n在centos7中增加脚本有两种常用的方法，以脚本autostart.sh为例：\n#!/bin/bash\n#description:开机自启脚本\n/usr/local/tomcat/bin/startup.sh  #启动tomcat\n\n方法一\n\n1、赋予脚本可执行权限（/opt/script/autostart.sh是你的脚本路径）\nchmod +x /opt/script/autostart.sh\n\n2、打开/etc/rc.d/rc/local文件，在末尾增加如下内容\n/opt/script/autostart.sh\n\n3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\nchmod +x /etc/rc.d/rc.local\n\n方法二\n\n1、将脚本移动到/etc/rc.d/init.d目录下\nmv  /opt/script/autostart.sh /etc/rc.d/init.d\n\n2、增加脚本的可执行权限\nchmod +x  /etc/rc.d/init.d/autostart.sh\n\n3、添加脚本到开机自动启动项目中\ncd /etc/rc.d/init.d\nchkconfig --add autostart.sh\nchkconfig autostart.sh on\n</code></pre><h2 id=\"系统进程管理\"><a href=\"#系统进程管理\" class=\"headerlink\" title=\"系统进程管理\"></a>系统进程管理</h2><h3 id=\"查看进程信息\"><a href=\"#查看进程信息\" class=\"headerlink\" title=\"查看进程信息\"></a>查看进程信息</h3><h4 id=\"1-根据端口，查看进程信息\"><a href=\"#1-根据端口，查看进程信息\" class=\"headerlink\" title=\"1.根据端口，查看进程信息\"></a>1.根据端口，查看进程信息</h4><pre><code># lsof -i:8011  //查看端口，找到进程pid\n# cd /proc/pid\n# ll\n\n---------------------------------------------------------\n\n[root@izwz9bwlp4pyxy4mnxaycez 1113]# ll\ntotal 0\ndr-xr-xr-x  2 root root 0 10月 31 17:30 attr\n-rw-r--r--  1 root root 0 11月  5 10:24 autogroup\n-r--------  1 root root 0 11月  5 10:24 auxv\n-r--r--r--  1 root root 0 11月  5 10:24 cgroup\n--w-------  1 root root 0 11月  5 10:24 clear_refs\n-r--r--r--  1 root root 0 10月  8 21:02 cmdline\n-rw-r--r--  1 root root 0 11月  5 10:24 comm\n-rw-r--r--  1 root root 0 11月  5 10:24 coredump_filter\n-r--r--r--  1 root root 0 11月  5 10:24 cpuset\nlrwxrwxrwx  1 root root 0 11月  5 10:24 cwd -&gt; /\n-r--------  1 root root 0 11月  1 15:13 environ\nlrwxrwxrwx  1 root root 0 11月  5 10:24 exe -&gt; /server/java/jdk/bin/java\ndr-x------  2 root root 0 10月 31 17:30 fd\ndr-x------  2 root root 0 11月  1 11:53 fdinfo\n-rw-r--r--  1 root root 0 11月  5 10:24 gid_map\n-r--------  1 root root 0 11月  5 10:24 io\n-r--r--r--  1 root root 0 11月  5 10:24 limits\n-rw-r--r--  1 root root 0 11月  5 10:24 loginuid\ndr-x------  2 root root 0 11月  5 10:24 map_files\n-r--r--r--  1 root root 0 11月  5 10:24 maps\n-rw-------  1 root root 0 11月  5 10:24 mem\n-r--r--r--  1 root root 0 11月  5 10:24 mountinfo\n-r--r--r--  1 root root 0 11月  5 10:24 mounts\n-r--------  1 root root 0 11月  5 10:24 mountstats\ndr-xr-xr-x  5 root root 0 11月  5 10:24 net\ndr-x--x--x  2 root root 0 11月  5 10:24 ns\n-r--r--r--  1 root root 0 11月  5 10:24 numa_maps\n-rw-r--r--  1 root root 0 11月  5 10:24 oom_adj\n-r--r--r--  1 root root 0 11月  5 10:24 oom_score\n-rw-r--r--  1 root root 0 11月  5 10:24 oom_score_adj\n-r--r--r--  1 root root 0 11月  5 10:24 pagemap\n-r--------  1 root root 0 11月  5 10:24 patch_state\n-r--r--r--  1 root root 0 11月  5 10:24 personality\n-rw-r--r--  1 root root 0 11月  5 10:24 projid_map\nlrwxrwxrwx  1 root root 0 11月  5 10:24 root -&gt; /\n-rw-r--r--  1 root root 0 11月  5 10:24 sched\n-r--r--r--  1 root root 0 11月  5 10:24 schedstat\n-r--r--r--  1 root root 0 11月  5 10:24 sessionid\n-rw-r--r--  1 root root 0 11月  5 10:24 setgroups\n-r--r--r--  1 root root 0 11月  5 10:24 smaps\n-r--r--r--  1 root root 0 11月  5 10:24 stack\n-r--r--r--  1 root root 0 10月  8 21:02 stat\n-r--r--r--  1 root root 0 11月  5 10:24 statm\n-r--r--r--  1 root root 0 10月  8 21:02 status\n-r--r--r--  1 root root 0 11月  5 10:24 syscall\ndr-xr-xr-x 30 root root 0 11月  5 10:24 task\n-r--r--r--  1 root root 0 11月  5 10:24 timers\n-rw-r--r--  1 root root 0 11月  5 10:24 uid_map\n-r--r--r--  1 root root 0 11月  5 10:24 wchan\n</code></pre><h4 id=\"2-查看进程\"><a href=\"#2-查看进程\" class=\"headerlink\" title=\"2.查看进程\"></a>2.查看进程</h4><pre><code># ps aux | less  --查看所有运行中的进程\n# ps -A --查看系统中的每个进程。\n# ps -u vivek --查看用户vivek运行的进程\n</code></pre><h4 id=\"3-动态显示进程\"><a href=\"#3-动态显示进程\" class=\"headerlink\" title=\"3.动态显示进程\"></a>3.动态显示进程</h4><pre><code># top\n</code></pre><p>按q退出，按h进入帮助</p>\n<h4 id=\"4-树状显示进程\"><a href=\"#4-树状显示进程\" class=\"headerlink\" title=\"4.树状显示进程\"></a>4.树状显示进程</h4><pre><code>[root@izwz9bwlp4pyxy4mnxaycez ~]# pstree\nsystemd─┬─aliyun-service\n        ├─atd\n        ├─auditd───{auditd}\n        ├─crond\n        ├─dbus-daemon\n        ├─dhclient\n        ├─irqbalance\n        ├─26*[java───27*[{java}]]\n        ├─java───26*[{java}]\n        ├─2*[java───32*[{java}]]\n        ├─java───23*[{java}]\n        ├─java───21*[{java}]\n        ├─java───61*[{java}]\n        ├─java───247*[{java}]\n        ├─java───57*[{java}]\n        ├─java───49*[{java}]\n        ├─login───bash\n        ├─mysqld_safe───mysqld───128*[{mysqld}]\n        ├─mysqld_safe───mysqld───194*[{mysqld}]\n        ├─10*[nginx───nginx]\n        ├─ntpd\n        ├─polkitd───5*[{polkitd}]\n        ├─redis-server───2*[{redis-server}]\n        ├─rsyslogd───2*[{rsyslogd}]\n        ├─sshd─┬─3*[sshd───bash]\n        │      ├─2*[sshd───bash───2*[tail]]\n        │      ├─sshd───bash───pstree\n        │      └─sshd───sshd\n        ├─systemd-journal\n        ├─systemd-logind\n        ├─systemd-udevd\n        ├─tuned───4*[{tuned}]\n        └─wrapper─┬─java───53*[{java}]\n                  └─{wrapper}\n</code></pre><h3 id=\"将进程快照储存到文件中\"><a href=\"#将进程快照储存到文件中\" class=\"headerlink\" title=\"将进程快照储存到文件中\"></a>将进程快照储存到文件中</h3><p>输入下列命令：</p>\n<pre><code># top -b -n1 &gt; /tmp/process.log\n</code></pre><p>你也可以将结果通过邮件发给自己：</p>\n<pre><code># top -b -n1 | mail -s &apos;Process snapshot&apos; you@example.com\n</code></pre><h2 id=\"查看服务器情况\"><a href=\"#查看服务器情况\" class=\"headerlink\" title=\"查看服务器情况\"></a>查看服务器情况</h2><h3 id=\"1-查看服务器CPU型号\"><a href=\"#1-查看服务器CPU型号\" class=\"headerlink\" title=\"1.查看服务器CPU型号\"></a>1.查看服务器CPU型号</h3><pre><code>grep &quot;model name&quot; /proc/cpuinfo | cut -f2 -d:  \n</code></pre><h3 id=\"2-查看服务器内存容量\"><a href=\"#2-查看服务器内存容量\" class=\"headerlink\" title=\"2.查看服务器内存容量\"></a>2.查看服务器内存容量</h3><pre><code>grep MemTotal /proc/meminfo\ngrep MemTotal /proc/meminfo | cut -f2 -d:\nfree -m |grep &quot;Mem&quot; | awk &apos;{print $2}&apos; \n</code></pre><h3 id=\"3-查看服务器的CPU是32位还是64位\"><a href=\"#3-查看服务器的CPU是32位还是64位\" class=\"headerlink\" title=\"3.查看服务器的CPU是32位还是64位\"></a>3.查看服务器的CPU是32位还是64位</h3><pre><code>getconf LONG_BIT\n</code></pre><h3 id=\"4-查看当前Linux的版本\"><a href=\"#4-查看当前Linux的版本\" class=\"headerlink\" title=\"4.查看当前Linux的版本\"></a>4.查看当前Linux的版本</h3><pre><code>more /etc/redhat-release cat /etc/redhat-release\n</code></pre><h3 id=\"5-查看Linux内核版本\"><a href=\"#5-查看Linux内核版本\" class=\"headerlink\" title=\"5.查看Linux内核版本\"></a>5.查看Linux内核版本</h3><pre><code>uname -r\nuname -a\n</code></pre><h3 id=\"6-查看服务器当前时间\"><a href=\"#6-查看服务器当前时间\" class=\"headerlink\" title=\"6.查看服务器当前时间\"></a>6.查看服务器当前时间</h3><pre><code>date\n</code></pre><h3 id=\"7-查看服务器硬盘和分区\"><a href=\"#7-查看服务器硬盘和分区\" class=\"headerlink\" title=\"7.查看服务器硬盘和分区\"></a>7.查看服务器硬盘和分区</h3><pre><code>df -h\nfdisk -l\n</code></pre><h3 id=\"8-查看挂载情况\"><a href=\"#8-查看挂载情况\" class=\"headerlink\" title=\"8.查看挂载情况\"></a>8.查看挂载情况</h3><pre><code>mount\n</code></pre><h3 id=\"9-查看目录大小\"><a href=\"#9-查看目录大小\" class=\"headerlink\" title=\"9.查看目录大小\"></a>9.查看目录大小</h3><pre><code>du /etc -sh  \n</code></pre><h3 id=\"10-查看服务器初始安装的软件包\"><a href=\"#10-查看服务器初始安装的软件包\" class=\"headerlink\" title=\"10.查看服务器初始安装的软件包\"></a>10.查看服务器初始安装的软件包</h3><pre><code>cat -n /root/install.log\nmore /root/install.log | wc -l\n</code></pre><h3 id=\"11-查看已经安装的软件包\"><a href=\"#11-查看已经安装的软件包\" class=\"headerlink\" title=\"11.查看已经安装的软件包\"></a>11.查看已经安装的软件包</h3><pre><code>rpm -qa\nrpm -qa | wc -l\nyum list installed | wc -l\n</code></pre><h3 id=\"12-查看服务器键盘布局\"><a href=\"#12-查看服务器键盘布局\" class=\"headerlink\" title=\"12.查看服务器键盘布局\"></a>12.查看服务器键盘布局</h3><pre><code>cat /etc/sysconfig/keyboard\ncat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d=\n</code></pre><h3 id=\"13-查看Selinux状态\"><a href=\"#13-查看Selinux状态\" class=\"headerlink\" title=\"13.查看Selinux状态\"></a>13.查看Selinux状态</h3><pre><code>sestatus\nsestatus | cut -f2 -d:\ncat /etc/sysconfig/selinux\n</code></pre><h3 id=\"14-查看服务器网卡的ip，Mac地址-在ifcfg-eth0-文件里你可以看到mac，网关等信息。\"><a href=\"#14-查看服务器网卡的ip，Mac地址-在ifcfg-eth0-文件里你可以看到mac，网关等信息。\" class=\"headerlink\" title=\"14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。\"></a>14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。</h3><pre><code>ifconfig\ncat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR\ncat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2 -d=\nifconfig eth0 |grep &quot;inet addr:&quot; |awk &apos;{print $2}&apos;|cut -c 6-\nifconfig | grep &apos;inet addr:&apos;| grep -v &apos;127.0.0.1&apos; | cut -d: -f2 | awk &apos;{ print $1}&apos;\n</code></pre><h3 id=\"15-查看服务器默认网关\"><a href=\"#15-查看服务器默认网关\" class=\"headerlink\" title=\"15.查看服务器默认网关\"></a>15.查看服务器默认网关</h3><pre><code>cat /etc/sysconfig/network\n</code></pre><h3 id=\"16-查看服务器的默认DNS\"><a href=\"#16-查看服务器的默认DNS\" class=\"headerlink\" title=\"16.查看服务器的默认DNS\"></a>16.查看服务器的默认DNS</h3><pre><code>cat /etc/resolv.conf\n</code></pre><h3 id=\"17-查看服务器默认语言\"><a href=\"#17-查看服务器默认语言\" class=\"headerlink\" title=\"17.查看服务器默认语言\"></a>17.查看服务器默认语言</h3><pre><code>echo $LANG $LANGUAGE\ncat /etc/sysconfig/i18n\n</code></pre><h3 id=\"18-查看服务器所属时区和UTC时间\"><a href=\"#18-查看服务器所属时区和UTC时间\" class=\"headerlink\" title=\"18.查看服务器所属时区和UTC时间\"></a>18.查看服务器所属时区和UTC时间</h3><pre><code>cat /etc/sysconfig/clock\n</code></pre><h3 id=\"19-查看服务器主机名\"><a href=\"#19-查看服务器主机名\" class=\"headerlink\" title=\"19.查看服务器主机名\"></a>19.查看服务器主机名</h3><pre><code>hostname\ncat /etc/sysconfig/network\n</code></pre><h3 id=\"20-查看文件大小\"><a href=\"#20-查看文件大小\" class=\"headerlink\" title=\"20.查看文件大小\"></a>20.查看文件大小</h3><pre><code>ll -h a.txt    \n</code></pre><h2 id=\"CentOS挂载新硬盘\"><a href=\"#CentOS挂载新硬盘\" class=\"headerlink\" title=\"CentOS挂载新硬盘\"></a>CentOS挂载新硬盘</h2><p>参考：<a href=\"http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html</a><br>1.查看当前硬盘使用状况：</p>\n<pre><code>df -h\n</code></pre><p>2.查看新硬盘</p>\n<pre><code>fdisk -l \n</code></pre><p>新添加的硬盘的编号为 <code>/dev/xvdb    /dev/xvde  /dev/vdb</code></p>\n<p>3.硬盘分区<br> 1)进入fdisk模式<br>    <code>/sbin/fdisk /dev/vdb</code><br> 2)输入n进行分区<br> 3)选择分区类型   </p>\n<p>  这里有两个选项：   </p>\n<ul>\n<li>p: 主分区 linux上主分区最多能有4个    </li>\n<li>e: 扩展分区 linux上扩展分区只能有1个，扩展分区创建后不能直接使用，还要在扩展分区上创建逻辑分区。     </li>\n</ul>\n<p>这里我选择的p。</p>\n<p> 4)选择分区个数<br> 可以选择4个分区，这里我只分成1个分区<br> 5)设置柱面，这里选择默认值就可以<br> 6)输入w，写入分区表，进行分区   </p>\n<p>4.格式化分区 </p>\n<p>将新分区格式化为ext4文件系统<br>1)如果创建的是主分区<br><code>mkfs -t ext4  /dev/vdb1</code></p>\n<p>5.挂载硬盘<br>1)创建挂载点<br>在根目录下创建sqjr目录<br><code>mkdir /server /sqjr</code><br>2)将/dev/vdb1挂载到/sqjr下<br> <code>mount /dev/vdb1 /server  /sqjr</code></p>\n<p>6.设置开机启动自动挂载<br>新创建的分区不能开机自动挂载，每次重启机器都要手动挂载。<br>设置开机自动挂载需要修改/etc/fstab文件<br><code>vi /etc/fstab</code><br>在文件的最后增加一行<br><code>/dev/vdb1 /server ext4 defaults 1 2</code></p>\n<p>7.取消挂载 /dev/xvdb1<br><code>umount /dev/vdb1</code></p>\n<p>8.重启<br><code>reboot -n</code>                        </p>\n<h2 id=\"清理缓存，释放内存\"><a href=\"#清理缓存，释放内存\" class=\"headerlink\" title=\"清理缓存，释放内存\"></a>清理缓存，释放内存</h2><p>1.清理yum缓存使用yum clean 命令，yum clean 的参数有headers, packages, metadata, dbcache, plugins, expire-cache, rpmdb, all</p>\n<pre><code>yum clean headers  #清理/var/cache/yum的headers\nyum clean packages #清理/var/cache/yum下的软件包\nyum clean metadata\n...\n</code></pre><p>2.Linux释放内存</p>\n<p>释放网页缓存(To free pagecache):    </p>\n<pre><code>sync; echo 1 &gt; /proc/sys/vm/drop_caches\n</code></pre><p>释放目录项和索引(To free dentries and inodes):</p>\n<pre><code>sync; echo 2 &gt; /proc/sys/vm/drop_caches\n</code></pre><p>释放网页缓存，目录项和索引（To free pagecache, dentries and inodes）:</p>\n<pre><code>sync; echo 3 &gt; /proc/sys/vm/drop_caches \n</code></pre><h2 id=\"利用curl获取本机的外网ip\"><a href=\"#利用curl获取本机的外网ip\" class=\"headerlink\" title=\"利用curl获取本机的外网ip\"></a>利用curl获取本机的外网ip</h2><pre><code>#oray国内地址，返回速度快\ncurl -s http://ddns.oray.com/checkip | awk -F &quot;: &quot; &apos;{print $2}&apos; | awk -F &quot;\\&lt;&quot; &apos;{print $1}&apos;\n#返回快\ncurl ident.me\ncurl myip.dnsomatic.com\n#返回较快\ncurl whatismyip.akamai.com\ncurl https://tnx.nl/ip\n#返回慢，不推荐\ncurl ifconfig.me\ncurl icanhazip.com\ncurl ipecho.net/plain  \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文主要记录常用的命令……  </p>\n<p>以备查询使用……</p>\n<h2 id=\"查看各种硬件信息\"><a href=\"#查看各种硬件信息\" class=\"headerlink\" title=\"查看各种硬件信息\"></a>查看各种硬件信息</h2><p><a href=\"https://blog.csdn.net/dream_broken/article/details/52883883\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/dream_broken/article/details/52883883</a></p>\n<h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><pre><code>/var/log/message 系统启动后的信息和错误日志，是Red Hat Linux中最常用的日志之一 \n/var/log/secure 与安全相关的日志信息 \n/var/log/maillog 与邮件相关的日志信息 \n/var/log/cron 与定时任务相关的日志信息 \n/var/log/spooler 与UUCP和news设备相关的日志信息\n/var/log/boot.log 守护进程启动和停止相关的日志消息\n</code></pre><h2 id=\"磁盘和分区\"><a href=\"#磁盘和分区\" class=\"headerlink\" title=\"磁盘和分区\"></a>磁盘和分区</h2><pre><code># mount | column -t  # 查看挂接的分区状态 \n# fdisk -l   # 查看所有分区 \n# swapon -s   # 查看所有交换分区 \n# hdparm -i /dev/hda  # 查看磁盘参数(仅适用于IDE设备) \n# dmesg | grep IDE  # 查看启动时IDE设备检测状况 \n</code></pre><h2 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h2><pre><code># ifconfig   # 查看所有网络接口的属性 \n# iptables -L   # 查看防火墙设置 \n# route -n   # 查看路由表 \n# netstat -lntp   # 查看所有监听端口 \n# netstat -antp   # 查看所有已经建立的连接 \n# netstat -s   # 查看网络统计信息 \n</code></pre><h2 id=\"用户\"><a href=\"#用户\" class=\"headerlink\" title=\"用户\"></a>用户</h2><pre><code># w    # 查看活动用户 \n# id &lt;用户名&gt;   # 查看指定用户信息 \n# last    # 查看用户登录日志 \n# cut -d: -f1 /etc/passwd # 查看系统所有用户 \n# cut -d: -f1 /etc/group # 查看系统所有组\n# crontab -l   # 查看当前用户的计划任务 \n</code></pre><h2 id=\"服务\"><a href=\"#服务\" class=\"headerlink\" title=\"服务\"></a>服务</h2><pre><code># chkconfig –list  # 列出所有系统服务 \n# chkconfig –list | grep on # 列出所有启动的系统服务                 \n</code></pre><h2 id=\"查看系统信息\"><a href=\"#查看系统信息\" class=\"headerlink\" title=\"查看系统信息\"></a>查看系统信息</h2><pre><code># uname -a   # 查看内核/操作系统/CPU信息 \n# cat /etc/issue \n# cat /etc/redhat-release # 查看操作系统版本 \n# cat /proc/cpuinfo  # 查看CPU信息 \n# hostname   # 查看计算机名 \n# lspci -tv   # 列出所有PCI设备 \n# lsusb -tv   # 列出所有USB设备 \n# lsmod    # 列出加载的内核模块\n# env    # 查看环境变量 \n</code></pre><h3 id=\"查看端口占用\"><a href=\"#查看端口占用\" class=\"headerlink\" title=\"查看端口占用\"></a>查看端口占用</h3><p><code>netstat -lnp|grep 8000</code></p>\n<h2 id=\"设置自启动\"><a href=\"#设置自启动\" class=\"headerlink\" title=\"设置自启动\"></a>设置自启动</h2><p>在生产环境，一些基础应用环境需要系统启动的时候自动启动……</p>\n<h3 id=\"服务自启动设置\"><a href=\"#服务自启动设置\" class=\"headerlink\" title=\"服务自启动设置\"></a>服务自启动设置</h3><p>执行命令<code>systemctl enable *</code>即可。</p>\n<p>例如设置<code>docker</code>服务自启动：<br><code>systemctl enable docker.service</code></p>\n<h3 id=\"脚本自启动\"><a href=\"#脚本自启动\" class=\"headerlink\" title=\"脚本自启动\"></a>脚本自启动</h3><h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><pre><code>一、添加开机自启服务\n\n在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：\nsystemctl enable jenkins.service #设置jenkins服务为自启动服务\nsysstemctl start  jenkins.service #启动jenkins服务\n\n二、添加开机自启脚本\n\n在centos7中增加脚本有两种常用的方法，以脚本autostart.sh为例：\n#!/bin/bash\n#description:开机自启脚本\n/usr/local/tomcat/bin/startup.sh  #启动tomcat\n\n方法一\n\n1、赋予脚本可执行权限（/opt/script/autostart.sh是你的脚本路径）\nchmod +x /opt/script/autostart.sh\n\n2、打开/etc/rc.d/rc/local文件，在末尾增加如下内容\n/opt/script/autostart.sh\n\n3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\nchmod +x /etc/rc.d/rc.local\n\n方法二\n\n1、将脚本移动到/etc/rc.d/init.d目录下\nmv  /opt/script/autostart.sh /etc/rc.d/init.d\n\n2、增加脚本的可执行权限\nchmod +x  /etc/rc.d/init.d/autostart.sh\n\n3、添加脚本到开机自动启动项目中\ncd /etc/rc.d/init.d\nchkconfig --add autostart.sh\nchkconfig autostart.sh on\n</code></pre><h2 id=\"系统进程管理\"><a href=\"#系统进程管理\" class=\"headerlink\" title=\"系统进程管理\"></a>系统进程管理</h2><h3 id=\"查看进程信息\"><a href=\"#查看进程信息\" class=\"headerlink\" title=\"查看进程信息\"></a>查看进程信息</h3><h4 id=\"1-根据端口，查看进程信息\"><a href=\"#1-根据端口，查看进程信息\" class=\"headerlink\" title=\"1.根据端口，查看进程信息\"></a>1.根据端口，查看进程信息</h4><pre><code># lsof -i:8011  //查看端口，找到进程pid\n# cd /proc/pid\n# ll\n\n---------------------------------------------------------\n\n[root@izwz9bwlp4pyxy4mnxaycez 1113]# ll\ntotal 0\ndr-xr-xr-x  2 root root 0 10月 31 17:30 attr\n-rw-r--r--  1 root root 0 11月  5 10:24 autogroup\n-r--------  1 root root 0 11月  5 10:24 auxv\n-r--r--r--  1 root root 0 11月  5 10:24 cgroup\n--w-------  1 root root 0 11月  5 10:24 clear_refs\n-r--r--r--  1 root root 0 10月  8 21:02 cmdline\n-rw-r--r--  1 root root 0 11月  5 10:24 comm\n-rw-r--r--  1 root root 0 11月  5 10:24 coredump_filter\n-r--r--r--  1 root root 0 11月  5 10:24 cpuset\nlrwxrwxrwx  1 root root 0 11月  5 10:24 cwd -&gt; /\n-r--------  1 root root 0 11月  1 15:13 environ\nlrwxrwxrwx  1 root root 0 11月  5 10:24 exe -&gt; /server/java/jdk/bin/java\ndr-x------  2 root root 0 10月 31 17:30 fd\ndr-x------  2 root root 0 11月  1 11:53 fdinfo\n-rw-r--r--  1 root root 0 11月  5 10:24 gid_map\n-r--------  1 root root 0 11月  5 10:24 io\n-r--r--r--  1 root root 0 11月  5 10:24 limits\n-rw-r--r--  1 root root 0 11月  5 10:24 loginuid\ndr-x------  2 root root 0 11月  5 10:24 map_files\n-r--r--r--  1 root root 0 11月  5 10:24 maps\n-rw-------  1 root root 0 11月  5 10:24 mem\n-r--r--r--  1 root root 0 11月  5 10:24 mountinfo\n-r--r--r--  1 root root 0 11月  5 10:24 mounts\n-r--------  1 root root 0 11月  5 10:24 mountstats\ndr-xr-xr-x  5 root root 0 11月  5 10:24 net\ndr-x--x--x  2 root root 0 11月  5 10:24 ns\n-r--r--r--  1 root root 0 11月  5 10:24 numa_maps\n-rw-r--r--  1 root root 0 11月  5 10:24 oom_adj\n-r--r--r--  1 root root 0 11月  5 10:24 oom_score\n-rw-r--r--  1 root root 0 11月  5 10:24 oom_score_adj\n-r--r--r--  1 root root 0 11月  5 10:24 pagemap\n-r--------  1 root root 0 11月  5 10:24 patch_state\n-r--r--r--  1 root root 0 11月  5 10:24 personality\n-rw-r--r--  1 root root 0 11月  5 10:24 projid_map\nlrwxrwxrwx  1 root root 0 11月  5 10:24 root -&gt; /\n-rw-r--r--  1 root root 0 11月  5 10:24 sched\n-r--r--r--  1 root root 0 11月  5 10:24 schedstat\n-r--r--r--  1 root root 0 11月  5 10:24 sessionid\n-rw-r--r--  1 root root 0 11月  5 10:24 setgroups\n-r--r--r--  1 root root 0 11月  5 10:24 smaps\n-r--r--r--  1 root root 0 11月  5 10:24 stack\n-r--r--r--  1 root root 0 10月  8 21:02 stat\n-r--r--r--  1 root root 0 11月  5 10:24 statm\n-r--r--r--  1 root root 0 10月  8 21:02 status\n-r--r--r--  1 root root 0 11月  5 10:24 syscall\ndr-xr-xr-x 30 root root 0 11月  5 10:24 task\n-r--r--r--  1 root root 0 11月  5 10:24 timers\n-rw-r--r--  1 root root 0 11月  5 10:24 uid_map\n-r--r--r--  1 root root 0 11月  5 10:24 wchan\n</code></pre><h4 id=\"2-查看进程\"><a href=\"#2-查看进程\" class=\"headerlink\" title=\"2.查看进程\"></a>2.查看进程</h4><pre><code># ps aux | less  --查看所有运行中的进程\n# ps -A --查看系统中的每个进程。\n# ps -u vivek --查看用户vivek运行的进程\n</code></pre><h4 id=\"3-动态显示进程\"><a href=\"#3-动态显示进程\" class=\"headerlink\" title=\"3.动态显示进程\"></a>3.动态显示进程</h4><pre><code># top\n</code></pre><p>按q退出，按h进入帮助</p>\n<h4 id=\"4-树状显示进程\"><a href=\"#4-树状显示进程\" class=\"headerlink\" title=\"4.树状显示进程\"></a>4.树状显示进程</h4><pre><code>[root@izwz9bwlp4pyxy4mnxaycez ~]# pstree\nsystemd─┬─aliyun-service\n        ├─atd\n        ├─auditd───{auditd}\n        ├─crond\n        ├─dbus-daemon\n        ├─dhclient\n        ├─irqbalance\n        ├─26*[java───27*[{java}]]\n        ├─java───26*[{java}]\n        ├─2*[java───32*[{java}]]\n        ├─java───23*[{java}]\n        ├─java───21*[{java}]\n        ├─java───61*[{java}]\n        ├─java───247*[{java}]\n        ├─java───57*[{java}]\n        ├─java───49*[{java}]\n        ├─login───bash\n        ├─mysqld_safe───mysqld───128*[{mysqld}]\n        ├─mysqld_safe───mysqld───194*[{mysqld}]\n        ├─10*[nginx───nginx]\n        ├─ntpd\n        ├─polkitd───5*[{polkitd}]\n        ├─redis-server───2*[{redis-server}]\n        ├─rsyslogd───2*[{rsyslogd}]\n        ├─sshd─┬─3*[sshd───bash]\n        │      ├─2*[sshd───bash───2*[tail]]\n        │      ├─sshd───bash───pstree\n        │      └─sshd───sshd\n        ├─systemd-journal\n        ├─systemd-logind\n        ├─systemd-udevd\n        ├─tuned───4*[{tuned}]\n        └─wrapper─┬─java───53*[{java}]\n                  └─{wrapper}\n</code></pre><h3 id=\"将进程快照储存到文件中\"><a href=\"#将进程快照储存到文件中\" class=\"headerlink\" title=\"将进程快照储存到文件中\"></a>将进程快照储存到文件中</h3><p>输入下列命令：</p>\n<pre><code># top -b -n1 &gt; /tmp/process.log\n</code></pre><p>你也可以将结果通过邮件发给自己：</p>\n<pre><code># top -b -n1 | mail -s &apos;Process snapshot&apos; you@example.com\n</code></pre><h2 id=\"查看服务器情况\"><a href=\"#查看服务器情况\" class=\"headerlink\" title=\"查看服务器情况\"></a>查看服务器情况</h2><h3 id=\"1-查看服务器CPU型号\"><a href=\"#1-查看服务器CPU型号\" class=\"headerlink\" title=\"1.查看服务器CPU型号\"></a>1.查看服务器CPU型号</h3><pre><code>grep &quot;model name&quot; /proc/cpuinfo | cut -f2 -d:  \n</code></pre><h3 id=\"2-查看服务器内存容量\"><a href=\"#2-查看服务器内存容量\" class=\"headerlink\" title=\"2.查看服务器内存容量\"></a>2.查看服务器内存容量</h3><pre><code>grep MemTotal /proc/meminfo\ngrep MemTotal /proc/meminfo | cut -f2 -d:\nfree -m |grep &quot;Mem&quot; | awk &apos;{print $2}&apos; \n</code></pre><h3 id=\"3-查看服务器的CPU是32位还是64位\"><a href=\"#3-查看服务器的CPU是32位还是64位\" class=\"headerlink\" title=\"3.查看服务器的CPU是32位还是64位\"></a>3.查看服务器的CPU是32位还是64位</h3><pre><code>getconf LONG_BIT\n</code></pre><h3 id=\"4-查看当前Linux的版本\"><a href=\"#4-查看当前Linux的版本\" class=\"headerlink\" title=\"4.查看当前Linux的版本\"></a>4.查看当前Linux的版本</h3><pre><code>more /etc/redhat-release cat /etc/redhat-release\n</code></pre><h3 id=\"5-查看Linux内核版本\"><a href=\"#5-查看Linux内核版本\" class=\"headerlink\" title=\"5.查看Linux内核版本\"></a>5.查看Linux内核版本</h3><pre><code>uname -r\nuname -a\n</code></pre><h3 id=\"6-查看服务器当前时间\"><a href=\"#6-查看服务器当前时间\" class=\"headerlink\" title=\"6.查看服务器当前时间\"></a>6.查看服务器当前时间</h3><pre><code>date\n</code></pre><h3 id=\"7-查看服务器硬盘和分区\"><a href=\"#7-查看服务器硬盘和分区\" class=\"headerlink\" title=\"7.查看服务器硬盘和分区\"></a>7.查看服务器硬盘和分区</h3><pre><code>df -h\nfdisk -l\n</code></pre><h3 id=\"8-查看挂载情况\"><a href=\"#8-查看挂载情况\" class=\"headerlink\" title=\"8.查看挂载情况\"></a>8.查看挂载情况</h3><pre><code>mount\n</code></pre><h3 id=\"9-查看目录大小\"><a href=\"#9-查看目录大小\" class=\"headerlink\" title=\"9.查看目录大小\"></a>9.查看目录大小</h3><pre><code>du /etc -sh  \n</code></pre><h3 id=\"10-查看服务器初始安装的软件包\"><a href=\"#10-查看服务器初始安装的软件包\" class=\"headerlink\" title=\"10.查看服务器初始安装的软件包\"></a>10.查看服务器初始安装的软件包</h3><pre><code>cat -n /root/install.log\nmore /root/install.log | wc -l\n</code></pre><h3 id=\"11-查看已经安装的软件包\"><a href=\"#11-查看已经安装的软件包\" class=\"headerlink\" title=\"11.查看已经安装的软件包\"></a>11.查看已经安装的软件包</h3><pre><code>rpm -qa\nrpm -qa | wc -l\nyum list installed | wc -l\n</code></pre><h3 id=\"12-查看服务器键盘布局\"><a href=\"#12-查看服务器键盘布局\" class=\"headerlink\" title=\"12.查看服务器键盘布局\"></a>12.查看服务器键盘布局</h3><pre><code>cat /etc/sysconfig/keyboard\ncat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d=\n</code></pre><h3 id=\"13-查看Selinux状态\"><a href=\"#13-查看Selinux状态\" class=\"headerlink\" title=\"13.查看Selinux状态\"></a>13.查看Selinux状态</h3><pre><code>sestatus\nsestatus | cut -f2 -d:\ncat /etc/sysconfig/selinux\n</code></pre><h3 id=\"14-查看服务器网卡的ip，Mac地址-在ifcfg-eth0-文件里你可以看到mac，网关等信息。\"><a href=\"#14-查看服务器网卡的ip，Mac地址-在ifcfg-eth0-文件里你可以看到mac，网关等信息。\" class=\"headerlink\" title=\"14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。\"></a>14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。</h3><pre><code>ifconfig\ncat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR\ncat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2 -d=\nifconfig eth0 |grep &quot;inet addr:&quot; |awk &apos;{print $2}&apos;|cut -c 6-\nifconfig | grep &apos;inet addr:&apos;| grep -v &apos;127.0.0.1&apos; | cut -d: -f2 | awk &apos;{ print $1}&apos;\n</code></pre><h3 id=\"15-查看服务器默认网关\"><a href=\"#15-查看服务器默认网关\" class=\"headerlink\" title=\"15.查看服务器默认网关\"></a>15.查看服务器默认网关</h3><pre><code>cat /etc/sysconfig/network\n</code></pre><h3 id=\"16-查看服务器的默认DNS\"><a href=\"#16-查看服务器的默认DNS\" class=\"headerlink\" title=\"16.查看服务器的默认DNS\"></a>16.查看服务器的默认DNS</h3><pre><code>cat /etc/resolv.conf\n</code></pre><h3 id=\"17-查看服务器默认语言\"><a href=\"#17-查看服务器默认语言\" class=\"headerlink\" title=\"17.查看服务器默认语言\"></a>17.查看服务器默认语言</h3><pre><code>echo $LANG $LANGUAGE\ncat /etc/sysconfig/i18n\n</code></pre><h3 id=\"18-查看服务器所属时区和UTC时间\"><a href=\"#18-查看服务器所属时区和UTC时间\" class=\"headerlink\" title=\"18.查看服务器所属时区和UTC时间\"></a>18.查看服务器所属时区和UTC时间</h3><pre><code>cat /etc/sysconfig/clock\n</code></pre><h3 id=\"19-查看服务器主机名\"><a href=\"#19-查看服务器主机名\" class=\"headerlink\" title=\"19.查看服务器主机名\"></a>19.查看服务器主机名</h3><pre><code>hostname\ncat /etc/sysconfig/network\n</code></pre><h3 id=\"20-查看文件大小\"><a href=\"#20-查看文件大小\" class=\"headerlink\" title=\"20.查看文件大小\"></a>20.查看文件大小</h3><pre><code>ll -h a.txt    \n</code></pre><h2 id=\"CentOS挂载新硬盘\"><a href=\"#CentOS挂载新硬盘\" class=\"headerlink\" title=\"CentOS挂载新硬盘\"></a>CentOS挂载新硬盘</h2><p>参考：<a href=\"http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html</a><br>1.查看当前硬盘使用状况：</p>\n<pre><code>df -h\n</code></pre><p>2.查看新硬盘</p>\n<pre><code>fdisk -l \n</code></pre><p>新添加的硬盘的编号为 <code>/dev/xvdb    /dev/xvde  /dev/vdb</code></p>\n<p>3.硬盘分区<br> 1)进入fdisk模式<br>    <code>/sbin/fdisk /dev/vdb</code><br> 2)输入n进行分区<br> 3)选择分区类型   </p>\n<p>  这里有两个选项：   </p>\n<ul>\n<li>p: 主分区 linux上主分区最多能有4个    </li>\n<li>e: 扩展分区 linux上扩展分区只能有1个，扩展分区创建后不能直接使用，还要在扩展分区上创建逻辑分区。     </li>\n</ul>\n<p>这里我选择的p。</p>\n<p> 4)选择分区个数<br> 可以选择4个分区，这里我只分成1个分区<br> 5)设置柱面，这里选择默认值就可以<br> 6)输入w，写入分区表，进行分区   </p>\n<p>4.格式化分区 </p>\n<p>将新分区格式化为ext4文件系统<br>1)如果创建的是主分区<br><code>mkfs -t ext4  /dev/vdb1</code></p>\n<p>5.挂载硬盘<br>1)创建挂载点<br>在根目录下创建sqjr目录<br><code>mkdir /server /sqjr</code><br>2)将/dev/vdb1挂载到/sqjr下<br> <code>mount /dev/vdb1 /server  /sqjr</code></p>\n<p>6.设置开机启动自动挂载<br>新创建的分区不能开机自动挂载，每次重启机器都要手动挂载。<br>设置开机自动挂载需要修改/etc/fstab文件<br><code>vi /etc/fstab</code><br>在文件的最后增加一行<br><code>/dev/vdb1 /server ext4 defaults 1 2</code></p>\n<p>7.取消挂载 /dev/xvdb1<br><code>umount /dev/vdb1</code></p>\n<p>8.重启<br><code>reboot -n</code>                        </p>\n<h2 id=\"清理缓存，释放内存\"><a href=\"#清理缓存，释放内存\" class=\"headerlink\" title=\"清理缓存，释放内存\"></a>清理缓存，释放内存</h2><p>1.清理yum缓存使用yum clean 命令，yum clean 的参数有headers, packages, metadata, dbcache, plugins, expire-cache, rpmdb, all</p>\n<pre><code>yum clean headers  #清理/var/cache/yum的headers\nyum clean packages #清理/var/cache/yum下的软件包\nyum clean metadata\n...\n</code></pre><p>2.Linux释放内存</p>\n<p>释放网页缓存(To free pagecache):    </p>\n<pre><code>sync; echo 1 &gt; /proc/sys/vm/drop_caches\n</code></pre><p>释放目录项和索引(To free dentries and inodes):</p>\n<pre><code>sync; echo 2 &gt; /proc/sys/vm/drop_caches\n</code></pre><p>释放网页缓存，目录项和索引（To free pagecache, dentries and inodes）:</p>\n<pre><code>sync; echo 3 &gt; /proc/sys/vm/drop_caches \n</code></pre><h2 id=\"利用curl获取本机的外网ip\"><a href=\"#利用curl获取本机的外网ip\" class=\"headerlink\" title=\"利用curl获取本机的外网ip\"></a>利用curl获取本机的外网ip</h2><pre><code>#oray国内地址，返回速度快\ncurl -s http://ddns.oray.com/checkip | awk -F &quot;: &quot; &apos;{print $2}&apos; | awk -F &quot;\\&lt;&quot; &apos;{print $1}&apos;\n#返回快\ncurl ident.me\ncurl myip.dnsomatic.com\n#返回较快\ncurl whatismyip.akamai.com\ncurl https://tnx.nl/ip\n#返回慢，不推荐\ncurl ifconfig.me\ncurl icanhazip.com\ncurl ipecho.net/plain  \n</code></pre>"},{"title":"jwt初识","date":"2018-03-08T08:47:23.000Z","_content":"\nJSON Web Token（JWT）是目前比较流行的跨域身份验证的解决方案。也是系统间信息交互的好助手。下面介绍其机制和原理，以及使用！\n\n## jwt是什么\n\nJSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。\n\n## 什么时候使用jwt\n\n- Authentication（认证）、Authorization（授权）: \n\n这是jwt使用的最广的场景。一旦用户登录后，返回jwt令牌，后续客户端携带该令牌作为身份访问授权的api资源。可以使用jwt来做单点登录，开销很小，并且可以轻松的跨域。\n\n- Information Exchange (信息交换) :\n\n在各方系统之间安全的传递消息，jwt无疑是一种很好的方式。因为jwt可以被签名，例如用公钥/私钥对，可以确定发送人就是所指定的那个人。同时，还可以验证内容有没有被篡改。    \n\n- 不依赖session机制： \n\n以往通过seesion会话机制来做验证，但是如果session保存在内存，就无法做分布式系统，因为分布式环境中要求请求无状态。即使把session持久化到如redis，关系数据库或者文件系统中能解决无状态问题，但是这个对业务侵入大，且持久化过程失败的话，整个验证过程就失败，系统开销也大。jwt直接把数据存储在客户端，每次请求携带上就可以认证，简单且开销小。\n\n## JSON Web Token的结构\n\n{% asset_img a-1.png %}\n\njwt要三部分组成，它们之间用圆点（.）隔开。三部分分别是：  \n\n- Header\n- Payload\n- Signature\n\n所以，一个jwt看起来应该是这个样子：\n\nxxxxxxxxxx.yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy.zzzzzzzzzzzz\n\n### Header\n\nheader由两部分组成：类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。\n\n像下面：    \n\n    {\n        \"alg\": \"HS256\",\n        \"typ\": \"JWT\"\n    }\n\nalg表示使用的签名算法，默认为HMAC SHA256（写为HS256）；typ表示令牌的类型，JWT令牌统一写为JWT。\n\n最后，要用Base64URL算法对上面json对象编码转为字符串作为JWT的第一部分。   \n\n### Payload\n\njwt的有效载体payload,声明关于实体（通常指用户）和其它数据，声明有三种类型：registered, public 和 private。    \n\n- Registered claims :   \n\n预定义的声明，不是强制的，但是推荐。指定7个默认的字段供选择： \n\n1.iss：发行人\n\n2.exp：到期时间\n\n3.sub：主题\n\n4.aud：用户\n\n5.nbf：在此之前不可用\n\n6.iat：发布时间\n\n7.jti：JWT ID用于标识该JW\n\n- Public claims : \n\n公开的，可以随意定义。\n\n- Private claims : \n\n用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。\n\n下面是个例子：\n\n    {\n        \"sub\": \"1234567890\",\n        \"name\": \"chongchong\",\n        \"admin\": true\n    }\n    \n对payload进行Base64URL编码就得到JWT的第二部分。\n\n_注意：_  不要在JWT的payload或header中放置敏感信息，除非它们是加密的。使用https或者加密算法才可以添加敏感信息，否则有信息泄露可能。\n\n### Signature签名哈希\n\n为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。\n\n例如： \n\n    HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret) \n    \n签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。secret必须保持在服务器，不可泄露。    \n\n### Base64URL算法\n\n如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。\n\n作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是\"+\"，\"/\"和\"=\"，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：\"=\"去掉，\"+\"用\"-\"替换，\"/\"用\"_\"替换，这就是Base64URL算法，很简单吧。\n\n## jwt工作机制\n\n认证的时候，当用户用他们的凭证登录成功后，服务端将会按照上面方式生成一个jwt返回给客户端。此后，该token就是用户的凭证了，后面每次请求都带上该token。你必须要非常小心的保护该token，在客户端保存令牌的时间不能超过令牌的有效时间。\n\n每次客户端请求受保护的路由或者资源，都得带上该token，一般的，放在Authorization header中，用Bearer schema。\n\nheader应该看起来是这样的：    \n\n    Authorization: Bearer <token>\n    \n服务端会在过滤器或者拦截器中，拦截每次请求，并检查Authorization header中的JWT是否有效。如果有效，则可以访问相关资源，否则返回token失效，此时客户端应该要重新登录获取最新的token。   \n\n如果jwt中包含足够的必要数据，那么可以减少查询数据库的次数。尽管不一定必要。例如，保存用户`username`到jwt中，而不仅仅保存`id`,下次服务端接到请求，就可以直接使用`username`，而不必根据`id`再查一遍。\n\n如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。\n\n注意：\n\n1.每一次请求都需要token。    \n2.Token应该放在请求header中。   \n3.我们还需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *。  \n\n## JWT与OAuth的区别\n\n1.OAuth2是一种授权框架 ，JWT是一种认证协议。    \n2.无论使用哪种方式切记用HTTPS来保证数据的安全性。    \n3.OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。 \n\n## 基于Token的身份认证 与 基于服务器的身份认证\n\n## 总结   \n\n1、JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。\n\n2、当JWT未加密方法是，一些私密数据无法通过JWT传输。\n\n3、JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。\n\n4、JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。\n\n5、JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。\n\n6、为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。","source":"_posts/jwt-study.md","raw":"---\ntitle: jwt初识\ndate: 2018-03-08 16:47:23\ncategories: jwt\ntags:\n---\n\nJSON Web Token（JWT）是目前比较流行的跨域身份验证的解决方案。也是系统间信息交互的好助手。下面介绍其机制和原理，以及使用！\n\n## jwt是什么\n\nJSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。\n\n## 什么时候使用jwt\n\n- Authentication（认证）、Authorization（授权）: \n\n这是jwt使用的最广的场景。一旦用户登录后，返回jwt令牌，后续客户端携带该令牌作为身份访问授权的api资源。可以使用jwt来做单点登录，开销很小，并且可以轻松的跨域。\n\n- Information Exchange (信息交换) :\n\n在各方系统之间安全的传递消息，jwt无疑是一种很好的方式。因为jwt可以被签名，例如用公钥/私钥对，可以确定发送人就是所指定的那个人。同时，还可以验证内容有没有被篡改。    \n\n- 不依赖session机制： \n\n以往通过seesion会话机制来做验证，但是如果session保存在内存，就无法做分布式系统，因为分布式环境中要求请求无状态。即使把session持久化到如redis，关系数据库或者文件系统中能解决无状态问题，但是这个对业务侵入大，且持久化过程失败的话，整个验证过程就失败，系统开销也大。jwt直接把数据存储在客户端，每次请求携带上就可以认证，简单且开销小。\n\n## JSON Web Token的结构\n\n{% asset_img a-1.png %}\n\njwt要三部分组成，它们之间用圆点（.）隔开。三部分分别是：  \n\n- Header\n- Payload\n- Signature\n\n所以，一个jwt看起来应该是这个样子：\n\nxxxxxxxxxx.yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy.zzzzzzzzzzzz\n\n### Header\n\nheader由两部分组成：类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。\n\n像下面：    \n\n    {\n        \"alg\": \"HS256\",\n        \"typ\": \"JWT\"\n    }\n\nalg表示使用的签名算法，默认为HMAC SHA256（写为HS256）；typ表示令牌的类型，JWT令牌统一写为JWT。\n\n最后，要用Base64URL算法对上面json对象编码转为字符串作为JWT的第一部分。   \n\n### Payload\n\njwt的有效载体payload,声明关于实体（通常指用户）和其它数据，声明有三种类型：registered, public 和 private。    \n\n- Registered claims :   \n\n预定义的声明，不是强制的，但是推荐。指定7个默认的字段供选择： \n\n1.iss：发行人\n\n2.exp：到期时间\n\n3.sub：主题\n\n4.aud：用户\n\n5.nbf：在此之前不可用\n\n6.iat：发布时间\n\n7.jti：JWT ID用于标识该JW\n\n- Public claims : \n\n公开的，可以随意定义。\n\n- Private claims : \n\n用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。\n\n下面是个例子：\n\n    {\n        \"sub\": \"1234567890\",\n        \"name\": \"chongchong\",\n        \"admin\": true\n    }\n    \n对payload进行Base64URL编码就得到JWT的第二部分。\n\n_注意：_  不要在JWT的payload或header中放置敏感信息，除非它们是加密的。使用https或者加密算法才可以添加敏感信息，否则有信息泄露可能。\n\n### Signature签名哈希\n\n为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。\n\n例如： \n\n    HMACSHA256(base64UrlEncode(header) + \".\" + base64UrlEncode(payload), secret) \n    \n签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。secret必须保持在服务器，不可泄露。    \n\n### Base64URL算法\n\n如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。\n\n作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是\"+\"，\"/\"和\"=\"，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：\"=\"去掉，\"+\"用\"-\"替换，\"/\"用\"_\"替换，这就是Base64URL算法，很简单吧。\n\n## jwt工作机制\n\n认证的时候，当用户用他们的凭证登录成功后，服务端将会按照上面方式生成一个jwt返回给客户端。此后，该token就是用户的凭证了，后面每次请求都带上该token。你必须要非常小心的保护该token，在客户端保存令牌的时间不能超过令牌的有效时间。\n\n每次客户端请求受保护的路由或者资源，都得带上该token，一般的，放在Authorization header中，用Bearer schema。\n\nheader应该看起来是这样的：    \n\n    Authorization: Bearer <token>\n    \n服务端会在过滤器或者拦截器中，拦截每次请求，并检查Authorization header中的JWT是否有效。如果有效，则可以访问相关资源，否则返回token失效，此时客户端应该要重新登录获取最新的token。   \n\n如果jwt中包含足够的必要数据，那么可以减少查询数据库的次数。尽管不一定必要。例如，保存用户`username`到jwt中，而不仅仅保存`id`,下次服务端接到请求，就可以直接使用`username`，而不必根据`id`再查一遍。\n\n如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。\n\n注意：\n\n1.每一次请求都需要token。    \n2.Token应该放在请求header中。   \n3.我们还需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *。  \n\n## JWT与OAuth的区别\n\n1.OAuth2是一种授权框架 ，JWT是一种认证协议。    \n2.无论使用哪种方式切记用HTTPS来保证数据的安全性。    \n3.OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。 \n\n## 基于Token的身份认证 与 基于服务器的身份认证\n\n## 总结   \n\n1、JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。\n\n2、当JWT未加密方法是，一些私密数据无法通过JWT传输。\n\n3、JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。\n\n4、JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。\n\n5、JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。\n\n6、为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。","slug":"jwt-study","published":1,"updated":"2019-06-16T14:38:33.406Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdb006kg4vabwcuyf2d","content":"<p>JSON Web Token（JWT）是目前比较流行的跨域身份验证的解决方案。也是系统间信息交互的好助手。下面介绍其机制和原理，以及使用！</p>\n<h2 id=\"jwt是什么\"><a href=\"#jwt是什么\" class=\"headerlink\" title=\"jwt是什么\"></a>jwt是什么</h2><p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>\n<h2 id=\"什么时候使用jwt\"><a href=\"#什么时候使用jwt\" class=\"headerlink\" title=\"什么时候使用jwt\"></a>什么时候使用jwt</h2><ul>\n<li>Authentication（认证）、Authorization（授权）: </li>\n</ul>\n<p>这是jwt使用的最广的场景。一旦用户登录后，返回jwt令牌，后续客户端携带该令牌作为身份访问授权的api资源。可以使用jwt来做单点登录，开销很小，并且可以轻松的跨域。</p>\n<ul>\n<li>Information Exchange (信息交换) :</li>\n</ul>\n<p>在各方系统之间安全的传递消息，jwt无疑是一种很好的方式。因为jwt可以被签名，例如用公钥/私钥对，可以确定发送人就是所指定的那个人。同时，还可以验证内容有没有被篡改。    </p>\n<ul>\n<li>不依赖session机制： </li>\n</ul>\n<p>以往通过seesion会话机制来做验证，但是如果session保存在内存，就无法做分布式系统，因为分布式环境中要求请求无状态。即使把session持久化到如redis，关系数据库或者文件系统中能解决无状态问题，但是这个对业务侵入大，且持久化过程失败的话，整个验证过程就失败，系统开销也大。jwt直接把数据存储在客户端，每次请求携带上就可以认证，简单且开销小。</p>\n<h2 id=\"JSON-Web-Token的结构\"><a href=\"#JSON-Web-Token的结构\" class=\"headerlink\" title=\"JSON Web Token的结构\"></a>JSON Web Token的结构</h2><img src=\"/2018/03/08/jwt-study/a-1.png\">\n<p>jwt要三部分组成，它们之间用圆点（.）隔开。三部分分别是：  </p>\n<ul>\n<li>Header</li>\n<li>Payload</li>\n<li>Signature</li>\n</ul>\n<p>所以，一个jwt看起来应该是这个样子：</p>\n<p>xxxxxxxxxx.yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy.zzzzzzzzzzzz</p>\n<h3 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h3><p>header由两部分组成：类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。</p>\n<p>像下面：    </p>\n<pre><code>{\n    &quot;alg&quot;: &quot;HS256&quot;,\n    &quot;typ&quot;: &quot;JWT&quot;\n}\n</code></pre><p>alg表示使用的签名算法，默认为HMAC SHA256（写为HS256）；typ表示令牌的类型，JWT令牌统一写为JWT。</p>\n<p>最后，要用Base64URL算法对上面json对象编码转为字符串作为JWT的第一部分。   </p>\n<h3 id=\"Payload\"><a href=\"#Payload\" class=\"headerlink\" title=\"Payload\"></a>Payload</h3><p>jwt的有效载体payload,声明关于实体（通常指用户）和其它数据，声明有三种类型：registered, public 和 private。    </p>\n<ul>\n<li>Registered claims :   </li>\n</ul>\n<p>预定义的声明，不是强制的，但是推荐。指定7个默认的字段供选择： </p>\n<p>1.iss：发行人</p>\n<p>2.exp：到期时间</p>\n<p>3.sub：主题</p>\n<p>4.aud：用户</p>\n<p>5.nbf：在此之前不可用</p>\n<p>6.iat：发布时间</p>\n<p>7.jti：JWT ID用于标识该JW</p>\n<ul>\n<li>Public claims : </li>\n</ul>\n<p>公开的，可以随意定义。</p>\n<ul>\n<li>Private claims : </li>\n</ul>\n<p>用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。</p>\n<p>下面是个例子：</p>\n<pre><code>{\n    &quot;sub&quot;: &quot;1234567890&quot;,\n    &quot;name&quot;: &quot;chongchong&quot;,\n    &quot;admin&quot;: true\n}\n</code></pre><p>对payload进行Base64URL编码就得到JWT的第二部分。</p>\n<p><em>注意：</em>  不要在JWT的payload或header中放置敏感信息，除非它们是加密的。使用https或者加密算法才可以添加敏感信息，否则有信息泄露可能。</p>\n<h3 id=\"Signature签名哈希\"><a href=\"#Signature签名哈希\" class=\"headerlink\" title=\"Signature签名哈希\"></a>Signature签名哈希</h3><p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p>\n<p>例如： </p>\n<pre><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) \n</code></pre><p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。secret必须保持在服务器，不可泄露。    </p>\n<h3 id=\"Base64URL算法\"><a href=\"#Base64URL算法\" class=\"headerlink\" title=\"Base64URL算法\"></a>Base64URL算法</h3><p>如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。</p>\n<p>作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是”+”，”/“和”=”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”=”去掉，”+”用”-“替换，”/“用”_”替换，这就是Base64URL算法，很简单吧。</p>\n<h2 id=\"jwt工作机制\"><a href=\"#jwt工作机制\" class=\"headerlink\" title=\"jwt工作机制\"></a>jwt工作机制</h2><p>认证的时候，当用户用他们的凭证登录成功后，服务端将会按照上面方式生成一个jwt返回给客户端。此后，该token就是用户的凭证了，后面每次请求都带上该token。你必须要非常小心的保护该token，在客户端保存令牌的时间不能超过令牌的有效时间。</p>\n<p>每次客户端请求受保护的路由或者资源，都得带上该token，一般的，放在Authorization header中，用Bearer schema。</p>\n<p>header应该看起来是这样的：    </p>\n<pre><code>Authorization: Bearer &lt;token&gt;\n</code></pre><p>服务端会在过滤器或者拦截器中，拦截每次请求，并检查Authorization header中的JWT是否有效。如果有效，则可以访问相关资源，否则返回token失效，此时客户端应该要重新登录获取最新的token。   </p>\n<p>如果jwt中包含足够的必要数据，那么可以减少查询数据库的次数。尽管不一定必要。例如，保存用户<code>username</code>到jwt中，而不仅仅保存<code>id</code>,下次服务端接到请求，就可以直接使用<code>username</code>，而不必根据<code>id</code>再查一遍。</p>\n<p>如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。</p>\n<p>注意：</p>\n<p>1.每一次请求都需要token。<br>2.Token应该放在请求header中。<br>3.我们还需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *。  </p>\n<h2 id=\"JWT与OAuth的区别\"><a href=\"#JWT与OAuth的区别\" class=\"headerlink\" title=\"JWT与OAuth的区别\"></a>JWT与OAuth的区别</h2><p>1.OAuth2是一种授权框架 ，JWT是一种认证协议。<br>2.无论使用哪种方式切记用HTTPS来保证数据的安全性。<br>3.OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。 </p>\n<h2 id=\"基于Token的身份认证-与-基于服务器的身份认证\"><a href=\"#基于Token的身份认证-与-基于服务器的身份认证\" class=\"headerlink\" title=\"基于Token的身份认证 与 基于服务器的身份认证\"></a>基于Token的身份认证 与 基于服务器的身份认证</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。</p>\n<p>2、当JWT未加密方法是，一些私密数据无法通过JWT传输。</p>\n<p>3、JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。</p>\n<p>4、JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。</p>\n<p>5、JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。</p>\n<p>6、为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>JSON Web Token（JWT）是目前比较流行的跨域身份验证的解决方案。也是系统间信息交互的好助手。下面介绍其机制和原理，以及使用！</p>\n<h2 id=\"jwt是什么\"><a href=\"#jwt是什么\" class=\"headerlink\" title=\"jwt是什么\"></a>jwt是什么</h2><p>JSON Web Token (JWT)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。</p>\n<h2 id=\"什么时候使用jwt\"><a href=\"#什么时候使用jwt\" class=\"headerlink\" title=\"什么时候使用jwt\"></a>什么时候使用jwt</h2><ul>\n<li>Authentication（认证）、Authorization（授权）: </li>\n</ul>\n<p>这是jwt使用的最广的场景。一旦用户登录后，返回jwt令牌，后续客户端携带该令牌作为身份访问授权的api资源。可以使用jwt来做单点登录，开销很小，并且可以轻松的跨域。</p>\n<ul>\n<li>Information Exchange (信息交换) :</li>\n</ul>\n<p>在各方系统之间安全的传递消息，jwt无疑是一种很好的方式。因为jwt可以被签名，例如用公钥/私钥对，可以确定发送人就是所指定的那个人。同时，还可以验证内容有没有被篡改。    </p>\n<ul>\n<li>不依赖session机制： </li>\n</ul>\n<p>以往通过seesion会话机制来做验证，但是如果session保存在内存，就无法做分布式系统，因为分布式环境中要求请求无状态。即使把session持久化到如redis，关系数据库或者文件系统中能解决无状态问题，但是这个对业务侵入大，且持久化过程失败的话，整个验证过程就失败，系统开销也大。jwt直接把数据存储在客户端，每次请求携带上就可以认证，简单且开销小。</p>\n<h2 id=\"JSON-Web-Token的结构\"><a href=\"#JSON-Web-Token的结构\" class=\"headerlink\" title=\"JSON Web Token的结构\"></a>JSON Web Token的结构</h2><img src=\"/2018/03/08/jwt-study/a-1.png\">\n<p>jwt要三部分组成，它们之间用圆点（.）隔开。三部分分别是：  </p>\n<ul>\n<li>Header</li>\n<li>Payload</li>\n<li>Signature</li>\n</ul>\n<p>所以，一个jwt看起来应该是这个样子：</p>\n<p>xxxxxxxxxx.yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy.zzzzzzzzzzzz</p>\n<h3 id=\"Header\"><a href=\"#Header\" class=\"headerlink\" title=\"Header\"></a>Header</h3><p>header由两部分组成：类型（“JWT”）和算法名称（比如：HMAC SHA256或者RSA等等）。</p>\n<p>像下面：    </p>\n<pre><code>{\n    &quot;alg&quot;: &quot;HS256&quot;,\n    &quot;typ&quot;: &quot;JWT&quot;\n}\n</code></pre><p>alg表示使用的签名算法，默认为HMAC SHA256（写为HS256）；typ表示令牌的类型，JWT令牌统一写为JWT。</p>\n<p>最后，要用Base64URL算法对上面json对象编码转为字符串作为JWT的第一部分。   </p>\n<h3 id=\"Payload\"><a href=\"#Payload\" class=\"headerlink\" title=\"Payload\"></a>Payload</h3><p>jwt的有效载体payload,声明关于实体（通常指用户）和其它数据，声明有三种类型：registered, public 和 private。    </p>\n<ul>\n<li>Registered claims :   </li>\n</ul>\n<p>预定义的声明，不是强制的，但是推荐。指定7个默认的字段供选择： </p>\n<p>1.iss：发行人</p>\n<p>2.exp：到期时间</p>\n<p>3.sub：主题</p>\n<p>4.aud：用户</p>\n<p>5.nbf：在此之前不可用</p>\n<p>6.iat：发布时间</p>\n<p>7.jti：JWT ID用于标识该JW</p>\n<ul>\n<li>Public claims : </li>\n</ul>\n<p>公开的，可以随意定义。</p>\n<ul>\n<li>Private claims : </li>\n</ul>\n<p>用于在同意使用它们的各方之间共享信息，并且不是注册的或公开的声明。</p>\n<p>下面是个例子：</p>\n<pre><code>{\n    &quot;sub&quot;: &quot;1234567890&quot;,\n    &quot;name&quot;: &quot;chongchong&quot;,\n    &quot;admin&quot;: true\n}\n</code></pre><p>对payload进行Base64URL编码就得到JWT的第二部分。</p>\n<p><em>注意：</em>  不要在JWT的payload或header中放置敏感信息，除非它们是加密的。使用https或者加密算法才可以添加敏感信息，否则有信息泄露可能。</p>\n<h3 id=\"Signature签名哈希\"><a href=\"#Signature签名哈希\" class=\"headerlink\" title=\"Signature签名哈希\"></a>Signature签名哈希</h3><p>为了得到签名部分，你必须有编码过的header、编码过的payload、一个秘钥，签名算法是header中指定的那个，然对它们签名即可。</p>\n<p>例如： </p>\n<pre><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) \n</code></pre><p>签名是用于验证消息在传递过程中有没有被更改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否为它所称的发送方。secret必须保持在服务器，不可泄露。    </p>\n<h3 id=\"Base64URL算法\"><a href=\"#Base64URL算法\" class=\"headerlink\" title=\"Base64URL算法\"></a>Base64URL算法</h3><p>如前所述，JWT头和有效载荷序列化的算法都用到了Base64URL。该算法和常见Base64算法类似，稍有差别。</p>\n<p>作为令牌的JWT可以放在URL中（例如api.example/?token=xxx）。 Base64中用的三个字符是”+”，”/“和”=”，由于在URL中有特殊含义，因此Base64URL中对他们做了替换：”=”去掉，”+”用”-“替换，”/“用”_”替换，这就是Base64URL算法，很简单吧。</p>\n<h2 id=\"jwt工作机制\"><a href=\"#jwt工作机制\" class=\"headerlink\" title=\"jwt工作机制\"></a>jwt工作机制</h2><p>认证的时候，当用户用他们的凭证登录成功后，服务端将会按照上面方式生成一个jwt返回给客户端。此后，该token就是用户的凭证了，后面每次请求都带上该token。你必须要非常小心的保护该token，在客户端保存令牌的时间不能超过令牌的有效时间。</p>\n<p>每次客户端请求受保护的路由或者资源，都得带上该token，一般的，放在Authorization header中，用Bearer schema。</p>\n<p>header应该看起来是这样的：    </p>\n<pre><code>Authorization: Bearer &lt;token&gt;\n</code></pre><p>服务端会在过滤器或者拦截器中，拦截每次请求，并检查Authorization header中的JWT是否有效。如果有效，则可以访问相关资源，否则返回token失效，此时客户端应该要重新登录获取最新的token。   </p>\n<p>如果jwt中包含足够的必要数据，那么可以减少查询数据库的次数。尽管不一定必要。例如，保存用户<code>username</code>到jwt中，而不仅仅保存<code>id</code>,下次服务端接到请求，就可以直接使用<code>username</code>，而不必根据<code>id</code>再查一遍。</p>\n<p>如果token是在授权头（Authorization header）中发送的，那么跨源资源共享(CORS)将不会成为问题，因为它不使用cookie。</p>\n<p>注意：</p>\n<p>1.每一次请求都需要token。<br>2.Token应该放在请求header中。<br>3.我们还需要将服务器设置为接受来自所有域的请求，用Access-Control-Allow-Origin: *。  </p>\n<h2 id=\"JWT与OAuth的区别\"><a href=\"#JWT与OAuth的区别\" class=\"headerlink\" title=\"JWT与OAuth的区别\"></a>JWT与OAuth的区别</h2><p>1.OAuth2是一种授权框架 ，JWT是一种认证协议。<br>2.无论使用哪种方式切记用HTTPS来保证数据的安全性。<br>3.OAuth2用在使用第三方账号登录的情况(比如使用weibo, qq, github登录某个app)，而JWT是用在前后端分离, 需要简单的对后台API进行保护时使用。 </p>\n<h2 id=\"基于Token的身份认证-与-基于服务器的身份认证\"><a href=\"#基于Token的身份认证-与-基于服务器的身份认证\" class=\"headerlink\" title=\"基于Token的身份认证 与 基于服务器的身份认证\"></a>基于Token的身份认证 与 基于服务器的身份认证</h2><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>1、JWT默认不加密，但可以加密。生成原始令牌后，可以使用改令牌再次对其进行加密。</p>\n<p>2、当JWT未加密方法是，一些私密数据无法通过JWT传输。</p>\n<p>3、JWT不仅可用于认证，还可用于信息交换。善用JWT有助于减少服务器请求数据库的次数。</p>\n<p>4、JWT的最大缺点是服务器不保存会话状态，所以在使用期间不可能取消令牌或更改令牌的权限。也就是说，一旦JWT签发，在有效期内将会一直有效。</p>\n<p>5、JWT本身包含认证信息，因此一旦信息泄露，任何人都可以获得令牌的所有权限。为了减少盗用，JWT的有效期不宜设置太长。对于某些重要操作，用户在使用时应该每次都进行进行身份验证。</p>\n<p>6、为了减少盗用和窃取，JWT不建议使用HTTP协议来传输代码，而是使用加密的HTTPS协议进行传输。</p>\n"},{"title":"ubuntu使用常用命令收集","date":"2018-03-01T08:02:21.000Z","_content":"\n记录在使用ubuntu系统过程中常见命令……\n\n## 查看占用端口\n\n`netstat -ln|grep 8388`或者`lsof -i:8388`\n\n## 关闭端口下应用\n\n`kill -9 PID号`\n\n\n## 防火墙\n\n1.安装\n\n`sudo apt-get install ufw` \n\n2.启用\n\n    sudo ufw enable\n    sudo ufw default deny\n    运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n\n3.开启/禁用\n\n    sudo ufw allow|deny [service]\n    打开或关闭某个端口，例如：\n    sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\n    sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\n    sudo ufw allow 53 允许外部访问53端口(tcp/udp)\n    sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\n    sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\n    sudo ufw deny smtp 禁止外部访问smtp服务\n    sudo ufw delete allow smtp 删除上面建立的某条规则\n    \n4.查看防火墙状态\n\n`sudo ufw status`    \n\n开启/关闭防火墙 (默认设置是’disable’)\n\n`# ufw enable|disable`\n\n5.UFW 使用范例：\n\n    允许 53 端口\n    \n    $ sudo ufw allow 53\n    \n    禁用 53 端口\n    \n    $ sudo ufw delete allow 53\n    \n    允许 80 端口\n    \n    $ sudo ufw allow 80/tcp\n    \n    禁用 80 端口\n    \n    $ sudo ufw delete allow 80/tcp\n    \n    允许 smtp 端口\n    \n    $ sudo ufw allow smtp\n    \n    删除 smtp 端口的许可\n    \n    $ sudo ufw delete allow smtp\n    \n    允许某特定 IP\n    \n    $ sudo ufw allow from 192.168.254.254\n    \n    删除上面的规则\n    \n    $ sudo ufw delete allow from 192.168.254.254","source":"_posts/linux-ubuntu-commom.md","raw":"---\ntitle: ubuntu使用常用命令收集\ndate: 2018-03-01 16:02:21\ncategories: ubuntu\ntags:\n---\n\n记录在使用ubuntu系统过程中常见命令……\n\n## 查看占用端口\n\n`netstat -ln|grep 8388`或者`lsof -i:8388`\n\n## 关闭端口下应用\n\n`kill -9 PID号`\n\n\n## 防火墙\n\n1.安装\n\n`sudo apt-get install ufw` \n\n2.启用\n\n    sudo ufw enable\n    sudo ufw default deny\n    运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n\n3.开启/禁用\n\n    sudo ufw allow|deny [service]\n    打开或关闭某个端口，例如：\n    sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\n    sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\n    sudo ufw allow 53 允许外部访问53端口(tcp/udp)\n    sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\n    sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\n    sudo ufw deny smtp 禁止外部访问smtp服务\n    sudo ufw delete allow smtp 删除上面建立的某条规则\n    \n4.查看防火墙状态\n\n`sudo ufw status`    \n\n开启/关闭防火墙 (默认设置是’disable’)\n\n`# ufw enable|disable`\n\n5.UFW 使用范例：\n\n    允许 53 端口\n    \n    $ sudo ufw allow 53\n    \n    禁用 53 端口\n    \n    $ sudo ufw delete allow 53\n    \n    允许 80 端口\n    \n    $ sudo ufw allow 80/tcp\n    \n    禁用 80 端口\n    \n    $ sudo ufw delete allow 80/tcp\n    \n    允许 smtp 端口\n    \n    $ sudo ufw allow smtp\n    \n    删除 smtp 端口的许可\n    \n    $ sudo ufw delete allow smtp\n    \n    允许某特定 IP\n    \n    $ sudo ufw allow from 192.168.254.254\n    \n    删除上面的规则\n    \n    $ sudo ufw delete allow from 192.168.254.254","slug":"linux-ubuntu-commom","published":1,"updated":"2019-06-16T14:38:33.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdd006ng4va1d1rhfgs","content":"<p>记录在使用ubuntu系统过程中常见命令……</p>\n<h2 id=\"查看占用端口\"><a href=\"#查看占用端口\" class=\"headerlink\" title=\"查看占用端口\"></a>查看占用端口</h2><p><code>netstat -ln|grep 8388</code>或者<code>lsof -i:8388</code></p>\n<h2 id=\"关闭端口下应用\"><a href=\"#关闭端口下应用\" class=\"headerlink\" title=\"关闭端口下应用\"></a>关闭端口下应用</h2><p><code>kill -9 PID号</code></p>\n<h2 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h2><p>1.安装</p>\n<p><code>sudo apt-get install ufw</code> </p>\n<p>2.启用</p>\n<pre><code>sudo ufw enable\nsudo ufw default deny\n运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n</code></pre><p>3.开启/禁用</p>\n<pre><code>sudo ufw allow|deny [service]\n打开或关闭某个端口，例如：\nsudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\nsudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\nsudo ufw allow 53 允许外部访问53端口(tcp/udp)\nsudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\nsudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\nsudo ufw deny smtp 禁止外部访问smtp服务\nsudo ufw delete allow smtp 删除上面建立的某条规则\n</code></pre><p>4.查看防火墙状态</p>\n<p><code>sudo ufw status</code>    </p>\n<p>开启/关闭防火墙 (默认设置是’disable’)</p>\n<p><code># ufw enable|disable</code></p>\n<p>5.UFW 使用范例：</p>\n<pre><code>允许 53 端口\n\n$ sudo ufw allow 53\n\n禁用 53 端口\n\n$ sudo ufw delete allow 53\n\n允许 80 端口\n\n$ sudo ufw allow 80/tcp\n\n禁用 80 端口\n\n$ sudo ufw delete allow 80/tcp\n\n允许 smtp 端口\n\n$ sudo ufw allow smtp\n\n删除 smtp 端口的许可\n\n$ sudo ufw delete allow smtp\n\n允许某特定 IP\n\n$ sudo ufw allow from 192.168.254.254\n\n删除上面的规则\n\n$ sudo ufw delete allow from 192.168.254.254\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>记录在使用ubuntu系统过程中常见命令……</p>\n<h2 id=\"查看占用端口\"><a href=\"#查看占用端口\" class=\"headerlink\" title=\"查看占用端口\"></a>查看占用端口</h2><p><code>netstat -ln|grep 8388</code>或者<code>lsof -i:8388</code></p>\n<h2 id=\"关闭端口下应用\"><a href=\"#关闭端口下应用\" class=\"headerlink\" title=\"关闭端口下应用\"></a>关闭端口下应用</h2><p><code>kill -9 PID号</code></p>\n<h2 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h2><p>1.安装</p>\n<p><code>sudo apt-get install ufw</code> </p>\n<p>2.启用</p>\n<pre><code>sudo ufw enable\nsudo ufw default deny\n运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n</code></pre><p>3.开启/禁用</p>\n<pre><code>sudo ufw allow|deny [service]\n打开或关闭某个端口，例如：\nsudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\nsudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\nsudo ufw allow 53 允许外部访问53端口(tcp/udp)\nsudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\nsudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\nsudo ufw deny smtp 禁止外部访问smtp服务\nsudo ufw delete allow smtp 删除上面建立的某条规则\n</code></pre><p>4.查看防火墙状态</p>\n<p><code>sudo ufw status</code>    </p>\n<p>开启/关闭防火墙 (默认设置是’disable’)</p>\n<p><code># ufw enable|disable</code></p>\n<p>5.UFW 使用范例：</p>\n<pre><code>允许 53 端口\n\n$ sudo ufw allow 53\n\n禁用 53 端口\n\n$ sudo ufw delete allow 53\n\n允许 80 端口\n\n$ sudo ufw allow 80/tcp\n\n禁用 80 端口\n\n$ sudo ufw delete allow 80/tcp\n\n允许 smtp 端口\n\n$ sudo ufw allow smtp\n\n删除 smtp 端口的许可\n\n$ sudo ufw delete allow smtp\n\n允许某特定 IP\n\n$ sudo ufw allow from 192.168.254.254\n\n删除上面的规则\n\n$ sudo ufw delete allow from 192.168.254.254\n</code></pre>"},{"title":"ubuntu下使用数据库客户端软件navicat","date":"2018-08-10T02:02:17.000Z","_content":"\n本文记录在ubuntu系统下使用navicat的各种问题……\n\n网址：http://navicat.com.cn/\n\n## 安装\n\n直接打开官网下载即可。\n\n1.下载好，解压，并进入文件根目录。会看到`start_navicat`文件。   \n\n2.启动\n\n把`export LANG=\"en_US.UTF-8\"`这句改为`export LANG=\"zh_CH.UTF-8\"`。    \n\n执行：`./start_navicat`。即可启动。会下载`wine`。   \n\n3.解决乱码\n\n- 给系统安装字体`sudo apt install fonts-wqy-zenhei`。   \n- 启动navicat，点解倒数第三个菜单，选择最后一个选项(options),在第一个tab下，下拉，选择最后一种字体`WenQuanYi Zen Hei Sharp`。  \n- 退出应用，然后重新启动，应该可以看到正确的显示了。\n\n## 破解\n\n进入目录`cd ~/.navicat64`,删除目录下的system.reg文件即可。如果还是不行，可以把整个.navicat64目录删除。然后重启。\n\n## 中文乱码\n\n下载最新中文版本。\n\n第一次进入主界面，乱码。    \n\n点击菜单：工具->选项->常规->界面字体, 下拉选择：AR PL UMing CN.然后关闭，再次启动navicat即可。\n\n--------\n工具-》选项-》常规-》界面字体：Noto Sans CJK TC Regular\n工具-》选项-》编辑器，编辑器字体：Noto Sans CJK SC Bold\n工具-》选项-》记录，网格字体：Noto Sans CJK KR Regular","source":"_posts/linux-ubuntu-navicat.md","raw":"---\ntitle: ubuntu下使用数据库客户端软件navicat\ndate: 2018-08-10 10:02:17\ncategories: ubuntu\ntags: ubuntu-navicat\n---\n\n本文记录在ubuntu系统下使用navicat的各种问题……\n\n网址：http://navicat.com.cn/\n\n## 安装\n\n直接打开官网下载即可。\n\n1.下载好，解压，并进入文件根目录。会看到`start_navicat`文件。   \n\n2.启动\n\n把`export LANG=\"en_US.UTF-8\"`这句改为`export LANG=\"zh_CH.UTF-8\"`。    \n\n执行：`./start_navicat`。即可启动。会下载`wine`。   \n\n3.解决乱码\n\n- 给系统安装字体`sudo apt install fonts-wqy-zenhei`。   \n- 启动navicat，点解倒数第三个菜单，选择最后一个选项(options),在第一个tab下，下拉，选择最后一种字体`WenQuanYi Zen Hei Sharp`。  \n- 退出应用，然后重新启动，应该可以看到正确的显示了。\n\n## 破解\n\n进入目录`cd ~/.navicat64`,删除目录下的system.reg文件即可。如果还是不行，可以把整个.navicat64目录删除。然后重启。\n\n## 中文乱码\n\n下载最新中文版本。\n\n第一次进入主界面，乱码。    \n\n点击菜单：工具->选项->常规->界面字体, 下拉选择：AR PL UMing CN.然后关闭，再次启动navicat即可。\n\n--------\n工具-》选项-》常规-》界面字体：Noto Sans CJK TC Regular\n工具-》选项-》编辑器，编辑器字体：Noto Sans CJK SC Bold\n工具-》选项-》记录，网格字体：Noto Sans CJK KR Regular","slug":"linux-ubuntu-navicat","published":1,"updated":"2019-06-16T14:38:33.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqde006qg4vafmmer3fp","content":"<p>本文记录在ubuntu系统下使用navicat的各种问题……</p>\n<p>网址：<a href=\"http://navicat.com.cn/\" target=\"_blank\" rel=\"noopener\">http://navicat.com.cn/</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>直接打开官网下载即可。</p>\n<p>1.下载好，解压，并进入文件根目录。会看到<code>start_navicat</code>文件。   </p>\n<p>2.启动</p>\n<p>把<code>export LANG=&quot;en_US.UTF-8&quot;</code>这句改为<code>export LANG=&quot;zh_CH.UTF-8&quot;</code>。    </p>\n<p>执行：<code>./start_navicat</code>。即可启动。会下载<code>wine</code>。   </p>\n<p>3.解决乱码</p>\n<ul>\n<li>给系统安装字体<code>sudo apt install fonts-wqy-zenhei</code>。   </li>\n<li>启动navicat，点解倒数第三个菜单，选择最后一个选项(options),在第一个tab下，下拉，选择最后一种字体<code>WenQuanYi Zen Hei Sharp</code>。  </li>\n<li>退出应用，然后重新启动，应该可以看到正确的显示了。</li>\n</ul>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><p>进入目录<code>cd ~/.navicat64</code>,删除目录下的system.reg文件即可。如果还是不行，可以把整个.navicat64目录删除。然后重启。</p>\n<h2 id=\"中文乱码\"><a href=\"#中文乱码\" class=\"headerlink\" title=\"中文乱码\"></a>中文乱码</h2><p>下载最新中文版本。</p>\n<p>第一次进入主界面，乱码。    </p>\n<p>点击菜单：工具-&gt;选项-&gt;常规-&gt;界面字体, 下拉选择：AR PL UMing CN.然后关闭，再次启动navicat即可。</p>\n<hr>\n<p>工具-》选项-》常规-》界面字体：Noto Sans CJK TC Regular<br>工具-》选项-》编辑器，编辑器字体：Noto Sans CJK SC Bold<br>工具-》选项-》记录，网格字体：Noto Sans CJK KR Regular</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录在ubuntu系统下使用navicat的各种问题……</p>\n<p>网址：<a href=\"http://navicat.com.cn/\" target=\"_blank\" rel=\"noopener\">http://navicat.com.cn/</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>直接打开官网下载即可。</p>\n<p>1.下载好，解压，并进入文件根目录。会看到<code>start_navicat</code>文件。   </p>\n<p>2.启动</p>\n<p>把<code>export LANG=&quot;en_US.UTF-8&quot;</code>这句改为<code>export LANG=&quot;zh_CH.UTF-8&quot;</code>。    </p>\n<p>执行：<code>./start_navicat</code>。即可启动。会下载<code>wine</code>。   </p>\n<p>3.解决乱码</p>\n<ul>\n<li>给系统安装字体<code>sudo apt install fonts-wqy-zenhei</code>。   </li>\n<li>启动navicat，点解倒数第三个菜单，选择最后一个选项(options),在第一个tab下，下拉，选择最后一种字体<code>WenQuanYi Zen Hei Sharp</code>。  </li>\n<li>退出应用，然后重新启动，应该可以看到正确的显示了。</li>\n</ul>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><p>进入目录<code>cd ~/.navicat64</code>,删除目录下的system.reg文件即可。如果还是不行，可以把整个.navicat64目录删除。然后重启。</p>\n<h2 id=\"中文乱码\"><a href=\"#中文乱码\" class=\"headerlink\" title=\"中文乱码\"></a>中文乱码</h2><p>下载最新中文版本。</p>\n<p>第一次进入主界面，乱码。    </p>\n<p>点击菜单：工具-&gt;选项-&gt;常规-&gt;界面字体, 下拉选择：AR PL UMing CN.然后关闭，再次启动navicat即可。</p>\n<hr>\n<p>工具-》选项-》常规-》界面字体：Noto Sans CJK TC Regular<br>工具-》选项-》编辑器，编辑器字体：Noto Sans CJK SC Bold<br>工具-》选项-》记录，网格字体：Noto Sans CJK KR Regular</p>\n"},{"title":"linux常用命令使用收藏","date":"2017-10-14T03:26:18.000Z","_content":"收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n## 4. 开机启动命令-chkconfig\n\n## 5. 文档操作\n### 5.1 复制文件-cp命令使用\n1. 文件到文件复制\n> 将文档a复制成b（相当于备份并改名）。\ncp -i a b\n或，\ncp a b\n\n2. 文件到目录复制\n>将文档 file1复制到dir1目录下，复制后名称仍未file1\ncp -i file1 dir1\n或，\ncp file1 dir1\n\n3. 目录到目录复制\n>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2\ncp -r dir1 dir2\n将目录dir1下所有文件包括文件夹，都复制到dir2目录下\ncp -r dir1/*.* dir2\n常见错误：\n1、提示cp: omitting directory错误\n复制目录时，使用-r选项即可递归拷贝，如下：\ncp -r dir1 dir2\n\n## 6. 解压/压缩\n### 6.1 压缩\n> 压缩\n  tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg\n  tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n  tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n  tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n  rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux\n  zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux\n  \n### 6.2 解压\n> 解压\n  tar –xvf file.tar //解压 tar包\n  tar -xzvf file.tar.gz //解压tar.gz\n  tar -xjvf file.tar.bz2   //解压 tar.bz2\n  tar –xZvf file.tar.Z   //解压tar.Z\n  unrar e file.rar //解压rar\n  unzip file.zip //解压zip\n  \n### 6.3 ubuntu 下rar解压工具安装方法：\n \n> 1、压缩功能\n 安装 sudo apt-get install rar\n 卸载 sudo apt-get remove rar\n 2、解压功能\n 安装 sudo apt-get install unrar\n 卸载 sudo apt-get remove unrar\n 压缩解压缩.rar\n 解压：rar x FileName.rar\n 压缩：rar a FileName.rar DirName  \n  \n### 6.4 总结\n> 1、`*.tar` 用 tar –xvf 解压\n  2、`*.gz` 用 gzip -d或者gunzip 解压\n  3、`*.tar.gz`和`*.tgz` 用 tar –xzf 解压\n  4、`*.bz2` 用 bzip2 -d或者用bunzip2 解压\n  5、`*.tar.bz2`用tar –xjf 解压\n  6、`*.Z` 用 uncompress 解压\n  7、`*.tar.Z` 用tar –xZf 解压\n  8、`*.rar` 用 unrar e解压\n  9、`*.zip` 用 unzip 解压    \n\n\n## 配置环境变量\n\n例子： \n\n    ########  JAVA_HOME #######\n    JAVA_HOME=/server/java/jdk\n    export JAVA_HOME\n    PATH=$JAVA_HOME/bin:$JAVA_HOME/include:$JAVA_HOME/include/linux:$PATH\n    export PATH\n    CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n    export CLASSPATH\n    \n    \n    ########  MySQL #######\n    MYSQL_HOME=/server/databases/mysql-3810\n    export MYSQL_HOME\n    PATH=$MYSQL_HOME/bin:$PATH\n    export PATH\n    \n##  SELinux 使用  \n\nhttps://blog.csdn.net/yanjun821126/article/details/80828908     \n\n#### selinux 开启和关闭\n\n1.查看开启状态\n\n    /usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态   \n    \n    -------------------------------\n    \n    [root@xr-server selinux]# /usr/sbin/sestatus -v \n    SELinux status:                 enabled\n    SELinuxfs mount:                /sys/fs/selinux\n    SELinux root directory:         /etc/selinux\n    Loaded policy name:             targeted\n    Current mode:                   enforcing\n    Mode from config file:          enforcing\n    Policy MLS status:              enabled\n    Policy deny_unknown status:     allowed\n    Max kernel policy version:      31\n    \n    Process contexts:\n    Current context:                unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\n    Init context:                   system_u:system_r:init_t:s0\n    /usr/sbin/sshd                  system_u:system_r:sshd_t:s0-s0:c0.c1023\n    \n    File contexts:\n    Controlling terminal:           unconfined_u:object_r:user_devpts_t:s0\n    /etc/passwd                     system_u:object_r:passwd_file_t:s0\n    /etc/shadow                     system_u:object_r:shadow_t:s0\n    /bin/bash                       system_u:object_r:shell_exec_t:s0\n    /bin/login                      system_u:object_r:login_exec_t:s0\n    /bin/sh                         system_u:object_r:bin_t:s0 -> system_u:object_r:shell_exec_t:s0\n    /sbin/agetty                    system_u:object_r:getty_exec_t:s0\n    /sbin/init                      system_u:object_r:bin_t:s0 -> system_u:object_r:init_exec_t:s0\n    /usr/sbin/sshd                  system_u:object_r:sshd_exec_t:s0\n\n也可以用下面命令查看：\n\n    [root@xr-server selinux]# getenforce \n    Enforcing\n    \n#### 关闭\n\n\n1.临时关闭（不需要重启系统）\n\n    setenforce 0  ##设置SELinux 成为permissive模式\n    \n    -----------------------------------------------------\n    setenforce 1  ##设置SELinux 成为enforcing模式（开启）\n    \n2.修改配置文件关闭（需要重启系统）\n\n修改/etc/selinux/config 文件\n\n将SELINUX=enforcing改为SELINUX=disabled\n\n然后重启系统即可。\n\n## 免密码切换到root用户\n\n Linux下普通用户切换到root用户下，默认情况是需要输入密码，这在自动化脚本里面很不方便，因此需要实现普通用户免密切换到root用户。\n\n解决方案：\n\n- 以root用户登录shell终端，执行vim /etc/sudoers命令，找到如下图所示位置：   \n\n      \n- 在下方添加一行类似的数据，例如用户名称为elk,则添加内容为：\n  \n        ## Allow root to run any commands anywhere \n        root\tALL=(ALL) \tALL\n        vagrant    ALL=(ALL)       ALL\n    \nvagrant是用户名。在vagrant下，执行sudo -s就可以直接切换到root了。其它的账号类似。\n\n           \n- 保存之后，在普通用户下输入sudo -s命令就可以直接免密切换到root账户了。       \n    \n            ","source":"_posts/linux-command-use.md","raw":"---\ntitle: linux常用命令使用收藏\ndate: 2017-10-14 11:26:18\ncategories: linux\ntags: linux-command\n---\n收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n## 4. 开机启动命令-chkconfig\n\n## 5. 文档操作\n### 5.1 复制文件-cp命令使用\n1. 文件到文件复制\n> 将文档a复制成b（相当于备份并改名）。\ncp -i a b\n或，\ncp a b\n\n2. 文件到目录复制\n>将文档 file1复制到dir1目录下，复制后名称仍未file1\ncp -i file1 dir1\n或，\ncp file1 dir1\n\n3. 目录到目录复制\n>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2\ncp -r dir1 dir2\n将目录dir1下所有文件包括文件夹，都复制到dir2目录下\ncp -r dir1/*.* dir2\n常见错误：\n1、提示cp: omitting directory错误\n复制目录时，使用-r选项即可递归拷贝，如下：\ncp -r dir1 dir2\n\n## 6. 解压/压缩\n### 6.1 压缩\n> 压缩\n  tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg\n  tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n  tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n  tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n  rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux\n  zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux\n  \n### 6.2 解压\n> 解压\n  tar –xvf file.tar //解压 tar包\n  tar -xzvf file.tar.gz //解压tar.gz\n  tar -xjvf file.tar.bz2   //解压 tar.bz2\n  tar –xZvf file.tar.Z   //解压tar.Z\n  unrar e file.rar //解压rar\n  unzip file.zip //解压zip\n  \n### 6.3 ubuntu 下rar解压工具安装方法：\n \n> 1、压缩功能\n 安装 sudo apt-get install rar\n 卸载 sudo apt-get remove rar\n 2、解压功能\n 安装 sudo apt-get install unrar\n 卸载 sudo apt-get remove unrar\n 压缩解压缩.rar\n 解压：rar x FileName.rar\n 压缩：rar a FileName.rar DirName  \n  \n### 6.4 总结\n> 1、`*.tar` 用 tar –xvf 解压\n  2、`*.gz` 用 gzip -d或者gunzip 解压\n  3、`*.tar.gz`和`*.tgz` 用 tar –xzf 解压\n  4、`*.bz2` 用 bzip2 -d或者用bunzip2 解压\n  5、`*.tar.bz2`用tar –xjf 解压\n  6、`*.Z` 用 uncompress 解压\n  7、`*.tar.Z` 用tar –xZf 解压\n  8、`*.rar` 用 unrar e解压\n  9、`*.zip` 用 unzip 解压    \n\n\n## 配置环境变量\n\n例子： \n\n    ########  JAVA_HOME #######\n    JAVA_HOME=/server/java/jdk\n    export JAVA_HOME\n    PATH=$JAVA_HOME/bin:$JAVA_HOME/include:$JAVA_HOME/include/linux:$PATH\n    export PATH\n    CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\n    export CLASSPATH\n    \n    \n    ########  MySQL #######\n    MYSQL_HOME=/server/databases/mysql-3810\n    export MYSQL_HOME\n    PATH=$MYSQL_HOME/bin:$PATH\n    export PATH\n    \n##  SELinux 使用  \n\nhttps://blog.csdn.net/yanjun821126/article/details/80828908     \n\n#### selinux 开启和关闭\n\n1.查看开启状态\n\n    /usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态   \n    \n    -------------------------------\n    \n    [root@xr-server selinux]# /usr/sbin/sestatus -v \n    SELinux status:                 enabled\n    SELinuxfs mount:                /sys/fs/selinux\n    SELinux root directory:         /etc/selinux\n    Loaded policy name:             targeted\n    Current mode:                   enforcing\n    Mode from config file:          enforcing\n    Policy MLS status:              enabled\n    Policy deny_unknown status:     allowed\n    Max kernel policy version:      31\n    \n    Process contexts:\n    Current context:                unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\n    Init context:                   system_u:system_r:init_t:s0\n    /usr/sbin/sshd                  system_u:system_r:sshd_t:s0-s0:c0.c1023\n    \n    File contexts:\n    Controlling terminal:           unconfined_u:object_r:user_devpts_t:s0\n    /etc/passwd                     system_u:object_r:passwd_file_t:s0\n    /etc/shadow                     system_u:object_r:shadow_t:s0\n    /bin/bash                       system_u:object_r:shell_exec_t:s0\n    /bin/login                      system_u:object_r:login_exec_t:s0\n    /bin/sh                         system_u:object_r:bin_t:s0 -> system_u:object_r:shell_exec_t:s0\n    /sbin/agetty                    system_u:object_r:getty_exec_t:s0\n    /sbin/init                      system_u:object_r:bin_t:s0 -> system_u:object_r:init_exec_t:s0\n    /usr/sbin/sshd                  system_u:object_r:sshd_exec_t:s0\n\n也可以用下面命令查看：\n\n    [root@xr-server selinux]# getenforce \n    Enforcing\n    \n#### 关闭\n\n\n1.临时关闭（不需要重启系统）\n\n    setenforce 0  ##设置SELinux 成为permissive模式\n    \n    -----------------------------------------------------\n    setenforce 1  ##设置SELinux 成为enforcing模式（开启）\n    \n2.修改配置文件关闭（需要重启系统）\n\n修改/etc/selinux/config 文件\n\n将SELINUX=enforcing改为SELINUX=disabled\n\n然后重启系统即可。\n\n## 免密码切换到root用户\n\n Linux下普通用户切换到root用户下，默认情况是需要输入密码，这在自动化脚本里面很不方便，因此需要实现普通用户免密切换到root用户。\n\n解决方案：\n\n- 以root用户登录shell终端，执行vim /etc/sudoers命令，找到如下图所示位置：   \n\n      \n- 在下方添加一行类似的数据，例如用户名称为elk,则添加内容为：\n  \n        ## Allow root to run any commands anywhere \n        root\tALL=(ALL) \tALL\n        vagrant    ALL=(ALL)       ALL\n    \nvagrant是用户名。在vagrant下，执行sudo -s就可以直接切换到root了。其它的账号类似。\n\n           \n- 保存之后，在普通用户下输入sudo -s命令就可以直接免密切换到root账户了。       \n    \n            ","slug":"linux-command-use","published":1,"updated":"2019-06-16T14:38:33.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdf006tg4va8nkbua1j","content":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p>_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p>_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2><h2 id=\"4-开机启动命令-chkconfig\"><a href=\"#4-开机启动命令-chkconfig\" class=\"headerlink\" title=\"4. 开机启动命令-chkconfig\"></a>4. 开机启动命令-chkconfig</h2><h2 id=\"5-文档操作\"><a href=\"#5-文档操作\" class=\"headerlink\" title=\"5. 文档操作\"></a>5. 文档操作</h2><h3 id=\"5-1-复制文件-cp命令使用\"><a href=\"#5-1-复制文件-cp命令使用\" class=\"headerlink\" title=\"5.1 复制文件-cp命令使用\"></a>5.1 复制文件-cp命令使用</h3><ol>\n<li><p>文件到文件复制</p>\n<blockquote>\n<p>将文档a复制成b（相当于备份并改名）。<br>cp -i a b<br>或，<br>cp a b</p>\n</blockquote>\n</li>\n<li><p>文件到目录复制</p>\n<blockquote>\n<p>将文档 file1复制到dir1目录下，复制后名称仍未file1<br>cp -i file1 dir1<br>或，<br>cp file1 dir1</p>\n</blockquote>\n</li>\n<li><p>目录到目录复制</p>\n<blockquote>\n<p>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2<br>cp -r dir1 dir2<br>将目录dir1下所有文件包括文件夹，都复制到dir2目录下<br>cp -r dir1/<em>.</em> dir2<br>常见错误：<br>1、提示cp: omitting directory错误<br>复制目录时，使用-r选项即可递归拷贝，如下：<br>cp -r dir1 dir2</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"6-解压-压缩\"><a href=\"#6-解压-压缩\" class=\"headerlink\" title=\"6. 解压/压缩\"></a>6. 解压/压缩</h2><h3 id=\"6-1-压缩\"><a href=\"#6-1-压缩\" class=\"headerlink\" title=\"6.1 压缩\"></a>6.1 压缩</h3><blockquote>\n<p>压缩<br>  tar –cvf jpg.tar <em>.jpg //将目录里所有jpg文件打包成tar.jpg<br>  tar –czf jpg.tar.gz </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>  tar –cjf jpg.tar.bz2 <em>.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>  tar –cZf jpg.tar.Z </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>  rar a jpg.rar <em>.jpg //rar格式的压缩，需要先下载rar for linux<br>  zip jpg.zip </em>.jpg //zip格式的压缩，需要先下载zip for linux</p>\n</blockquote>\n<h3 id=\"6-2-解压\"><a href=\"#6-2-解压\" class=\"headerlink\" title=\"6.2 解压\"></a>6.2 解压</h3><blockquote>\n<p>解压<br>  tar –xvf file.tar //解压 tar包<br>  tar -xzvf file.tar.gz //解压tar.gz<br>  tar -xjvf file.tar.bz2   //解压 tar.bz2<br>  tar –xZvf file.tar.Z   //解压tar.Z<br>  unrar e file.rar //解压rar<br>  unzip file.zip //解压zip</p>\n</blockquote>\n<h3 id=\"6-3-ubuntu-下rar解压工具安装方法：\"><a href=\"#6-3-ubuntu-下rar解压工具安装方法：\" class=\"headerlink\" title=\"6.3 ubuntu 下rar解压工具安装方法：\"></a>6.3 ubuntu 下rar解压工具安装方法：</h3><blockquote>\n<p>1、压缩功能<br> 安装 sudo apt-get install rar<br> 卸载 sudo apt-get remove rar<br> 2、解压功能<br> 安装 sudo apt-get install unrar<br> 卸载 sudo apt-get remove unrar<br> 压缩解压缩.rar<br> 解压：rar x FileName.rar<br> 压缩：rar a FileName.rar DirName  </p>\n</blockquote>\n<h3 id=\"6-4-总结\"><a href=\"#6-4-总结\" class=\"headerlink\" title=\"6.4 总结\"></a>6.4 总结</h3><blockquote>\n<p>1、<code>*.tar</code> 用 tar –xvf 解压<br>  2、<code>*.gz</code> 用 gzip -d或者gunzip 解压<br>  3、<code>*.tar.gz</code>和<code>*.tgz</code> 用 tar –xzf 解压<br>  4、<code>*.bz2</code> 用 bzip2 -d或者用bunzip2 解压<br>  5、<code>*.tar.bz2</code>用tar –xjf 解压<br>  6、<code>*.Z</code> 用 uncompress 解压<br>  7、<code>*.tar.Z</code> 用tar –xZf 解压<br>  8、<code>*.rar</code> 用 unrar e解压<br>  9、<code>*.zip</code> 用 unzip 解压    </p>\n</blockquote>\n<h2 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h2><p>例子： </p>\n<pre><code>########  JAVA_HOME #######\nJAVA_HOME=/server/java/jdk\nexport JAVA_HOME\nPATH=$JAVA_HOME/bin:$JAVA_HOME/include:$JAVA_HOME/include/linux:$PATH\nexport PATH\nCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport CLASSPATH\n\n\n########  MySQL #######\nMYSQL_HOME=/server/databases/mysql-3810\nexport MYSQL_HOME\nPATH=$MYSQL_HOME/bin:$PATH\nexport PATH\n</code></pre><h2 id=\"SELinux-使用\"><a href=\"#SELinux-使用\" class=\"headerlink\" title=\"SELinux 使用\"></a>SELinux 使用</h2><p><a href=\"https://blog.csdn.net/yanjun821126/article/details/80828908\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yanjun821126/article/details/80828908</a>     </p>\n<h4 id=\"selinux-开启和关闭\"><a href=\"#selinux-开启和关闭\" class=\"headerlink\" title=\"selinux 开启和关闭\"></a>selinux 开启和关闭</h4><p>1.查看开启状态</p>\n<pre><code>/usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态   \n\n-------------------------------\n\n[root@xr-server selinux]# /usr/sbin/sestatus -v \nSELinux status:                 enabled\nSELinuxfs mount:                /sys/fs/selinux\nSELinux root directory:         /etc/selinux\nLoaded policy name:             targeted\nCurrent mode:                   enforcing\nMode from config file:          enforcing\nPolicy MLS status:              enabled\nPolicy deny_unknown status:     allowed\nMax kernel policy version:      31\n\nProcess contexts:\nCurrent context:                unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\nInit context:                   system_u:system_r:init_t:s0\n/usr/sbin/sshd                  system_u:system_r:sshd_t:s0-s0:c0.c1023\n\nFile contexts:\nControlling terminal:           unconfined_u:object_r:user_devpts_t:s0\n/etc/passwd                     system_u:object_r:passwd_file_t:s0\n/etc/shadow                     system_u:object_r:shadow_t:s0\n/bin/bash                       system_u:object_r:shell_exec_t:s0\n/bin/login                      system_u:object_r:login_exec_t:s0\n/bin/sh                         system_u:object_r:bin_t:s0 -&gt; system_u:object_r:shell_exec_t:s0\n/sbin/agetty                    system_u:object_r:getty_exec_t:s0\n/sbin/init                      system_u:object_r:bin_t:s0 -&gt; system_u:object_r:init_exec_t:s0\n/usr/sbin/sshd                  system_u:object_r:sshd_exec_t:s0\n</code></pre><p>也可以用下面命令查看：</p>\n<pre><code>[root@xr-server selinux]# getenforce \nEnforcing\n</code></pre><h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>1.临时关闭（不需要重启系统）</p>\n<pre><code>setenforce 0  ##设置SELinux 成为permissive模式\n\n-----------------------------------------------------\nsetenforce 1  ##设置SELinux 成为enforcing模式（开启）\n</code></pre><p>2.修改配置文件关闭（需要重启系统）</p>\n<p>修改/etc/selinux/config 文件</p>\n<p>将SELINUX=enforcing改为SELINUX=disabled</p>\n<p>然后重启系统即可。</p>\n<h2 id=\"免密码切换到root用户\"><a href=\"#免密码切换到root用户\" class=\"headerlink\" title=\"免密码切换到root用户\"></a>免密码切换到root用户</h2><p> Linux下普通用户切换到root用户下，默认情况是需要输入密码，这在自动化脚本里面很不方便，因此需要实现普通用户免密切换到root用户。</p>\n<p>解决方案：</p>\n<ul>\n<li>以root用户登录shell终端，执行vim /etc/sudoers命令，找到如下图所示位置：   </li>\n</ul>\n<ul>\n<li><p>在下方添加一行类似的数据，例如用户名称为elk,则添加内容为：</p>\n<pre><code>## Allow root to run any commands anywhere \nroot    ALL=(ALL)     ALL\nvagrant    ALL=(ALL)       ALL\n</code></pre></li>\n</ul>\n<p>vagrant是用户名。在vagrant下，执行sudo -s就可以直接切换到root了。其它的账号类似。</p>\n<ul>\n<li>保存之后，在普通用户下输入sudo -s命令就可以直接免密切换到root账户了。       </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p>_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p>_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2><h2 id=\"4-开机启动命令-chkconfig\"><a href=\"#4-开机启动命令-chkconfig\" class=\"headerlink\" title=\"4. 开机启动命令-chkconfig\"></a>4. 开机启动命令-chkconfig</h2><h2 id=\"5-文档操作\"><a href=\"#5-文档操作\" class=\"headerlink\" title=\"5. 文档操作\"></a>5. 文档操作</h2><h3 id=\"5-1-复制文件-cp命令使用\"><a href=\"#5-1-复制文件-cp命令使用\" class=\"headerlink\" title=\"5.1 复制文件-cp命令使用\"></a>5.1 复制文件-cp命令使用</h3><ol>\n<li><p>文件到文件复制</p>\n<blockquote>\n<p>将文档a复制成b（相当于备份并改名）。<br>cp -i a b<br>或，<br>cp a b</p>\n</blockquote>\n</li>\n<li><p>文件到目录复制</p>\n<blockquote>\n<p>将文档 file1复制到dir1目录下，复制后名称仍未file1<br>cp -i file1 dir1<br>或，<br>cp file1 dir1</p>\n</blockquote>\n</li>\n<li><p>目录到目录复制</p>\n<blockquote>\n<p>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2<br>cp -r dir1 dir2<br>将目录dir1下所有文件包括文件夹，都复制到dir2目录下<br>cp -r dir1/<em>.</em> dir2<br>常见错误：<br>1、提示cp: omitting directory错误<br>复制目录时，使用-r选项即可递归拷贝，如下：<br>cp -r dir1 dir2</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"6-解压-压缩\"><a href=\"#6-解压-压缩\" class=\"headerlink\" title=\"6. 解压/压缩\"></a>6. 解压/压缩</h2><h3 id=\"6-1-压缩\"><a href=\"#6-1-压缩\" class=\"headerlink\" title=\"6.1 压缩\"></a>6.1 压缩</h3><blockquote>\n<p>压缩<br>  tar –cvf jpg.tar <em>.jpg //将目录里所有jpg文件打包成tar.jpg<br>  tar –czf jpg.tar.gz </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>  tar –cjf jpg.tar.bz2 <em>.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>  tar –cZf jpg.tar.Z </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>  rar a jpg.rar <em>.jpg //rar格式的压缩，需要先下载rar for linux<br>  zip jpg.zip </em>.jpg //zip格式的压缩，需要先下载zip for linux</p>\n</blockquote>\n<h3 id=\"6-2-解压\"><a href=\"#6-2-解压\" class=\"headerlink\" title=\"6.2 解压\"></a>6.2 解压</h3><blockquote>\n<p>解压<br>  tar –xvf file.tar //解压 tar包<br>  tar -xzvf file.tar.gz //解压tar.gz<br>  tar -xjvf file.tar.bz2   //解压 tar.bz2<br>  tar –xZvf file.tar.Z   //解压tar.Z<br>  unrar e file.rar //解压rar<br>  unzip file.zip //解压zip</p>\n</blockquote>\n<h3 id=\"6-3-ubuntu-下rar解压工具安装方法：\"><a href=\"#6-3-ubuntu-下rar解压工具安装方法：\" class=\"headerlink\" title=\"6.3 ubuntu 下rar解压工具安装方法：\"></a>6.3 ubuntu 下rar解压工具安装方法：</h3><blockquote>\n<p>1、压缩功能<br> 安装 sudo apt-get install rar<br> 卸载 sudo apt-get remove rar<br> 2、解压功能<br> 安装 sudo apt-get install unrar<br> 卸载 sudo apt-get remove unrar<br> 压缩解压缩.rar<br> 解压：rar x FileName.rar<br> 压缩：rar a FileName.rar DirName  </p>\n</blockquote>\n<h3 id=\"6-4-总结\"><a href=\"#6-4-总结\" class=\"headerlink\" title=\"6.4 总结\"></a>6.4 总结</h3><blockquote>\n<p>1、<code>*.tar</code> 用 tar –xvf 解压<br>  2、<code>*.gz</code> 用 gzip -d或者gunzip 解压<br>  3、<code>*.tar.gz</code>和<code>*.tgz</code> 用 tar –xzf 解压<br>  4、<code>*.bz2</code> 用 bzip2 -d或者用bunzip2 解压<br>  5、<code>*.tar.bz2</code>用tar –xjf 解压<br>  6、<code>*.Z</code> 用 uncompress 解压<br>  7、<code>*.tar.Z</code> 用tar –xZf 解压<br>  8、<code>*.rar</code> 用 unrar e解压<br>  9、<code>*.zip</code> 用 unzip 解压    </p>\n</blockquote>\n<h2 id=\"配置环境变量\"><a href=\"#配置环境变量\" class=\"headerlink\" title=\"配置环境变量\"></a>配置环境变量</h2><p>例子： </p>\n<pre><code>########  JAVA_HOME #######\nJAVA_HOME=/server/java/jdk\nexport JAVA_HOME\nPATH=$JAVA_HOME/bin:$JAVA_HOME/include:$JAVA_HOME/include/linux:$PATH\nexport PATH\nCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar\nexport CLASSPATH\n\n\n########  MySQL #######\nMYSQL_HOME=/server/databases/mysql-3810\nexport MYSQL_HOME\nPATH=$MYSQL_HOME/bin:$PATH\nexport PATH\n</code></pre><h2 id=\"SELinux-使用\"><a href=\"#SELinux-使用\" class=\"headerlink\" title=\"SELinux 使用\"></a>SELinux 使用</h2><p><a href=\"https://blog.csdn.net/yanjun821126/article/details/80828908\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/yanjun821126/article/details/80828908</a>     </p>\n<h4 id=\"selinux-开启和关闭\"><a href=\"#selinux-开启和关闭\" class=\"headerlink\" title=\"selinux 开启和关闭\"></a>selinux 开启和关闭</h4><p>1.查看开启状态</p>\n<pre><code>/usr/sbin/sestatus -v      ##如果SELinux status参数为enabled即为开启状态   \n\n-------------------------------\n\n[root@xr-server selinux]# /usr/sbin/sestatus -v \nSELinux status:                 enabled\nSELinuxfs mount:                /sys/fs/selinux\nSELinux root directory:         /etc/selinux\nLoaded policy name:             targeted\nCurrent mode:                   enforcing\nMode from config file:          enforcing\nPolicy MLS status:              enabled\nPolicy deny_unknown status:     allowed\nMax kernel policy version:      31\n\nProcess contexts:\nCurrent context:                unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023\nInit context:                   system_u:system_r:init_t:s0\n/usr/sbin/sshd                  system_u:system_r:sshd_t:s0-s0:c0.c1023\n\nFile contexts:\nControlling terminal:           unconfined_u:object_r:user_devpts_t:s0\n/etc/passwd                     system_u:object_r:passwd_file_t:s0\n/etc/shadow                     system_u:object_r:shadow_t:s0\n/bin/bash                       system_u:object_r:shell_exec_t:s0\n/bin/login                      system_u:object_r:login_exec_t:s0\n/bin/sh                         system_u:object_r:bin_t:s0 -&gt; system_u:object_r:shell_exec_t:s0\n/sbin/agetty                    system_u:object_r:getty_exec_t:s0\n/sbin/init                      system_u:object_r:bin_t:s0 -&gt; system_u:object_r:init_exec_t:s0\n/usr/sbin/sshd                  system_u:object_r:sshd_exec_t:s0\n</code></pre><p>也可以用下面命令查看：</p>\n<pre><code>[root@xr-server selinux]# getenforce \nEnforcing\n</code></pre><h4 id=\"关闭\"><a href=\"#关闭\" class=\"headerlink\" title=\"关闭\"></a>关闭</h4><p>1.临时关闭（不需要重启系统）</p>\n<pre><code>setenforce 0  ##设置SELinux 成为permissive模式\n\n-----------------------------------------------------\nsetenforce 1  ##设置SELinux 成为enforcing模式（开启）\n</code></pre><p>2.修改配置文件关闭（需要重启系统）</p>\n<p>修改/etc/selinux/config 文件</p>\n<p>将SELINUX=enforcing改为SELINUX=disabled</p>\n<p>然后重启系统即可。</p>\n<h2 id=\"免密码切换到root用户\"><a href=\"#免密码切换到root用户\" class=\"headerlink\" title=\"免密码切换到root用户\"></a>免密码切换到root用户</h2><p> Linux下普通用户切换到root用户下，默认情况是需要输入密码，这在自动化脚本里面很不方便，因此需要实现普通用户免密切换到root用户。</p>\n<p>解决方案：</p>\n<ul>\n<li>以root用户登录shell终端，执行vim /etc/sudoers命令，找到如下图所示位置：   </li>\n</ul>\n<ul>\n<li><p>在下方添加一行类似的数据，例如用户名称为elk,则添加内容为：</p>\n<pre><code>## Allow root to run any commands anywhere \nroot    ALL=(ALL)     ALL\nvagrant    ALL=(ALL)       ALL\n</code></pre></li>\n</ul>\n<p>vagrant是用户名。在vagrant下，执行sudo -s就可以直接切换到root了。其它的账号类似。</p>\n<ul>\n<li>保存之后，在普通用户下输入sudo -s命令就可以直接免密切换到root账户了。       </li>\n</ul>\n"},{"title":"maven构建jar上传到nexus私服并拉取","date":"2018-12-30T06:57:05.000Z","_content":"\n公司内部有很多自己的java lib库等共用代码，为了在公司内部自由共享这些资源，所以需要搭建maven私服。下面介绍利用maven构建java项目为jar包并上传到nexus私服，以及在其它项目中如何引用私服中的jar包。\n\n\n## nexus3的安装\n\n这里不做介绍，参考章节{%post_link centos-maven-nexus%},或者{%post_link docker-app-install%}。 \n\n## 新建maven2仓库\n\n{%asset_img a-1.png%}\n\n说明：\n\n- 仓库名称：ymu-hosted，类型为hosted。maven仓库有三种类型，hosted、proxy、group。hosted代表私服本机服务器，proxy代理外部仓库服务器，group整合各个hosted和proxy，按顺序策略获取jar。\n- 这里选择Version policy为：Release。正式发布版本。正式发布版本都上传到这里来。\n- Deployment policy: 选择为Allow Redeploy，可重复发布。代表同一个版本号的jar可以多次发布。这样就不必要设置快照仓库了，项目小改动也作为正式版本发布上去，不必要修改版本号。\n\n\n## maven构建jar并上传到私服相应仓库\n\n### 配置pom.xml\n\n    <!--mavne 发布-->\n    <distributionManagement>\n        <snapshotRepository>\n            <id>snapshots</id>\n            <name>maven-snapshots</name>\n            <url>http://ip:8085/repository/maven-snapshots/</url>\n        </snapshotRepository>\n        <repository>\n            <id>repository</id>\n            <name>ymu-hosted</name>\n            <url>http://ip:8085/repository/ymu-hosted/</url>\n        </repository>\n    </distributionManagement>\n\n说明： \n-  snapshotRepository：指定jar包要发布的快照仓库。版本号这样`0.0.1-SNAPSHOT`，代表的是快照版本，后缀的`SNAPSHOT`必须是大写，不能是小写。\n- repository：指定jar包发布上去的正式版本仓库。当版本号是这样`<version>0.0.2</version>`，没有`SNAPSHOT`的时候，jar将发布到这里指定的私服仓库ymu-hosted下。\n- id：对应maven配置setting.xml中的配置。保持id一致。远程仓库的唯一标志，很重要。\n- name：只是方便阅读，随意定义。   \n- url：仓库地址。登录nexus，在配置中可以查看。\n\n### 配置setting.xml\n\n    <server>\n      <id>repository</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n\n    <server>\n      <id>snapshots</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n\n配置完成后，执行`mvn deploy`命令，就可以发布jar到私服了。修改版本号，可以实际验证查看发布到哪个仓库下。 \n\n\n## 从nexus私服下载构件\n\n配置pom.xml:\n\n    <repositories>\n        <!--自己私仓,下载jar-->\n        <repository>\n            <id>ymu-public</id>\n            <name>ymu nexus</name>\n            <url>http://119.145.41.171:8085/repository/maven-public/</url>\n            <snapshots>\n                <enabled>true</enabled>\n            </snapshots>\n            <releases>\n                <enabled>true</enabled>\n            </releases>\n        </repository>\n\n        \n    </repositories>\n\n    <pluginRepositories>\n        <!--私服，插件-->\n        <pluginRepository>\n            <id>ymu-public</id>\n            <name>ymu nexus</name>\n            <url>http://119.145.41.171:8085/repository/maven-public/</url>\n            <snapshots>\n                <enabled>true</enabled>\n            </snapshots>\n        </pluginRepository>\n        \n    </pluginRepositories>\n\n看上面配置，我们配置自己的私服用的是`maven-public`仓库，该仓库是group类型，整合了自己的私仓等，如下图：\n\n{%asset_img a-2.png%}\n\n看Group组，我们可以看到Member里面有很多个仓库，这代表，拉取jar构件的时候，首先从私服本机拉取，拉取不到的话再从下一个拉取，按顺序处理。从maven中央仓库拉取的jar构件都会缓存到其它仓库。  \n\n以上，我们看到的配置在pom.xml中，只针对某个项目有效。如果是多个项目想都通用私服，则可以在maven的setting.xml中配置:\n\n    <settings>\n      <mirrors>\n        <mirror>\n          <!--This sends everything else to /public -->\n          <id>nexus</id>\n          <mirrorOf>*</mirrorOf>\n          <url>http://localhost:8081/repository/maven-public/</url>\n        </mirror>\n      </mirrors>\n      <profiles>\n        <profile>\n          <id>nexus</id>\n          <!--Enable snapshots for the built in central repo to direct -->\n          <!--all requests to nexus via the mirror -->\n          <repositories>\n            <repository>\n              <id>central</id>\n              <url>http://central</url>\n              <releases><enabled>true</enabled></releases>\n              <snapshots><enabled>true</enabled></snapshots>\n            </repository>\n          </repositories>\n         <pluginRepositories>\n            <pluginRepository>\n              <id>central</id>\n              <url>http://central</url>\n              <releases><enabled>true</enabled></releases>\n              <snapshots><enabled>true</enabled></snapshots>\n            </pluginRepository>\n          </pluginRepositories>\n        </profile>\n      </profiles>\n      <activeProfiles>\n        <!--make the profile active all the time -->\n        <activeProfile>nexus</activeProfile>\n      </activeProfiles>\n    </settings>\n    \n这样子就可以全局引用了，所有项目都是从配置的私服以及其它第三方私服下载构件。不用在每个项目的pom.xml中配置了。  \n第三方的私服，可以添加proxy私仓，然后整合进去group里面。  \n\n\n## 上传第三个jar包到nexus私服中\n\n### 方法一：在nexus3界面直接操作\n\n{%asset_img a-3.png%}\n\n如上图，点击`maven-releases`仓库，进入下面图：\n\n{%asset_img a-4.png%}\n\n按照输入要求，下面我们上传一个第三方的jar包：\n\n{%asset_img a-5.png%}\n\n最好选定下生成pom.xml，否则在其它项目引用的时候，无法点击跳进去。但是对jar使用没影响。\n\n可以打开对应仓库浏览已上传的jar构件：\n\n{%asset_img a-6.png%}  \n\n下面就可以在pom.xml中正常的引用了。\n\n### 方法二：mvn命令直接操作\n\n    mvn deploy:deploy-file -DgroupId=com.csource -DartifactId=fastdfs-client-java -Dversion=1.27-RELEASE -Dpackaging=jar -Dfile=/home/mutian/Desktop/fastdfs-client-java-1.27-RELEASE.jar -Durl=http://119.145.41.171:8085/repository/ymu-hosted/ -DrepositoryId=repository\n    \n参数说明：   \n- -Durl: 仓库地址，jar包要上传到这个自己设定的本机仓库下面。\n- -DrepositoryId：重要，这个是在maven配置文件setting.xml中设定的。对应该仓库的访问id。名字要一致。\n- -DgroupId=com.csource -DartifactId=fastdfs-client-java -Dversion=1.27-RELEASE 这三个参数根据你的jar包随便设。\n- -Dfile：要上传的jar包所在路径。\n\n\n  ","source":"_posts/maven-nexus-jar.md","raw":"---\ntitle: maven构建jar上传到nexus私服并拉取\ndate: 2018-12-30 14:57:05\ncategories: maven\ntags:\n---\n\n公司内部有很多自己的java lib库等共用代码，为了在公司内部自由共享这些资源，所以需要搭建maven私服。下面介绍利用maven构建java项目为jar包并上传到nexus私服，以及在其它项目中如何引用私服中的jar包。\n\n\n## nexus3的安装\n\n这里不做介绍，参考章节{%post_link centos-maven-nexus%},或者{%post_link docker-app-install%}。 \n\n## 新建maven2仓库\n\n{%asset_img a-1.png%}\n\n说明：\n\n- 仓库名称：ymu-hosted，类型为hosted。maven仓库有三种类型，hosted、proxy、group。hosted代表私服本机服务器，proxy代理外部仓库服务器，group整合各个hosted和proxy，按顺序策略获取jar。\n- 这里选择Version policy为：Release。正式发布版本。正式发布版本都上传到这里来。\n- Deployment policy: 选择为Allow Redeploy，可重复发布。代表同一个版本号的jar可以多次发布。这样就不必要设置快照仓库了，项目小改动也作为正式版本发布上去，不必要修改版本号。\n\n\n## maven构建jar并上传到私服相应仓库\n\n### 配置pom.xml\n\n    <!--mavne 发布-->\n    <distributionManagement>\n        <snapshotRepository>\n            <id>snapshots</id>\n            <name>maven-snapshots</name>\n            <url>http://ip:8085/repository/maven-snapshots/</url>\n        </snapshotRepository>\n        <repository>\n            <id>repository</id>\n            <name>ymu-hosted</name>\n            <url>http://ip:8085/repository/ymu-hosted/</url>\n        </repository>\n    </distributionManagement>\n\n说明： \n-  snapshotRepository：指定jar包要发布的快照仓库。版本号这样`0.0.1-SNAPSHOT`，代表的是快照版本，后缀的`SNAPSHOT`必须是大写，不能是小写。\n- repository：指定jar包发布上去的正式版本仓库。当版本号是这样`<version>0.0.2</version>`，没有`SNAPSHOT`的时候，jar将发布到这里指定的私服仓库ymu-hosted下。\n- id：对应maven配置setting.xml中的配置。保持id一致。远程仓库的唯一标志，很重要。\n- name：只是方便阅读，随意定义。   \n- url：仓库地址。登录nexus，在配置中可以查看。\n\n### 配置setting.xml\n\n    <server>\n      <id>repository</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n\n    <server>\n      <id>snapshots</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n\n配置完成后，执行`mvn deploy`命令，就可以发布jar到私服了。修改版本号，可以实际验证查看发布到哪个仓库下。 \n\n\n## 从nexus私服下载构件\n\n配置pom.xml:\n\n    <repositories>\n        <!--自己私仓,下载jar-->\n        <repository>\n            <id>ymu-public</id>\n            <name>ymu nexus</name>\n            <url>http://119.145.41.171:8085/repository/maven-public/</url>\n            <snapshots>\n                <enabled>true</enabled>\n            </snapshots>\n            <releases>\n                <enabled>true</enabled>\n            </releases>\n        </repository>\n\n        \n    </repositories>\n\n    <pluginRepositories>\n        <!--私服，插件-->\n        <pluginRepository>\n            <id>ymu-public</id>\n            <name>ymu nexus</name>\n            <url>http://119.145.41.171:8085/repository/maven-public/</url>\n            <snapshots>\n                <enabled>true</enabled>\n            </snapshots>\n        </pluginRepository>\n        \n    </pluginRepositories>\n\n看上面配置，我们配置自己的私服用的是`maven-public`仓库，该仓库是group类型，整合了自己的私仓等，如下图：\n\n{%asset_img a-2.png%}\n\n看Group组，我们可以看到Member里面有很多个仓库，这代表，拉取jar构件的时候，首先从私服本机拉取，拉取不到的话再从下一个拉取，按顺序处理。从maven中央仓库拉取的jar构件都会缓存到其它仓库。  \n\n以上，我们看到的配置在pom.xml中，只针对某个项目有效。如果是多个项目想都通用私服，则可以在maven的setting.xml中配置:\n\n    <settings>\n      <mirrors>\n        <mirror>\n          <!--This sends everything else to /public -->\n          <id>nexus</id>\n          <mirrorOf>*</mirrorOf>\n          <url>http://localhost:8081/repository/maven-public/</url>\n        </mirror>\n      </mirrors>\n      <profiles>\n        <profile>\n          <id>nexus</id>\n          <!--Enable snapshots for the built in central repo to direct -->\n          <!--all requests to nexus via the mirror -->\n          <repositories>\n            <repository>\n              <id>central</id>\n              <url>http://central</url>\n              <releases><enabled>true</enabled></releases>\n              <snapshots><enabled>true</enabled></snapshots>\n            </repository>\n          </repositories>\n         <pluginRepositories>\n            <pluginRepository>\n              <id>central</id>\n              <url>http://central</url>\n              <releases><enabled>true</enabled></releases>\n              <snapshots><enabled>true</enabled></snapshots>\n            </pluginRepository>\n          </pluginRepositories>\n        </profile>\n      </profiles>\n      <activeProfiles>\n        <!--make the profile active all the time -->\n        <activeProfile>nexus</activeProfile>\n      </activeProfiles>\n    </settings>\n    \n这样子就可以全局引用了，所有项目都是从配置的私服以及其它第三方私服下载构件。不用在每个项目的pom.xml中配置了。  \n第三方的私服，可以添加proxy私仓，然后整合进去group里面。  \n\n\n## 上传第三个jar包到nexus私服中\n\n### 方法一：在nexus3界面直接操作\n\n{%asset_img a-3.png%}\n\n如上图，点击`maven-releases`仓库，进入下面图：\n\n{%asset_img a-4.png%}\n\n按照输入要求，下面我们上传一个第三方的jar包：\n\n{%asset_img a-5.png%}\n\n最好选定下生成pom.xml，否则在其它项目引用的时候，无法点击跳进去。但是对jar使用没影响。\n\n可以打开对应仓库浏览已上传的jar构件：\n\n{%asset_img a-6.png%}  \n\n下面就可以在pom.xml中正常的引用了。\n\n### 方法二：mvn命令直接操作\n\n    mvn deploy:deploy-file -DgroupId=com.csource -DartifactId=fastdfs-client-java -Dversion=1.27-RELEASE -Dpackaging=jar -Dfile=/home/mutian/Desktop/fastdfs-client-java-1.27-RELEASE.jar -Durl=http://119.145.41.171:8085/repository/ymu-hosted/ -DrepositoryId=repository\n    \n参数说明：   \n- -Durl: 仓库地址，jar包要上传到这个自己设定的本机仓库下面。\n- -DrepositoryId：重要，这个是在maven配置文件setting.xml中设定的。对应该仓库的访问id。名字要一致。\n- -DgroupId=com.csource -DartifactId=fastdfs-client-java -Dversion=1.27-RELEASE 这三个参数根据你的jar包随便设。\n- -Dfile：要上传的jar包所在路径。\n\n\n  ","slug":"maven-nexus-jar","published":1,"updated":"2019-06-16T14:38:33.411Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdh006xg4vapmm8f2e1","content":"<p>公司内部有很多自己的java lib库等共用代码，为了在公司内部自由共享这些资源，所以需要搭建maven私服。下面介绍利用maven构建java项目为jar包并上传到nexus私服，以及在其它项目中如何引用私服中的jar包。</p>\n<h2 id=\"nexus3的安装\"><a href=\"#nexus3的安装\" class=\"headerlink\" title=\"nexus3的安装\"></a>nexus3的安装</h2><p>这里不做介绍，参考章节<a href=\"/2017/11/12/centos-maven-nexus/\" title=\"centos7下搭建maven私仓Nexus\">centos7下搭建maven私仓Nexus</a>,或者<a href=\"/2018/07/19/docker-app-install/\" title=\"docker安装各种常用开发应用软件\">docker安装各种常用开发应用软件</a>。 </p>\n<h2 id=\"新建maven2仓库\"><a href=\"#新建maven2仓库\" class=\"headerlink\" title=\"新建maven2仓库\"></a>新建maven2仓库</h2><img src=\"/2018/12/30/maven-nexus-jar/a-1.png\">\n<p>说明：</p>\n<ul>\n<li>仓库名称：ymu-hosted，类型为hosted。maven仓库有三种类型，hosted、proxy、group。hosted代表私服本机服务器，proxy代理外部仓库服务器，group整合各个hosted和proxy，按顺序策略获取jar。</li>\n<li>这里选择Version policy为：Release。正式发布版本。正式发布版本都上传到这里来。</li>\n<li>Deployment policy: 选择为Allow Redeploy，可重复发布。代表同一个版本号的jar可以多次发布。这样就不必要设置快照仓库了，项目小改动也作为正式版本发布上去，不必要修改版本号。</li>\n</ul>\n<h2 id=\"maven构建jar并上传到私服相应仓库\"><a href=\"#maven构建jar并上传到私服相应仓库\" class=\"headerlink\" title=\"maven构建jar并上传到私服相应仓库\"></a>maven构建jar并上传到私服相应仓库</h2><h3 id=\"配置pom-xml\"><a href=\"#配置pom-xml\" class=\"headerlink\" title=\"配置pom.xml\"></a>配置pom.xml</h3><pre><code>&lt;!--mavne 发布--&gt;\n&lt;distributionManagement&gt;\n    &lt;snapshotRepository&gt;\n        &lt;id&gt;snapshots&lt;/id&gt;\n        &lt;name&gt;maven-snapshots&lt;/name&gt;\n        &lt;url&gt;http://ip:8085/repository/maven-snapshots/&lt;/url&gt;\n    &lt;/snapshotRepository&gt;\n    &lt;repository&gt;\n        &lt;id&gt;repository&lt;/id&gt;\n        &lt;name&gt;ymu-hosted&lt;/name&gt;\n        &lt;url&gt;http://ip:8085/repository/ymu-hosted/&lt;/url&gt;\n    &lt;/repository&gt;\n&lt;/distributionManagement&gt;\n</code></pre><p>说明： </p>\n<ul>\n<li>snapshotRepository：指定jar包要发布的快照仓库。版本号这样<code>0.0.1-SNAPSHOT</code>，代表的是快照版本，后缀的<code>SNAPSHOT</code>必须是大写，不能是小写。</li>\n<li>repository：指定jar包发布上去的正式版本仓库。当版本号是这样<code>&lt;version&gt;0.0.2&lt;/version&gt;</code>，没有<code>SNAPSHOT</code>的时候，jar将发布到这里指定的私服仓库ymu-hosted下。</li>\n<li>id：对应maven配置setting.xml中的配置。保持id一致。远程仓库的唯一标志，很重要。</li>\n<li>name：只是方便阅读，随意定义。   </li>\n<li>url：仓库地址。登录nexus，在配置中可以查看。</li>\n</ul>\n<h3 id=\"配置setting-xml\"><a href=\"#配置setting-xml\" class=\"headerlink\" title=\"配置setting.xml\"></a>配置setting.xml</h3><pre><code>&lt;server&gt;\n  &lt;id&gt;repository&lt;/id&gt;\n  &lt;username&gt;admin&lt;/username&gt;\n  &lt;password&gt;admin123&lt;/password&gt;\n&lt;/server&gt;\n\n&lt;server&gt;\n  &lt;id&gt;snapshots&lt;/id&gt;\n  &lt;username&gt;admin&lt;/username&gt;\n  &lt;password&gt;admin123&lt;/password&gt;\n&lt;/server&gt;\n</code></pre><p>配置完成后，执行<code>mvn deploy</code>命令，就可以发布jar到私服了。修改版本号，可以实际验证查看发布到哪个仓库下。 </p>\n<h2 id=\"从nexus私服下载构件\"><a href=\"#从nexus私服下载构件\" class=\"headerlink\" title=\"从nexus私服下载构件\"></a>从nexus私服下载构件</h2><p>配置pom.xml:</p>\n<pre><code>&lt;repositories&gt;\n    &lt;!--自己私仓,下载jar--&gt;\n    &lt;repository&gt;\n        &lt;id&gt;ymu-public&lt;/id&gt;\n        &lt;name&gt;ymu nexus&lt;/name&gt;\n        &lt;url&gt;http://119.145.41.171:8085/repository/maven-public/&lt;/url&gt;\n        &lt;snapshots&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/snapshots&gt;\n        &lt;releases&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/releases&gt;\n    &lt;/repository&gt;\n\n\n&lt;/repositories&gt;\n\n&lt;pluginRepositories&gt;\n    &lt;!--私服，插件--&gt;\n    &lt;pluginRepository&gt;\n        &lt;id&gt;ymu-public&lt;/id&gt;\n        &lt;name&gt;ymu nexus&lt;/name&gt;\n        &lt;url&gt;http://119.145.41.171:8085/repository/maven-public/&lt;/url&gt;\n        &lt;snapshots&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/snapshots&gt;\n    &lt;/pluginRepository&gt;\n\n&lt;/pluginRepositories&gt;\n</code></pre><p>看上面配置，我们配置自己的私服用的是<code>maven-public</code>仓库，该仓库是group类型，整合了自己的私仓等，如下图：</p>\n<img src=\"/2018/12/30/maven-nexus-jar/a-2.png\">\n<p>看Group组，我们可以看到Member里面有很多个仓库，这代表，拉取jar构件的时候，首先从私服本机拉取，拉取不到的话再从下一个拉取，按顺序处理。从maven中央仓库拉取的jar构件都会缓存到其它仓库。  </p>\n<p>以上，我们看到的配置在pom.xml中，只针对某个项目有效。如果是多个项目想都通用私服，则可以在maven的setting.xml中配置:</p>\n<pre><code>&lt;settings&gt;\n  &lt;mirrors&gt;\n    &lt;mirror&gt;\n      &lt;!--This sends everything else to /public --&gt;\n      &lt;id&gt;nexus&lt;/id&gt;\n      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\n      &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;\n    &lt;/mirror&gt;\n  &lt;/mirrors&gt;\n  &lt;profiles&gt;\n    &lt;profile&gt;\n      &lt;id&gt;nexus&lt;/id&gt;\n      &lt;!--Enable snapshots for the built in central repo to direct --&gt;\n      &lt;!--all requests to nexus via the mirror --&gt;\n      &lt;repositories&gt;\n        &lt;repository&gt;\n          &lt;id&gt;central&lt;/id&gt;\n          &lt;url&gt;http://central&lt;/url&gt;\n          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;\n          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;\n        &lt;/repository&gt;\n      &lt;/repositories&gt;\n     &lt;pluginRepositories&gt;\n        &lt;pluginRepository&gt;\n          &lt;id&gt;central&lt;/id&gt;\n          &lt;url&gt;http://central&lt;/url&gt;\n          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;\n          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;\n        &lt;/pluginRepository&gt;\n      &lt;/pluginRepositories&gt;\n    &lt;/profile&gt;\n  &lt;/profiles&gt;\n  &lt;activeProfiles&gt;\n    &lt;!--make the profile active all the time --&gt;\n    &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;\n  &lt;/activeProfiles&gt;\n&lt;/settings&gt;\n</code></pre><p>这样子就可以全局引用了，所有项目都是从配置的私服以及其它第三方私服下载构件。不用在每个项目的pom.xml中配置了。<br>第三方的私服，可以添加proxy私仓，然后整合进去group里面。  </p>\n<h2 id=\"上传第三个jar包到nexus私服中\"><a href=\"#上传第三个jar包到nexus私服中\" class=\"headerlink\" title=\"上传第三个jar包到nexus私服中\"></a>上传第三个jar包到nexus私服中</h2><h3 id=\"方法一：在nexus3界面直接操作\"><a href=\"#方法一：在nexus3界面直接操作\" class=\"headerlink\" title=\"方法一：在nexus3界面直接操作\"></a>方法一：在nexus3界面直接操作</h3><img src=\"/2018/12/30/maven-nexus-jar/a-3.png\">\n<p>如上图，点击<code>maven-releases</code>仓库，进入下面图：</p>\n<img src=\"/2018/12/30/maven-nexus-jar/a-4.png\">\n<p>按照输入要求，下面我们上传一个第三方的jar包：</p>\n<img src=\"/2018/12/30/maven-nexus-jar/a-5.png\">\n<p>最好选定下生成pom.xml，否则在其它项目引用的时候，无法点击跳进去。但是对jar使用没影响。</p>\n<p>可以打开对应仓库浏览已上传的jar构件：</p>\n<img src=\"/2018/12/30/maven-nexus-jar/a-6.png\">  \n<p>下面就可以在pom.xml中正常的引用了。</p>\n<h3 id=\"方法二：mvn命令直接操作\"><a href=\"#方法二：mvn命令直接操作\" class=\"headerlink\" title=\"方法二：mvn命令直接操作\"></a>方法二：mvn命令直接操作</h3><pre><code>mvn deploy:deploy-file -DgroupId=com.csource -DartifactId=fastdfs-client-java -Dversion=1.27-RELEASE -Dpackaging=jar -Dfile=/home/mutian/Desktop/fastdfs-client-java-1.27-RELEASE.jar -Durl=http://119.145.41.171:8085/repository/ymu-hosted/ -DrepositoryId=repository\n</code></pre><p>参数说明：   </p>\n<ul>\n<li>-Durl: 仓库地址，jar包要上传到这个自己设定的本机仓库下面。</li>\n<li>-DrepositoryId：重要，这个是在maven配置文件setting.xml中设定的。对应该仓库的访问id。名字要一致。</li>\n<li>-DgroupId=com.csource -DartifactId=fastdfs-client-java -Dversion=1.27-RELEASE 这三个参数根据你的jar包随便设。</li>\n<li>-Dfile：要上传的jar包所在路径。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>公司内部有很多自己的java lib库等共用代码，为了在公司内部自由共享这些资源，所以需要搭建maven私服。下面介绍利用maven构建java项目为jar包并上传到nexus私服，以及在其它项目中如何引用私服中的jar包。</p>\n<h2 id=\"nexus3的安装\"><a href=\"#nexus3的安装\" class=\"headerlink\" title=\"nexus3的安装\"></a>nexus3的安装</h2><p>这里不做介绍，参考章节<a href=\"/2017/11/12/centos-maven-nexus/\" title=\"centos7下搭建maven私仓Nexus\">centos7下搭建maven私仓Nexus</a>,或者<a href=\"/2018/07/19/docker-app-install/\" title=\"docker安装各种常用开发应用软件\">docker安装各种常用开发应用软件</a>。 </p>\n<h2 id=\"新建maven2仓库\"><a href=\"#新建maven2仓库\" class=\"headerlink\" title=\"新建maven2仓库\"></a>新建maven2仓库</h2><img src=\"/2018/12/30/maven-nexus-jar/a-1.png\">\n<p>说明：</p>\n<ul>\n<li>仓库名称：ymu-hosted，类型为hosted。maven仓库有三种类型，hosted、proxy、group。hosted代表私服本机服务器，proxy代理外部仓库服务器，group整合各个hosted和proxy，按顺序策略获取jar。</li>\n<li>这里选择Version policy为：Release。正式发布版本。正式发布版本都上传到这里来。</li>\n<li>Deployment policy: 选择为Allow Redeploy，可重复发布。代表同一个版本号的jar可以多次发布。这样就不必要设置快照仓库了，项目小改动也作为正式版本发布上去，不必要修改版本号。</li>\n</ul>\n<h2 id=\"maven构建jar并上传到私服相应仓库\"><a href=\"#maven构建jar并上传到私服相应仓库\" class=\"headerlink\" title=\"maven构建jar并上传到私服相应仓库\"></a>maven构建jar并上传到私服相应仓库</h2><h3 id=\"配置pom-xml\"><a href=\"#配置pom-xml\" class=\"headerlink\" title=\"配置pom.xml\"></a>配置pom.xml</h3><pre><code>&lt;!--mavne 发布--&gt;\n&lt;distributionManagement&gt;\n    &lt;snapshotRepository&gt;\n        &lt;id&gt;snapshots&lt;/id&gt;\n        &lt;name&gt;maven-snapshots&lt;/name&gt;\n        &lt;url&gt;http://ip:8085/repository/maven-snapshots/&lt;/url&gt;\n    &lt;/snapshotRepository&gt;\n    &lt;repository&gt;\n        &lt;id&gt;repository&lt;/id&gt;\n        &lt;name&gt;ymu-hosted&lt;/name&gt;\n        &lt;url&gt;http://ip:8085/repository/ymu-hosted/&lt;/url&gt;\n    &lt;/repository&gt;\n&lt;/distributionManagement&gt;\n</code></pre><p>说明： </p>\n<ul>\n<li>snapshotRepository：指定jar包要发布的快照仓库。版本号这样<code>0.0.1-SNAPSHOT</code>，代表的是快照版本，后缀的<code>SNAPSHOT</code>必须是大写，不能是小写。</li>\n<li>repository：指定jar包发布上去的正式版本仓库。当版本号是这样<code>&lt;version&gt;0.0.2&lt;/version&gt;</code>，没有<code>SNAPSHOT</code>的时候，jar将发布到这里指定的私服仓库ymu-hosted下。</li>\n<li>id：对应maven配置setting.xml中的配置。保持id一致。远程仓库的唯一标志，很重要。</li>\n<li>name：只是方便阅读，随意定义。   </li>\n<li>url：仓库地址。登录nexus，在配置中可以查看。</li>\n</ul>\n<h3 id=\"配置setting-xml\"><a href=\"#配置setting-xml\" class=\"headerlink\" title=\"配置setting.xml\"></a>配置setting.xml</h3><pre><code>&lt;server&gt;\n  &lt;id&gt;repository&lt;/id&gt;\n  &lt;username&gt;admin&lt;/username&gt;\n  &lt;password&gt;admin123&lt;/password&gt;\n&lt;/server&gt;\n\n&lt;server&gt;\n  &lt;id&gt;snapshots&lt;/id&gt;\n  &lt;username&gt;admin&lt;/username&gt;\n  &lt;password&gt;admin123&lt;/password&gt;\n&lt;/server&gt;\n</code></pre><p>配置完成后，执行<code>mvn deploy</code>命令，就可以发布jar到私服了。修改版本号，可以实际验证查看发布到哪个仓库下。 </p>\n<h2 id=\"从nexus私服下载构件\"><a href=\"#从nexus私服下载构件\" class=\"headerlink\" title=\"从nexus私服下载构件\"></a>从nexus私服下载构件</h2><p>配置pom.xml:</p>\n<pre><code>&lt;repositories&gt;\n    &lt;!--自己私仓,下载jar--&gt;\n    &lt;repository&gt;\n        &lt;id&gt;ymu-public&lt;/id&gt;\n        &lt;name&gt;ymu nexus&lt;/name&gt;\n        &lt;url&gt;http://119.145.41.171:8085/repository/maven-public/&lt;/url&gt;\n        &lt;snapshots&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/snapshots&gt;\n        &lt;releases&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/releases&gt;\n    &lt;/repository&gt;\n\n\n&lt;/repositories&gt;\n\n&lt;pluginRepositories&gt;\n    &lt;!--私服，插件--&gt;\n    &lt;pluginRepository&gt;\n        &lt;id&gt;ymu-public&lt;/id&gt;\n        &lt;name&gt;ymu nexus&lt;/name&gt;\n        &lt;url&gt;http://119.145.41.171:8085/repository/maven-public/&lt;/url&gt;\n        &lt;snapshots&gt;\n            &lt;enabled&gt;true&lt;/enabled&gt;\n        &lt;/snapshots&gt;\n    &lt;/pluginRepository&gt;\n\n&lt;/pluginRepositories&gt;\n</code></pre><p>看上面配置，我们配置自己的私服用的是<code>maven-public</code>仓库，该仓库是group类型，整合了自己的私仓等，如下图：</p>\n<img src=\"/2018/12/30/maven-nexus-jar/a-2.png\">\n<p>看Group组，我们可以看到Member里面有很多个仓库，这代表，拉取jar构件的时候，首先从私服本机拉取，拉取不到的话再从下一个拉取，按顺序处理。从maven中央仓库拉取的jar构件都会缓存到其它仓库。  </p>\n<p>以上，我们看到的配置在pom.xml中，只针对某个项目有效。如果是多个项目想都通用私服，则可以在maven的setting.xml中配置:</p>\n<pre><code>&lt;settings&gt;\n  &lt;mirrors&gt;\n    &lt;mirror&gt;\n      &lt;!--This sends everything else to /public --&gt;\n      &lt;id&gt;nexus&lt;/id&gt;\n      &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;\n      &lt;url&gt;http://localhost:8081/repository/maven-public/&lt;/url&gt;\n    &lt;/mirror&gt;\n  &lt;/mirrors&gt;\n  &lt;profiles&gt;\n    &lt;profile&gt;\n      &lt;id&gt;nexus&lt;/id&gt;\n      &lt;!--Enable snapshots for the built in central repo to direct --&gt;\n      &lt;!--all requests to nexus via the mirror --&gt;\n      &lt;repositories&gt;\n        &lt;repository&gt;\n          &lt;id&gt;central&lt;/id&gt;\n          &lt;url&gt;http://central&lt;/url&gt;\n          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;\n          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;\n        &lt;/repository&gt;\n      &lt;/repositories&gt;\n     &lt;pluginRepositories&gt;\n        &lt;pluginRepository&gt;\n          &lt;id&gt;central&lt;/id&gt;\n          &lt;url&gt;http://central&lt;/url&gt;\n          &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;\n          &lt;snapshots&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/snapshots&gt;\n        &lt;/pluginRepository&gt;\n      &lt;/pluginRepositories&gt;\n    &lt;/profile&gt;\n  &lt;/profiles&gt;\n  &lt;activeProfiles&gt;\n    &lt;!--make the profile active all the time --&gt;\n    &lt;activeProfile&gt;nexus&lt;/activeProfile&gt;\n  &lt;/activeProfiles&gt;\n&lt;/settings&gt;\n</code></pre><p>这样子就可以全局引用了，所有项目都是从配置的私服以及其它第三方私服下载构件。不用在每个项目的pom.xml中配置了。<br>第三方的私服，可以添加proxy私仓，然后整合进去group里面。  </p>\n<h2 id=\"上传第三个jar包到nexus私服中\"><a href=\"#上传第三个jar包到nexus私服中\" class=\"headerlink\" title=\"上传第三个jar包到nexus私服中\"></a>上传第三个jar包到nexus私服中</h2><h3 id=\"方法一：在nexus3界面直接操作\"><a href=\"#方法一：在nexus3界面直接操作\" class=\"headerlink\" title=\"方法一：在nexus3界面直接操作\"></a>方法一：在nexus3界面直接操作</h3><img src=\"/2018/12/30/maven-nexus-jar/a-3.png\">\n<p>如上图，点击<code>maven-releases</code>仓库，进入下面图：</p>\n<img src=\"/2018/12/30/maven-nexus-jar/a-4.png\">\n<p>按照输入要求，下面我们上传一个第三方的jar包：</p>\n<img src=\"/2018/12/30/maven-nexus-jar/a-5.png\">\n<p>最好选定下生成pom.xml，否则在其它项目引用的时候，无法点击跳进去。但是对jar使用没影响。</p>\n<p>可以打开对应仓库浏览已上传的jar构件：</p>\n<img src=\"/2018/12/30/maven-nexus-jar/a-6.png\">  \n<p>下面就可以在pom.xml中正常的引用了。</p>\n<h3 id=\"方法二：mvn命令直接操作\"><a href=\"#方法二：mvn命令直接操作\" class=\"headerlink\" title=\"方法二：mvn命令直接操作\"></a>方法二：mvn命令直接操作</h3><pre><code>mvn deploy:deploy-file -DgroupId=com.csource -DartifactId=fastdfs-client-java -Dversion=1.27-RELEASE -Dpackaging=jar -Dfile=/home/mutian/Desktop/fastdfs-client-java-1.27-RELEASE.jar -Durl=http://119.145.41.171:8085/repository/ymu-hosted/ -DrepositoryId=repository\n</code></pre><p>参数说明：   </p>\n<ul>\n<li>-Durl: 仓库地址，jar包要上传到这个自己设定的本机仓库下面。</li>\n<li>-DrepositoryId：重要，这个是在maven配置文件setting.xml中设定的。对应该仓库的访问id。名字要一致。</li>\n<li>-DgroupId=com.csource -DartifactId=fastdfs-client-java -Dversion=1.27-RELEASE 这三个参数根据你的jar包随便设。</li>\n<li>-Dfile：要上传的jar包所在路径。</li>\n</ul>\n"},{"title":"maven使用经验记录","date":"2018-02-03T02:00:23.000Z","_content":"\n本文记录在开发过程中经常性使用到的maven特性……\n\n### 导出maven依赖的jar包到目录\n\n方法一：在pom目录下执行命令\t\n`mvn dependency:copy-dependencies`\n\n方法二：eclipse项目下：\n选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行\nmaven项目所依赖的jar包会导出到targed/dependency目录中。\n\n{% asset_img a.jpg %} \n\n{% asset_img b.jpg %} \n\n### maven打包时候跳过test检查\n\n方法一： 在pom目录下执行命令\n`mvn clean install -Dmaven.test.skip=true`\n\n方法二： 在pom中添加插件\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-surefire-plugin</artifactId>\n        <configuration>\n            <skipTests>true</skipTests>\n        </configuration>\n    </plugin>\n\n\n### 打包jar\n\n#### 普通打包\n会把maven依赖包一起打包。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n            <source>1.8</source>\n            <target>1.8</target>\n        </configuration>\n    </plugin>\n\n#### 不打包lib\n在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。 \n让后启动指定main类，并指定依赖包目录lib。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-jar-plugin</artifactId>\n        <configuration>\n            <archive>\n                <manifest>\n                    <mainClass>com.xcsqjr.StartAbsServiceAllApplication</mainClass>\n                    <addClasspath>true</addClasspath>\n                    <classpathPrefix>lib/</classpathPrefix>\n                </manifest>\n                <manifestEntries>\n                    <Class-Path>./</Class-Path>\n                </manifestEntries>\n            </archive>\n        </configuration>\n    </plugin>\n\n\n## jar包无法更新下来，爆本地已有缓存\n\n有时候，maven依赖包拉取失败，但是有部分内容已经拉取，一部分没拉去，再次更新的时候，不会再次去远程仓库拉取。所以会报错误：\n\n    Maven-010-maven 编译报错：Failure to ... in ... was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced.\n\n\n解决办法是，在maven配置文件setting.xml中加入如下策略：\n\n    <profile>\n      <id>dev</id>\n        <repositories>\n            <!--自己私仓,下载jar-->\n            <repository>\n                <id>ymu-public</id>\n                <name>ymu nexus</name>\n                <url>http://119.145.41.171:8085/repository/maven-public/</url>\n                <snapshots>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </snapshots>\n                <releases>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </releases>\n            </repository>\n\n            <repository>\n                <id>central</id>\n                <url>http://central</url>\n                <releases>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </releases>\n                <snapshots>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </snapshots>\n            </repository>\n\n        </repositories>\n\n        <pluginRepositories>\n            <!--私服，插件-->\n            <pluginRepository>\n                <id>ymu-public</id>\n                <name>ymu nexus</name>\n                <url>http://119.145.41.171:8085/repository/maven-public/</url>\n                <snapshots>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </snapshots>\n                <releases>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </releases>\n            </pluginRepository>\n            <pluginRepository>\n                <id>central</id>\n                <url>http://central</url>\n                <releases>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </releases>\n                <snapshots>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </snapshots>\n            </pluginRepository>\n        </pluginRepositories>\n    </profile>\n    \n关键加上属性`<updatePolicy>always</updatePolicy> `\n\n## 常用maven中央仓库地址\n\n    1、http://www.sonatype.org/nexus/  私服nexus工具使用\n    2、http://mvnrepository.com/ （推荐）\n    3、http://repo1.maven.org/maven2\n    \n    4、http://maven.aliyun.com/nexus/content/groups/public/  阿里云  （强力推荐）\n    \n    5、http://repo2.maven.org/maven2/ 私服nexus工具使用\n    \n    6、http://uk.maven.org/maven2/\n    \n    7、http://repository.jboss.org/nexus/content/groups/public\n    \n    8、http://maven.oschina.net/content/groups/public/  oschina可惜啦，以前一直用这个，不过现在有阿里云来擦屁股啦\n    \n    9、http://mirrors.ibiblio.org/maven2/\n    \n    10、http://maven.antelink.com/content/repositories/central/\n    \n    11、http://nexus.openkoala.org/nexus/content/groups/Koala-release/\n    \n    12、http://maven.tmatesoft.com/content/groups/public/ \n    \n    ---------------------- spring的 -------------------------\n    \n    <repository>\n        <id>spring-snapshots</id>\n        <name>Spring Snapshots</name>\n        <url>https://repo.spring.io/libs-snapshot-local</url>\n        <snapshots>\n            <enabled>true</enabled>\n        </snapshots>\n    </repository>\n    <repository>\n        <id>spring-milestones</id>\n        <name>Spring Milestones</name>\n        <url>https://repo.spring.io/libs-milestone-local</url>\n        <snapshots>\n            <enabled>false</enabled>\n        </snapshots>\n    </repository>\n    <repository>\n        <id>spring-releases</id>\n        <name>Spring Releases</name>\n        <url>https://repo.spring.io/libs-release-local</url>\n        <snapshots>\n            <enabled>false</enabled>\n        </snapshots>\n    </repository>  \n    \n    \n## 从私服无法拉取构件\n\n- 方法一：  \n上传第三方jar到私服，再应用。\n\n- 方法二：  \n找到第三方jar包所在的第三方私服，然后在自己的私服中做代理请求。    \n\n{% asset_img a-1.png %} \n\n可以看到里面代理了很多第三方私服，阿里云的，spring的，等。然后整合到`maven-pblic`group组中即可。","source":"_posts/maven-ofen.md","raw":"---\ntitle: maven使用经验记录\ndate: 2018-02-03 10:00:23\ncategories: maven\ntags: maven常用功能\n---\n\n本文记录在开发过程中经常性使用到的maven特性……\n\n### 导出maven依赖的jar包到目录\n\n方法一：在pom目录下执行命令\t\n`mvn dependency:copy-dependencies`\n\n方法二：eclipse项目下：\n选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行\nmaven项目所依赖的jar包会导出到targed/dependency目录中。\n\n{% asset_img a.jpg %} \n\n{% asset_img b.jpg %} \n\n### maven打包时候跳过test检查\n\n方法一： 在pom目录下执行命令\n`mvn clean install -Dmaven.test.skip=true`\n\n方法二： 在pom中添加插件\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-surefire-plugin</artifactId>\n        <configuration>\n            <skipTests>true</skipTests>\n        </configuration>\n    </plugin>\n\n\n### 打包jar\n\n#### 普通打包\n会把maven依赖包一起打包。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n            <source>1.8</source>\n            <target>1.8</target>\n        </configuration>\n    </plugin>\n\n#### 不打包lib\n在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。 \n让后启动指定main类，并指定依赖包目录lib。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-jar-plugin</artifactId>\n        <configuration>\n            <archive>\n                <manifest>\n                    <mainClass>com.xcsqjr.StartAbsServiceAllApplication</mainClass>\n                    <addClasspath>true</addClasspath>\n                    <classpathPrefix>lib/</classpathPrefix>\n                </manifest>\n                <manifestEntries>\n                    <Class-Path>./</Class-Path>\n                </manifestEntries>\n            </archive>\n        </configuration>\n    </plugin>\n\n\n## jar包无法更新下来，爆本地已有缓存\n\n有时候，maven依赖包拉取失败，但是有部分内容已经拉取，一部分没拉去，再次更新的时候，不会再次去远程仓库拉取。所以会报错误：\n\n    Maven-010-maven 编译报错：Failure to ... in ... was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced.\n\n\n解决办法是，在maven配置文件setting.xml中加入如下策略：\n\n    <profile>\n      <id>dev</id>\n        <repositories>\n            <!--自己私仓,下载jar-->\n            <repository>\n                <id>ymu-public</id>\n                <name>ymu nexus</name>\n                <url>http://119.145.41.171:8085/repository/maven-public/</url>\n                <snapshots>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </snapshots>\n                <releases>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </releases>\n            </repository>\n\n            <repository>\n                <id>central</id>\n                <url>http://central</url>\n                <releases>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </releases>\n                <snapshots>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </snapshots>\n            </repository>\n\n        </repositories>\n\n        <pluginRepositories>\n            <!--私服，插件-->\n            <pluginRepository>\n                <id>ymu-public</id>\n                <name>ymu nexus</name>\n                <url>http://119.145.41.171:8085/repository/maven-public/</url>\n                <snapshots>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </snapshots>\n                <releases>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </releases>\n            </pluginRepository>\n            <pluginRepository>\n                <id>central</id>\n                <url>http://central</url>\n                <releases>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </releases>\n                <snapshots>\n                    <enabled>true</enabled>\n                    <updatePolicy>always</updatePolicy>\n                </snapshots>\n            </pluginRepository>\n        </pluginRepositories>\n    </profile>\n    \n关键加上属性`<updatePolicy>always</updatePolicy> `\n\n## 常用maven中央仓库地址\n\n    1、http://www.sonatype.org/nexus/  私服nexus工具使用\n    2、http://mvnrepository.com/ （推荐）\n    3、http://repo1.maven.org/maven2\n    \n    4、http://maven.aliyun.com/nexus/content/groups/public/  阿里云  （强力推荐）\n    \n    5、http://repo2.maven.org/maven2/ 私服nexus工具使用\n    \n    6、http://uk.maven.org/maven2/\n    \n    7、http://repository.jboss.org/nexus/content/groups/public\n    \n    8、http://maven.oschina.net/content/groups/public/  oschina可惜啦，以前一直用这个，不过现在有阿里云来擦屁股啦\n    \n    9、http://mirrors.ibiblio.org/maven2/\n    \n    10、http://maven.antelink.com/content/repositories/central/\n    \n    11、http://nexus.openkoala.org/nexus/content/groups/Koala-release/\n    \n    12、http://maven.tmatesoft.com/content/groups/public/ \n    \n    ---------------------- spring的 -------------------------\n    \n    <repository>\n        <id>spring-snapshots</id>\n        <name>Spring Snapshots</name>\n        <url>https://repo.spring.io/libs-snapshot-local</url>\n        <snapshots>\n            <enabled>true</enabled>\n        </snapshots>\n    </repository>\n    <repository>\n        <id>spring-milestones</id>\n        <name>Spring Milestones</name>\n        <url>https://repo.spring.io/libs-milestone-local</url>\n        <snapshots>\n            <enabled>false</enabled>\n        </snapshots>\n    </repository>\n    <repository>\n        <id>spring-releases</id>\n        <name>Spring Releases</name>\n        <url>https://repo.spring.io/libs-release-local</url>\n        <snapshots>\n            <enabled>false</enabled>\n        </snapshots>\n    </repository>  \n    \n    \n## 从私服无法拉取构件\n\n- 方法一：  \n上传第三方jar到私服，再应用。\n\n- 方法二：  \n找到第三方jar包所在的第三方私服，然后在自己的私服中做代理请求。    \n\n{% asset_img a-1.png %} \n\n可以看到里面代理了很多第三方私服，阿里云的，spring的，等。然后整合到`maven-pblic`group组中即可。","slug":"maven-ofen","published":1,"updated":"2019-06-16T14:38:33.417Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdi006zg4vac2klwwc3","content":"<p>本文记录在开发过程中经常性使用到的maven特性……</p>\n<h3 id=\"导出maven依赖的jar包到目录\"><a href=\"#导出maven依赖的jar包到目录\" class=\"headerlink\" title=\"导出maven依赖的jar包到目录\"></a>导出maven依赖的jar包到目录</h3><p>方法一：在pom目录下执行命令<br><code>mvn dependency:copy-dependencies</code></p>\n<p>方法二：eclipse项目下：<br>选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行<br>maven项目所依赖的jar包会导出到targed/dependency目录中。</p>\n<img src=\"/2018/02/03/maven-ofen/a.jpg\"> \n<img src=\"/2018/02/03/maven-ofen/b.jpg\"> \n<h3 id=\"maven打包时候跳过test检查\"><a href=\"#maven打包时候跳过test检查\" class=\"headerlink\" title=\"maven打包时候跳过test检查\"></a>maven打包时候跳过test检查</h3><p>方法一： 在pom目录下执行命令<br><code>mvn clean install -Dmaven.test.skip=true</code></p>\n<p>方法二： 在pom中添加插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;skipTests&gt;true&lt;/skipTests&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h3 id=\"打包jar\"><a href=\"#打包jar\" class=\"headerlink\" title=\"打包jar\"></a>打包jar</h3><h4 id=\"普通打包\"><a href=\"#普通打包\" class=\"headerlink\" title=\"普通打包\"></a>普通打包</h4><p>会把maven依赖包一起打包。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;source&gt;1.8&lt;/source&gt;\n        &lt;target&gt;1.8&lt;/target&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h4 id=\"不打包lib\"><a href=\"#不打包lib\" class=\"headerlink\" title=\"不打包lib\"></a>不打包lib</h4><p>在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。<br>让后启动指定main类，并指定依赖包目录lib。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;archive&gt;\n            &lt;manifest&gt;\n                &lt;mainClass&gt;com.xcsqjr.StartAbsServiceAllApplication&lt;/mainClass&gt;\n                &lt;addClasspath&gt;true&lt;/addClasspath&gt;\n                &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;\n            &lt;/manifest&gt;\n            &lt;manifestEntries&gt;\n                &lt;Class-Path&gt;./&lt;/Class-Path&gt;\n            &lt;/manifestEntries&gt;\n        &lt;/archive&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h2 id=\"jar包无法更新下来，爆本地已有缓存\"><a href=\"#jar包无法更新下来，爆本地已有缓存\" class=\"headerlink\" title=\"jar包无法更新下来，爆本地已有缓存\"></a>jar包无法更新下来，爆本地已有缓存</h2><p>有时候，maven依赖包拉取失败，但是有部分内容已经拉取，一部分没拉去，再次更新的时候，不会再次去远程仓库拉取。所以会报错误：</p>\n<pre><code>Maven-010-maven 编译报错：Failure to ... in ... was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced.\n</code></pre><p>解决办法是，在maven配置文件setting.xml中加入如下策略：</p>\n<pre><code>&lt;profile&gt;\n  &lt;id&gt;dev&lt;/id&gt;\n    &lt;repositories&gt;\n        &lt;!--自己私仓,下载jar--&gt;\n        &lt;repository&gt;\n            &lt;id&gt;ymu-public&lt;/id&gt;\n            &lt;name&gt;ymu nexus&lt;/name&gt;\n            &lt;url&gt;http://119.145.41.171:8085/repository/maven-public/&lt;/url&gt;\n            &lt;snapshots&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/snapshots&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/releases&gt;\n        &lt;/repository&gt;\n\n        &lt;repository&gt;\n            &lt;id&gt;central&lt;/id&gt;\n            &lt;url&gt;http://central&lt;/url&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/releases&gt;\n            &lt;snapshots&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/snapshots&gt;\n        &lt;/repository&gt;\n\n    &lt;/repositories&gt;\n\n    &lt;pluginRepositories&gt;\n        &lt;!--私服，插件--&gt;\n        &lt;pluginRepository&gt;\n            &lt;id&gt;ymu-public&lt;/id&gt;\n            &lt;name&gt;ymu nexus&lt;/name&gt;\n            &lt;url&gt;http://119.145.41.171:8085/repository/maven-public/&lt;/url&gt;\n            &lt;snapshots&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/snapshots&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/releases&gt;\n        &lt;/pluginRepository&gt;\n        &lt;pluginRepository&gt;\n            &lt;id&gt;central&lt;/id&gt;\n            &lt;url&gt;http://central&lt;/url&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/releases&gt;\n            &lt;snapshots&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/snapshots&gt;\n        &lt;/pluginRepository&gt;\n    &lt;/pluginRepositories&gt;\n&lt;/profile&gt;\n</code></pre><p>关键加上属性<code>&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;</code></p>\n<h2 id=\"常用maven中央仓库地址\"><a href=\"#常用maven中央仓库地址\" class=\"headerlink\" title=\"常用maven中央仓库地址\"></a>常用maven中央仓库地址</h2><pre><code>1、http://www.sonatype.org/nexus/  私服nexus工具使用\n2、http://mvnrepository.com/ （推荐）\n3、http://repo1.maven.org/maven2\n\n4、http://maven.aliyun.com/nexus/content/groups/public/  阿里云  （强力推荐）\n\n5、http://repo2.maven.org/maven2/ 私服nexus工具使用\n\n6、http://uk.maven.org/maven2/\n\n7、http://repository.jboss.org/nexus/content/groups/public\n\n8、http://maven.oschina.net/content/groups/public/  oschina可惜啦，以前一直用这个，不过现在有阿里云来擦屁股啦\n\n9、http://mirrors.ibiblio.org/maven2/\n\n10、http://maven.antelink.com/content/repositories/central/\n\n11、http://nexus.openkoala.org/nexus/content/groups/Koala-release/\n\n12、http://maven.tmatesoft.com/content/groups/public/ \n\n---------------------- spring的 -------------------------\n\n&lt;repository&gt;\n    &lt;id&gt;spring-snapshots&lt;/id&gt;\n    &lt;name&gt;Spring Snapshots&lt;/name&gt;\n    &lt;url&gt;https://repo.spring.io/libs-snapshot-local&lt;/url&gt;\n    &lt;snapshots&gt;\n        &lt;enabled&gt;true&lt;/enabled&gt;\n    &lt;/snapshots&gt;\n&lt;/repository&gt;\n&lt;repository&gt;\n    &lt;id&gt;spring-milestones&lt;/id&gt;\n    &lt;name&gt;Spring Milestones&lt;/name&gt;\n    &lt;url&gt;https://repo.spring.io/libs-milestone-local&lt;/url&gt;\n    &lt;snapshots&gt;\n        &lt;enabled&gt;false&lt;/enabled&gt;\n    &lt;/snapshots&gt;\n&lt;/repository&gt;\n&lt;repository&gt;\n    &lt;id&gt;spring-releases&lt;/id&gt;\n    &lt;name&gt;Spring Releases&lt;/name&gt;\n    &lt;url&gt;https://repo.spring.io/libs-release-local&lt;/url&gt;\n    &lt;snapshots&gt;\n        &lt;enabled&gt;false&lt;/enabled&gt;\n    &lt;/snapshots&gt;\n&lt;/repository&gt;  \n</code></pre><h2 id=\"从私服无法拉取构件\"><a href=\"#从私服无法拉取构件\" class=\"headerlink\" title=\"从私服无法拉取构件\"></a>从私服无法拉取构件</h2><ul>\n<li><p>方法一：<br>上传第三方jar到私服，再应用。</p>\n</li>\n<li><p>方法二：<br>找到第三方jar包所在的第三方私服，然后在自己的私服中做代理请求。    </p>\n</li>\n</ul>\n<img src=\"/2018/02/03/maven-ofen/a-1.png\"> \n<p>可以看到里面代理了很多第三方私服，阿里云的，spring的，等。然后整合到<code>maven-pblic</code>group组中即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录在开发过程中经常性使用到的maven特性……</p>\n<h3 id=\"导出maven依赖的jar包到目录\"><a href=\"#导出maven依赖的jar包到目录\" class=\"headerlink\" title=\"导出maven依赖的jar包到目录\"></a>导出maven依赖的jar包到目录</h3><p>方法一：在pom目录下执行命令<br><code>mvn dependency:copy-dependencies</code></p>\n<p>方法二：eclipse项目下：<br>选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行<br>maven项目所依赖的jar包会导出到targed/dependency目录中。</p>\n<img src=\"/2018/02/03/maven-ofen/a.jpg\"> \n<img src=\"/2018/02/03/maven-ofen/b.jpg\"> \n<h3 id=\"maven打包时候跳过test检查\"><a href=\"#maven打包时候跳过test检查\" class=\"headerlink\" title=\"maven打包时候跳过test检查\"></a>maven打包时候跳过test检查</h3><p>方法一： 在pom目录下执行命令<br><code>mvn clean install -Dmaven.test.skip=true</code></p>\n<p>方法二： 在pom中添加插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;skipTests&gt;true&lt;/skipTests&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h3 id=\"打包jar\"><a href=\"#打包jar\" class=\"headerlink\" title=\"打包jar\"></a>打包jar</h3><h4 id=\"普通打包\"><a href=\"#普通打包\" class=\"headerlink\" title=\"普通打包\"></a>普通打包</h4><p>会把maven依赖包一起打包。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;source&gt;1.8&lt;/source&gt;\n        &lt;target&gt;1.8&lt;/target&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h4 id=\"不打包lib\"><a href=\"#不打包lib\" class=\"headerlink\" title=\"不打包lib\"></a>不打包lib</h4><p>在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。<br>让后启动指定main类，并指定依赖包目录lib。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;archive&gt;\n            &lt;manifest&gt;\n                &lt;mainClass&gt;com.xcsqjr.StartAbsServiceAllApplication&lt;/mainClass&gt;\n                &lt;addClasspath&gt;true&lt;/addClasspath&gt;\n                &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;\n            &lt;/manifest&gt;\n            &lt;manifestEntries&gt;\n                &lt;Class-Path&gt;./&lt;/Class-Path&gt;\n            &lt;/manifestEntries&gt;\n        &lt;/archive&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h2 id=\"jar包无法更新下来，爆本地已有缓存\"><a href=\"#jar包无法更新下来，爆本地已有缓存\" class=\"headerlink\" title=\"jar包无法更新下来，爆本地已有缓存\"></a>jar包无法更新下来，爆本地已有缓存</h2><p>有时候，maven依赖包拉取失败，但是有部分内容已经拉取，一部分没拉去，再次更新的时候，不会再次去远程仓库拉取。所以会报错误：</p>\n<pre><code>Maven-010-maven 编译报错：Failure to ... in ... was cached in the local repository, resolution will not be reattempted until the update interval of nexus has elapsed or updates are forced.\n</code></pre><p>解决办法是，在maven配置文件setting.xml中加入如下策略：</p>\n<pre><code>&lt;profile&gt;\n  &lt;id&gt;dev&lt;/id&gt;\n    &lt;repositories&gt;\n        &lt;!--自己私仓,下载jar--&gt;\n        &lt;repository&gt;\n            &lt;id&gt;ymu-public&lt;/id&gt;\n            &lt;name&gt;ymu nexus&lt;/name&gt;\n            &lt;url&gt;http://119.145.41.171:8085/repository/maven-public/&lt;/url&gt;\n            &lt;snapshots&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/snapshots&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/releases&gt;\n        &lt;/repository&gt;\n\n        &lt;repository&gt;\n            &lt;id&gt;central&lt;/id&gt;\n            &lt;url&gt;http://central&lt;/url&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/releases&gt;\n            &lt;snapshots&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/snapshots&gt;\n        &lt;/repository&gt;\n\n    &lt;/repositories&gt;\n\n    &lt;pluginRepositories&gt;\n        &lt;!--私服，插件--&gt;\n        &lt;pluginRepository&gt;\n            &lt;id&gt;ymu-public&lt;/id&gt;\n            &lt;name&gt;ymu nexus&lt;/name&gt;\n            &lt;url&gt;http://119.145.41.171:8085/repository/maven-public/&lt;/url&gt;\n            &lt;snapshots&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/snapshots&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/releases&gt;\n        &lt;/pluginRepository&gt;\n        &lt;pluginRepository&gt;\n            &lt;id&gt;central&lt;/id&gt;\n            &lt;url&gt;http://central&lt;/url&gt;\n            &lt;releases&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/releases&gt;\n            &lt;snapshots&gt;\n                &lt;enabled&gt;true&lt;/enabled&gt;\n                &lt;updatePolicy&gt;always&lt;/updatePolicy&gt;\n            &lt;/snapshots&gt;\n        &lt;/pluginRepository&gt;\n    &lt;/pluginRepositories&gt;\n&lt;/profile&gt;\n</code></pre><p>关键加上属性<code>&lt;updatePolicy&gt;always&lt;/updatePolicy&gt;</code></p>\n<h2 id=\"常用maven中央仓库地址\"><a href=\"#常用maven中央仓库地址\" class=\"headerlink\" title=\"常用maven中央仓库地址\"></a>常用maven中央仓库地址</h2><pre><code>1、http://www.sonatype.org/nexus/  私服nexus工具使用\n2、http://mvnrepository.com/ （推荐）\n3、http://repo1.maven.org/maven2\n\n4、http://maven.aliyun.com/nexus/content/groups/public/  阿里云  （强力推荐）\n\n5、http://repo2.maven.org/maven2/ 私服nexus工具使用\n\n6、http://uk.maven.org/maven2/\n\n7、http://repository.jboss.org/nexus/content/groups/public\n\n8、http://maven.oschina.net/content/groups/public/  oschina可惜啦，以前一直用这个，不过现在有阿里云来擦屁股啦\n\n9、http://mirrors.ibiblio.org/maven2/\n\n10、http://maven.antelink.com/content/repositories/central/\n\n11、http://nexus.openkoala.org/nexus/content/groups/Koala-release/\n\n12、http://maven.tmatesoft.com/content/groups/public/ \n\n---------------------- spring的 -------------------------\n\n&lt;repository&gt;\n    &lt;id&gt;spring-snapshots&lt;/id&gt;\n    &lt;name&gt;Spring Snapshots&lt;/name&gt;\n    &lt;url&gt;https://repo.spring.io/libs-snapshot-local&lt;/url&gt;\n    &lt;snapshots&gt;\n        &lt;enabled&gt;true&lt;/enabled&gt;\n    &lt;/snapshots&gt;\n&lt;/repository&gt;\n&lt;repository&gt;\n    &lt;id&gt;spring-milestones&lt;/id&gt;\n    &lt;name&gt;Spring Milestones&lt;/name&gt;\n    &lt;url&gt;https://repo.spring.io/libs-milestone-local&lt;/url&gt;\n    &lt;snapshots&gt;\n        &lt;enabled&gt;false&lt;/enabled&gt;\n    &lt;/snapshots&gt;\n&lt;/repository&gt;\n&lt;repository&gt;\n    &lt;id&gt;spring-releases&lt;/id&gt;\n    &lt;name&gt;Spring Releases&lt;/name&gt;\n    &lt;url&gt;https://repo.spring.io/libs-release-local&lt;/url&gt;\n    &lt;snapshots&gt;\n        &lt;enabled&gt;false&lt;/enabled&gt;\n    &lt;/snapshots&gt;\n&lt;/repository&gt;  \n</code></pre><h2 id=\"从私服无法拉取构件\"><a href=\"#从私服无法拉取构件\" class=\"headerlink\" title=\"从私服无法拉取构件\"></a>从私服无法拉取构件</h2><ul>\n<li><p>方法一：<br>上传第三方jar到私服，再应用。</p>\n</li>\n<li><p>方法二：<br>找到第三方jar包所在的第三方私服，然后在自己的私服中做代理请求。    </p>\n</li>\n</ul>\n<img src=\"/2018/02/03/maven-ofen/a-1.png\"> \n<p>可以看到里面代理了很多第三方私服，阿里云的，spring的，等。然后整合到<code>maven-pblic</code>group组中即可。</p>\n"},{"title":"maven配置文件加密","date":"2019-02-16T02:16:30.000Z","_content":"\n在使用maven私服的时候，我们需要在maven配置文件settings.xml中配置私服的账号密码，但是明文的密码会暴露出去，每个开发人员都能看到，这就有安全风险。很幸运，maven提供了加密这些密码的方式，下面我们就来学习……\n\n参考：http://maven.apache.org/guides/mini/guide-encryption.html\n\n## 获取master密码\n\n改密码是一个用来加密其它密码的密码。  \n例如下面，对xrlj.123456加密，作为master的密码。\n\n    D:\\apache-maven-3.6.0\\conf>mvn --encrypt-master-password xrlj.123456\n    {Naja8OoiZ1EHpj5eAL2pD3KVDC/qh0EBXZuvivt53+w=}\n    \n然后编辑文件`~/.m2/settings-security.xml`这个文件,如果没有，则新建一个。该文件必须在这个目录下。 \n\n编辑添加内容：\n\n    <settingsSecurity>\n        <master>{Naja8OoiZ1EHpj5eAL2pD3KVDC/qh0EBXZuvivt53+w=}</master>\n    </settingsSecurity>\n    \n也可以把`settings-security.xml`文件放到指定的目录下，编辑内容和上面一样。但是，但是依然要在`~/.m2`目录中编辑`settings-security.xml` ,指向实际的`settings-security.xml`。如下：\n\n      <settingsSecurity>\n          <master>/path/setting-security.xml</master>\n      </settingsSecurity>\n      \n## 加密server的密码\n\n例如，对下面的server加密：\n\n    <server>\n        <id>repository</id>\n        <username>admin</username>\n        <password>admin123</password>\n    </server>\n    \n执行下面命令：\n\n    D:\\apache-maven-3.6.0\\conf>mvn --encrypt-password admin123\n    {K7e0zxQTHJ4HCDH8Wtxj7Lvv0sV2F1qTpAewNVEz7FI=}\n    \n所以配置改为：\n\n    <server>\n        <id>repository</id>\n        <username>admin</username>\n        <password>{K7e0zxQTHJ4HCDH8Wtxj7Lvv0sV2F1qTpAewNVEz7FI=}</password>\n    </server> \n    \n--------------- 完  ------------------------           \n    ","source":"_posts/maven-pwd-encryption.md","raw":"---\ntitle: maven配置文件加密\ndate: 2019-02-16 10:16:30\ncategories: maven\ntags:\n---\n\n在使用maven私服的时候，我们需要在maven配置文件settings.xml中配置私服的账号密码，但是明文的密码会暴露出去，每个开发人员都能看到，这就有安全风险。很幸运，maven提供了加密这些密码的方式，下面我们就来学习……\n\n参考：http://maven.apache.org/guides/mini/guide-encryption.html\n\n## 获取master密码\n\n改密码是一个用来加密其它密码的密码。  \n例如下面，对xrlj.123456加密，作为master的密码。\n\n    D:\\apache-maven-3.6.0\\conf>mvn --encrypt-master-password xrlj.123456\n    {Naja8OoiZ1EHpj5eAL2pD3KVDC/qh0EBXZuvivt53+w=}\n    \n然后编辑文件`~/.m2/settings-security.xml`这个文件,如果没有，则新建一个。该文件必须在这个目录下。 \n\n编辑添加内容：\n\n    <settingsSecurity>\n        <master>{Naja8OoiZ1EHpj5eAL2pD3KVDC/qh0EBXZuvivt53+w=}</master>\n    </settingsSecurity>\n    \n也可以把`settings-security.xml`文件放到指定的目录下，编辑内容和上面一样。但是，但是依然要在`~/.m2`目录中编辑`settings-security.xml` ,指向实际的`settings-security.xml`。如下：\n\n      <settingsSecurity>\n          <master>/path/setting-security.xml</master>\n      </settingsSecurity>\n      \n## 加密server的密码\n\n例如，对下面的server加密：\n\n    <server>\n        <id>repository</id>\n        <username>admin</username>\n        <password>admin123</password>\n    </server>\n    \n执行下面命令：\n\n    D:\\apache-maven-3.6.0\\conf>mvn --encrypt-password admin123\n    {K7e0zxQTHJ4HCDH8Wtxj7Lvv0sV2F1qTpAewNVEz7FI=}\n    \n所以配置改为：\n\n    <server>\n        <id>repository</id>\n        <username>admin</username>\n        <password>{K7e0zxQTHJ4HCDH8Wtxj7Lvv0sV2F1qTpAewNVEz7FI=}</password>\n    </server> \n    \n--------------- 完  ------------------------           \n    ","slug":"maven-pwd-encryption","published":1,"updated":"2019-06-16T14:38:33.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdk0072g4vaqnql4cyr","content":"<p>在使用maven私服的时候，我们需要在maven配置文件settings.xml中配置私服的账号密码，但是明文的密码会暴露出去，每个开发人员都能看到，这就有安全风险。很幸运，maven提供了加密这些密码的方式，下面我们就来学习……</p>\n<p>参考：<a href=\"http://maven.apache.org/guides/mini/guide-encryption.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/guides/mini/guide-encryption.html</a></p>\n<h2 id=\"获取master密码\"><a href=\"#获取master密码\" class=\"headerlink\" title=\"获取master密码\"></a>获取master密码</h2><p>改密码是一个用来加密其它密码的密码。<br>例如下面，对xrlj.123456加密，作为master的密码。</p>\n<pre><code>D:\\apache-maven-3.6.0\\conf&gt;mvn --encrypt-master-password xrlj.123456\n{Naja8OoiZ1EHpj5eAL2pD3KVDC/qh0EBXZuvivt53+w=}\n</code></pre><p>然后编辑文件<code>~/.m2/settings-security.xml</code>这个文件,如果没有，则新建一个。该文件必须在这个目录下。 </p>\n<p>编辑添加内容：</p>\n<pre><code>&lt;settingsSecurity&gt;\n    &lt;master&gt;{Naja8OoiZ1EHpj5eAL2pD3KVDC/qh0EBXZuvivt53+w=}&lt;/master&gt;\n&lt;/settingsSecurity&gt;\n</code></pre><p>也可以把<code>settings-security.xml</code>文件放到指定的目录下，编辑内容和上面一样。但是，但是依然要在<code>~/.m2</code>目录中编辑<code>settings-security.xml</code> ,指向实际的<code>settings-security.xml</code>。如下：</p>\n<pre><code>&lt;settingsSecurity&gt;\n    &lt;master&gt;/path/setting-security.xml&lt;/master&gt;\n&lt;/settingsSecurity&gt;\n</code></pre><h2 id=\"加密server的密码\"><a href=\"#加密server的密码\" class=\"headerlink\" title=\"加密server的密码\"></a>加密server的密码</h2><p>例如，对下面的server加密：</p>\n<pre><code>&lt;server&gt;\n    &lt;id&gt;repository&lt;/id&gt;\n    &lt;username&gt;admin&lt;/username&gt;\n    &lt;password&gt;admin123&lt;/password&gt;\n&lt;/server&gt;\n</code></pre><p>执行下面命令：</p>\n<pre><code>D:\\apache-maven-3.6.0\\conf&gt;mvn --encrypt-password admin123\n{K7e0zxQTHJ4HCDH8Wtxj7Lvv0sV2F1qTpAewNVEz7FI=}\n</code></pre><p>所以配置改为：</p>\n<pre><code>&lt;server&gt;\n    &lt;id&gt;repository&lt;/id&gt;\n    &lt;username&gt;admin&lt;/username&gt;\n    &lt;password&gt;{K7e0zxQTHJ4HCDH8Wtxj7Lvv0sV2F1qTpAewNVEz7FI=}&lt;/password&gt;\n&lt;/server&gt; \n</code></pre><p>————— 完  ————————           </p>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用maven私服的时候，我们需要在maven配置文件settings.xml中配置私服的账号密码，但是明文的密码会暴露出去，每个开发人员都能看到，这就有安全风险。很幸运，maven提供了加密这些密码的方式，下面我们就来学习……</p>\n<p>参考：<a href=\"http://maven.apache.org/guides/mini/guide-encryption.html\" target=\"_blank\" rel=\"noopener\">http://maven.apache.org/guides/mini/guide-encryption.html</a></p>\n<h2 id=\"获取master密码\"><a href=\"#获取master密码\" class=\"headerlink\" title=\"获取master密码\"></a>获取master密码</h2><p>改密码是一个用来加密其它密码的密码。<br>例如下面，对xrlj.123456加密，作为master的密码。</p>\n<pre><code>D:\\apache-maven-3.6.0\\conf&gt;mvn --encrypt-master-password xrlj.123456\n{Naja8OoiZ1EHpj5eAL2pD3KVDC/qh0EBXZuvivt53+w=}\n</code></pre><p>然后编辑文件<code>~/.m2/settings-security.xml</code>这个文件,如果没有，则新建一个。该文件必须在这个目录下。 </p>\n<p>编辑添加内容：</p>\n<pre><code>&lt;settingsSecurity&gt;\n    &lt;master&gt;{Naja8OoiZ1EHpj5eAL2pD3KVDC/qh0EBXZuvivt53+w=}&lt;/master&gt;\n&lt;/settingsSecurity&gt;\n</code></pre><p>也可以把<code>settings-security.xml</code>文件放到指定的目录下，编辑内容和上面一样。但是，但是依然要在<code>~/.m2</code>目录中编辑<code>settings-security.xml</code> ,指向实际的<code>settings-security.xml</code>。如下：</p>\n<pre><code>&lt;settingsSecurity&gt;\n    &lt;master&gt;/path/setting-security.xml&lt;/master&gt;\n&lt;/settingsSecurity&gt;\n</code></pre><h2 id=\"加密server的密码\"><a href=\"#加密server的密码\" class=\"headerlink\" title=\"加密server的密码\"></a>加密server的密码</h2><p>例如，对下面的server加密：</p>\n<pre><code>&lt;server&gt;\n    &lt;id&gt;repository&lt;/id&gt;\n    &lt;username&gt;admin&lt;/username&gt;\n    &lt;password&gt;admin123&lt;/password&gt;\n&lt;/server&gt;\n</code></pre><p>执行下面命令：</p>\n<pre><code>D:\\apache-maven-3.6.0\\conf&gt;mvn --encrypt-password admin123\n{K7e0zxQTHJ4HCDH8Wtxj7Lvv0sV2F1qTpAewNVEz7FI=}\n</code></pre><p>所以配置改为：</p>\n<pre><code>&lt;server&gt;\n    &lt;id&gt;repository&lt;/id&gt;\n    &lt;username&gt;admin&lt;/username&gt;\n    &lt;password&gt;{K7e0zxQTHJ4HCDH8Wtxj7Lvv0sV2F1qTpAewNVEz7FI=}&lt;/password&gt;\n&lt;/server&gt; \n</code></pre><p>————— 完  ————————           </p>\n"},{"title":"maven使用常见错误收集","date":"2017-10-25T06:41:24.000Z","_content":"\n本文收集使用maven过程中的常见错误。\n\n> - 问题：\nmaven继承，使用 *`<relativePath></relativePath>`*，出现找不到指向pom，但是实际上已经正确指向了。 \n- 解决：\n    The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, `the group ID, artifact ID and version are still required,` and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.\n  Default value is: ../pom.xml.\n  *所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。*\n    \n    \n","source":"_posts/maven-use-error-collect.md","raw":"---\ntitle: maven使用常见错误收集\ndate: 2017-10-25 14:41:24\ncategories: maven\ntags: maven-error\n---\n\n本文收集使用maven过程中的常见错误。\n\n> - 问题：\nmaven继承，使用 *`<relativePath></relativePath>`*，出现找不到指向pom，但是实际上已经正确指向了。 \n- 解决：\n    The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, `the group ID, artifact ID and version are still required,` and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.\n  Default value is: ../pom.xml.\n  *所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。*\n    \n    \n","slug":"maven-use-error-collect","published":1,"updated":"2019-06-16T14:38:33.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdl0075g4vad9llfiaz","content":"<p>本文收集使用maven过程中的常见错误。</p>\n<blockquote>\n<ul>\n<li>问题：<br>maven继承，使用 <em><code>&lt;relativePath&gt;&lt;/relativePath&gt;</code></em>，出现找不到指向pom，但是实际上已经正确指向了。 </li>\n<li>解决：<br>  The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, <code>the group ID, artifact ID and version are still required,</code> and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.<br>Default value is: ../pom.xml.<br><em>所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。</em></li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>本文收集使用maven过程中的常见错误。</p>\n<blockquote>\n<ul>\n<li>问题：<br>maven继承，使用 <em><code>&lt;relativePath&gt;&lt;/relativePath&gt;</code></em>，出现找不到指向pom，但是实际上已经正确指向了。 </li>\n<li>解决：<br>  The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, <code>the group ID, artifact ID and version are still required,</code> and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.<br>Default value is: ../pom.xml.<br><em>所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。</em></li>\n</ul>\n</blockquote>\n"},{"title":"利用metrics、influxdata或者Elasticsearch、grafana搭建应用监控平台","date":"2019-03-16T06:01:23.000Z","_content":"\nhttps://metrics.dropwizard.io/4.0.0/index.html# \n\nhttps://www.influxdata.com/ \n\nhttps://grafana.com/\n","source":"_posts/metrics-influxdata-grafana.md","raw":"---\ntitle: 利用metrics、influxdata或者Elasticsearch、grafana搭建应用监控平台\ndate: 2019-03-16 14:01:23\ncategories: 监控\ntags:\n---\n\nhttps://metrics.dropwizard.io/4.0.0/index.html# \n\nhttps://www.influxdata.com/ \n\nhttps://grafana.com/\n","slug":"metrics-influxdata-grafana","published":1,"updated":"2019-06-16T14:38:33.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdn0078g4va1jrx6ph2","content":"<p><a href=\"https://metrics.dropwizard.io/4.0.0/index.html#\" target=\"_blank\" rel=\"noopener\">https://metrics.dropwizard.io/4.0.0/index.html#</a> </p>\n<p><a href=\"https://www.influxdata.com/\" target=\"_blank\" rel=\"noopener\">https://www.influxdata.com/</a> </p>\n<p><a href=\"https://grafana.com/\" target=\"_blank\" rel=\"noopener\">https://grafana.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://metrics.dropwizard.io/4.0.0/index.html#\" target=\"_blank\" rel=\"noopener\">https://metrics.dropwizard.io/4.0.0/index.html#</a> </p>\n<p><a href=\"https://www.influxdata.com/\" target=\"_blank\" rel=\"noopener\">https://www.influxdata.com/</a> </p>\n<p><a href=\"https://grafana.com/\" target=\"_blank\" rel=\"noopener\">https://grafana.com/</a></p>\n"},{"title":"java应用服务性能监控metrics入门","date":"2019-03-16T05:51:52.000Z","_content":"","source":"_posts/metrics-start.md","raw":"---\ntitle: java应用服务性能监控metrics入门\ndate: 2019-03-16 13:51:52\ncategories: 监控\ntags:\n---\n","slug":"metrics-start","published":1,"updated":"2019-06-16T14:38:33.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdo007bg4vagkbhex5s","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"微服务实践思考","date":"2017-09-26T02:14:45.000Z","_content":"","source":"_posts/microservice-think.md","raw":"---\ntitle: 微服务实践思考\ndate: 2017-09-26 10:14:45\ncategories: micro-service\ntags: 微服务实践总结\n---\n","slug":"microservice-think","published":1,"updated":"2019-06-16T14:38:33.422Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdq007fg4va030xfo13","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"mysql复制","date":"2018-10-24T14:00:17.000Z","_content":"\n系统性能的提升，高并发的实现，其中一个部分就是提高数据库性能。而数据库的读写分离，就是其中一个优化。在主库写入，在读库做查询，减少主库的请求压力，这对整个系统将会有大大性能提升。   \n但是，这里会出现一个问题，就是主从库在数据同步时候，会出现迟延问题，如何保证数据同步及时，保证数据一致性将是个难题。但是，在一般要求不是实时的系统，是没问题。     \n下面我们就来逐个探索这些问题的……   \n\n## docker环境搭建mysql关系数据库一主多从架构\n\ndocker安装mysql。参考章节{% post_link  docker-app-install docker安装mysql %}  \n\n### 在三台服务器安装mysql服务器。    \n\n其中一台作为master，一台slave1，一台slave2，一主二从配置。\n\n1.修改每台mysql服务配置：    \n\n- 主库master配置修改：   \n\n\n    [mysqld] \n    port = 3910\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    \n    log-bin = mysql-bin\n    server-id = 1\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n    \n_注_： 主要就是在原来配置上，添加下面两行：  \n\n    log-bin = mysql-bin\n    server-id = 1\n\n> _说明_:   \nserver-id=1： 唯一服务器ID，非0整数，不能和其他服务器的server-id重复\nlog-bin=mysql-bin：开启二进制日志功能。使用binary logging，mysql-bin是log文件名的前缀\n\n- 从库slave1，配置文件修改：  \n\n\n    [mysqld] \n    port = 3911\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    \n    log-bin = mysql-bin\n    server-id = 2\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n    \n- 从库slave2，配置文件修改：  \n\n\n    [mysqld] \n    port = 3912\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    \n    log-bin = mysql-bin\n    server-id = 3\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n    \n2.重新启动三个mysql服务：    \n\n    docker restart mysql容器  \n    \n3.用navicat工具连接数据库\n\n保证三台mysql数据都能正确连接。   \n\n{%asset_img a-1.png%} \n\n### 配置主从关系\n\n为了方便直接在navicat客户端连接操作。  \n\n#### 在master操作   \n\n1.新增用来复制数据的用户：  \n\n    CREATE USER 'slave'@'%' IDENTIFIED BY '123456';\n    \n用户名：slave  密码：123456\n\n2.对用户slave授权：   \n\n    GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';\n    \n3.查看授权： \n\n    show grants for 'slave'@'%';\n    \n4.查看主库状态：   \n\n    show master status;\n    \n{%asset_img a-2.png%}  \n\n如图，字段File，Position,后面会用到。   \n\n到此，不要再操作主库。 否则这连个字段会变。   \n\n#### 从库slave1操作  \n\n1.连接从库slave1，执行如下命令：    \n\n    change master to master_host='192.168.199.101', master_user='slave', master_password='123456', master_port=3910, master_log_file='mysql-bin.000001', master_log_pos= 155, master_connect_retry=30;\n    \n_命令说明：_ \n\n- master_host： 主数据库ip地址，navicat连接的master库的ip地址即可。   \n- master_user： 上面在主库创建的用来复制数据的用户名。\n- master_port： 主库的端口，navicat连接的端口。  \n- master_password： 用于同步数据的主库用户的对应密码。    \n- master_log_file: 指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值。    \n- master_log_pos： 从哪个 Position 开始读，即上文中提到的 Position 字段的值。\n- master_connect_retry： 如果连接失败，重试的时间间隔，单位是秒，默认是60秒。\n\n2.查看从库状态：   \n\n    show slave status;\n\n正常会看到，Slave_IO_State字段是空的，Slave_IO_Runngin为NO，Slave_SQL_Running为No。 \n那是因为还没启动主从复制服务。 \n\n3.启动主从复制功能： \n\n    start slave;\n    \n启动后，再次查看从库状态：   \n\n    show slave status;\n    \n{%asset_img a-3.png%}    \n        \n如果看到： \n                   \nSlave_IO_State：  Waiting for master to send event       \nSlave_IO_Runngin： YES       \nSlave_SQL_Running: YES  \n\n则说明主从配置成功了。 \n\n4.停止主从配置服务： \n\n    stop slave;\n    \n5.刷新主从配置信息，重新设置主从配置：    \n\n    reset slave all;    \n\n#### 从库slave2操作\n\n从库slave2的操作，和在从库slave1上的操作一样。\n\n    show slave status;\n    \n    change master to master_host='192.168.199.101', master_user='slave', master_password='123456', master_port=3910, master_log_file='mysql-bin.000001', master_log_pos= 155, master_connect_retry=30;\n    \n    start slave;\n    \n    show slave status;\n\n### 测试主从配置\n \n在主库，随便新建数据库，新增表，然后打开两个从库，你会马上看到同样的库和表。  \n\n恭喜你，一主二从配置成功了。\n\n## 双主双从配置\n\n待续……\n\n\n      ","source":"_posts/mysql-copy.md","raw":"---\ntitle: mysql复制\ndate: 2018-10-24 22:00:17\ncategories: mysql\ntags: mysql一主多从配置\n---\n\n系统性能的提升，高并发的实现，其中一个部分就是提高数据库性能。而数据库的读写分离，就是其中一个优化。在主库写入，在读库做查询，减少主库的请求压力，这对整个系统将会有大大性能提升。   \n但是，这里会出现一个问题，就是主从库在数据同步时候，会出现迟延问题，如何保证数据同步及时，保证数据一致性将是个难题。但是，在一般要求不是实时的系统，是没问题。     \n下面我们就来逐个探索这些问题的……   \n\n## docker环境搭建mysql关系数据库一主多从架构\n\ndocker安装mysql。参考章节{% post_link  docker-app-install docker安装mysql %}  \n\n### 在三台服务器安装mysql服务器。    \n\n其中一台作为master，一台slave1，一台slave2，一主二从配置。\n\n1.修改每台mysql服务配置：    \n\n- 主库master配置修改：   \n\n\n    [mysqld] \n    port = 3910\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    \n    log-bin = mysql-bin\n    server-id = 1\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n    \n_注_： 主要就是在原来配置上，添加下面两行：  \n\n    log-bin = mysql-bin\n    server-id = 1\n\n> _说明_:   \nserver-id=1： 唯一服务器ID，非0整数，不能和其他服务器的server-id重复\nlog-bin=mysql-bin：开启二进制日志功能。使用binary logging，mysql-bin是log文件名的前缀\n\n- 从库slave1，配置文件修改：  \n\n\n    [mysqld] \n    port = 3911\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    \n    log-bin = mysql-bin\n    server-id = 2\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n    \n- 从库slave2，配置文件修改：  \n\n\n    [mysqld] \n    port = 3912\n    character-set-client-handshake = FALSE \n    character-set-server = utf8mb4 \n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    \n    log-bin = mysql-bin\n    server-id = 3\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n    \n2.重新启动三个mysql服务：    \n\n    docker restart mysql容器  \n    \n3.用navicat工具连接数据库\n\n保证三台mysql数据都能正确连接。   \n\n{%asset_img a-1.png%} \n\n### 配置主从关系\n\n为了方便直接在navicat客户端连接操作。  \n\n#### 在master操作   \n\n1.新增用来复制数据的用户：  \n\n    CREATE USER 'slave'@'%' IDENTIFIED BY '123456';\n    \n用户名：slave  密码：123456\n\n2.对用户slave授权：   \n\n    GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO 'slave'@'%';\n    \n3.查看授权： \n\n    show grants for 'slave'@'%';\n    \n4.查看主库状态：   \n\n    show master status;\n    \n{%asset_img a-2.png%}  \n\n如图，字段File，Position,后面会用到。   \n\n到此，不要再操作主库。 否则这连个字段会变。   \n\n#### 从库slave1操作  \n\n1.连接从库slave1，执行如下命令：    \n\n    change master to master_host='192.168.199.101', master_user='slave', master_password='123456', master_port=3910, master_log_file='mysql-bin.000001', master_log_pos= 155, master_connect_retry=30;\n    \n_命令说明：_ \n\n- master_host： 主数据库ip地址，navicat连接的master库的ip地址即可。   \n- master_user： 上面在主库创建的用来复制数据的用户名。\n- master_port： 主库的端口，navicat连接的端口。  \n- master_password： 用于同步数据的主库用户的对应密码。    \n- master_log_file: 指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值。    \n- master_log_pos： 从哪个 Position 开始读，即上文中提到的 Position 字段的值。\n- master_connect_retry： 如果连接失败，重试的时间间隔，单位是秒，默认是60秒。\n\n2.查看从库状态：   \n\n    show slave status;\n\n正常会看到，Slave_IO_State字段是空的，Slave_IO_Runngin为NO，Slave_SQL_Running为No。 \n那是因为还没启动主从复制服务。 \n\n3.启动主从复制功能： \n\n    start slave;\n    \n启动后，再次查看从库状态：   \n\n    show slave status;\n    \n{%asset_img a-3.png%}    \n        \n如果看到： \n                   \nSlave_IO_State：  Waiting for master to send event       \nSlave_IO_Runngin： YES       \nSlave_SQL_Running: YES  \n\n则说明主从配置成功了。 \n\n4.停止主从配置服务： \n\n    stop slave;\n    \n5.刷新主从配置信息，重新设置主从配置：    \n\n    reset slave all;    \n\n#### 从库slave2操作\n\n从库slave2的操作，和在从库slave1上的操作一样。\n\n    show slave status;\n    \n    change master to master_host='192.168.199.101', master_user='slave', master_password='123456', master_port=3910, master_log_file='mysql-bin.000001', master_log_pos= 155, master_connect_retry=30;\n    \n    start slave;\n    \n    show slave status;\n\n### 测试主从配置\n \n在主库，随便新建数据库，新增表，然后打开两个从库，你会马上看到同样的库和表。  \n\n恭喜你，一主二从配置成功了。\n\n## 双主双从配置\n\n待续……\n\n\n      ","slug":"mysql-copy","published":1,"updated":"2019-06-16T14:38:33.423Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqds007ig4vae8s6qi2w","content":"<p>系统性能的提升，高并发的实现，其中一个部分就是提高数据库性能。而数据库的读写分离，就是其中一个优化。在主库写入，在读库做查询，减少主库的请求压力，这对整个系统将会有大大性能提升。<br>但是，这里会出现一个问题，就是主从库在数据同步时候，会出现迟延问题，如何保证数据同步及时，保证数据一致性将是个难题。但是，在一般要求不是实时的系统，是没问题。<br>下面我们就来逐个探索这些问题的……   </p>\n<h2 id=\"docker环境搭建mysql关系数据库一主多从架构\"><a href=\"#docker环境搭建mysql关系数据库一主多从架构\" class=\"headerlink\" title=\"docker环境搭建mysql关系数据库一主多从架构\"></a>docker环境搭建mysql关系数据库一主多从架构</h2><p>docker安装mysql。参考章节<a href=\"/2018/07/19/docker-app-install/\" title=\"docker安装mysql\">docker安装mysql</a>  </p>\n<h3 id=\"在三台服务器安装mysql服务器。\"><a href=\"#在三台服务器安装mysql服务器。\" class=\"headerlink\" title=\"在三台服务器安装mysql服务器。\"></a>在三台服务器安装mysql服务器。</h3><p>其中一台作为master，一台slave1，一台slave2，一主二从配置。</p>\n<p>1.修改每台mysql服务配置：    </p>\n<ul>\n<li>主库master配置修改：   </li>\n</ul>\n<pre><code>[mysqld] \nport = 3910\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\n\nlog-bin = mysql-bin\nserver-id = 1\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><p>_注_： 主要就是在原来配置上，添加下面两行：  </p>\n<pre><code>log-bin = mysql-bin\nserver-id = 1\n</code></pre><blockquote>\n<p>_说明_:<br>server-id=1： 唯一服务器ID，非0整数，不能和其他服务器的server-id重复<br>log-bin=mysql-bin：开启二进制日志功能。使用binary logging，mysql-bin是log文件名的前缀</p>\n</blockquote>\n<ul>\n<li>从库slave1，配置文件修改：  </li>\n</ul>\n<pre><code>[mysqld] \nport = 3911\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\n\nlog-bin = mysql-bin\nserver-id = 2\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><ul>\n<li>从库slave2，配置文件修改：  </li>\n</ul>\n<pre><code>[mysqld] \nport = 3912\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\n\nlog-bin = mysql-bin\nserver-id = 3\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><p>2.重新启动三个mysql服务：    </p>\n<pre><code>docker restart mysql容器  \n</code></pre><p>3.用navicat工具连接数据库</p>\n<p>保证三台mysql数据都能正确连接。   </p>\n<img src=\"/2018/10/24/mysql-copy/a-1.png\"> \n<h3 id=\"配置主从关系\"><a href=\"#配置主从关系\" class=\"headerlink\" title=\"配置主从关系\"></a>配置主从关系</h3><p>为了方便直接在navicat客户端连接操作。  </p>\n<h4 id=\"在master操作\"><a href=\"#在master操作\" class=\"headerlink\" title=\"在master操作\"></a>在master操作</h4><p>1.新增用来复制数据的用户：  </p>\n<pre><code>CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;\n</code></pre><p>用户名：slave  密码：123456</p>\n<p>2.对用户slave授权：   </p>\n<pre><code>GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;slave&apos;@&apos;%&apos;;\n</code></pre><p>3.查看授权： </p>\n<pre><code>show grants for &apos;slave&apos;@&apos;%&apos;;\n</code></pre><p>4.查看主库状态：   </p>\n<pre><code>show master status;\n</code></pre><img src=\"/2018/10/24/mysql-copy/a-2.png\">  \n<p>如图，字段File，Position,后面会用到。   </p>\n<p>到此，不要再操作主库。 否则这连个字段会变。   </p>\n<h4 id=\"从库slave1操作\"><a href=\"#从库slave1操作\" class=\"headerlink\" title=\"从库slave1操作\"></a>从库slave1操作</h4><p>1.连接从库slave1，执行如下命令：    </p>\n<pre><code>change master to master_host=&apos;192.168.199.101&apos;, master_user=&apos;slave&apos;, master_password=&apos;123456&apos;, master_port=3910, master_log_file=&apos;mysql-bin.000001&apos;, master_log_pos= 155, master_connect_retry=30;\n</code></pre><p><em>命令说明：</em> </p>\n<ul>\n<li>master_host： 主数据库ip地址，navicat连接的master库的ip地址即可。   </li>\n<li>master_user： 上面在主库创建的用来复制数据的用户名。</li>\n<li>master_port： 主库的端口，navicat连接的端口。  </li>\n<li>master_password： 用于同步数据的主库用户的对应密码。    </li>\n<li>master_log_file: 指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值。    </li>\n<li>master_log_pos： 从哪个 Position 开始读，即上文中提到的 Position 字段的值。</li>\n<li>master_connect_retry： 如果连接失败，重试的时间间隔，单位是秒，默认是60秒。</li>\n</ul>\n<p>2.查看从库状态：   </p>\n<pre><code>show slave status;\n</code></pre><p>正常会看到，Slave_IO_State字段是空的，Slave_IO_Runngin为NO，Slave_SQL_Running为No。<br>那是因为还没启动主从复制服务。 </p>\n<p>3.启动主从复制功能： </p>\n<pre><code>start slave;\n</code></pre><p>启动后，再次查看从库状态：   </p>\n<pre><code>show slave status;\n</code></pre><img src=\"/2018/10/24/mysql-copy/a-3.png\">    \n<p>如果看到： </p>\n<p>Slave_IO_State：  Waiting for master to send event<br>Slave_IO_Runngin： YES<br>Slave_SQL_Running: YES  </p>\n<p>则说明主从配置成功了。 </p>\n<p>4.停止主从配置服务： </p>\n<pre><code>stop slave;\n</code></pre><p>5.刷新主从配置信息，重新设置主从配置：    </p>\n<pre><code>reset slave all;    \n</code></pre><h4 id=\"从库slave2操作\"><a href=\"#从库slave2操作\" class=\"headerlink\" title=\"从库slave2操作\"></a>从库slave2操作</h4><p>从库slave2的操作，和在从库slave1上的操作一样。</p>\n<pre><code>show slave status;\n\nchange master to master_host=&apos;192.168.199.101&apos;, master_user=&apos;slave&apos;, master_password=&apos;123456&apos;, master_port=3910, master_log_file=&apos;mysql-bin.000001&apos;, master_log_pos= 155, master_connect_retry=30;\n\nstart slave;\n\nshow slave status;\n</code></pre><h3 id=\"测试主从配置\"><a href=\"#测试主从配置\" class=\"headerlink\" title=\"测试主从配置\"></a>测试主从配置</h3><p>在主库，随便新建数据库，新增表，然后打开两个从库，你会马上看到同样的库和表。  </p>\n<p>恭喜你，一主二从配置成功了。</p>\n<h2 id=\"双主双从配置\"><a href=\"#双主双从配置\" class=\"headerlink\" title=\"双主双从配置\"></a>双主双从配置</h2><p>待续……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>系统性能的提升，高并发的实现，其中一个部分就是提高数据库性能。而数据库的读写分离，就是其中一个优化。在主库写入，在读库做查询，减少主库的请求压力，这对整个系统将会有大大性能提升。<br>但是，这里会出现一个问题，就是主从库在数据同步时候，会出现迟延问题，如何保证数据同步及时，保证数据一致性将是个难题。但是，在一般要求不是实时的系统，是没问题。<br>下面我们就来逐个探索这些问题的……   </p>\n<h2 id=\"docker环境搭建mysql关系数据库一主多从架构\"><a href=\"#docker环境搭建mysql关系数据库一主多从架构\" class=\"headerlink\" title=\"docker环境搭建mysql关系数据库一主多从架构\"></a>docker环境搭建mysql关系数据库一主多从架构</h2><p>docker安装mysql。参考章节<a href=\"/2018/07/19/docker-app-install/\" title=\"docker安装mysql\">docker安装mysql</a>  </p>\n<h3 id=\"在三台服务器安装mysql服务器。\"><a href=\"#在三台服务器安装mysql服务器。\" class=\"headerlink\" title=\"在三台服务器安装mysql服务器。\"></a>在三台服务器安装mysql服务器。</h3><p>其中一台作为master，一台slave1，一台slave2，一主二从配置。</p>\n<p>1.修改每台mysql服务配置：    </p>\n<ul>\n<li>主库master配置修改：   </li>\n</ul>\n<pre><code>[mysqld] \nport = 3910\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\n\nlog-bin = mysql-bin\nserver-id = 1\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><p>_注_： 主要就是在原来配置上，添加下面两行：  </p>\n<pre><code>log-bin = mysql-bin\nserver-id = 1\n</code></pre><blockquote>\n<p>_说明_:<br>server-id=1： 唯一服务器ID，非0整数，不能和其他服务器的server-id重复<br>log-bin=mysql-bin：开启二进制日志功能。使用binary logging，mysql-bin是log文件名的前缀</p>\n</blockquote>\n<ul>\n<li>从库slave1，配置文件修改：  </li>\n</ul>\n<pre><code>[mysqld] \nport = 3911\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\n\nlog-bin = mysql-bin\nserver-id = 2\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><ul>\n<li>从库slave2，配置文件修改：  </li>\n</ul>\n<pre><code>[mysqld] \nport = 3912\ncharacter-set-client-handshake = FALSE \ncharacter-set-server = utf8mb4 \ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\n\nlog-bin = mysql-bin\nserver-id = 3\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><p>2.重新启动三个mysql服务：    </p>\n<pre><code>docker restart mysql容器  \n</code></pre><p>3.用navicat工具连接数据库</p>\n<p>保证三台mysql数据都能正确连接。   </p>\n<img src=\"/2018/10/24/mysql-copy/a-1.png\"> \n<h3 id=\"配置主从关系\"><a href=\"#配置主从关系\" class=\"headerlink\" title=\"配置主从关系\"></a>配置主从关系</h3><p>为了方便直接在navicat客户端连接操作。  </p>\n<h4 id=\"在master操作\"><a href=\"#在master操作\" class=\"headerlink\" title=\"在master操作\"></a>在master操作</h4><p>1.新增用来复制数据的用户：  </p>\n<pre><code>CREATE USER &apos;slave&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos;;\n</code></pre><p>用户名：slave  密码：123456</p>\n<p>2.对用户slave授权：   </p>\n<pre><code>GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &apos;slave&apos;@&apos;%&apos;;\n</code></pre><p>3.查看授权： </p>\n<pre><code>show grants for &apos;slave&apos;@&apos;%&apos;;\n</code></pre><p>4.查看主库状态：   </p>\n<pre><code>show master status;\n</code></pre><img src=\"/2018/10/24/mysql-copy/a-2.png\">  \n<p>如图，字段File，Position,后面会用到。   </p>\n<p>到此，不要再操作主库。 否则这连个字段会变。   </p>\n<h4 id=\"从库slave1操作\"><a href=\"#从库slave1操作\" class=\"headerlink\" title=\"从库slave1操作\"></a>从库slave1操作</h4><p>1.连接从库slave1，执行如下命令：    </p>\n<pre><code>change master to master_host=&apos;192.168.199.101&apos;, master_user=&apos;slave&apos;, master_password=&apos;123456&apos;, master_port=3910, master_log_file=&apos;mysql-bin.000001&apos;, master_log_pos= 155, master_connect_retry=30;\n</code></pre><p><em>命令说明：</em> </p>\n<ul>\n<li>master_host： 主数据库ip地址，navicat连接的master库的ip地址即可。   </li>\n<li>master_user： 上面在主库创建的用来复制数据的用户名。</li>\n<li>master_port： 主库的端口，navicat连接的端口。  </li>\n<li>master_password： 用于同步数据的主库用户的对应密码。    </li>\n<li>master_log_file: 指定 Slave 从哪个日志文件开始复制数据，即上文中提到的 File 字段的值。    </li>\n<li>master_log_pos： 从哪个 Position 开始读，即上文中提到的 Position 字段的值。</li>\n<li>master_connect_retry： 如果连接失败，重试的时间间隔，单位是秒，默认是60秒。</li>\n</ul>\n<p>2.查看从库状态：   </p>\n<pre><code>show slave status;\n</code></pre><p>正常会看到，Slave_IO_State字段是空的，Slave_IO_Runngin为NO，Slave_SQL_Running为No。<br>那是因为还没启动主从复制服务。 </p>\n<p>3.启动主从复制功能： </p>\n<pre><code>start slave;\n</code></pre><p>启动后，再次查看从库状态：   </p>\n<pre><code>show slave status;\n</code></pre><img src=\"/2018/10/24/mysql-copy/a-3.png\">    \n<p>如果看到： </p>\n<p>Slave_IO_State：  Waiting for master to send event<br>Slave_IO_Runngin： YES<br>Slave_SQL_Running: YES  </p>\n<p>则说明主从配置成功了。 </p>\n<p>4.停止主从配置服务： </p>\n<pre><code>stop slave;\n</code></pre><p>5.刷新主从配置信息，重新设置主从配置：    </p>\n<pre><code>reset slave all;    \n</code></pre><h4 id=\"从库slave2操作\"><a href=\"#从库slave2操作\" class=\"headerlink\" title=\"从库slave2操作\"></a>从库slave2操作</h4><p>从库slave2的操作，和在从库slave1上的操作一样。</p>\n<pre><code>show slave status;\n\nchange master to master_host=&apos;192.168.199.101&apos;, master_user=&apos;slave&apos;, master_password=&apos;123456&apos;, master_port=3910, master_log_file=&apos;mysql-bin.000001&apos;, master_log_pos= 155, master_connect_retry=30;\n\nstart slave;\n\nshow slave status;\n</code></pre><h3 id=\"测试主从配置\"><a href=\"#测试主从配置\" class=\"headerlink\" title=\"测试主从配置\"></a>测试主从配置</h3><p>在主库，随便新建数据库，新增表，然后打开两个从库，你会马上看到同样的库和表。  </p>\n<p>恭喜你，一主二从配置成功了。</p>\n<h2 id=\"双主双从配置\"><a href=\"#双主双从配置\" class=\"headerlink\" title=\"双主双从配置\"></a>双主双从配置</h2><p>待续……</p>\n"},{"title":"mysql主从复制延迟问题","date":"2018-10-24T14:11:17.000Z","_content":"\n参考博文：\n\n1.https://blog.csdn.net/hao_yunfeng/article/details/82392261    \n\n2.https://cloud.tencent.com/developer/news/218904\n","source":"_posts/mysql-copy-delay.md","raw":"---\ntitle: mysql主从复制延迟问题\ndate: 2018-10-24 22:11:17\ncategories: mysql\ntags:\n---\n\n参考博文：\n\n1.https://blog.csdn.net/hao_yunfeng/article/details/82392261    \n\n2.https://cloud.tencent.com/developer/news/218904\n","slug":"mysql-copy-delay","published":1,"updated":"2020-05-30T11:28:23.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdw007mg4va2ytcxv00","content":"<p>参考博文：</p>\n<p>1.<a href=\"https://blog.csdn.net/hao_yunfeng/article/details/82392261\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hao_yunfeng/article/details/82392261</a>    </p>\n<p>2.<a href=\"https://cloud.tencent.com/developer/news/218904\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/news/218904</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考博文：</p>\n<p>1.<a href=\"https://blog.csdn.net/hao_yunfeng/article/details/82392261\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/hao_yunfeng/article/details/82392261</a>    </p>\n<p>2.<a href=\"https://cloud.tencent.com/developer/news/218904\" target=\"_blank\" rel=\"noopener\">https://cloud.tencent.com/developer/news/218904</a></p>\n"},{"title":"mysql建表规范","date":"2017-11-20T05:51:19.000Z","_content":"\n在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：\n\n## 1. 选择优化的数据类型\n\n原则：\n1. 更小的通常更好\n更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。\n\n2. 简单就好\n简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。\n\n3. 尽量避免NULL\n通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。   \n通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。\n\n### 1.1 整数类型\n整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。  \n整数计算通常使用64位的BIGINT。\n\n### 1.2 实数类型\n实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。  \nDOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。  \n在做高精度计算时，使用DECIMAL，比如财务计算。  \n\n### 1.3 字符串类型\nVARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。\nCHAR 不可变长。少用。\nBINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。\nBLOB 存储很大的数据量的字符串类型，二进制存储。\nTEXT 大文本。字符存储。\n- 使用枚举代替字符串\n可以存储枚举对应整型或者字符串……\n\n## 1.4 日期和时间类型\n\n\n","source":"_posts/mysql-create.md","raw":"---\ntitle: mysql建表规范\ndate: 2017-11-20 13:51:19\ncategories: mysql\ntags: mysql建表规范\n---\n\n在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：\n\n## 1. 选择优化的数据类型\n\n原则：\n1. 更小的通常更好\n更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。\n\n2. 简单就好\n简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。\n\n3. 尽量避免NULL\n通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。   \n通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。\n\n### 1.1 整数类型\n整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。  \n整数计算通常使用64位的BIGINT。\n\n### 1.2 实数类型\n实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。  \nDOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。  \n在做高精度计算时，使用DECIMAL，比如财务计算。  \n\n### 1.3 字符串类型\nVARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。\nCHAR 不可变长。少用。\nBINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。\nBLOB 存储很大的数据量的字符串类型，二进制存储。\nTEXT 大文本。字符存储。\n- 使用枚举代替字符串\n可以存储枚举对应整型或者字符串……\n\n## 1.4 日期和时间类型\n\n\n","slug":"mysql-create","published":1,"updated":"2019-06-16T14:38:33.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdy007pg4vaj9fbnrge","content":"<p>在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：</p>\n<h2 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1. 选择优化的数据类型\"></a>1. 选择优化的数据类型</h2><p>原则：</p>\n<ol>\n<li><p>更小的通常更好<br>更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。</p>\n</li>\n<li><p>简单就好<br>简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。</p>\n</li>\n<li><p>尽量避免NULL<br>通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。<br>通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。</p>\n</li>\n</ol>\n<h3 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h3><p>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。<br>整数计算通常使用64位的BIGINT。</p>\n<h3 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h3><p>实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。<br>DOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。<br>在做高精度计算时，使用DECIMAL，比如财务计算。  </p>\n<h3 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h3><p>VARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。<br>CHAR 不可变长。少用。<br>BINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。<br>BLOB 存储很大的数据量的字符串类型，二进制存储。<br>TEXT 大文本。字符存储。</p>\n<ul>\n<li>使用枚举代替字符串<br>可以存储枚举对应整型或者字符串……</li>\n</ul>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2>","site":{"data":{}},"excerpt":"","more":"<p>在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：</p>\n<h2 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1. 选择优化的数据类型\"></a>1. 选择优化的数据类型</h2><p>原则：</p>\n<ol>\n<li><p>更小的通常更好<br>更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。</p>\n</li>\n<li><p>简单就好<br>简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。</p>\n</li>\n<li><p>尽量避免NULL<br>通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。<br>通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。</p>\n</li>\n</ol>\n<h3 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h3><p>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。<br>整数计算通常使用64位的BIGINT。</p>\n<h3 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h3><p>实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。<br>DOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。<br>在做高精度计算时，使用DECIMAL，比如财务计算。  </p>\n<h3 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h3><p>VARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。<br>CHAR 不可变长。少用。<br>BINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。<br>BLOB 存储很大的数据量的字符串类型，二进制存储。<br>TEXT 大文本。字符存储。</p>\n<ul>\n<li>使用枚举代替字符串<br>可以存储枚举对应整型或者字符串……</li>\n</ul>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2>"},{"title":"mysql性能优化神器explain","date":"2017-11-21T05:36:04.000Z","_content":"\nMySQL 性能优化神器 Explain 使用分析\n\nmysql mysql优化  永顺 1月16日发布\n赞  |   6收藏  |  50\n3.2k 次浏览\n简介\nMySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.\nEXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:\n\nEXPLAIN SELECT * from user_info WHERE id < 300;\n准备\n为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:\n\n    CREATE TABLE `user_info` (\n      `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `name` VARCHAR(50) NOT NULL DEFAULT '',\n      `age`  INT(11)              DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `name_index` (`name`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO user_info (name, age) VALUES ('xys', 20);\n    INSERT INTO user_info (name, age) VALUES ('a', 21);\n    INSERT INTO user_info (name, age) VALUES ('b', 23);\n    INSERT INTO user_info (name, age) VALUES ('c', 50);\n    INSERT INTO user_info (name, age) VALUES ('d', 15);\n    INSERT INTO user_info (name, age) VALUES ('e', 20);\n    INSERT INTO user_info (name, age) VALUES ('f', 21);\n    INSERT INTO user_info (name, age) VALUES ('g', 23);\n    INSERT INTO user_info (name, age) VALUES ('h', 50);\n    INSERT INTO user_info (name, age) VALUES ('i', 15);\n    CREATE TABLE `order_info` (\n      `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `user_id`      BIGINT(20)           DEFAULT NULL,\n      `product_name` VARCHAR(50) NOT NULL DEFAULT '',\n      `productor`    VARCHAR(30)          DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p2', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'DX');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p5', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (3, 'p3', 'MA');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (4, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (6, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (9, 'p8', 'TE');\nEXPLAIN 输出格式\nEXPLAIN 命令的输出内容大致如下:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n各列的含义如下:\n\n- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n- select_type: SELECT 查询的类型.\n- table: 查询的是哪个表\n- partitions: 匹配的分区\n- type: join 类型\n- possible_keys: 此次查询中可能选用的索引\n- key: 此次查询中确切使用到的索引.\n- ref: 哪个字段或常数与 key 一起被使用\n- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\n- filtered: 表示此查询条件所过滤的数据的百分比\n- extra: 额外的信息\n接下来我们来重点看一下比较重要的几个字段.\n\nselect_type  \nselect_type 表示了查询的类型, 它的常用取值有:\n\nSIMPLE, 表示此查询不包含 UNION 查询或子查询  \nPRIMARY, 表示此查询是最外层的查询  \nUNION, 表示此查询是 UNION 的第二或随后的查询  \nDEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询  \nUNION RESULT, UNION 的结果  \nSUBQUERY, 子查询中的第一个 SELECT  \nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.   \n最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:\n\n    mysql> EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n        -> UNION\n        -> (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    |  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.00 sec)\n    table\n表示查询涉及的表或衍生表\n\n- type  \ntype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.   \ntype 常用类型   \ntype 常用的取值有:   \nsystem: 表中只有一条数据. 这个类型是特殊的 const 类型.   \nconst: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.   \n例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   \n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n    \n- eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 314\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using where; Using index\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: eq_ref\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: test.order_info.user_id\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        2 rows in set, 1 warning (0.00 sec)\n        \n- ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. \n例如下面这个例子中, 就使用到了 ref 类型的查询:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: const\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: Using index\n        2 rows in set, 1 warning (0.01 sec)\n\n- range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.  \n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.\n例如下面的例子就是一个范围查询:  \n\n        mysql> EXPLAIN SELECT *\n            ->         FROM user_info\n            ->         WHERE id BETWEEN 2 AND 8 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: range\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: NULL\n                 rows: 7\n             filtered: 100.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n    \n- index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.  \nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.  \n例如:  \n\n        mysql> EXPLAIN SELECT name FROM  user_info \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: name_index\n              key_len: 152\n                  ref: NULL\n                 rows: 10\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n    \n上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  \n\n- ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.   \n下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   \n\n        mysql> EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: ALL\n        possible_keys: NULL\n                  key: NULL\n              key_len: NULL\n                  ref: NULL\n                 rows: 10\n             filtered: 10.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n        \n- type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\nALL < index < range ~ index_merge < ref < eq_ref < const < system\nALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\npossible_keys\npossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\nkey\n此字段是 MySQL 在当前查询时所真正使用到的索引.\nkey_len\n表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\nkey_len 的计算规则如下:\n字符串\nchar(n): n 字节长度\nvarchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.\n数值类型:\nTINYINT: 1字节\nSMALLINT: 2字节\nMEDIUMINT: 3字节\nINT: 4字节\nBIGINT: 8字节\n时间类型\nDATE: 3字节\nTIMESTAMP: 4字节\nDATETIME: 8字节\n字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n我们来举两个简单的栗子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: range\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: NULL\n                 rows: 5\n             filtered: 11.11\n                Extra: Using where; Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:\n\n- `KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n不过此查询语句 WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT '0', 则 key_length 应该是8.\n\n上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.\n\n接下来我们来看一下下一个例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \\G;\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 161\n                  ref: const,const\n                 rows: 2\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = 'p1' 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161\n\n- rows\nrows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.\n这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n\n- Extra\nEXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:\n\n- Using filesort\n当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n例如下面的例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index; Using filesort\n        1 row in set, 1 warning (0.00 sec)\n        \n我们的索引是\n\n`KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.\n如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n- Using index\n\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n-   Using temporary\n查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.","source":"_posts/mysql-explain.md","raw":"---\ntitle: mysql性能优化神器explain\ndate: 2017-11-21 13:36:04\ncategories: mysql\ntags: mysql-expain\n---\n\nMySQL 性能优化神器 Explain 使用分析\n\nmysql mysql优化  永顺 1月16日发布\n赞  |   6收藏  |  50\n3.2k 次浏览\n简介\nMySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.\nEXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:\n\nEXPLAIN SELECT * from user_info WHERE id < 300;\n准备\n为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:\n\n    CREATE TABLE `user_info` (\n      `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `name` VARCHAR(50) NOT NULL DEFAULT '',\n      `age`  INT(11)              DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `name_index` (`name`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO user_info (name, age) VALUES ('xys', 20);\n    INSERT INTO user_info (name, age) VALUES ('a', 21);\n    INSERT INTO user_info (name, age) VALUES ('b', 23);\n    INSERT INTO user_info (name, age) VALUES ('c', 50);\n    INSERT INTO user_info (name, age) VALUES ('d', 15);\n    INSERT INTO user_info (name, age) VALUES ('e', 20);\n    INSERT INTO user_info (name, age) VALUES ('f', 21);\n    INSERT INTO user_info (name, age) VALUES ('g', 23);\n    INSERT INTO user_info (name, age) VALUES ('h', 50);\n    INSERT INTO user_info (name, age) VALUES ('i', 15);\n    CREATE TABLE `order_info` (\n      `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `user_id`      BIGINT(20)           DEFAULT NULL,\n      `product_name` VARCHAR(50) NOT NULL DEFAULT '',\n      `productor`    VARCHAR(30)          DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p2', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'DX');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p5', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (3, 'p3', 'MA');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (4, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (6, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (9, 'p8', 'TE');\nEXPLAIN 输出格式\nEXPLAIN 命令的输出内容大致如下:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n各列的含义如下:\n\n- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n- select_type: SELECT 查询的类型.\n- table: 查询的是哪个表\n- partitions: 匹配的分区\n- type: join 类型\n- possible_keys: 此次查询中可能选用的索引\n- key: 此次查询中确切使用到的索引.\n- ref: 哪个字段或常数与 key 一起被使用\n- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\n- filtered: 表示此查询条件所过滤的数据的百分比\n- extra: 额外的信息\n接下来我们来重点看一下比较重要的几个字段.\n\nselect_type  \nselect_type 表示了查询的类型, 它的常用取值有:\n\nSIMPLE, 表示此查询不包含 UNION 查询或子查询  \nPRIMARY, 表示此查询是最外层的查询  \nUNION, 表示此查询是 UNION 的第二或随后的查询  \nDEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询  \nUNION RESULT, UNION 的结果  \nSUBQUERY, 子查询中的第一个 SELECT  \nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.   \n最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:\n\n    mysql> EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n        -> UNION\n        -> (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    |  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.00 sec)\n    table\n表示查询涉及的表或衍生表\n\n- type  \ntype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.   \ntype 常用类型   \ntype 常用的取值有:   \nsystem: 表中只有一条数据. 这个类型是特殊的 const 类型.   \nconst: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.   \n例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   \n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n    \n- eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 314\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using where; Using index\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: eq_ref\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: test.order_info.user_id\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        2 rows in set, 1 warning (0.00 sec)\n        \n- ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. \n例如下面这个例子中, 就使用到了 ref 类型的查询:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: const\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: Using index\n        2 rows in set, 1 warning (0.01 sec)\n\n- range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.  \n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.\n例如下面的例子就是一个范围查询:  \n\n        mysql> EXPLAIN SELECT *\n            ->         FROM user_info\n            ->         WHERE id BETWEEN 2 AND 8 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: range\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: NULL\n                 rows: 7\n             filtered: 100.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n    \n- index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.  \nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.  \n例如:  \n\n        mysql> EXPLAIN SELECT name FROM  user_info \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: name_index\n              key_len: 152\n                  ref: NULL\n                 rows: 10\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n    \n上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  \n\n- ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.   \n下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   \n\n        mysql> EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: ALL\n        possible_keys: NULL\n                  key: NULL\n              key_len: NULL\n                  ref: NULL\n                 rows: 10\n             filtered: 10.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n        \n- type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\nALL < index < range ~ index_merge < ref < eq_ref < const < system\nALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\npossible_keys\npossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\nkey\n此字段是 MySQL 在当前查询时所真正使用到的索引.\nkey_len\n表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\nkey_len 的计算规则如下:\n字符串\nchar(n): n 字节长度\nvarchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.\n数值类型:\nTINYINT: 1字节\nSMALLINT: 2字节\nMEDIUMINT: 3字节\nINT: 4字节\nBIGINT: 8字节\n时间类型\nDATE: 3字节\nTIMESTAMP: 4字节\nDATETIME: 8字节\n字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n我们来举两个简单的栗子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: range\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: NULL\n                 rows: 5\n             filtered: 11.11\n                Extra: Using where; Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:\n\n- `KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n不过此查询语句 WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT '0', 则 key_length 应该是8.\n\n上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.\n\n接下来我们来看一下下一个例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \\G;\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 161\n                  ref: const,const\n                 rows: 2\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = 'p1' 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161\n\n- rows\nrows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.\n这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n\n- Extra\nEXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:\n\n- Using filesort\n当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n例如下面的例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index; Using filesort\n        1 row in set, 1 warning (0.00 sec)\n        \n我们的索引是\n\n`KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.\n如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n- Using index\n\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n-   Using temporary\n查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.","slug":"mysql-explain","published":1,"updated":"2019-06-16T14:38:33.426Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqdz007tg4vaxlxxsggv","content":"<p>MySQL 性能优化神器 Explain 使用分析</p>\n<p>mysql mysql优化  永顺 1月16日发布<br>赞  |   6收藏  |  50<br>3.2k 次浏览<br>简介<br>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p>\n<p>EXPLAIN SELECT * from user_info WHERE id &lt; 300;<br>准备<br>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>\n<pre><code>CREATE TABLE `user_info` (\n  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `age`  INT(11)              DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name_index` (`name`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);\nINSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);\nCREATE TABLE `order_info` (\n  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `user_id`      BIGINT(20)           DEFAULT NULL,\n  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `productor`    VARCHAR(30)          DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);\n</code></pre><p>EXPLAIN 输出格式<br>EXPLAIN 命令的输出内容大致如下:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>各列的含义如下:</p>\n<ul>\n<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li>select_type: SELECT 查询的类型.</li>\n<li>table: 查询的是哪个表</li>\n<li>partitions: 匹配的分区</li>\n<li>type: join 类型</li>\n<li>possible_keys: 此次查询中可能选用的索引</li>\n<li>key: 此次查询中确切使用到的索引.</li>\n<li>ref: 哪个字段或常数与 key 一起被使用</li>\n<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>\n<li>filtered: 表示此查询条件所过滤的数据的百分比</li>\n<li>extra: 额外的信息<br>接下来我们来重点看一下比较重要的几个字段.</li>\n</ul>\n<p>select_type<br>select_type 表示了查询的类型, 它的常用取值有:</p>\n<p>SIMPLE, 表示此查询不包含 UNION 查询或子查询<br>PRIMARY, 表示此查询是最外层的查询<br>UNION, 表示此查询是 UNION 的第二或随后的查询<br>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>UNION RESULT, UNION 的结果<br>SUBQUERY, 子查询中的第一个 SELECT<br>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.<br>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p>\n<pre><code>mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n    -&gt; UNION\n    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n3 rows in set, 1 warning (0.00 sec)\ntable\n</code></pre><p>表示查询涉及的表或衍生表</p>\n<ul>\n<li><p>type<br>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.<br>type 常用类型<br>type 常用的取值有:<br>system: 表中只有一条数据. 这个类型是特殊的 const 类型.<br>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   </p>\n<p>  mysql&gt; explain select <em> from user_info where id = 2\\G<br>  <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>\n<pre><code>         id: 1\nselect_type: SIMPLE\n      table: user_info\n partitions: NULL\n       type: const\n</code></pre><p>  possible_keys: PRIMARY</p>\n<pre><code>     key: PRIMARY\n key_len: 8\n     ref: const\n    rows: 1\nfiltered: 100.00\n   Extra: NULL\n</code></pre><p>  1 row in set, 1 warning (0.00 sec)</p>\n</li>\n<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 314\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using where; Using index\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: eq_ref\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: test.order_info.user_id\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n2 rows in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index\n2 rows in set, 1 warning (0.01 sec)\n</code></pre></li>\n<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.<br>例如下面的例子就是一个范围查询:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT *\n    -&gt;         FROM user_info\n    -&gt;         WHERE id BETWEEN 2 AND 8 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 7\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.<br>例如:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT name FROM  user_info \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: name_index\n      key_len: 152\n          ref: NULL\n         rows: 10\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  </p>\n<ul>\n<li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   </p>\n<pre><code>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 10\n     filtered: 10.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:<br>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system<br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.<br>possible_keys<br>possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.<br>key<br>此字段是 MySQL 在当前查询时所真正使用到的索引.<br>key_len<br>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:<br>字符串<br>char(n): n 字节长度<br>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.<br>数值类型:<br>TINYINT: 1字节<br>SMALLINT: 2字节<br>MEDIUMINT: 3字节<br>INT: 4字节<br>BIGINT: 8字节<br>时间类型<br>DATE: 3字节<br>TIMESTAMP: 4字节<br>DATETIME: 8字节<br>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.<br>我们来举两个简单的栗子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: range\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: NULL\n         rows: 5\n     filtered: 11.11\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p>\n<ul>\n<li><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>不过此查询语句 WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</li>\n</ul>\n<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>\n<p>接下来我们来看一下下一个例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 161\n          ref: const,const\n         rows: 2\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = ‘p1’ 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p>\n<ul>\n<li><p>rows<br>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>\n</li>\n<li><p>Extra<br>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>\n</li>\n<li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.<br>例如下面的例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index; Using filesort\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>我们的索引是</p>\n<p><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><ul>\n<li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>MySQL 性能优化神器 Explain 使用分析</p>\n<p>mysql mysql优化  永顺 1月16日发布<br>赞  |   6收藏  |  50<br>3.2k 次浏览<br>简介<br>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p>\n<p>EXPLAIN SELECT * from user_info WHERE id &lt; 300;<br>准备<br>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>\n<pre><code>CREATE TABLE `user_info` (\n  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `age`  INT(11)              DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name_index` (`name`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);\nINSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);\nCREATE TABLE `order_info` (\n  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `user_id`      BIGINT(20)           DEFAULT NULL,\n  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `productor`    VARCHAR(30)          DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);\n</code></pre><p>EXPLAIN 输出格式<br>EXPLAIN 命令的输出内容大致如下:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>各列的含义如下:</p>\n<ul>\n<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li>select_type: SELECT 查询的类型.</li>\n<li>table: 查询的是哪个表</li>\n<li>partitions: 匹配的分区</li>\n<li>type: join 类型</li>\n<li>possible_keys: 此次查询中可能选用的索引</li>\n<li>key: 此次查询中确切使用到的索引.</li>\n<li>ref: 哪个字段或常数与 key 一起被使用</li>\n<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>\n<li>filtered: 表示此查询条件所过滤的数据的百分比</li>\n<li>extra: 额外的信息<br>接下来我们来重点看一下比较重要的几个字段.</li>\n</ul>\n<p>select_type<br>select_type 表示了查询的类型, 它的常用取值有:</p>\n<p>SIMPLE, 表示此查询不包含 UNION 查询或子查询<br>PRIMARY, 表示此查询是最外层的查询<br>UNION, 表示此查询是 UNION 的第二或随后的查询<br>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>UNION RESULT, UNION 的结果<br>SUBQUERY, 子查询中的第一个 SELECT<br>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.<br>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p>\n<pre><code>mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n    -&gt; UNION\n    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n3 rows in set, 1 warning (0.00 sec)\ntable\n</code></pre><p>表示查询涉及的表或衍生表</p>\n<ul>\n<li><p>type<br>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.<br>type 常用类型<br>type 常用的取值有:<br>system: 表中只有一条数据. 这个类型是特殊的 const 类型.<br>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   </p>\n<p>  mysql&gt; explain select <em> from user_info where id = 2\\G<br>  <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>\n<pre><code>         id: 1\nselect_type: SIMPLE\n      table: user_info\n partitions: NULL\n       type: const\n</code></pre><p>  possible_keys: PRIMARY</p>\n<pre><code>     key: PRIMARY\n key_len: 8\n     ref: const\n    rows: 1\nfiltered: 100.00\n   Extra: NULL\n</code></pre><p>  1 row in set, 1 warning (0.00 sec)</p>\n</li>\n<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 314\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using where; Using index\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: eq_ref\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: test.order_info.user_id\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n2 rows in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index\n2 rows in set, 1 warning (0.01 sec)\n</code></pre></li>\n<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.<br>例如下面的例子就是一个范围查询:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT *\n    -&gt;         FROM user_info\n    -&gt;         WHERE id BETWEEN 2 AND 8 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 7\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.<br>例如:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT name FROM  user_info \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: name_index\n      key_len: 152\n          ref: NULL\n         rows: 10\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  </p>\n<ul>\n<li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   </p>\n<pre><code>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 10\n     filtered: 10.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:<br>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system<br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.<br>possible_keys<br>possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.<br>key<br>此字段是 MySQL 在当前查询时所真正使用到的索引.<br>key_len<br>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:<br>字符串<br>char(n): n 字节长度<br>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.<br>数值类型:<br>TINYINT: 1字节<br>SMALLINT: 2字节<br>MEDIUMINT: 3字节<br>INT: 4字节<br>BIGINT: 8字节<br>时间类型<br>DATE: 3字节<br>TIMESTAMP: 4字节<br>DATETIME: 8字节<br>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.<br>我们来举两个简单的栗子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: range\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: NULL\n         rows: 5\n     filtered: 11.11\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p>\n<ul>\n<li><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>不过此查询语句 WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</li>\n</ul>\n<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>\n<p>接下来我们来看一下下一个例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 161\n          ref: const,const\n         rows: 2\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = ‘p1’ 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p>\n<ul>\n<li><p>rows<br>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>\n</li>\n<li><p>Extra<br>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>\n</li>\n<li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.<br>例如下面的例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index; Using filesort\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>我们的索引是</p>\n<p><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><ul>\n<li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n"},{"title":"mysql使用问题记录","date":"2018-06-01T14:46:53.000Z","_content":"\n本文记录在实际使用mysql过程遇到的问题……\n\n## 配置my.cnf\n\n    [mysqld]\n    port = 3910\n    character-set-client-handshake = FALSE\n    character-set-server = utf8mb4\n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    skip-name-resolve\n    # 一下三个配置，解决too manay connection问题。\n    max_connections=1000 # 最大连接数，默认100\n    wait_timeout = 300 #\n    interactive_timeout = 500\n    \n    log-bin = mysql-bin\n    server-id = 1\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n\n## mysql5.7更改数据库密码强度和长度\n\n    set global validate_password_policy=0;  \n    set global validate_password_length=4;  \n\n## mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库\n\n    CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';\n    flush privileges;\n    \n 创建用户redmine,密码为：redmine，只对数据库redmine拥有读写权限。   \n \n ## 设置超时\n \n 数据库连接时间太短，会自动释放，业务代码没执行完成，就断开了。设置太长，会导致整个系统被拖慢。所以要设置一个恰当的时间。\n \n     SHOW GLOBAL VARIABLES LIKE '%timeout%'\n     \n     SET GLOBAL wait_timeout=10000\n     \n## mysql too many connections 解决方法     \n\n以下三个配置，解决too manay connection问题。\n\n    max_connections=1000 # 最大连接数，默认100\n    wait_timeout = 300 #\n    interactive_timeout = 500\n    \n参考：\nhttps://www.jianshu.com/p/fc40067c4dc9      \nhttps://jingyan.baidu.com/article/fc07f989c5c6bd52fee5192c.html \n","source":"_posts/mysql-practice.md","raw":"---\ntitle: mysql使用问题记录\ndate: 2018-06-01 22:46:53\ncategories: mysql\ntags: mysql使用问题收藏\n---\n\n本文记录在实际使用mysql过程遇到的问题……\n\n## 配置my.cnf\n\n    [mysqld]\n    port = 3910\n    character-set-client-handshake = FALSE\n    character-set-server = utf8mb4\n    collation-server = utf8mb4_unicode_ci\n    init_connect='SET NAMES utf8mb4'\n    default_authentication_plugin = mysql_native_password\n    skip-name-resolve\n    # 一下三个配置，解决too manay connection问题。\n    max_connections=1000 # 最大连接数，默认100\n    wait_timeout = 300 #\n    interactive_timeout = 500\n    \n    log-bin = mysql-bin\n    server-id = 1\n    \n    [client]\n    default-character-set=utf8mb4\n    \n    [mysql]\n    default-character-set=utf8mb4\n\n## mysql5.7更改数据库密码强度和长度\n\n    set global validate_password_policy=0;  \n    set global validate_password_length=4;  \n\n## mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库\n\n    CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';\n    flush privileges;\n    \n 创建用户redmine,密码为：redmine，只对数据库redmine拥有读写权限。   \n \n ## 设置超时\n \n 数据库连接时间太短，会自动释放，业务代码没执行完成，就断开了。设置太长，会导致整个系统被拖慢。所以要设置一个恰当的时间。\n \n     SHOW GLOBAL VARIABLES LIKE '%timeout%'\n     \n     SET GLOBAL wait_timeout=10000\n     \n## mysql too many connections 解决方法     \n\n以下三个配置，解决too manay connection问题。\n\n    max_connections=1000 # 最大连接数，默认100\n    wait_timeout = 300 #\n    interactive_timeout = 500\n    \n参考：\nhttps://www.jianshu.com/p/fc40067c4dc9      \nhttps://jingyan.baidu.com/article/fc07f989c5c6bd52fee5192c.html \n","slug":"mysql-practice","published":1,"updated":"2020-05-30T11:28:23.366Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqe0007vg4vatgskgxyl","content":"<p>本文记录在实际使用mysql过程遇到的问题……</p>\n<h2 id=\"配置my-cnf\"><a href=\"#配置my-cnf\" class=\"headerlink\" title=\"配置my.cnf\"></a>配置my.cnf</h2><pre><code>[mysqld]\nport = 3910\ncharacter-set-client-handshake = FALSE\ncharacter-set-server = utf8mb4\ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\nskip-name-resolve\n# 一下三个配置，解决too manay connection问题。\nmax_connections=1000 # 最大连接数，默认100\nwait_timeout = 300 #\ninteractive_timeout = 500\n\nlog-bin = mysql-bin\nserver-id = 1\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><h2 id=\"mysql5-7更改数据库密码强度和长度\"><a href=\"#mysql5-7更改数据库密码强度和长度\" class=\"headerlink\" title=\"mysql5.7更改数据库密码强度和长度\"></a>mysql5.7更改数据库密码强度和长度</h2><pre><code>set global validate_password_policy=0;  \nset global validate_password_length=4;  \n</code></pre><h2 id=\"mysql5-7，创建登录用户，并对用户赋权只能查看某个数据库\"><a href=\"#mysql5-7，创建登录用户，并对用户赋权只能查看某个数据库\" class=\"headerlink\" title=\"mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库\"></a>mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库</h2><pre><code>CREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;\nflush privileges;\n</code></pre><p> 创建用户redmine,密码为：redmine，只对数据库redmine拥有读写权限。   </p>\n<h2 id=\"设置超时\"><a href=\"#设置超时\" class=\"headerlink\" title=\"设置超时\"></a>设置超时</h2><p> 数据库连接时间太短，会自动释放，业务代码没执行完成，就断开了。设置太长，会导致整个系统被拖慢。所以要设置一个恰当的时间。</p>\n<pre><code>SHOW GLOBAL VARIABLES LIKE &apos;%timeout%&apos;\n\nSET GLOBAL wait_timeout=10000\n</code></pre><h2 id=\"mysql-too-many-connections-解决方法\"><a href=\"#mysql-too-many-connections-解决方法\" class=\"headerlink\" title=\"mysql too many connections 解决方法\"></a>mysql too many connections 解决方法</h2><p>以下三个配置，解决too manay connection问题。</p>\n<pre><code>max_connections=1000 # 最大连接数，默认100\nwait_timeout = 300 #\ninteractive_timeout = 500\n</code></pre><p>参考：<br><a href=\"https://www.jianshu.com/p/fc40067c4dc9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/fc40067c4dc9</a><br><a href=\"https://jingyan.baidu.com/article/fc07f989c5c6bd52fee5192c.html\" target=\"_blank\" rel=\"noopener\">https://jingyan.baidu.com/article/fc07f989c5c6bd52fee5192c.html</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录在实际使用mysql过程遇到的问题……</p>\n<h2 id=\"配置my-cnf\"><a href=\"#配置my-cnf\" class=\"headerlink\" title=\"配置my.cnf\"></a>配置my.cnf</h2><pre><code>[mysqld]\nport = 3910\ncharacter-set-client-handshake = FALSE\ncharacter-set-server = utf8mb4\ncollation-server = utf8mb4_unicode_ci\ninit_connect=&apos;SET NAMES utf8mb4&apos;\ndefault_authentication_plugin = mysql_native_password\nskip-name-resolve\n# 一下三个配置，解决too manay connection问题。\nmax_connections=1000 # 最大连接数，默认100\nwait_timeout = 300 #\ninteractive_timeout = 500\n\nlog-bin = mysql-bin\nserver-id = 1\n\n[client]\ndefault-character-set=utf8mb4\n\n[mysql]\ndefault-character-set=utf8mb4\n</code></pre><h2 id=\"mysql5-7更改数据库密码强度和长度\"><a href=\"#mysql5-7更改数据库密码强度和长度\" class=\"headerlink\" title=\"mysql5.7更改数据库密码强度和长度\"></a>mysql5.7更改数据库密码强度和长度</h2><pre><code>set global validate_password_policy=0;  \nset global validate_password_length=4;  \n</code></pre><h2 id=\"mysql5-7，创建登录用户，并对用户赋权只能查看某个数据库\"><a href=\"#mysql5-7，创建登录用户，并对用户赋权只能查看某个数据库\" class=\"headerlink\" title=\"mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库\"></a>mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库</h2><pre><code>CREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;\nflush privileges;\n</code></pre><p> 创建用户redmine,密码为：redmine，只对数据库redmine拥有读写权限。   </p>\n<h2 id=\"设置超时\"><a href=\"#设置超时\" class=\"headerlink\" title=\"设置超时\"></a>设置超时</h2><p> 数据库连接时间太短，会自动释放，业务代码没执行完成，就断开了。设置太长，会导致整个系统被拖慢。所以要设置一个恰当的时间。</p>\n<pre><code>SHOW GLOBAL VARIABLES LIKE &apos;%timeout%&apos;\n\nSET GLOBAL wait_timeout=10000\n</code></pre><h2 id=\"mysql-too-many-connections-解决方法\"><a href=\"#mysql-too-many-connections-解决方法\" class=\"headerlink\" title=\"mysql too many connections 解决方法\"></a>mysql too many connections 解决方法</h2><p>以下三个配置，解决too manay connection问题。</p>\n<pre><code>max_connections=1000 # 最大连接数，默认100\nwait_timeout = 300 #\ninteractive_timeout = 500\n</code></pre><p>参考：<br><a href=\"https://www.jianshu.com/p/fc40067c4dc9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/fc40067c4dc9</a><br><a href=\"https://jingyan.baidu.com/article/fc07f989c5c6bd52fee5192c.html\" target=\"_blank\" rel=\"noopener\">https://jingyan.baidu.com/article/fc07f989c5c6bd52fee5192c.html</a> </p>\n"},{"title":"nginx能做什么","date":"2018-09-12T09:14:54.000Z","_content":"\n## 前言\n本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。\n\n## Nginx能做什么\n反向代理\n负载均衡\nHTTP服务器（包含动静分离）\n正向代理\n以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做\n\n## 反向代理\n反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码\n\n    server {  \n        listen       80;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n        location / {\n            proxy_pass http://localhost:8080;\n            proxy_set_header Host $host:$server_port;\n        }\n    }\n保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了\n\n## 负载均衡\n负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。\n\n### 1.RR（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n简单配置\n\n\n    upstream test {\n        server localhost:8080;\n        server localhost:8081;\n    }\n    server {\n        listen       81;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n        location / {\n            proxy_pass http://test;\n            proxy_set_header Host $host:$server_port;\n        }\n    }\n    \n负载均衡的核心代码为\n\n    upstream test {\n        server localhost:8080;\n        server localhost:8081;\n    }\n这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问http://localhost 的时候,也不会有问题，会默认跳转到http://localhost:8080 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。\n\n### 2.权重\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如\n\n    upstream test {\n        server localhost:8080 weight=9;\n        server localhost:8081 weight=1;\n    }\n那么10次一般只会有1次会访问到8081，而有9次会访问到8080\n\n### 3.ip_hash\n上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n\n    upstream test {\n        ip_hash;\n        server localhost:8080;\n        server localhost:8081;\n    }\n### 4.fair（第三方）\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\n    upstream backend { \n        fair; \n        server localhost:8080;\n        server localhost:8081;\n    }\n### 5.url_hash（第三方）\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n\n    upstream backend { \n        hash $request_uri; \n        hash_method crc32; \n        server localhost:8080;\n        server localhost:8081;\n    }\n以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍\n\n## HTTP服务器\nNginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器\n\n    server {\n        listen       80;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n\n        location / {\n               root   e:\\wwwroot;\n               index  index.html;\n           }\n    }\n这样如果访问http://localhost 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。\n\n## 动静分离\n动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路\n\n    upstream test{  \n       server localhost:8080;  \n       server localhost:8081;  \n    }   \n\n    server {  \n        listen       80;  \n        server_name  localhost;  \n\n        location / {  \n            root   e:\\wwwroot;  \n            index  index.html;  \n        }  \n\n        # 所有静态请求都由nginx处理，存放目录为html  \n        location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n            root    e:\\wwwroot;  \n        }  \n\n        # 所有动态请求都转发给tomcat处理  \n        location ~ \\.(jsp|do)$ {  \n            proxy_pass  http://test;  \n        }  \n\n        error_page   500 502 503 504  /50x.html;  \n        location = /50x.html {  \n            root   e:\\wwwroot;  \n        }  \n    }\n这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活\n\n## 正向代理\n正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。\n\n    resolver 114.114.114.114 8.8.8.8;\n    server {\n\n        resolver_timeout 5s;\n\n        listen 81;\n\n        access_log  e:\\wwwroot\\proxy.access.log;\n        error_log   e:\\wwwroot\\proxy.error.log;\n\n        location / {\n            proxy_pass http://$host$request_uri;\n        }\n    }\nresolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。\n\n## 最后说两句\n启动停止及配置文件位置的命令:\n\n    /etc/init.d/nginx start/restart # 启动/重启Nginx服务\n    \n    /etc/init.d/nginx stop # 停止Nginx服务\n    \n    /etc/nginx/nginx.conf # Nginx配置文件位置\nNginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是\n\n    nginx -s reload\nwindows下面就是\n\n    nginx.exe -s reload\n\n著作权归作者所有。\n商业转载请联系作者获得授权，非商业转载请注明出处。\n作者：ll\n链接：https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340\n来源：极客教程","source":"_posts/nginx-study.md","raw":"---\ntitle: nginx能做什么\ndate: 2018-09-12 17:14:54\ncategories: Nginx\ntags: nginx能做什么\n---\n\n## 前言\n本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。\n\n## Nginx能做什么\n反向代理\n负载均衡\nHTTP服务器（包含动静分离）\n正向代理\n以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做\n\n## 反向代理\n反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码\n\n    server {  \n        listen       80;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n        location / {\n            proxy_pass http://localhost:8080;\n            proxy_set_header Host $host:$server_port;\n        }\n    }\n保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了\n\n## 负载均衡\n负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。\n\n### 1.RR（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n简单配置\n\n\n    upstream test {\n        server localhost:8080;\n        server localhost:8081;\n    }\n    server {\n        listen       81;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n        location / {\n            proxy_pass http://test;\n            proxy_set_header Host $host:$server_port;\n        }\n    }\n    \n负载均衡的核心代码为\n\n    upstream test {\n        server localhost:8080;\n        server localhost:8081;\n    }\n这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问http://localhost 的时候,也不会有问题，会默认跳转到http://localhost:8080 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。\n\n### 2.权重\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如\n\n    upstream test {\n        server localhost:8080 weight=9;\n        server localhost:8081 weight=1;\n    }\n那么10次一般只会有1次会访问到8081，而有9次会访问到8080\n\n### 3.ip_hash\n上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n\n    upstream test {\n        ip_hash;\n        server localhost:8080;\n        server localhost:8081;\n    }\n### 4.fair（第三方）\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\n    upstream backend { \n        fair; \n        server localhost:8080;\n        server localhost:8081;\n    }\n### 5.url_hash（第三方）\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n\n    upstream backend { \n        hash $request_uri; \n        hash_method crc32; \n        server localhost:8080;\n        server localhost:8081;\n    }\n以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍\n\n## HTTP服务器\nNginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器\n\n    server {\n        listen       80;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n\n        location / {\n               root   e:\\wwwroot;\n               index  index.html;\n           }\n    }\n这样如果访问http://localhost 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。\n\n## 动静分离\n动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路\n\n    upstream test{  \n       server localhost:8080;  \n       server localhost:8081;  \n    }   \n\n    server {  \n        listen       80;  \n        server_name  localhost;  \n\n        location / {  \n            root   e:\\wwwroot;  \n            index  index.html;  \n        }  \n\n        # 所有静态请求都由nginx处理，存放目录为html  \n        location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n            root    e:\\wwwroot;  \n        }  \n\n        # 所有动态请求都转发给tomcat处理  \n        location ~ \\.(jsp|do)$ {  \n            proxy_pass  http://test;  \n        }  \n\n        error_page   500 502 503 504  /50x.html;  \n        location = /50x.html {  \n            root   e:\\wwwroot;  \n        }  \n    }\n这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活\n\n## 正向代理\n正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。\n\n    resolver 114.114.114.114 8.8.8.8;\n    server {\n\n        resolver_timeout 5s;\n\n        listen 81;\n\n        access_log  e:\\wwwroot\\proxy.access.log;\n        error_log   e:\\wwwroot\\proxy.error.log;\n\n        location / {\n            proxy_pass http://$host$request_uri;\n        }\n    }\nresolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。\n\n## 最后说两句\n启动停止及配置文件位置的命令:\n\n    /etc/init.d/nginx start/restart # 启动/重启Nginx服务\n    \n    /etc/init.d/nginx stop # 停止Nginx服务\n    \n    /etc/nginx/nginx.conf # Nginx配置文件位置\nNginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是\n\n    nginx -s reload\nwindows下面就是\n\n    nginx.exe -s reload\n\n著作权归作者所有。\n商业转载请联系作者获得授权，非商业转载请注明出处。\n作者：ll\n链接：https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340\n来源：极客教程","slug":"nginx-study","published":1,"updated":"2019-06-16T14:38:33.427Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqe20080g4vah68zgeep","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。</p>\n<h2 id=\"Nginx能做什么\"><a href=\"#Nginx能做什么\" class=\"headerlink\" title=\"Nginx能做什么\"></a>Nginx能做什么</h2><p>反向代理<br>负载均衡<br>HTTP服务器（包含动静分离）<br>正向代理<br>以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码</p>\n<pre><code>server {  \n    listen       80;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_set_header Host $host:$server_port;\n    }\n}\n</code></pre><p>保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。</p>\n<h3 id=\"1-RR（默认）\"><a href=\"#1-RR（默认）\" class=\"headerlink\" title=\"1.RR（默认）\"></a>1.RR（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>简单配置</p>\n<pre><code>upstream test {\n    server localhost:8080;\n    server localhost:8081;\n}\nserver {\n    listen       81;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n    location / {\n        proxy_pass http://test;\n        proxy_set_header Host $host:$server_port;\n    }\n}\n</code></pre><p>负载均衡的核心代码为</p>\n<pre><code>upstream test {\n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><p>这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问<a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">http://localhost</a> 的时候,也不会有问题，会默认跳转到<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。</p>\n<h3 id=\"2-权重\"><a href=\"#2-权重\" class=\"headerlink\" title=\"2.权重\"></a>2.权重</h3><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如</p>\n<pre><code>upstream test {\n    server localhost:8080 weight=9;\n    server localhost:8081 weight=1;\n}\n</code></pre><p>那么10次一般只会有1次会访问到8081，而有9次会访问到8080</p>\n<h3 id=\"3-ip-hash\"><a href=\"#3-ip-hash\" class=\"headerlink\" title=\"3.ip_hash\"></a>3.ip_hash</h3><p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>\n<pre><code>upstream test {\n    ip_hash;\n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><h3 id=\"4-fair（第三方）\"><a href=\"#4-fair（第三方）\" class=\"headerlink\" title=\"4.fair（第三方）\"></a>4.fair（第三方）</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<pre><code>upstream backend { \n    fair; \n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><h3 id=\"5-url-hash（第三方）\"><a href=\"#5-url-hash（第三方）\" class=\"headerlink\" title=\"5.url_hash（第三方）\"></a>5.url_hash（第三方）</h3><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</p>\n<pre><code>upstream backend { \n    hash $request_uri; \n    hash_method crc32; \n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><p>以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍</p>\n<h2 id=\"HTTP服务器\"><a href=\"#HTTP服务器\" class=\"headerlink\" title=\"HTTP服务器\"></a>HTTP服务器</h2><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器</p>\n<pre><code>server {\n    listen       80;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n\n    location / {\n           root   e:\\wwwroot;\n           index  index.html;\n       }\n}\n</code></pre><p>这样如果访问<a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">http://localhost</a> 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路</p>\n<pre><code>upstream test{  \n   server localhost:8080;  \n   server localhost:8081;  \n}   \n\nserver {  \n    listen       80;  \n    server_name  localhost;  \n\n    location / {  \n        root   e:\\wwwroot;  \n        index  index.html;  \n    }  \n\n    # 所有静态请求都由nginx处理，存放目录为html  \n    location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n        root    e:\\wwwroot;  \n    }  \n\n    # 所有动态请求都转发给tomcat处理  \n    location ~ \\.(jsp|do)$ {  \n        proxy_pass  http://test;  \n    }  \n\n    error_page   500 502 503 504  /50x.html;  \n    location = /50x.html {  \n        root   e:\\wwwroot;  \n    }  \n}\n</code></pre><p>这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。</p>\n<pre><code>resolver 114.114.114.114 8.8.8.8;\nserver {\n\n    resolver_timeout 5s;\n\n    listen 81;\n\n    access_log  e:\\wwwroot\\proxy.access.log;\n    error_log   e:\\wwwroot\\proxy.error.log;\n\n    location / {\n        proxy_pass http://$host$request_uri;\n    }\n}\n</code></pre><p>resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。</p>\n<h2 id=\"最后说两句\"><a href=\"#最后说两句\" class=\"headerlink\" title=\"最后说两句\"></a>最后说两句</h2><p>启动停止及配置文件位置的命令:</p>\n<pre><code>/etc/init.d/nginx start/restart # 启动/重启Nginx服务\n\n/etc/init.d/nginx stop # 停止Nginx服务\n\n/etc/nginx/nginx.conf # Nginx配置文件位置\n</code></pre><p>Nginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是</p>\n<pre><code>nginx -s reload\n</code></pre><p>windows下面就是</p>\n<pre><code>nginx.exe -s reload\n</code></pre><p>著作权归作者所有。<br>商业转载请联系作者获得授权，非商业转载请注明出处。<br>作者：ll<br>链接：<a href=\"https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340\" target=\"_blank\" rel=\"noopener\">https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340</a><br>来源：极客教程</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。</p>\n<h2 id=\"Nginx能做什么\"><a href=\"#Nginx能做什么\" class=\"headerlink\" title=\"Nginx能做什么\"></a>Nginx能做什么</h2><p>反向代理<br>负载均衡<br>HTTP服务器（包含动静分离）<br>正向代理<br>以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码</p>\n<pre><code>server {  \n    listen       80;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_set_header Host $host:$server_port;\n    }\n}\n</code></pre><p>保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。</p>\n<h3 id=\"1-RR（默认）\"><a href=\"#1-RR（默认）\" class=\"headerlink\" title=\"1.RR（默认）\"></a>1.RR（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>简单配置</p>\n<pre><code>upstream test {\n    server localhost:8080;\n    server localhost:8081;\n}\nserver {\n    listen       81;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n    location / {\n        proxy_pass http://test;\n        proxy_set_header Host $host:$server_port;\n    }\n}\n</code></pre><p>负载均衡的核心代码为</p>\n<pre><code>upstream test {\n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><p>这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问<a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">http://localhost</a> 的时候,也不会有问题，会默认跳转到<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。</p>\n<h3 id=\"2-权重\"><a href=\"#2-权重\" class=\"headerlink\" title=\"2.权重\"></a>2.权重</h3><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如</p>\n<pre><code>upstream test {\n    server localhost:8080 weight=9;\n    server localhost:8081 weight=1;\n}\n</code></pre><p>那么10次一般只会有1次会访问到8081，而有9次会访问到8080</p>\n<h3 id=\"3-ip-hash\"><a href=\"#3-ip-hash\" class=\"headerlink\" title=\"3.ip_hash\"></a>3.ip_hash</h3><p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>\n<pre><code>upstream test {\n    ip_hash;\n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><h3 id=\"4-fair（第三方）\"><a href=\"#4-fair（第三方）\" class=\"headerlink\" title=\"4.fair（第三方）\"></a>4.fair（第三方）</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<pre><code>upstream backend { \n    fair; \n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><h3 id=\"5-url-hash（第三方）\"><a href=\"#5-url-hash（第三方）\" class=\"headerlink\" title=\"5.url_hash（第三方）\"></a>5.url_hash（第三方）</h3><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</p>\n<pre><code>upstream backend { \n    hash $request_uri; \n    hash_method crc32; \n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><p>以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍</p>\n<h2 id=\"HTTP服务器\"><a href=\"#HTTP服务器\" class=\"headerlink\" title=\"HTTP服务器\"></a>HTTP服务器</h2><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器</p>\n<pre><code>server {\n    listen       80;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n\n    location / {\n           root   e:\\wwwroot;\n           index  index.html;\n       }\n}\n</code></pre><p>这样如果访问<a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">http://localhost</a> 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路</p>\n<pre><code>upstream test{  \n   server localhost:8080;  \n   server localhost:8081;  \n}   \n\nserver {  \n    listen       80;  \n    server_name  localhost;  \n\n    location / {  \n        root   e:\\wwwroot;  \n        index  index.html;  \n    }  \n\n    # 所有静态请求都由nginx处理，存放目录为html  \n    location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n        root    e:\\wwwroot;  \n    }  \n\n    # 所有动态请求都转发给tomcat处理  \n    location ~ \\.(jsp|do)$ {  \n        proxy_pass  http://test;  \n    }  \n\n    error_page   500 502 503 504  /50x.html;  \n    location = /50x.html {  \n        root   e:\\wwwroot;  \n    }  \n}\n</code></pre><p>这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。</p>\n<pre><code>resolver 114.114.114.114 8.8.8.8;\nserver {\n\n    resolver_timeout 5s;\n\n    listen 81;\n\n    access_log  e:\\wwwroot\\proxy.access.log;\n    error_log   e:\\wwwroot\\proxy.error.log;\n\n    location / {\n        proxy_pass http://$host$request_uri;\n    }\n}\n</code></pre><p>resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。</p>\n<h2 id=\"最后说两句\"><a href=\"#最后说两句\" class=\"headerlink\" title=\"最后说两句\"></a>最后说两句</h2><p>启动停止及配置文件位置的命令:</p>\n<pre><code>/etc/init.d/nginx start/restart # 启动/重启Nginx服务\n\n/etc/init.d/nginx stop # 停止Nginx服务\n\n/etc/nginx/nginx.conf # Nginx配置文件位置\n</code></pre><p>Nginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是</p>\n<pre><code>nginx -s reload\n</code></pre><p>windows下面就是</p>\n<pre><code>nginx.exe -s reload\n</code></pre><p>著作权归作者所有。<br>商业转载请联系作者获得授权，非商业转载请注明出处。<br>作者：ll<br>链接：<a href=\"https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340\" target=\"_blank\" rel=\"noopener\">https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340</a><br>来源：极客教程</p>\n"},{"title":"nginx使用问题收藏","date":"2019-01-25T03:52:40.000Z","_content":"\n## nginx出现 “414 request-uri too large”\n\n客户端请求头缓冲区大小，如果请求头总长度大于小于128k，则使用此缓冲区，\n\n请求头总长度大于128k时使用large_client_header_buffers设置的缓存区\nclient_header_buffer_size 128k;\n\nlarge_client_header_buffers 指令参数4为个数，128k为大小，默认是8k。申请4个128k。\nlarge_client_header_buffers 4 128k\n\n解决办法：   \n在nginx的nginx.conf修改如下参数的：\n\nclient_header_buffer_size 512k;\nlarge_client_header_buffers 4 512k;\n\n然后重新启动nginx\n     \n## 上传文件失败 Failed to load resource: the server responded with a status of 413 (Request Entity Too Large)    \n\n报错问题：\n\nFailed to load resource: the server responded with a status of 413 (Request Entity Too Large) \n\n解决：\n\n 打开nginx.conf配置文件，修改client_max_body_size值   \n 加上下面这行：\n\n client_max_body_size   30M（改成你想要的数值） \n \n 然后重新启动nginx\n \n _提醒：_  \n \n 于是奇葩的问题被我们遇到了，详细配置请参考下面。我们的问题是，无论client_max_body_size设置在哪里，nginx －s reload后，依然一直报413.多次尝试reload，始终无效。最终决定kill 进程，restart，终于好了。","source":"_posts/nginx-use-issue.md","raw":"---\ntitle: nginx使用问题收藏\ndate: 2019-01-25 11:52:40\ncategories: nginx\ntags:\n---\n\n## nginx出现 “414 request-uri too large”\n\n客户端请求头缓冲区大小，如果请求头总长度大于小于128k，则使用此缓冲区，\n\n请求头总长度大于128k时使用large_client_header_buffers设置的缓存区\nclient_header_buffer_size 128k;\n\nlarge_client_header_buffers 指令参数4为个数，128k为大小，默认是8k。申请4个128k。\nlarge_client_header_buffers 4 128k\n\n解决办法：   \n在nginx的nginx.conf修改如下参数的：\n\nclient_header_buffer_size 512k;\nlarge_client_header_buffers 4 512k;\n\n然后重新启动nginx\n     \n## 上传文件失败 Failed to load resource: the server responded with a status of 413 (Request Entity Too Large)    \n\n报错问题：\n\nFailed to load resource: the server responded with a status of 413 (Request Entity Too Large) \n\n解决：\n\n 打开nginx.conf配置文件，修改client_max_body_size值   \n 加上下面这行：\n\n client_max_body_size   30M（改成你想要的数值） \n \n 然后重新启动nginx\n \n _提醒：_  \n \n 于是奇葩的问题被我们遇到了，详细配置请参考下面。我们的问题是，无论client_max_body_size设置在哪里，nginx －s reload后，依然一直报413.多次尝试reload，始终无效。最终决定kill 进程，restart，终于好了。","slug":"nginx-use-issue","published":1,"updated":"2019-06-16T14:38:33.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqe30081g4vazs3ubcer","content":"<h2 id=\"nginx出现-“414-request-uri-too-large”\"><a href=\"#nginx出现-“414-request-uri-too-large”\" class=\"headerlink\" title=\"nginx出现 “414 request-uri too large”\"></a>nginx出现 “414 request-uri too large”</h2><p>客户端请求头缓冲区大小，如果请求头总长度大于小于128k，则使用此缓冲区，</p>\n<p>请求头总长度大于128k时使用large_client_header_buffers设置的缓存区<br>client_header_buffer_size 128k;</p>\n<p>large_client_header_buffers 指令参数4为个数，128k为大小，默认是8k。申请4个128k。<br>large_client_header_buffers 4 128k</p>\n<p>解决办法：<br>在nginx的nginx.conf修改如下参数的：</p>\n<p>client_header_buffer_size 512k;<br>large_client_header_buffers 4 512k;</p>\n<p>然后重新启动nginx</p>\n<h2 id=\"上传文件失败-Failed-to-load-resource-the-server-responded-with-a-status-of-413-Request-Entity-Too-Large\"><a href=\"#上传文件失败-Failed-to-load-resource-the-server-responded-with-a-status-of-413-Request-Entity-Too-Large\" class=\"headerlink\" title=\"上传文件失败 Failed to load resource: the server responded with a status of 413 (Request Entity Too Large)\"></a>上传文件失败 Failed to load resource: the server responded with a status of 413 (Request Entity Too Large)</h2><p>报错问题：</p>\n<p>Failed to load resource: the server responded with a status of 413 (Request Entity Too Large) </p>\n<p>解决：</p>\n<p> 打开nginx.conf配置文件，修改client_max_body_size值<br> 加上下面这行：</p>\n<p> client_max_body_size   30M（改成你想要的数值） </p>\n<p> 然后重新启动nginx</p>\n<p> <em>提醒：</em>  </p>\n<p> 于是奇葩的问题被我们遇到了，详细配置请参考下面。我们的问题是，无论client_max_body_size设置在哪里，nginx －s reload后，依然一直报413.多次尝试reload，始终无效。最终决定kill 进程，restart，终于好了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"nginx出现-“414-request-uri-too-large”\"><a href=\"#nginx出现-“414-request-uri-too-large”\" class=\"headerlink\" title=\"nginx出现 “414 request-uri too large”\"></a>nginx出现 “414 request-uri too large”</h2><p>客户端请求头缓冲区大小，如果请求头总长度大于小于128k，则使用此缓冲区，</p>\n<p>请求头总长度大于128k时使用large_client_header_buffers设置的缓存区<br>client_header_buffer_size 128k;</p>\n<p>large_client_header_buffers 指令参数4为个数，128k为大小，默认是8k。申请4个128k。<br>large_client_header_buffers 4 128k</p>\n<p>解决办法：<br>在nginx的nginx.conf修改如下参数的：</p>\n<p>client_header_buffer_size 512k;<br>large_client_header_buffers 4 512k;</p>\n<p>然后重新启动nginx</p>\n<h2 id=\"上传文件失败-Failed-to-load-resource-the-server-responded-with-a-status-of-413-Request-Entity-Too-Large\"><a href=\"#上传文件失败-Failed-to-load-resource-the-server-responded-with-a-status-of-413-Request-Entity-Too-Large\" class=\"headerlink\" title=\"上传文件失败 Failed to load resource: the server responded with a status of 413 (Request Entity Too Large)\"></a>上传文件失败 Failed to load resource: the server responded with a status of 413 (Request Entity Too Large)</h2><p>报错问题：</p>\n<p>Failed to load resource: the server responded with a status of 413 (Request Entity Too Large) </p>\n<p>解决：</p>\n<p> 打开nginx.conf配置文件，修改client_max_body_size值<br> 加上下面这行：</p>\n<p> client_max_body_size   30M（改成你想要的数值） </p>\n<p> 然后重新启动nginx</p>\n<p> <em>提醒：</em>  </p>\n<p> 于是奇葩的问题被我们遇到了，详细配置请参考下面。我们的问题是，无论client_max_body_size设置在哪里，nginx －s reload后，依然一直报413.多次尝试reload，始终无效。最终决定kill 进程，restart，终于好了。</p>\n"},{"title":"npm使用问题收集","date":"2018-09-13T03:36:53.000Z","_content":"\n收集在使用过程中遇到的问题……\n\n1.错误一：install错误，强制清空缓存\n\n` npm cache clean --force`","source":"_posts/npm-use.md","raw":"---\ntitle: npm使用问题收集\ndate: 2018-09-13 11:36:53\ncategories: npm\ntags: npm使用问题\n---\n\n收集在使用过程中遇到的问题……\n\n1.错误一：install错误，强制清空缓存\n\n` npm cache clean --force`","slug":"npm-use","published":1,"updated":"2019-06-16T14:38:33.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqe40085g4vaibwqoyuf","content":"<p>收集在使用过程中遇到的问题……</p>\n<p>1.错误一：install错误，强制清空缓存</p>\n<p><code>npm cache clean --force</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>收集在使用过程中遇到的问题……</p>\n<p>1.错误一：install错误，强制清空缓存</p>\n<p><code>npm cache clean --force</code></p>\n"},{"title":"ngrok使用","date":"2018-08-13T07:36:39.000Z","_content":"\n官网：https://ngrok.com","source":"_posts/ngrok-start.md","raw":"---\ntitle: ngrok使用\ndate: 2018-08-13 15:36:39\ncategories: ngrok\ntags: ngrok使用\n---\n\n官网：https://ngrok.com","slug":"ngrok-start","published":1,"updated":"2019-06-16T14:38:33.428Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqe60087g4vaev2l7as8","content":"<p>官网：<a href=\"https://ngrok.com\" target=\"_blank\" rel=\"noopener\">https://ngrok.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"https://ngrok.com\" target=\"_blank\" rel=\"noopener\">https://ngrok.com</a></p>\n"},{"title":"在Pivotal Web Service上发布Spring Boot应用","date":"2017-10-12T07:08:33.000Z","_content":"\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","source":"_posts/pivotal-web-service-start.md","raw":"---\ntitle: 在Pivotal Web Service上发布Spring Boot应用\ndate: 2017-10-12 15:08:33\ncategories: Pivotal Web Service\ntags: pws-push\n---\n\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","slug":"pivotal-web-service-start","published":1,"updated":"2019-06-16T14:38:33.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqe8008bg4vawu8gx8xl","content":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"noopener\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"noopener\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"noopener\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"noopener\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"noopener\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"noopener\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\"></li>\n</ol>\n"},{"title":"新一代消息中间件pulsar","date":"2019-08-16T01:13:14.000Z","_content":"\n官网：http://pulsar.apache.org\n\n\n## 单机安装\n\n除了最极端的情况，对于绝大多数的用例来说，单机群安装的Pulsar就能够满足要求了。 如果是创业公司或一个团队想体验下Pulsar，我们推荐使用单集群。\n\nhttp://pulsar.apache.org/docs/zh-CN/standalone/\n\n### 下载安装包\n\n下载安装包，有以下几种方式：\n\n- download from the Apache mirror ([Pulsar 2.4.1 binary release](https://archive.apache.org/dist/pulsar/pulsar-2.4.1/apache-pulsar-2.4.1-bin.tar.gz))\n- download from the Pulsar [downloads page](http://pulsar.apache.org/download/)\n- download from the [Pulsar releases page](https://github.com/apache/pulsar/releases/tag/v2.4.1)\n- use wget:\n\n    ","source":"_posts/pulsar-start.md","raw":"---\ntitle: 新一代消息中间件pulsar\ndate: 2019-08-16 09:13:14\ncategories:\ntags:\n---\n\n官网：http://pulsar.apache.org\n\n\n## 单机安装\n\n除了最极端的情况，对于绝大多数的用例来说，单机群安装的Pulsar就能够满足要求了。 如果是创业公司或一个团队想体验下Pulsar，我们推荐使用单集群。\n\nhttp://pulsar.apache.org/docs/zh-CN/standalone/\n\n### 下载安装包\n\n下载安装包，有以下几种方式：\n\n- download from the Apache mirror ([Pulsar 2.4.1 binary release](https://archive.apache.org/dist/pulsar/pulsar-2.4.1/apache-pulsar-2.4.1-bin.tar.gz))\n- download from the Pulsar [downloads page](http://pulsar.apache.org/download/)\n- download from the [Pulsar releases page](https://github.com/apache/pulsar/releases/tag/v2.4.1)\n- use wget:\n\n    ","slug":"pulsar-start","published":1,"updated":"2019-09-22T00:56:27.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqe9008eg4vazgu78pi7","content":"<p>官网：<a href=\"http://pulsar.apache.org\" target=\"_blank\" rel=\"noopener\">http://pulsar.apache.org</a></p>\n<h2 id=\"单机安装\"><a href=\"#单机安装\" class=\"headerlink\" title=\"单机安装\"></a>单机安装</h2><p>除了最极端的情况，对于绝大多数的用例来说，单机群安装的Pulsar就能够满足要求了。 如果是创业公司或一个团队想体验下Pulsar，我们推荐使用单集群。</p>\n<p><a href=\"http://pulsar.apache.org/docs/zh-CN/standalone/\" target=\"_blank\" rel=\"noopener\">http://pulsar.apache.org/docs/zh-CN/standalone/</a></p>\n<h3 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h3><p>下载安装包，有以下几种方式：</p>\n<ul>\n<li>download from the Apache mirror (<a href=\"https://archive.apache.org/dist/pulsar/pulsar-2.4.1/apache-pulsar-2.4.1-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">Pulsar 2.4.1 binary release</a>)</li>\n<li>download from the Pulsar <a href=\"http://pulsar.apache.org/download/\" target=\"_blank\" rel=\"noopener\">downloads page</a></li>\n<li>download from the <a href=\"https://github.com/apache/pulsar/releases/tag/v2.4.1\" target=\"_blank\" rel=\"noopener\">Pulsar releases page</a></li>\n<li>use wget:</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"http://pulsar.apache.org\" target=\"_blank\" rel=\"noopener\">http://pulsar.apache.org</a></p>\n<h2 id=\"单机安装\"><a href=\"#单机安装\" class=\"headerlink\" title=\"单机安装\"></a>单机安装</h2><p>除了最极端的情况，对于绝大多数的用例来说，单机群安装的Pulsar就能够满足要求了。 如果是创业公司或一个团队想体验下Pulsar，我们推荐使用单集群。</p>\n<p><a href=\"http://pulsar.apache.org/docs/zh-CN/standalone/\" target=\"_blank\" rel=\"noopener\">http://pulsar.apache.org/docs/zh-CN/standalone/</a></p>\n<h3 id=\"下载安装包\"><a href=\"#下载安装包\" class=\"headerlink\" title=\"下载安装包\"></a>下载安装包</h3><p>下载安装包，有以下几种方式：</p>\n<ul>\n<li>download from the Apache mirror (<a href=\"https://archive.apache.org/dist/pulsar/pulsar-2.4.1/apache-pulsar-2.4.1-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">Pulsar 2.4.1 binary release</a>)</li>\n<li>download from the Pulsar <a href=\"http://pulsar.apache.org/download/\" target=\"_blank\" rel=\"noopener\">downloads page</a></li>\n<li>download from the <a href=\"https://github.com/apache/pulsar/releases/tag/v2.4.1\" target=\"_blank\" rel=\"noopener\">Pulsar releases page</a></li>\n<li>use wget:</li>\n</ul>\n"},{"title":"rabbitMq实战记录","date":"2018-01-19T04:12:57.000Z","_content":"\nrabbitMq使用记录，好记性不如烂……\n\n## 避免消息堆积？\n\n1） 采用workqueue，多个消费者监听同一队列。\n\n2）接收到消息以后，而是通过线程池，异步消费。\n\n## 如何避免消息丢失？\n\n1） 消费者的ACK机制。可以防止消费者丢失消息。\n\n但是，如果在消费者消费之前，MQ就宕机了，消息就没了？\n\n2）可以将消息进行持久化。要将消息持久化，前提是：队列、Exchange都持久化\n\n","source":"_posts/rabbitmq-action.md","raw":"---\ntitle: rabbitMq实战记录\ndate: 2018-01-19 12:12:57\ncategories: rabbitmq\ntags: \n---\n\nrabbitMq使用记录，好记性不如烂……\n\n## 避免消息堆积？\n\n1） 采用workqueue，多个消费者监听同一队列。\n\n2）接收到消息以后，而是通过线程池，异步消费。\n\n## 如何避免消息丢失？\n\n1） 消费者的ACK机制。可以防止消费者丢失消息。\n\n但是，如果在消费者消费之前，MQ就宕机了，消息就没了？\n\n2）可以将消息进行持久化。要将消息持久化，前提是：队列、Exchange都持久化\n\n","slug":"rabbitmq-action","published":1,"updated":"2020-05-30T11:28:23.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqeb008ig4vah0wygwqy","content":"<p>rabbitMq使用记录，好记性不如烂……</p>\n<h2 id=\"避免消息堆积？\"><a href=\"#避免消息堆积？\" class=\"headerlink\" title=\"避免消息堆积？\"></a>避免消息堆积？</h2><p>1） 采用workqueue，多个消费者监听同一队列。</p>\n<p>2）接收到消息以后，而是通过线程池，异步消费。</p>\n<h2 id=\"如何避免消息丢失？\"><a href=\"#如何避免消息丢失？\" class=\"headerlink\" title=\"如何避免消息丢失？\"></a>如何避免消息丢失？</h2><p>1） 消费者的ACK机制。可以防止消费者丢失消息。</p>\n<p>但是，如果在消费者消费之前，MQ就宕机了，消息就没了？</p>\n<p>2）可以将消息进行持久化。要将消息持久化，前提是：队列、Exchange都持久化</p>\n","site":{"data":{}},"excerpt":"","more":"<p>rabbitMq使用记录，好记性不如烂……</p>\n<h2 id=\"避免消息堆积？\"><a href=\"#避免消息堆积？\" class=\"headerlink\" title=\"避免消息堆积？\"></a>避免消息堆积？</h2><p>1） 采用workqueue，多个消费者监听同一队列。</p>\n<p>2）接收到消息以后，而是通过线程池，异步消费。</p>\n<h2 id=\"如何避免消息丢失？\"><a href=\"#如何避免消息丢失？\" class=\"headerlink\" title=\"如何避免消息丢失？\"></a>如何避免消息丢失？</h2><p>1） 消费者的ACK机制。可以防止消费者丢失消息。</p>\n<p>但是，如果在消费者消费之前，MQ就宕机了，消息就没了？</p>\n<p>2）可以将消息进行持久化。要将消息持久化，前提是：队列、Exchange都持久化</p>\n"},{"title":"RabbitMQ学习-基础","date":"2020-04-11T08:31:59.000Z","_content":"\n## 什么是RabbitMQ？\n\nRabbitMQ是由Erlang语言编写的实现了高级消息队列协议（AMQP）的开源消息代理软件（也可称为 面向消息的中间件）。 \n\nRabbitMQ就像一个邮局，用来投递消息，接收消息。\n\n## 使用场景\n\n1.异步处理，提高并发量，提高程序响应速度。  \n2.多个程序之间解耦。多个系统之间通过消息中间件进行消息交互。\n\n典型的应用场景：\n\n1、注册时发送邮件或发送短信\n2、日志分析使用，多个服务产生的数据发送到中间件发送到分析服务。\n3、消息复制，用于跨机房数据传输、搜索、离线数据计算等。\n4、延迟消息发送和暂存，把中间件当成可靠的消息暂存地。接受消息，暂时先不发送。\n\n## 重要概念\n\n{%asset_img a.png%}\n\n（1）_Broker_：经纪人。提供一种传输服务，维护一条从生产者到消费者的传输线路，保证消息数据能按照指定的方式传输。粗略的可以将图中的RabbitMQ Server当作Broker。\n\n（2）_Exchange_：消息交换机。指定消息按照什么规则路由到哪个队列Queue。\n\n（3）_Queue_：消息队列。消息的载体，每条消息都会被投送到一个或多个队列中。\n\n（4）_Binding_：绑定。作用就是将Exchange和Queue按照某种路由规则绑定起来。\n\n（5）_RoutingKey_：路由关键字。Exchange根据RoutingKey进行消息投递。\n\n（6）_Vhost_：虚拟主机。一个Broker可以有多个虚拟主机，用作不同用户的权限分离。一个虚拟主机持有一组Exchange、Queue和Binding。\n\n（7）_Producer_：消息生产者。主要将消息投递到对应的Exchange上面。一般是独立的程序。\n\n（8）_Consumer_：消息消费者。消息的接收者，一般是独立的程序。\n\n（9）_Channel_：消息通道，也称信道。在客户端的每个连接里可以建立多个Channel，每个Channel代表一个会话任务。\n\n## RabbitMQ使用过程概述\n\nAMQP模型中，消息在Producer中产生，并发送到MQ的exchange上，exchange根据配置的路由将消息投递到对应的Queue上，Queue又将消息发送给已经在此Queue上注册的consumer，消息从queue到consumer有push和pull两种方式。\n\n消息队列的使用过程大概如下：\n\n（1）客户端连接到消息队列服务器，打开一个channel。\n\n（2）客户端声明一个exchange，并设置相关属性。\n\n（3）客户端声明一个queue，并设置相关属性。\n\n（4）客户端使用routing key，在exchange和queue之间建立好Binding关系。\n\n（5）生产者客户端投递消息到exchange。\n\n（6）exchange接收到消息后，就根据消息的RoutingKey和已经设置的binding，进行消息路由（投递），将消息投递到一个或多个队列里。\n\n（7）消费者客户端从对应的队列中获取并处理消息。\n\n\n#### 工作过程\n\n- _生产者客户端_：  \n \n1.客户端连接到RabbitMQ服务器上，打开一个消息通道（channel）。         \n2.客户端声明一个消息交换机（exchange），并设置相关属性。              \n3.客户端声明一个消息队列（queue），并设置相关属性。       \n4.客户端使用routing key在消息交换机（exchange）和消息队列（queue）中建立好绑定关系。        \n5.客户端投递消息都消息交换机（exchange）上。          \n6.客户端关闭消息通道（channel）以及和服务器的连接。      \n\n- _服务器端_：\n\nexchange接收到消息后，根据消息的key（这个key的产生规则暂时没研究，有知道的小伙伴可以留言告诉我）和以及设置的binding，进行消息路由，将消息投递到一个或多个消息队列中。\n\n关于exchange也有几个类型：\n\n(1). Direct交换机：完全根据key进行投递。例如，绑定时设置了routing key为abc，客户端提交信息提交信息时只有设置了key为abc的才会投递到队列；\n\n(2).Topic交换机：在key进行模式匹配后进行投递。例如：符号”#”匹配一个或多个字符，符号”*”匹配一串连续的字母字符，例如”abc.#”可以匹配”abc.def.ghi”，而”abc.*”只可以匹配”abc.def”。\n\n(3).Fanout交换机：它采取广播模式，消息进来时，将会被投递到与改交换机绑定的所有队列中。\n\n- _消费者_\n\n1、消费者和Broker建立TCP连接\n\n2、消费者和Broker建立通道\n\n3、消费者监听指定的Queue（队列）\n\n4、当有消息到达Queue时Broker默认将消息推送给消费者。\n\n5、消费者接收到消息。\n\n6、ack回复\n\n## RabbitMQ的消息持久化\n\nRabbitMQ支持数据持久化，也就是把数据写在磁盘上，可以增加数据的安全性。消息队列持久化包括三个部分：\n\n消息交换机（exchange）持久化，在声明时指定durable为1\n消息队列（queue）持久化，在声明时指定durable为1\n消息持久化，在投递时指定delivery_mode为2（1是非持久化）\n如果消息交换机（exchange）和消息队列（queue）都是持久化的话，那么他们之间的绑定（Binding）也是持久化的。如果消息交换机和消息队列之间一个持久化、一个非持久化，那么就不允许绑定。\n\n\n\n\n","source":"_posts/rabbitmq-basic.md","raw":"---\ntitle: RabbitMQ学习-基础\ndate: 2020-04-11 16:31:59\ncategories: rabbitmq\ntags:\n---\n\n## 什么是RabbitMQ？\n\nRabbitMQ是由Erlang语言编写的实现了高级消息队列协议（AMQP）的开源消息代理软件（也可称为 面向消息的中间件）。 \n\nRabbitMQ就像一个邮局，用来投递消息，接收消息。\n\n## 使用场景\n\n1.异步处理，提高并发量，提高程序响应速度。  \n2.多个程序之间解耦。多个系统之间通过消息中间件进行消息交互。\n\n典型的应用场景：\n\n1、注册时发送邮件或发送短信\n2、日志分析使用，多个服务产生的数据发送到中间件发送到分析服务。\n3、消息复制，用于跨机房数据传输、搜索、离线数据计算等。\n4、延迟消息发送和暂存，把中间件当成可靠的消息暂存地。接受消息，暂时先不发送。\n\n## 重要概念\n\n{%asset_img a.png%}\n\n（1）_Broker_：经纪人。提供一种传输服务，维护一条从生产者到消费者的传输线路，保证消息数据能按照指定的方式传输。粗略的可以将图中的RabbitMQ Server当作Broker。\n\n（2）_Exchange_：消息交换机。指定消息按照什么规则路由到哪个队列Queue。\n\n（3）_Queue_：消息队列。消息的载体，每条消息都会被投送到一个或多个队列中。\n\n（4）_Binding_：绑定。作用就是将Exchange和Queue按照某种路由规则绑定起来。\n\n（5）_RoutingKey_：路由关键字。Exchange根据RoutingKey进行消息投递。\n\n（6）_Vhost_：虚拟主机。一个Broker可以有多个虚拟主机，用作不同用户的权限分离。一个虚拟主机持有一组Exchange、Queue和Binding。\n\n（7）_Producer_：消息生产者。主要将消息投递到对应的Exchange上面。一般是独立的程序。\n\n（8）_Consumer_：消息消费者。消息的接收者，一般是独立的程序。\n\n（9）_Channel_：消息通道，也称信道。在客户端的每个连接里可以建立多个Channel，每个Channel代表一个会话任务。\n\n## RabbitMQ使用过程概述\n\nAMQP模型中，消息在Producer中产生，并发送到MQ的exchange上，exchange根据配置的路由将消息投递到对应的Queue上，Queue又将消息发送给已经在此Queue上注册的consumer，消息从queue到consumer有push和pull两种方式。\n\n消息队列的使用过程大概如下：\n\n（1）客户端连接到消息队列服务器，打开一个channel。\n\n（2）客户端声明一个exchange，并设置相关属性。\n\n（3）客户端声明一个queue，并设置相关属性。\n\n（4）客户端使用routing key，在exchange和queue之间建立好Binding关系。\n\n（5）生产者客户端投递消息到exchange。\n\n（6）exchange接收到消息后，就根据消息的RoutingKey和已经设置的binding，进行消息路由（投递），将消息投递到一个或多个队列里。\n\n（7）消费者客户端从对应的队列中获取并处理消息。\n\n\n#### 工作过程\n\n- _生产者客户端_：  \n \n1.客户端连接到RabbitMQ服务器上，打开一个消息通道（channel）。         \n2.客户端声明一个消息交换机（exchange），并设置相关属性。              \n3.客户端声明一个消息队列（queue），并设置相关属性。       \n4.客户端使用routing key在消息交换机（exchange）和消息队列（queue）中建立好绑定关系。        \n5.客户端投递消息都消息交换机（exchange）上。          \n6.客户端关闭消息通道（channel）以及和服务器的连接。      \n\n- _服务器端_：\n\nexchange接收到消息后，根据消息的key（这个key的产生规则暂时没研究，有知道的小伙伴可以留言告诉我）和以及设置的binding，进行消息路由，将消息投递到一个或多个消息队列中。\n\n关于exchange也有几个类型：\n\n(1). Direct交换机：完全根据key进行投递。例如，绑定时设置了routing key为abc，客户端提交信息提交信息时只有设置了key为abc的才会投递到队列；\n\n(2).Topic交换机：在key进行模式匹配后进行投递。例如：符号”#”匹配一个或多个字符，符号”*”匹配一串连续的字母字符，例如”abc.#”可以匹配”abc.def.ghi”，而”abc.*”只可以匹配”abc.def”。\n\n(3).Fanout交换机：它采取广播模式，消息进来时，将会被投递到与改交换机绑定的所有队列中。\n\n- _消费者_\n\n1、消费者和Broker建立TCP连接\n\n2、消费者和Broker建立通道\n\n3、消费者监听指定的Queue（队列）\n\n4、当有消息到达Queue时Broker默认将消息推送给消费者。\n\n5、消费者接收到消息。\n\n6、ack回复\n\n## RabbitMQ的消息持久化\n\nRabbitMQ支持数据持久化，也就是把数据写在磁盘上，可以增加数据的安全性。消息队列持久化包括三个部分：\n\n消息交换机（exchange）持久化，在声明时指定durable为1\n消息队列（queue）持久化，在声明时指定durable为1\n消息持久化，在投递时指定delivery_mode为2（1是非持久化）\n如果消息交换机（exchange）和消息队列（queue）都是持久化的话，那么他们之间的绑定（Binding）也是持久化的。如果消息交换机和消息队列之间一个持久化、一个非持久化，那么就不允许绑定。\n\n\n\n\n","slug":"rabbitmq-basic","published":1,"updated":"2020-05-30T11:28:23.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqeb008kg4va2lphu7zb","content":"<h2 id=\"什么是RabbitMQ？\"><a href=\"#什么是RabbitMQ？\" class=\"headerlink\" title=\"什么是RabbitMQ？\"></a>什么是RabbitMQ？</h2><p>RabbitMQ是由Erlang语言编写的实现了高级消息队列协议（AMQP）的开源消息代理软件（也可称为 面向消息的中间件）。 </p>\n<p>RabbitMQ就像一个邮局，用来投递消息，接收消息。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>1.异步处理，提高并发量，提高程序响应速度。<br>2.多个程序之间解耦。多个系统之间通过消息中间件进行消息交互。</p>\n<p>典型的应用场景：</p>\n<p>1、注册时发送邮件或发送短信<br>2、日志分析使用，多个服务产生的数据发送到中间件发送到分析服务。<br>3、消息复制，用于跨机房数据传输、搜索、离线数据计算等。<br>4、延迟消息发送和暂存，把中间件当成可靠的消息暂存地。接受消息，暂时先不发送。</p>\n<h2 id=\"重要概念\"><a href=\"#重要概念\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h2><img src=\"/2020/04/11/rabbitmq-basic/a.png\">\n<p>（1）<em>Broker</em>：经纪人。提供一种传输服务，维护一条从生产者到消费者的传输线路，保证消息数据能按照指定的方式传输。粗略的可以将图中的RabbitMQ Server当作Broker。</p>\n<p>（2）<em>Exchange</em>：消息交换机。指定消息按照什么规则路由到哪个队列Queue。</p>\n<p>（3）<em>Queue</em>：消息队列。消息的载体，每条消息都会被投送到一个或多个队列中。</p>\n<p>（4）<em>Binding</em>：绑定。作用就是将Exchange和Queue按照某种路由规则绑定起来。</p>\n<p>（5）<em>RoutingKey</em>：路由关键字。Exchange根据RoutingKey进行消息投递。</p>\n<p>（6）<em>Vhost</em>：虚拟主机。一个Broker可以有多个虚拟主机，用作不同用户的权限分离。一个虚拟主机持有一组Exchange、Queue和Binding。</p>\n<p>（7）<em>Producer</em>：消息生产者。主要将消息投递到对应的Exchange上面。一般是独立的程序。</p>\n<p>（8）<em>Consumer</em>：消息消费者。消息的接收者，一般是独立的程序。</p>\n<p>（9）<em>Channel</em>：消息通道，也称信道。在客户端的每个连接里可以建立多个Channel，每个Channel代表一个会话任务。</p>\n<h2 id=\"RabbitMQ使用过程概述\"><a href=\"#RabbitMQ使用过程概述\" class=\"headerlink\" title=\"RabbitMQ使用过程概述\"></a>RabbitMQ使用过程概述</h2><p>AMQP模型中，消息在Producer中产生，并发送到MQ的exchange上，exchange根据配置的路由将消息投递到对应的Queue上，Queue又将消息发送给已经在此Queue上注册的consumer，消息从queue到consumer有push和pull两种方式。</p>\n<p>消息队列的使用过程大概如下：</p>\n<p>（1）客户端连接到消息队列服务器，打开一个channel。</p>\n<p>（2）客户端声明一个exchange，并设置相关属性。</p>\n<p>（3）客户端声明一个queue，并设置相关属性。</p>\n<p>（4）客户端使用routing key，在exchange和queue之间建立好Binding关系。</p>\n<p>（5）生产者客户端投递消息到exchange。</p>\n<p>（6）exchange接收到消息后，就根据消息的RoutingKey和已经设置的binding，进行消息路由（投递），将消息投递到一个或多个队列里。</p>\n<p>（7）消费者客户端从对应的队列中获取并处理消息。</p>\n<h4 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h4><ul>\n<li><em>生产者客户端</em>：  </li>\n</ul>\n<p>1.客户端连接到RabbitMQ服务器上，打开一个消息通道（channel）。<br>2.客户端声明一个消息交换机（exchange），并设置相关属性。<br>3.客户端声明一个消息队列（queue），并设置相关属性。<br>4.客户端使用routing key在消息交换机（exchange）和消息队列（queue）中建立好绑定关系。<br>5.客户端投递消息都消息交换机（exchange）上。<br>6.客户端关闭消息通道（channel）以及和服务器的连接。      </p>\n<ul>\n<li><em>服务器端</em>：</li>\n</ul>\n<p>exchange接收到消息后，根据消息的key（这个key的产生规则暂时没研究，有知道的小伙伴可以留言告诉我）和以及设置的binding，进行消息路由，将消息投递到一个或多个消息队列中。</p>\n<p>关于exchange也有几个类型：</p>\n<p>(1). Direct交换机：完全根据key进行投递。例如，绑定时设置了routing key为abc，客户端提交信息提交信息时只有设置了key为abc的才会投递到队列；</p>\n<p>(2).Topic交换机：在key进行模式匹配后进行投递。例如：符号”#”匹配一个或多个字符，符号”<em>”匹配一串连续的字母字符，例如”abc.#”可以匹配”abc.def.ghi”，而”abc.</em>”只可以匹配”abc.def”。</p>\n<p>(3).Fanout交换机：它采取广播模式，消息进来时，将会被投递到与改交换机绑定的所有队列中。</p>\n<ul>\n<li><em>消费者</em></li>\n</ul>\n<p>1、消费者和Broker建立TCP连接</p>\n<p>2、消费者和Broker建立通道</p>\n<p>3、消费者监听指定的Queue（队列）</p>\n<p>4、当有消息到达Queue时Broker默认将消息推送给消费者。</p>\n<p>5、消费者接收到消息。</p>\n<p>6、ack回复</p>\n<h2 id=\"RabbitMQ的消息持久化\"><a href=\"#RabbitMQ的消息持久化\" class=\"headerlink\" title=\"RabbitMQ的消息持久化\"></a>RabbitMQ的消息持久化</h2><p>RabbitMQ支持数据持久化，也就是把数据写在磁盘上，可以增加数据的安全性。消息队列持久化包括三个部分：</p>\n<p>消息交换机（exchange）持久化，在声明时指定durable为1<br>消息队列（queue）持久化，在声明时指定durable为1<br>消息持久化，在投递时指定delivery_mode为2（1是非持久化）<br>如果消息交换机（exchange）和消息队列（queue）都是持久化的话，那么他们之间的绑定（Binding）也是持久化的。如果消息交换机和消息队列之间一个持久化、一个非持久化，那么就不允许绑定。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是RabbitMQ？\"><a href=\"#什么是RabbitMQ？\" class=\"headerlink\" title=\"什么是RabbitMQ？\"></a>什么是RabbitMQ？</h2><p>RabbitMQ是由Erlang语言编写的实现了高级消息队列协议（AMQP）的开源消息代理软件（也可称为 面向消息的中间件）。 </p>\n<p>RabbitMQ就像一个邮局，用来投递消息，接收消息。</p>\n<h2 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h2><p>1.异步处理，提高并发量，提高程序响应速度。<br>2.多个程序之间解耦。多个系统之间通过消息中间件进行消息交互。</p>\n<p>典型的应用场景：</p>\n<p>1、注册时发送邮件或发送短信<br>2、日志分析使用，多个服务产生的数据发送到中间件发送到分析服务。<br>3、消息复制，用于跨机房数据传输、搜索、离线数据计算等。<br>4、延迟消息发送和暂存，把中间件当成可靠的消息暂存地。接受消息，暂时先不发送。</p>\n<h2 id=\"重要概念\"><a href=\"#重要概念\" class=\"headerlink\" title=\"重要概念\"></a>重要概念</h2><img src=\"/2020/04/11/rabbitmq-basic/a.png\">\n<p>（1）<em>Broker</em>：经纪人。提供一种传输服务，维护一条从生产者到消费者的传输线路，保证消息数据能按照指定的方式传输。粗略的可以将图中的RabbitMQ Server当作Broker。</p>\n<p>（2）<em>Exchange</em>：消息交换机。指定消息按照什么规则路由到哪个队列Queue。</p>\n<p>（3）<em>Queue</em>：消息队列。消息的载体，每条消息都会被投送到一个或多个队列中。</p>\n<p>（4）<em>Binding</em>：绑定。作用就是将Exchange和Queue按照某种路由规则绑定起来。</p>\n<p>（5）<em>RoutingKey</em>：路由关键字。Exchange根据RoutingKey进行消息投递。</p>\n<p>（6）<em>Vhost</em>：虚拟主机。一个Broker可以有多个虚拟主机，用作不同用户的权限分离。一个虚拟主机持有一组Exchange、Queue和Binding。</p>\n<p>（7）<em>Producer</em>：消息生产者。主要将消息投递到对应的Exchange上面。一般是独立的程序。</p>\n<p>（8）<em>Consumer</em>：消息消费者。消息的接收者，一般是独立的程序。</p>\n<p>（9）<em>Channel</em>：消息通道，也称信道。在客户端的每个连接里可以建立多个Channel，每个Channel代表一个会话任务。</p>\n<h2 id=\"RabbitMQ使用过程概述\"><a href=\"#RabbitMQ使用过程概述\" class=\"headerlink\" title=\"RabbitMQ使用过程概述\"></a>RabbitMQ使用过程概述</h2><p>AMQP模型中，消息在Producer中产生，并发送到MQ的exchange上，exchange根据配置的路由将消息投递到对应的Queue上，Queue又将消息发送给已经在此Queue上注册的consumer，消息从queue到consumer有push和pull两种方式。</p>\n<p>消息队列的使用过程大概如下：</p>\n<p>（1）客户端连接到消息队列服务器，打开一个channel。</p>\n<p>（2）客户端声明一个exchange，并设置相关属性。</p>\n<p>（3）客户端声明一个queue，并设置相关属性。</p>\n<p>（4）客户端使用routing key，在exchange和queue之间建立好Binding关系。</p>\n<p>（5）生产者客户端投递消息到exchange。</p>\n<p>（6）exchange接收到消息后，就根据消息的RoutingKey和已经设置的binding，进行消息路由（投递），将消息投递到一个或多个队列里。</p>\n<p>（7）消费者客户端从对应的队列中获取并处理消息。</p>\n<h4 id=\"工作过程\"><a href=\"#工作过程\" class=\"headerlink\" title=\"工作过程\"></a>工作过程</h4><ul>\n<li><em>生产者客户端</em>：  </li>\n</ul>\n<p>1.客户端连接到RabbitMQ服务器上，打开一个消息通道（channel）。<br>2.客户端声明一个消息交换机（exchange），并设置相关属性。<br>3.客户端声明一个消息队列（queue），并设置相关属性。<br>4.客户端使用routing key在消息交换机（exchange）和消息队列（queue）中建立好绑定关系。<br>5.客户端投递消息都消息交换机（exchange）上。<br>6.客户端关闭消息通道（channel）以及和服务器的连接。      </p>\n<ul>\n<li><em>服务器端</em>：</li>\n</ul>\n<p>exchange接收到消息后，根据消息的key（这个key的产生规则暂时没研究，有知道的小伙伴可以留言告诉我）和以及设置的binding，进行消息路由，将消息投递到一个或多个消息队列中。</p>\n<p>关于exchange也有几个类型：</p>\n<p>(1). Direct交换机：完全根据key进行投递。例如，绑定时设置了routing key为abc，客户端提交信息提交信息时只有设置了key为abc的才会投递到队列；</p>\n<p>(2).Topic交换机：在key进行模式匹配后进行投递。例如：符号”#”匹配一个或多个字符，符号”<em>”匹配一串连续的字母字符，例如”abc.#”可以匹配”abc.def.ghi”，而”abc.</em>”只可以匹配”abc.def”。</p>\n<p>(3).Fanout交换机：它采取广播模式，消息进来时，将会被投递到与改交换机绑定的所有队列中。</p>\n<ul>\n<li><em>消费者</em></li>\n</ul>\n<p>1、消费者和Broker建立TCP连接</p>\n<p>2、消费者和Broker建立通道</p>\n<p>3、消费者监听指定的Queue（队列）</p>\n<p>4、当有消息到达Queue时Broker默认将消息推送给消费者。</p>\n<p>5、消费者接收到消息。</p>\n<p>6、ack回复</p>\n<h2 id=\"RabbitMQ的消息持久化\"><a href=\"#RabbitMQ的消息持久化\" class=\"headerlink\" title=\"RabbitMQ的消息持久化\"></a>RabbitMQ的消息持久化</h2><p>RabbitMQ支持数据持久化，也就是把数据写在磁盘上，可以增加数据的安全性。消息队列持久化包括三个部分：</p>\n<p>消息交换机（exchange）持久化，在声明时指定durable为1<br>消息队列（queue）持久化，在声明时指定durable为1<br>消息持久化，在投递时指定delivery_mode为2（1是非持久化）<br>如果消息交换机（exchange）和消息队列（queue）都是持久化的话，那么他们之间的绑定（Binding）也是持久化的。如果消息交换机和消息队列之间一个持久化、一个非持久化，那么就不允许绑定。</p>\n"},{"title":"RabbitMQ学习-交换机","date":"2020-04-11T16:18:23.000Z","_content":"\n本文介绍交换机exchange的使用。\n\n## Exchange交换机的类型\n\nRabbitMQ的Exchange（交换器）分为四类：\n\ndirect（默认）\nheaders\nfanout\ntopic\n\n其中headers交换器允许你匹配AMQP消息的header而非路由键，除此之外headers交换器和direct交换器完全一致，但性能却很差，几乎用不到，所以我们本文也不做讲解。\n\n_注意_：fanout、topic交换器是没有历史数据的，也就是说对于中途创建的队列，获取不到之前的消息\n\n## 1、 Direct Exchange\n\n（1）名称：直接交换器类型\n\n（2）默认的预先定义exchange名字：空字符串或者amq.direct\n\n（3）作用描述：根据Binding指定的Routing Key，将符合Key的消息发送到Binding的Queue。可以构建点对点消息传输模型。\n\n{%asset_img a-1.png%}\n\n如图中RoutingKey分别是error、info、warning，其中error被Binding（绑定）到queue1和queue2上，info和warning被Binding到queue2上。当消息的RoutingKey是error，这条消息将被投递到queue1和queue2中（相当于消息被复制成两个分别投放到两个queue中），然后分别被Consumer1和Consumer2处理。如果消息的RoutingKey是info或者warning，这条消息只会被投递到queue2中，然后被Consumer2处理。如果消息的RoutingKey是其他的字符串，这条消息则会被丢弃。\n\n## 2、 fanout交换器——发布/订阅模式\n\n（1）名称：广播式交换器类型\n\n（2）默认的预先定义exchange名字：amq.fanout\n\n（3）作用描述：将同一个message发送到所有同该Exchange 绑定的queue。不论RoutingKey是什么，这条消息都会被投递到所有与此Exchange绑定的queue中。\n\n{%asset_img a-2.png%}\n\n广播式交换器类型的工作方式：不使用任何参数将queue和Exchange进行Binding，发布者publisher向Exchange发送一条消息（注意：直接交换器类型中的producer变成了publisher，其中隐含了两种交换器的区别），然后这条消息被无条件的投递给所有和这个Exchange绑定的queue中。\n\n如图中，没有RoutingKey的限制，只要消息到达Exchange，都会被投递到queue1和queue2中，然后被对应的Consumer处理。\n\n## 3、 topic交换器——匹配订阅模式\n\n（1）名称：主题交换器类型\n\n（2）默认的预先定义exchange名字：amq.topic\n\n（3）作用描述：根据Binding指定的RoutingKey，Exchange对key进行模式匹配后投递到相应的Queue，模式匹配时符号“#”匹配一个或多个词，符号“*”匹配正好一个词，而且单词与单词之间必须要用“.”符号进行分隔。此模式可以用来支持经典的发布/订阅消息传输模型-使用主题名字空间作为消息寻址模式，将消息传递给那些部分或者全部匹配主题模式的queue。\n\n{%asset_img a-3.png%}\n\n 如图中，假如消息的RoutingKey是American.action.13，这条消息将被投递到Q1和Q2中。假如RoutingKey是American.action.13.test（注意：此处是四个词），这条消息将会被丢弃，因为没有routingkey与之匹配。假如RoutingKey是Chinese.action.13，这条消息将被投递到Q2和Q3中。假如RoutingKey是Chinese.action.13.test，这条消息只会被投递到Q3中，#可以匹配一个或者多个单词，而*只能匹配一个词。\n\n\n## 参考\n\nhttps://www.cnblogs.com/vipstone/p/9295625.html\n","source":"_posts/rabbitmq-exchange.md","raw":"---\ntitle: RabbitMQ学习-交换机\ndate: 2020-04-12 00:18:23\ncategories: rabbitmq\ntags:\n---\n\n本文介绍交换机exchange的使用。\n\n## Exchange交换机的类型\n\nRabbitMQ的Exchange（交换器）分为四类：\n\ndirect（默认）\nheaders\nfanout\ntopic\n\n其中headers交换器允许你匹配AMQP消息的header而非路由键，除此之外headers交换器和direct交换器完全一致，但性能却很差，几乎用不到，所以我们本文也不做讲解。\n\n_注意_：fanout、topic交换器是没有历史数据的，也就是说对于中途创建的队列，获取不到之前的消息\n\n## 1、 Direct Exchange\n\n（1）名称：直接交换器类型\n\n（2）默认的预先定义exchange名字：空字符串或者amq.direct\n\n（3）作用描述：根据Binding指定的Routing Key，将符合Key的消息发送到Binding的Queue。可以构建点对点消息传输模型。\n\n{%asset_img a-1.png%}\n\n如图中RoutingKey分别是error、info、warning，其中error被Binding（绑定）到queue1和queue2上，info和warning被Binding到queue2上。当消息的RoutingKey是error，这条消息将被投递到queue1和queue2中（相当于消息被复制成两个分别投放到两个queue中），然后分别被Consumer1和Consumer2处理。如果消息的RoutingKey是info或者warning，这条消息只会被投递到queue2中，然后被Consumer2处理。如果消息的RoutingKey是其他的字符串，这条消息则会被丢弃。\n\n## 2、 fanout交换器——发布/订阅模式\n\n（1）名称：广播式交换器类型\n\n（2）默认的预先定义exchange名字：amq.fanout\n\n（3）作用描述：将同一个message发送到所有同该Exchange 绑定的queue。不论RoutingKey是什么，这条消息都会被投递到所有与此Exchange绑定的queue中。\n\n{%asset_img a-2.png%}\n\n广播式交换器类型的工作方式：不使用任何参数将queue和Exchange进行Binding，发布者publisher向Exchange发送一条消息（注意：直接交换器类型中的producer变成了publisher，其中隐含了两种交换器的区别），然后这条消息被无条件的投递给所有和这个Exchange绑定的queue中。\n\n如图中，没有RoutingKey的限制，只要消息到达Exchange，都会被投递到queue1和queue2中，然后被对应的Consumer处理。\n\n## 3、 topic交换器——匹配订阅模式\n\n（1）名称：主题交换器类型\n\n（2）默认的预先定义exchange名字：amq.topic\n\n（3）作用描述：根据Binding指定的RoutingKey，Exchange对key进行模式匹配后投递到相应的Queue，模式匹配时符号“#”匹配一个或多个词，符号“*”匹配正好一个词，而且单词与单词之间必须要用“.”符号进行分隔。此模式可以用来支持经典的发布/订阅消息传输模型-使用主题名字空间作为消息寻址模式，将消息传递给那些部分或者全部匹配主题模式的queue。\n\n{%asset_img a-3.png%}\n\n 如图中，假如消息的RoutingKey是American.action.13，这条消息将被投递到Q1和Q2中。假如RoutingKey是American.action.13.test（注意：此处是四个词），这条消息将会被丢弃，因为没有routingkey与之匹配。假如RoutingKey是Chinese.action.13，这条消息将被投递到Q2和Q3中。假如RoutingKey是Chinese.action.13.test，这条消息只会被投递到Q3中，#可以匹配一个或者多个单词，而*只能匹配一个词。\n\n\n## 参考\n\nhttps://www.cnblogs.com/vipstone/p/9295625.html\n","slug":"rabbitmq-exchange","published":1,"updated":"2020-05-30T11:28:23.373Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqed008mg4vaj5djmm47","content":"<p>本文介绍交换机exchange的使用。</p>\n<h2 id=\"Exchange交换机的类型\"><a href=\"#Exchange交换机的类型\" class=\"headerlink\" title=\"Exchange交换机的类型\"></a>Exchange交换机的类型</h2><p>RabbitMQ的Exchange（交换器）分为四类：</p>\n<p>direct（默认）<br>headers<br>fanout<br>topic</p>\n<p>其中headers交换器允许你匹配AMQP消息的header而非路由键，除此之外headers交换器和direct交换器完全一致，但性能却很差，几乎用不到，所以我们本文也不做讲解。</p>\n<p>_注意_：fanout、topic交换器是没有历史数据的，也就是说对于中途创建的队列，获取不到之前的消息</p>\n<h2 id=\"1、-Direct-Exchange\"><a href=\"#1、-Direct-Exchange\" class=\"headerlink\" title=\"1、 Direct Exchange\"></a>1、 Direct Exchange</h2><p>（1）名称：直接交换器类型</p>\n<p>（2）默认的预先定义exchange名字：空字符串或者amq.direct</p>\n<p>（3）作用描述：根据Binding指定的Routing Key，将符合Key的消息发送到Binding的Queue。可以构建点对点消息传输模型。</p>\n<img src=\"/2020/04/12/rabbitmq-exchange/a-1.png\">\n<p>如图中RoutingKey分别是error、info、warning，其中error被Binding（绑定）到queue1和queue2上，info和warning被Binding到queue2上。当消息的RoutingKey是error，这条消息将被投递到queue1和queue2中（相当于消息被复制成两个分别投放到两个queue中），然后分别被Consumer1和Consumer2处理。如果消息的RoutingKey是info或者warning，这条消息只会被投递到queue2中，然后被Consumer2处理。如果消息的RoutingKey是其他的字符串，这条消息则会被丢弃。</p>\n<h2 id=\"2、-fanout交换器——发布-订阅模式\"><a href=\"#2、-fanout交换器——发布-订阅模式\" class=\"headerlink\" title=\"2、 fanout交换器——发布/订阅模式\"></a>2、 fanout交换器——发布/订阅模式</h2><p>（1）名称：广播式交换器类型</p>\n<p>（2）默认的预先定义exchange名字：amq.fanout</p>\n<p>（3）作用描述：将同一个message发送到所有同该Exchange 绑定的queue。不论RoutingKey是什么，这条消息都会被投递到所有与此Exchange绑定的queue中。</p>\n<img src=\"/2020/04/12/rabbitmq-exchange/a-2.png\">\n<p>广播式交换器类型的工作方式：不使用任何参数将queue和Exchange进行Binding，发布者publisher向Exchange发送一条消息（注意：直接交换器类型中的producer变成了publisher，其中隐含了两种交换器的区别），然后这条消息被无条件的投递给所有和这个Exchange绑定的queue中。</p>\n<p>如图中，没有RoutingKey的限制，只要消息到达Exchange，都会被投递到queue1和queue2中，然后被对应的Consumer处理。</p>\n<h2 id=\"3、-topic交换器——匹配订阅模式\"><a href=\"#3、-topic交换器——匹配订阅模式\" class=\"headerlink\" title=\"3、 topic交换器——匹配订阅模式\"></a>3、 topic交换器——匹配订阅模式</h2><p>（1）名称：主题交换器类型</p>\n<p>（2）默认的预先定义exchange名字：amq.topic</p>\n<p>（3）作用描述：根据Binding指定的RoutingKey，Exchange对key进行模式匹配后投递到相应的Queue，模式匹配时符号“#”匹配一个或多个词，符号“*”匹配正好一个词，而且单词与单词之间必须要用“.”符号进行分隔。此模式可以用来支持经典的发布/订阅消息传输模型-使用主题名字空间作为消息寻址模式，将消息传递给那些部分或者全部匹配主题模式的queue。</p>\n<img src=\"/2020/04/12/rabbitmq-exchange/a-3.png\">\n<p> 如图中，假如消息的RoutingKey是American.action.13，这条消息将被投递到Q1和Q2中。假如RoutingKey是American.action.13.test（注意：此处是四个词），这条消息将会被丢弃，因为没有routingkey与之匹配。假如RoutingKey是Chinese.action.13，这条消息将被投递到Q2和Q3中。假如RoutingKey是Chinese.action.13.test，这条消息只会被投递到Q3中，#可以匹配一个或者多个单词，而*只能匹配一个词。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/vipstone/p/9295625.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/vipstone/p/9295625.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍交换机exchange的使用。</p>\n<h2 id=\"Exchange交换机的类型\"><a href=\"#Exchange交换机的类型\" class=\"headerlink\" title=\"Exchange交换机的类型\"></a>Exchange交换机的类型</h2><p>RabbitMQ的Exchange（交换器）分为四类：</p>\n<p>direct（默认）<br>headers<br>fanout<br>topic</p>\n<p>其中headers交换器允许你匹配AMQP消息的header而非路由键，除此之外headers交换器和direct交换器完全一致，但性能却很差，几乎用不到，所以我们本文也不做讲解。</p>\n<p>_注意_：fanout、topic交换器是没有历史数据的，也就是说对于中途创建的队列，获取不到之前的消息</p>\n<h2 id=\"1、-Direct-Exchange\"><a href=\"#1、-Direct-Exchange\" class=\"headerlink\" title=\"1、 Direct Exchange\"></a>1、 Direct Exchange</h2><p>（1）名称：直接交换器类型</p>\n<p>（2）默认的预先定义exchange名字：空字符串或者amq.direct</p>\n<p>（3）作用描述：根据Binding指定的Routing Key，将符合Key的消息发送到Binding的Queue。可以构建点对点消息传输模型。</p>\n<img src=\"/2020/04/12/rabbitmq-exchange/a-1.png\">\n<p>如图中RoutingKey分别是error、info、warning，其中error被Binding（绑定）到queue1和queue2上，info和warning被Binding到queue2上。当消息的RoutingKey是error，这条消息将被投递到queue1和queue2中（相当于消息被复制成两个分别投放到两个queue中），然后分别被Consumer1和Consumer2处理。如果消息的RoutingKey是info或者warning，这条消息只会被投递到queue2中，然后被Consumer2处理。如果消息的RoutingKey是其他的字符串，这条消息则会被丢弃。</p>\n<h2 id=\"2、-fanout交换器——发布-订阅模式\"><a href=\"#2、-fanout交换器——发布-订阅模式\" class=\"headerlink\" title=\"2、 fanout交换器——发布/订阅模式\"></a>2、 fanout交换器——发布/订阅模式</h2><p>（1）名称：广播式交换器类型</p>\n<p>（2）默认的预先定义exchange名字：amq.fanout</p>\n<p>（3）作用描述：将同一个message发送到所有同该Exchange 绑定的queue。不论RoutingKey是什么，这条消息都会被投递到所有与此Exchange绑定的queue中。</p>\n<img src=\"/2020/04/12/rabbitmq-exchange/a-2.png\">\n<p>广播式交换器类型的工作方式：不使用任何参数将queue和Exchange进行Binding，发布者publisher向Exchange发送一条消息（注意：直接交换器类型中的producer变成了publisher，其中隐含了两种交换器的区别），然后这条消息被无条件的投递给所有和这个Exchange绑定的queue中。</p>\n<p>如图中，没有RoutingKey的限制，只要消息到达Exchange，都会被投递到queue1和queue2中，然后被对应的Consumer处理。</p>\n<h2 id=\"3、-topic交换器——匹配订阅模式\"><a href=\"#3、-topic交换器——匹配订阅模式\" class=\"headerlink\" title=\"3、 topic交换器——匹配订阅模式\"></a>3、 topic交换器——匹配订阅模式</h2><p>（1）名称：主题交换器类型</p>\n<p>（2）默认的预先定义exchange名字：amq.topic</p>\n<p>（3）作用描述：根据Binding指定的RoutingKey，Exchange对key进行模式匹配后投递到相应的Queue，模式匹配时符号“#”匹配一个或多个词，符号“*”匹配正好一个词，而且单词与单词之间必须要用“.”符号进行分隔。此模式可以用来支持经典的发布/订阅消息传输模型-使用主题名字空间作为消息寻址模式，将消息传递给那些部分或者全部匹配主题模式的queue。</p>\n<img src=\"/2020/04/12/rabbitmq-exchange/a-3.png\">\n<p> 如图中，假如消息的RoutingKey是American.action.13，这条消息将被投递到Q1和Q2中。假如RoutingKey是American.action.13.test（注意：此处是四个词），这条消息将会被丢弃，因为没有routingkey与之匹配。假如RoutingKey是Chinese.action.13，这条消息将被投递到Q2和Q3中。假如RoutingKey是Chinese.action.13.test，这条消息只会被投递到Q3中，#可以匹配一个或者多个单词，而*只能匹配一个词。</p>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.cnblogs.com/vipstone/p/9295625.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/vipstone/p/9295625.html</a></p>\n"},{"title":"rabbitmq快速安装","date":"2018-01-02T08:02:01.000Z","_content":"\n本文介绍rabbitmq在各系统平台下的安装……\n\n## 在Centos下的快速安装\n\n一、安装erlang\nsudo yum install erlang\n\n检查是否安装好：\n\n    [root@localhost /]# erl\n    Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n\n二、安装rabbitmq\n\n（1）下载安装包\nwget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\n\n（2）安装\n\n    > rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n    > yum install rabbitmq-server-3.6.0-1.noarch.rpm\n\n（3）启用web管理插件\nrabbitmq-plugins enable rabbitmq_management\n\n三、启动RabbitMQ\nchkconfig rabbitmq-server on  //开机启动设置\nservice rabbitmq-server start\n\n 四、打开对应端口\n        # firewall-cmd --permanent --zone=public --add-port=5672/tcp\n        # firewall-cmd --permanent --zone=public --add-port=15672/tcp\n        # firewall-cmd --reload\n\n五、打开网页\nhttp://119.23.78.160:15672/\n\n## 在Ubuntu下的快速安装\n\n安装最新版，参考网址： \nhttp://www.rabbitmq.com/install-debian.html\n\n注：下面安装的不是最新版本。\n一. 安装对应erlang版本：\nerlang-nox (>= 1:19.3-1) | esl-erlang (>= 1:19.3-1).\n`sudo apt-get install erlang-nox`\n\n二. 安装rabbitMq:\n\n    $ sudo apt-get update\n    $ sudo apt-get install rabbitmq-server\n    \n三. 启用web管理插件：\n\n`sudo rabbitmq-plugins enable rabbitmq_management`  \n\n四. 访问\n打开：http://localhost:15672  \n\n五. 登录（本机）：\n用户：guest\n密码：guest\n\n注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。\n\n## docker安装rabbitMq\n\n参考：https://hub.docker.com/_/rabbitmq?tab=description\n\n执行下面命令安装：\n\n    docker run --hostname myRabbit --restart=always --name my-rabbitmq -v /server/data/rabbitmq:/var/lib/rabbitmq  -e RABBITMQ_DEFAULT_USER=ymu -e RABBITMQ_DEFAULT_PASS=123456 -e RABBITMQ_DEFAULT_VHOST=ymu_vhost  -p 15672:15672 -p 4369:4369 -p 5671-5672:5671-5672 -p 15671:15671 -p 25672:25672 -d rabbitmq:3.7.8-management\n    \n安装成功后，在浏览器输入：\n\nhttp://ip:15672，进入控制台。  \n\n账号：ymu\n密码：123456\n    \n_参数说明：_ \n\n- -e 指定环境变量；（RABBITMQ_DEFAULT_VHOST：默认虚拟机名；RABBITMQ_DEFAULT_USER：默认的用户名；RABBITMQ_DEFAULT_PASS：默认用户名的密码）\n- --hostname  主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；  \n\n_端口说明：_\n- 4369 (epmd), 25672 (Erlang distribution)\n- 5672, 5671 (AMQP 0-9-1 without and with TLS)应用访问端口号 \n- 15672 (if management plugin is enabled)控制台端口号\n- 61613, 61614 (if STOMP is enabled)\n- 1883, 8883 (if MQTT is enabled)   \n    \n    \n","source":"_posts/rabbitmq-install.md","raw":"---\ntitle: rabbitmq快速安装\ndate: 2018-01-02 16:02:01\ncategories: rabbitmq\ntags: rabbitmq-install\n---\n\n本文介绍rabbitmq在各系统平台下的安装……\n\n## 在Centos下的快速安装\n\n一、安装erlang\nsudo yum install erlang\n\n检查是否安装好：\n\n    [root@localhost /]# erl\n    Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n\n二、安装rabbitmq\n\n（1）下载安装包\nwget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\n\n（2）安装\n\n    > rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n    > yum install rabbitmq-server-3.6.0-1.noarch.rpm\n\n（3）启用web管理插件\nrabbitmq-plugins enable rabbitmq_management\n\n三、启动RabbitMQ\nchkconfig rabbitmq-server on  //开机启动设置\nservice rabbitmq-server start\n\n 四、打开对应端口\n        # firewall-cmd --permanent --zone=public --add-port=5672/tcp\n        # firewall-cmd --permanent --zone=public --add-port=15672/tcp\n        # firewall-cmd --reload\n\n五、打开网页\nhttp://119.23.78.160:15672/\n\n## 在Ubuntu下的快速安装\n\n安装最新版，参考网址： \nhttp://www.rabbitmq.com/install-debian.html\n\n注：下面安装的不是最新版本。\n一. 安装对应erlang版本：\nerlang-nox (>= 1:19.3-1) | esl-erlang (>= 1:19.3-1).\n`sudo apt-get install erlang-nox`\n\n二. 安装rabbitMq:\n\n    $ sudo apt-get update\n    $ sudo apt-get install rabbitmq-server\n    \n三. 启用web管理插件：\n\n`sudo rabbitmq-plugins enable rabbitmq_management`  \n\n四. 访问\n打开：http://localhost:15672  \n\n五. 登录（本机）：\n用户：guest\n密码：guest\n\n注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。\n\n## docker安装rabbitMq\n\n参考：https://hub.docker.com/_/rabbitmq?tab=description\n\n执行下面命令安装：\n\n    docker run --hostname myRabbit --restart=always --name my-rabbitmq -v /server/data/rabbitmq:/var/lib/rabbitmq  -e RABBITMQ_DEFAULT_USER=ymu -e RABBITMQ_DEFAULT_PASS=123456 -e RABBITMQ_DEFAULT_VHOST=ymu_vhost  -p 15672:15672 -p 4369:4369 -p 5671-5672:5671-5672 -p 15671:15671 -p 25672:25672 -d rabbitmq:3.7.8-management\n    \n安装成功后，在浏览器输入：\n\nhttp://ip:15672，进入控制台。  \n\n账号：ymu\n密码：123456\n    \n_参数说明：_ \n\n- -e 指定环境变量；（RABBITMQ_DEFAULT_VHOST：默认虚拟机名；RABBITMQ_DEFAULT_USER：默认的用户名；RABBITMQ_DEFAULT_PASS：默认用户名的密码）\n- --hostname  主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；  \n\n_端口说明：_\n- 4369 (epmd), 25672 (Erlang distribution)\n- 5672, 5671 (AMQP 0-9-1 without and with TLS)应用访问端口号 \n- 15672 (if management plugin is enabled)控制台端口号\n- 61613, 61614 (if STOMP is enabled)\n- 1883, 8883 (if MQTT is enabled)   \n    \n    \n","slug":"rabbitmq-install","published":1,"updated":"2019-06-16T14:38:33.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqee008qg4va6el1zwqe","content":"<p>本文介绍rabbitmq在各系统平台下的安装……</p>\n<h2 id=\"在Centos下的快速安装\"><a href=\"#在Centos下的快速安装\" class=\"headerlink\" title=\"在Centos下的快速安装\"></a>在Centos下的快速安装</h2><p>一、安装erlang<br>sudo yum install erlang</p>\n<p>检查是否安装好：</p>\n<pre><code>[root@localhost /]# erl\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n</code></pre><p>二、安装rabbitmq</p>\n<p>（1）下载安装包<br>wget <a href=\"http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm</a></p>\n<p>（2）安装</p>\n<pre><code>&gt; rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n&gt; yum install rabbitmq-server-3.6.0-1.noarch.rpm\n</code></pre><p>（3）启用web管理插件<br>rabbitmq-plugins enable rabbitmq_management</p>\n<p>三、启动RabbitMQ<br>chkconfig rabbitmq-server on  //开机启动设置<br>service rabbitmq-server start</p>\n<p> 四、打开对应端口</p>\n<pre><code># firewall-cmd --permanent --zone=public --add-port=5672/tcp\n# firewall-cmd --permanent --zone=public --add-port=15672/tcp\n# firewall-cmd --reload\n</code></pre><p>五、打开网页<br><a href=\"http://119.23.78.160:15672/\" target=\"_blank\" rel=\"noopener\">http://119.23.78.160:15672/</a></p>\n<h2 id=\"在Ubuntu下的快速安装\"><a href=\"#在Ubuntu下的快速安装\" class=\"headerlink\" title=\"在Ubuntu下的快速安装\"></a>在Ubuntu下的快速安装</h2><p>安装最新版，参考网址：<br><a href=\"http://www.rabbitmq.com/install-debian.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/install-debian.html</a></p>\n<p>注：下面安装的不是最新版本。<br>一. 安装对应erlang版本：<br>erlang-nox (&gt;= 1:19.3-1) | esl-erlang (&gt;= 1:19.3-1).<br><code>sudo apt-get install erlang-nox</code></p>\n<p>二. 安装rabbitMq:</p>\n<pre><code>$ sudo apt-get update\n$ sudo apt-get install rabbitmq-server\n</code></pre><p>三. 启用web管理插件：</p>\n<p><code>sudo rabbitmq-plugins enable rabbitmq_management</code>  </p>\n<p>四. 访问<br>打开：<a href=\"http://localhost:15672\" target=\"_blank\" rel=\"noopener\">http://localhost:15672</a>  </p>\n<p>五. 登录（本机）：<br>用户：guest<br>密码：guest</p>\n<p>注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。</p>\n<h2 id=\"docker安装rabbitMq\"><a href=\"#docker安装rabbitMq\" class=\"headerlink\" title=\"docker安装rabbitMq\"></a>docker安装rabbitMq</h2><p>参考：<a href=\"https://hub.docker.com/_/rabbitmq?tab=description\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/rabbitmq?tab=description</a></p>\n<p>执行下面命令安装：</p>\n<pre><code>docker run --hostname myRabbit --restart=always --name my-rabbitmq -v /server/data/rabbitmq:/var/lib/rabbitmq  -e RABBITMQ_DEFAULT_USER=ymu -e RABBITMQ_DEFAULT_PASS=123456 -e RABBITMQ_DEFAULT_VHOST=ymu_vhost  -p 15672:15672 -p 4369:4369 -p 5671-5672:5671-5672 -p 15671:15671 -p 25672:25672 -d rabbitmq:3.7.8-management\n</code></pre><p>安装成功后，在浏览器输入：</p>\n<p><a href=\"http://ip:15672，进入控制台。\" target=\"_blank\" rel=\"noopener\">http://ip:15672，进入控制台。</a>  </p>\n<p>账号：ymu<br>密码：123456</p>\n<p><em>参数说明：</em> </p>\n<ul>\n<li>-e 指定环境变量；（RABBITMQ_DEFAULT_VHOST：默认虚拟机名；RABBITMQ_DEFAULT_USER：默认的用户名；RABBITMQ_DEFAULT_PASS：默认用户名的密码）</li>\n<li>–hostname  主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；  </li>\n</ul>\n<p><em>端口说明：</em></p>\n<ul>\n<li>4369 (epmd), 25672 (Erlang distribution)</li>\n<li>5672, 5671 (AMQP 0-9-1 without and with TLS)应用访问端口号 </li>\n<li>15672 (if management plugin is enabled)控制台端口号</li>\n<li>61613, 61614 (if STOMP is enabled)</li>\n<li>1883, 8883 (if MQTT is enabled)   </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍rabbitmq在各系统平台下的安装……</p>\n<h2 id=\"在Centos下的快速安装\"><a href=\"#在Centos下的快速安装\" class=\"headerlink\" title=\"在Centos下的快速安装\"></a>在Centos下的快速安装</h2><p>一、安装erlang<br>sudo yum install erlang</p>\n<p>检查是否安装好：</p>\n<pre><code>[root@localhost /]# erl\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n</code></pre><p>二、安装rabbitmq</p>\n<p>（1）下载安装包<br>wget <a href=\"http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm</a></p>\n<p>（2）安装</p>\n<pre><code>&gt; rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n&gt; yum install rabbitmq-server-3.6.0-1.noarch.rpm\n</code></pre><p>（3）启用web管理插件<br>rabbitmq-plugins enable rabbitmq_management</p>\n<p>三、启动RabbitMQ<br>chkconfig rabbitmq-server on  //开机启动设置<br>service rabbitmq-server start</p>\n<p> 四、打开对应端口</p>\n<pre><code># firewall-cmd --permanent --zone=public --add-port=5672/tcp\n# firewall-cmd --permanent --zone=public --add-port=15672/tcp\n# firewall-cmd --reload\n</code></pre><p>五、打开网页<br><a href=\"http://119.23.78.160:15672/\" target=\"_blank\" rel=\"noopener\">http://119.23.78.160:15672/</a></p>\n<h2 id=\"在Ubuntu下的快速安装\"><a href=\"#在Ubuntu下的快速安装\" class=\"headerlink\" title=\"在Ubuntu下的快速安装\"></a>在Ubuntu下的快速安装</h2><p>安装最新版，参考网址：<br><a href=\"http://www.rabbitmq.com/install-debian.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/install-debian.html</a></p>\n<p>注：下面安装的不是最新版本。<br>一. 安装对应erlang版本：<br>erlang-nox (&gt;= 1:19.3-1) | esl-erlang (&gt;= 1:19.3-1).<br><code>sudo apt-get install erlang-nox</code></p>\n<p>二. 安装rabbitMq:</p>\n<pre><code>$ sudo apt-get update\n$ sudo apt-get install rabbitmq-server\n</code></pre><p>三. 启用web管理插件：</p>\n<p><code>sudo rabbitmq-plugins enable rabbitmq_management</code>  </p>\n<p>四. 访问<br>打开：<a href=\"http://localhost:15672\" target=\"_blank\" rel=\"noopener\">http://localhost:15672</a>  </p>\n<p>五. 登录（本机）：<br>用户：guest<br>密码：guest</p>\n<p>注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。</p>\n<h2 id=\"docker安装rabbitMq\"><a href=\"#docker安装rabbitMq\" class=\"headerlink\" title=\"docker安装rabbitMq\"></a>docker安装rabbitMq</h2><p>参考：<a href=\"https://hub.docker.com/_/rabbitmq?tab=description\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/rabbitmq?tab=description</a></p>\n<p>执行下面命令安装：</p>\n<pre><code>docker run --hostname myRabbit --restart=always --name my-rabbitmq -v /server/data/rabbitmq:/var/lib/rabbitmq  -e RABBITMQ_DEFAULT_USER=ymu -e RABBITMQ_DEFAULT_PASS=123456 -e RABBITMQ_DEFAULT_VHOST=ymu_vhost  -p 15672:15672 -p 4369:4369 -p 5671-5672:5671-5672 -p 15671:15671 -p 25672:25672 -d rabbitmq:3.7.8-management\n</code></pre><p>安装成功后，在浏览器输入：</p>\n<p><a href=\"http://ip:15672，进入控制台。\" target=\"_blank\" rel=\"noopener\">http://ip:15672，进入控制台。</a>  </p>\n<p>账号：ymu<br>密码：123456</p>\n<p><em>参数说明：</em> </p>\n<ul>\n<li>-e 指定环境变量；（RABBITMQ_DEFAULT_VHOST：默认虚拟机名；RABBITMQ_DEFAULT_USER：默认的用户名；RABBITMQ_DEFAULT_PASS：默认用户名的密码）</li>\n<li>–hostname  主机名（RabbitMQ的一个重要注意事项是它根据所谓的 “节点名称” 存储数据，默认为主机名）；  </li>\n</ul>\n<p><em>端口说明：</em></p>\n<ul>\n<li>4369 (epmd), 25672 (Erlang distribution)</li>\n<li>5672, 5671 (AMQP 0-9-1 without and with TLS)应用访问端口号 </li>\n<li>15672 (if management plugin is enabled)控制台端口号</li>\n<li>61613, 61614 (if STOMP is enabled)</li>\n<li>1883, 8883 (if MQTT is enabled)   </li>\n</ul>\n"},{"title":"RabbitMQ学习-消息类型","date":"2020-04-11T16:34:52.000Z","_content":"\n本文介绍消息类型，共用六种消息类型……\n\n## 基本消息模型\n\n{%asset_img b-1.png%}\n\n上图中：\n\n- P： 生产者，发送消息的程序。   \n- C： 消费者，消息的接收者，会一直等待消息的到来，并消费。\n- queue： 消息队列，上图红色部分，一般存在内存，也可以持久化到磁盘。存储消息的媒介，生产者投递消息过来，消费者从中获取。\n\n_例子_：\n\n略……\n\n#### 消息确认机制（ACK）\n\n上面的案例中，消息一旦被消费者消费，队列中的消息就会被删除。\n\n那么问题是，RabbitMQ是怎么知道消息已经被接收了的呢？\n\n如果消费者接收到消息后，还没来得及处理就宕机了或者程序抛出异常，消息消费失败，RabbitMQ服务器无从知道，这样消息就丢失了。\n\n因此，RabbitMQ有个ACK机制。当消费之接收到消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。\n\nACK有两种方式：\n\n1.自动ACK：消息一旦被接收，消费者自动发送ACK。         \n2.手动ACK: 消息被接收后，消费者不自动发送ACK，要程序手动发送ACK。\n\n以上两种方式的选择：\n\n- 如果消息不那么重要，允许消息丢失的情况，那么就选择自动发送ACK方便些。\n- 如果消息非常重要，不允许丢失的情况，那么就要在正确的处理好接收的消息后，再手动发送ACK告知RabbitMQ。否则，消息可能丢失。\n\n_示例：_\n\n略……\n\n生产者避免数据丢失：https://www.cnblogs.com/vipstone/p/9350075.html\n\n\n##  work消息模型\n\n\n工作队列或者竞争消费者模式。\n\n{%asset_img b-2.png%}\n\n该模式与上面的入门模式相比，多了个消费者，两个消费者共同消费同一个队列中的消息，但是一个消息只能被一个消费者消费。\n\n这个消息模式在web应用中特别有用，在复杂http请求中，可以开启多个消费者，相当于开启多个任务处理处理消息，提高响应速度。\n\n>消息分配给消费的方式有两种：\n>- 一种是平均的分给每个消费者。哪怕一个消费者很忙，一个很空闲，但是最终，各个消费者消费的消息条数一样。\n>- 另外一种方式就是，能者多劳。消费的越快的消费者，消费更多的消息。这种模式下，手动ack的情况下才生效，自动ack不生效。\n\n\n##  Publish/subscribe（交换机类型：Fanout，也称为广播 ）\n\n{%asset_img b-3.png%}\n\n说民：\n\n1.一个生产者，多个消费者。      \n2.每个消费者都有自己的一个队列。       \n3.生产者没有将消息直接发送给队列，而是发送给exchange(交换机、转发器)。   \n4.每个队列都需要绑定到交换机上。       \n5.生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者消费\n\n例子：注册->发邮件、发短信\n\nX（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。\n\nExchange类型有以下几种：\n\nFanout：广播，将消息交给所有绑定到交换机的队列\n\nDirect：定向，把消息交给符合指定routing key 的队列\n\nTopic：通配符，把消息交给符合routing pattern（路由模式） 的队列\n\nHeader：header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。\n\nExchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！\n\n_示例：_\n\n略……\n\n_思考：_\n\n1、publish/subscribe与work queues有什么区别。\n\n区别：\n\n1）work queues不用定义交换机，而publish/subscribe需要定义交换机。\n\n2）publish/subscribe的生产方是面向交换机发送消息，work queues的生产方是面向队列发送消息(底层使用默认交换机)。\n\n3）publish/subscribe需要设置队列和交换机的绑定，work queues不需要设置，实际上work queues会将队列绑定到默认的交换机 。\n\n相同点：\n\n所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。\n\n2、实际工作用 publish/subscribe还是work queues。\n\n建议使用 publish/subscribe，发布订阅模式比工作队列模式更强大（也可以做到同一队列竞争），并且发布订阅模式可以指定自己专用的交换机。\n\n##  Routing 路由模型（交换机类型：direct）\n\n{%asset_img b-4.png%}\n\n_P_：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。\n\n_X_：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列\n\n_C1_：消费者，其所在队列指定了需要routing key 为 error 的消息\n\n_C2_：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息\n\n\n例子：\n\n发送者sender：\n\n    public class Send {\n        private final static String EXCHANGE_NAME = \"test_direct_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明exchange，指定类型为direct\n            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n            // 消息内容，\n            String message = \"注册成功！请短信回复[T]退订\";\n            // 发送消息，并且指定routing key 为：sms，只有短信服务能接收到消息\n            channel.basicPublish(EXCHANGE_NAME, \"sms\", null, message.getBytes());\n            System.out.println(\" [x] Sent '\" + message + \"'\");\n     \n            channel.close();\n            connection.close();\n        }\n    }\n    \n消费者1：\n  \n    public class Recv {\n        private final static String QUEUE_NAME = \"direct_exchange_queue_sms\";//短信队列\n        private final static String EXCHANGE_NAME = \"test_direct_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明队列\n            channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n            \n            // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"sms\");//指定接收发送方指定routing key为sms的消息\n            //channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"email\");\n     \n            // 定义队列的消费者\n            DefaultConsumer consumer = new DefaultConsumer(channel) {\n                // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n                @Override\n                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                           byte[] body) throws IOException {\n                    // body 即消息体\n                    String msg = new String(body);\n                    System.out.println(\" [短信服务] received : \" + msg + \"!\");\n                }\n            };\n            // 监听队列，自动ACK\n            channel.basicConsume(QUEUE_NAME, true, consumer);\n        }\n    }    \n    \n消费者2：\n  \n    public class Recv2 {\n        private final static String QUEUE_NAME = \"direct_exchange_queue_email\";//邮件队列\n        private final static String EXCHANGE_NAME = \"test_direct_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明队列\n            channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n            \n            // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"email\");//指定接收发送方指定routing key为email的消息\n     \n            // 定义队列的消费者\n            DefaultConsumer consumer = new DefaultConsumer(channel) {\n                // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n                @Override\n                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                           byte[] body) throws IOException {\n                    // body 即消息体\n                    String msg = new String(body);\n                    System.out.println(\" [邮件服务] received : \" + msg + \"!\");\n                }\n            };\n            // 监听队列，自动ACK\n            channel.basicConsume(QUEUE_NAME, true, consumer);\n        }\n    }  \n\n我们发送sms的RoutingKey，发现结果：只有指定短信的消费者1收到消息了。\n\n##  Topics 通配符模式（交换机类型：topics）\n\n 每个消费者监听自己的队列，并且设置带统配符的routingkey,生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。\n\nRoutingkey一般都是有一个或者多个单词组成，多个单词之间以“.”分割，例如：inform.sms\n\n通配符规则：\n\n`#`：匹配一个或多个词\n\n`*`：匹配不多不少恰好1个词\n\n举例：\n\naudit.#：能够匹配audit.irs.corporate 或者 audit.irs\n\naudit.*：只能匹配audit.irs\n\n从示意图可知，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的Routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。\n\n我们创建了三个绑定：Q1绑定了“*.orange.*”，Q2绑定了“.*.*.rabbit”和“lazy.＃”。\n\nQ1匹配所有的橙色动物。\n\nQ2匹配关于兔子以及懒惰动物的消息。\n\n 下面做个小练习，假如生产者发送如下消息，会进入哪个队列：\n\nquick.orange.rabbit       Q1 Q2   routingKey=\"quick.orange.rabbit\"的消息会同时路由到Q1与Q2\n\nlazy.orange.elephant    Q1 Q2\n\nquick.orange.fox           Q1\n\nlazy.pink.rabbit              Q2  (值得注意的是，虽然这个routingKey与Q2的两个bindingKey都匹配，但是只会投递Q2一次)\n\nquick.brown.fox            不匹配任意队列，被丢弃\n\nquick.orange.male.rabbit   不匹配任意队列，被丢弃\n\norange         不匹配任意队列，被丢弃\n\n下面我们以指定Routing key=\"quick.orange.rabbit\"为例，验证上面的答案\n\n生产者：\n\n    public class Send {\n        private final static String EXCHANGE_NAME = \"test_topic_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明exchange，指定类型为topic\n            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n            // 消息内容\n            String message = \"这是一只行动迅速的橙色的兔子\";\n            // 发送消息，并且指定routing key为：quick.orange.rabbit\n            channel.basicPublish(EXCHANGE_NAME, \"quick.orange.rabbit\", null, message.getBytes());\n            System.out.println(\" [动物描述：] Sent '\" + message + \"'\");\n     \n            channel.close();\n            connection.close();\n        }\n    }\n\n消费者1：\n\n    public class Recv {\n        private final static String QUEUE_NAME = \"topic_exchange_queue_Q1\";\n        private final static String EXCHANGE_NAME = \"test_topic_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明队列\n            channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n            \n            // 绑定队列到交换机，同时指定需要订阅的routing key。订阅所有的橙色动物\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"*.orange.*\");\n     \n            // 定义队列的消费者\n            DefaultConsumer consumer = new DefaultConsumer(channel) {\n                // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n                @Override\n                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                           byte[] body) throws IOException {\n                    // body 即消息体\n                    String msg = new String(body);\n                    System.out.println(\" [消费者1] received : \" + msg + \"!\");\n                }\n            };\n            // 监听队列，自动ACK\n            channel.basicConsume(QUEUE_NAME, true, consumer);\n        }\n    }\n    \n消费者2：\n\n    public class Recv2 {\n        private final static String QUEUE_NAME = \"topic_exchange_queue_Q2\";\n        private final static String EXCHANGE_NAME = \"test_topic_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明队列\n            channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n            \n            // 绑定队列到交换机，同时指定需要订阅的routing key。订阅关于兔子以及懒惰动物的消息\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"*.*.rabbit\");\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"lazy.＃\");\n     \n            // 定义队列的消费者\n            DefaultConsumer consumer = new DefaultConsumer(channel) {\n                // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n                @Override\n                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                           byte[] body) throws IOException {\n                    // body 即消息体\n                    String msg = new String(body);\n                    System.out.println(\" [消费者2] received : \" + msg + \"!\");\n                }\n            };\n            // 监听队列，自动ACK\n            channel.basicConsume(QUEUE_NAME, true, consumer);\n        }\n    }\n    \n结果C1、C2是都接收到消息了。\n\n## RPC\n\n{%asset_img b-6.png%}\n\n基本概念：\n\nCallback queue 回调队列，客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址reply_to。\n\nCorrelation id 关联标识，客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有correlation_id属性，这样客户端在回调队列中根据correlation_id字段的值就可以分辨此响应属于哪个请求。\n\n流程说明：\n\n当客户端启动的时候，它创建一个匿名独享的回调队列。\n在 RPC 请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性。\n将请求发送到一个 rpc_queue 队列中。\n服务器等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。\n客户端等待回调队列里的数据。当有消息出现的时候，它会检查 correlation_id 属性。如果此属性的值与请求匹配，将它返回给应用\n\n    \n\n\n\n\n","source":"_posts/rabbitmq-messages.md","raw":"---\ntitle: RabbitMQ学习-消息类型\ndate: 2020-04-12 00:34:52\ncategories: rabbitmq\ntags:\n---\n\n本文介绍消息类型，共用六种消息类型……\n\n## 基本消息模型\n\n{%asset_img b-1.png%}\n\n上图中：\n\n- P： 生产者，发送消息的程序。   \n- C： 消费者，消息的接收者，会一直等待消息的到来，并消费。\n- queue： 消息队列，上图红色部分，一般存在内存，也可以持久化到磁盘。存储消息的媒介，生产者投递消息过来，消费者从中获取。\n\n_例子_：\n\n略……\n\n#### 消息确认机制（ACK）\n\n上面的案例中，消息一旦被消费者消费，队列中的消息就会被删除。\n\n那么问题是，RabbitMQ是怎么知道消息已经被接收了的呢？\n\n如果消费者接收到消息后，还没来得及处理就宕机了或者程序抛出异常，消息消费失败，RabbitMQ服务器无从知道，这样消息就丢失了。\n\n因此，RabbitMQ有个ACK机制。当消费之接收到消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。\n\nACK有两种方式：\n\n1.自动ACK：消息一旦被接收，消费者自动发送ACK。         \n2.手动ACK: 消息被接收后，消费者不自动发送ACK，要程序手动发送ACK。\n\n以上两种方式的选择：\n\n- 如果消息不那么重要，允许消息丢失的情况，那么就选择自动发送ACK方便些。\n- 如果消息非常重要，不允许丢失的情况，那么就要在正确的处理好接收的消息后，再手动发送ACK告知RabbitMQ。否则，消息可能丢失。\n\n_示例：_\n\n略……\n\n生产者避免数据丢失：https://www.cnblogs.com/vipstone/p/9350075.html\n\n\n##  work消息模型\n\n\n工作队列或者竞争消费者模式。\n\n{%asset_img b-2.png%}\n\n该模式与上面的入门模式相比，多了个消费者，两个消费者共同消费同一个队列中的消息，但是一个消息只能被一个消费者消费。\n\n这个消息模式在web应用中特别有用，在复杂http请求中，可以开启多个消费者，相当于开启多个任务处理处理消息，提高响应速度。\n\n>消息分配给消费的方式有两种：\n>- 一种是平均的分给每个消费者。哪怕一个消费者很忙，一个很空闲，但是最终，各个消费者消费的消息条数一样。\n>- 另外一种方式就是，能者多劳。消费的越快的消费者，消费更多的消息。这种模式下，手动ack的情况下才生效，自动ack不生效。\n\n\n##  Publish/subscribe（交换机类型：Fanout，也称为广播 ）\n\n{%asset_img b-3.png%}\n\n说民：\n\n1.一个生产者，多个消费者。      \n2.每个消费者都有自己的一个队列。       \n3.生产者没有将消息直接发送给队列，而是发送给exchange(交换机、转发器)。   \n4.每个队列都需要绑定到交换机上。       \n5.生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者消费\n\n例子：注册->发邮件、发短信\n\nX（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。\n\nExchange类型有以下几种：\n\nFanout：广播，将消息交给所有绑定到交换机的队列\n\nDirect：定向，把消息交给符合指定routing key 的队列\n\nTopic：通配符，把消息交给符合routing pattern（路由模式） 的队列\n\nHeader：header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。\n\nExchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！\n\n_示例：_\n\n略……\n\n_思考：_\n\n1、publish/subscribe与work queues有什么区别。\n\n区别：\n\n1）work queues不用定义交换机，而publish/subscribe需要定义交换机。\n\n2）publish/subscribe的生产方是面向交换机发送消息，work queues的生产方是面向队列发送消息(底层使用默认交换机)。\n\n3）publish/subscribe需要设置队列和交换机的绑定，work queues不需要设置，实际上work queues会将队列绑定到默认的交换机 。\n\n相同点：\n\n所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。\n\n2、实际工作用 publish/subscribe还是work queues。\n\n建议使用 publish/subscribe，发布订阅模式比工作队列模式更强大（也可以做到同一队列竞争），并且发布订阅模式可以指定自己专用的交换机。\n\n##  Routing 路由模型（交换机类型：direct）\n\n{%asset_img b-4.png%}\n\n_P_：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。\n\n_X_：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列\n\n_C1_：消费者，其所在队列指定了需要routing key 为 error 的消息\n\n_C2_：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息\n\n\n例子：\n\n发送者sender：\n\n    public class Send {\n        private final static String EXCHANGE_NAME = \"test_direct_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明exchange，指定类型为direct\n            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n            // 消息内容，\n            String message = \"注册成功！请短信回复[T]退订\";\n            // 发送消息，并且指定routing key 为：sms，只有短信服务能接收到消息\n            channel.basicPublish(EXCHANGE_NAME, \"sms\", null, message.getBytes());\n            System.out.println(\" [x] Sent '\" + message + \"'\");\n     \n            channel.close();\n            connection.close();\n        }\n    }\n    \n消费者1：\n  \n    public class Recv {\n        private final static String QUEUE_NAME = \"direct_exchange_queue_sms\";//短信队列\n        private final static String EXCHANGE_NAME = \"test_direct_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明队列\n            channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n            \n            // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"sms\");//指定接收发送方指定routing key为sms的消息\n            //channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"email\");\n     \n            // 定义队列的消费者\n            DefaultConsumer consumer = new DefaultConsumer(channel) {\n                // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n                @Override\n                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                           byte[] body) throws IOException {\n                    // body 即消息体\n                    String msg = new String(body);\n                    System.out.println(\" [短信服务] received : \" + msg + \"!\");\n                }\n            };\n            // 监听队列，自动ACK\n            channel.basicConsume(QUEUE_NAME, true, consumer);\n        }\n    }    \n    \n消费者2：\n  \n    public class Recv2 {\n        private final static String QUEUE_NAME = \"direct_exchange_queue_email\";//邮件队列\n        private final static String EXCHANGE_NAME = \"test_direct_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明队列\n            channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n            \n            // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"email\");//指定接收发送方指定routing key为email的消息\n     \n            // 定义队列的消费者\n            DefaultConsumer consumer = new DefaultConsumer(channel) {\n                // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n                @Override\n                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                           byte[] body) throws IOException {\n                    // body 即消息体\n                    String msg = new String(body);\n                    System.out.println(\" [邮件服务] received : \" + msg + \"!\");\n                }\n            };\n            // 监听队列，自动ACK\n            channel.basicConsume(QUEUE_NAME, true, consumer);\n        }\n    }  \n\n我们发送sms的RoutingKey，发现结果：只有指定短信的消费者1收到消息了。\n\n##  Topics 通配符模式（交换机类型：topics）\n\n 每个消费者监听自己的队列，并且设置带统配符的routingkey,生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。\n\nRoutingkey一般都是有一个或者多个单词组成，多个单词之间以“.”分割，例如：inform.sms\n\n通配符规则：\n\n`#`：匹配一个或多个词\n\n`*`：匹配不多不少恰好1个词\n\n举例：\n\naudit.#：能够匹配audit.irs.corporate 或者 audit.irs\n\naudit.*：只能匹配audit.irs\n\n从示意图可知，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的Routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。\n\n我们创建了三个绑定：Q1绑定了“*.orange.*”，Q2绑定了“.*.*.rabbit”和“lazy.＃”。\n\nQ1匹配所有的橙色动物。\n\nQ2匹配关于兔子以及懒惰动物的消息。\n\n 下面做个小练习，假如生产者发送如下消息，会进入哪个队列：\n\nquick.orange.rabbit       Q1 Q2   routingKey=\"quick.orange.rabbit\"的消息会同时路由到Q1与Q2\n\nlazy.orange.elephant    Q1 Q2\n\nquick.orange.fox           Q1\n\nlazy.pink.rabbit              Q2  (值得注意的是，虽然这个routingKey与Q2的两个bindingKey都匹配，但是只会投递Q2一次)\n\nquick.brown.fox            不匹配任意队列，被丢弃\n\nquick.orange.male.rabbit   不匹配任意队列，被丢弃\n\norange         不匹配任意队列，被丢弃\n\n下面我们以指定Routing key=\"quick.orange.rabbit\"为例，验证上面的答案\n\n生产者：\n\n    public class Send {\n        private final static String EXCHANGE_NAME = \"test_topic_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明exchange，指定类型为topic\n            channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n            // 消息内容\n            String message = \"这是一只行动迅速的橙色的兔子\";\n            // 发送消息，并且指定routing key为：quick.orange.rabbit\n            channel.basicPublish(EXCHANGE_NAME, \"quick.orange.rabbit\", null, message.getBytes());\n            System.out.println(\" [动物描述：] Sent '\" + message + \"'\");\n     \n            channel.close();\n            connection.close();\n        }\n    }\n\n消费者1：\n\n    public class Recv {\n        private final static String QUEUE_NAME = \"topic_exchange_queue_Q1\";\n        private final static String EXCHANGE_NAME = \"test_topic_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明队列\n            channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n            \n            // 绑定队列到交换机，同时指定需要订阅的routing key。订阅所有的橙色动物\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"*.orange.*\");\n     \n            // 定义队列的消费者\n            DefaultConsumer consumer = new DefaultConsumer(channel) {\n                // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n                @Override\n                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                           byte[] body) throws IOException {\n                    // body 即消息体\n                    String msg = new String(body);\n                    System.out.println(\" [消费者1] received : \" + msg + \"!\");\n                }\n            };\n            // 监听队列，自动ACK\n            channel.basicConsume(QUEUE_NAME, true, consumer);\n        }\n    }\n    \n消费者2：\n\n    public class Recv2 {\n        private final static String QUEUE_NAME = \"topic_exchange_queue_Q2\";\n        private final static String EXCHANGE_NAME = \"test_topic_exchange\";\n     \n        public static void main(String[] argv) throws Exception {\n            // 获取到连接\n            Connection connection = ConnectionUtil.getConnection();\n            // 获取通道\n            Channel channel = connection.createChannel();\n            // 声明队列\n            channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n            \n            // 绑定队列到交换机，同时指定需要订阅的routing key。订阅关于兔子以及懒惰动物的消息\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"*.*.rabbit\");\n            channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, \"lazy.＃\");\n     \n            // 定义队列的消费者\n            DefaultConsumer consumer = new DefaultConsumer(channel) {\n                // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n                @Override\n                public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                           byte[] body) throws IOException {\n                    // body 即消息体\n                    String msg = new String(body);\n                    System.out.println(\" [消费者2] received : \" + msg + \"!\");\n                }\n            };\n            // 监听队列，自动ACK\n            channel.basicConsume(QUEUE_NAME, true, consumer);\n        }\n    }\n    \n结果C1、C2是都接收到消息了。\n\n## RPC\n\n{%asset_img b-6.png%}\n\n基本概念：\n\nCallback queue 回调队列，客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址reply_to。\n\nCorrelation id 关联标识，客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有correlation_id属性，这样客户端在回调队列中根据correlation_id字段的值就可以分辨此响应属于哪个请求。\n\n流程说明：\n\n当客户端启动的时候，它创建一个匿名独享的回调队列。\n在 RPC 请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性。\n将请求发送到一个 rpc_queue 队列中。\n服务器等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。\n客户端等待回调队列里的数据。当有消息出现的时候，它会检查 correlation_id 属性。如果此属性的值与请求匹配，将它返回给应用\n\n    \n\n\n\n\n","slug":"rabbitmq-messages","published":1,"updated":"2020-05-30T11:28:23.376Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqef008rg4vaohamr8op","content":"<p>本文介绍消息类型，共用六种消息类型……</p>\n<h2 id=\"基本消息模型\"><a href=\"#基本消息模型\" class=\"headerlink\" title=\"基本消息模型\"></a>基本消息模型</h2><img src=\"/2020/04/12/rabbitmq-messages/b-1.png\">\n<p>上图中：</p>\n<ul>\n<li>P： 生产者，发送消息的程序。   </li>\n<li>C： 消费者，消息的接收者，会一直等待消息的到来，并消费。</li>\n<li>queue： 消息队列，上图红色部分，一般存在内存，也可以持久化到磁盘。存储消息的媒介，生产者投递消息过来，消费者从中获取。</li>\n</ul>\n<p>_例子_：</p>\n<p>略……</p>\n<h4 id=\"消息确认机制（ACK）\"><a href=\"#消息确认机制（ACK）\" class=\"headerlink\" title=\"消息确认机制（ACK）\"></a>消息确认机制（ACK）</h4><p>上面的案例中，消息一旦被消费者消费，队列中的消息就会被删除。</p>\n<p>那么问题是，RabbitMQ是怎么知道消息已经被接收了的呢？</p>\n<p>如果消费者接收到消息后，还没来得及处理就宕机了或者程序抛出异常，消息消费失败，RabbitMQ服务器无从知道，这样消息就丢失了。</p>\n<p>因此，RabbitMQ有个ACK机制。当消费之接收到消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。</p>\n<p>ACK有两种方式：</p>\n<p>1.自动ACK：消息一旦被接收，消费者自动发送ACK。<br>2.手动ACK: 消息被接收后，消费者不自动发送ACK，要程序手动发送ACK。</p>\n<p>以上两种方式的选择：</p>\n<ul>\n<li>如果消息不那么重要，允许消息丢失的情况，那么就选择自动发送ACK方便些。</li>\n<li>如果消息非常重要，不允许丢失的情况，那么就要在正确的处理好接收的消息后，再手动发送ACK告知RabbitMQ。否则，消息可能丢失。</li>\n</ul>\n<p><em>示例：</em></p>\n<p>略……</p>\n<p>生产者避免数据丢失：<a href=\"https://www.cnblogs.com/vipstone/p/9350075.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/vipstone/p/9350075.html</a></p>\n<h2 id=\"work消息模型\"><a href=\"#work消息模型\" class=\"headerlink\" title=\"work消息模型\"></a>work消息模型</h2><p>工作队列或者竞争消费者模式。</p>\n<img src=\"/2020/04/12/rabbitmq-messages/b-2.png\">\n<p>该模式与上面的入门模式相比，多了个消费者，两个消费者共同消费同一个队列中的消息，但是一个消息只能被一个消费者消费。</p>\n<p>这个消息模式在web应用中特别有用，在复杂http请求中，可以开启多个消费者，相当于开启多个任务处理处理消息，提高响应速度。</p>\n<blockquote>\n<p>消息分配给消费的方式有两种：</p>\n<ul>\n<li>一种是平均的分给每个消费者。哪怕一个消费者很忙，一个很空闲，但是最终，各个消费者消费的消息条数一样。</li>\n<li>另外一种方式就是，能者多劳。消费的越快的消费者，消费更多的消息。这种模式下，手动ack的情况下才生效，自动ack不生效。</li>\n</ul>\n</blockquote>\n<h2 id=\"Publish-subscribe（交换机类型：Fanout，也称为广播-）\"><a href=\"#Publish-subscribe（交换机类型：Fanout，也称为广播-）\" class=\"headerlink\" title=\"Publish/subscribe（交换机类型：Fanout，也称为广播 ）\"></a>Publish/subscribe（交换机类型：Fanout，也称为广播 ）</h2><img src=\"/2020/04/12/rabbitmq-messages/b-3.png\">\n<p>说民：</p>\n<p>1.一个生产者，多个消费者。<br>2.每个消费者都有自己的一个队列。<br>3.生产者没有将消息直接发送给队列，而是发送给exchange(交换机、转发器)。<br>4.每个队列都需要绑定到交换机上。<br>5.生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者消费</p>\n<p>例子：注册-&gt;发邮件、发短信</p>\n<p>X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p>\n<p>Exchange类型有以下几种：</p>\n<p>Fanout：广播，将消息交给所有绑定到交换机的队列</p>\n<p>Direct：定向，把消息交给符合指定routing key 的队列</p>\n<p>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</p>\n<p>Header：header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。</p>\n<p>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>\n<p><em>示例：</em></p>\n<p>略……</p>\n<p><em>思考：</em></p>\n<p>1、publish/subscribe与work queues有什么区别。</p>\n<p>区别：</p>\n<p>1）work queues不用定义交换机，而publish/subscribe需要定义交换机。</p>\n<p>2）publish/subscribe的生产方是面向交换机发送消息，work queues的生产方是面向队列发送消息(底层使用默认交换机)。</p>\n<p>3）publish/subscribe需要设置队列和交换机的绑定，work queues不需要设置，实际上work queues会将队列绑定到默认的交换机 。</p>\n<p>相同点：</p>\n<p>所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。</p>\n<p>2、实际工作用 publish/subscribe还是work queues。</p>\n<p>建议使用 publish/subscribe，发布订阅模式比工作队列模式更强大（也可以做到同一队列竞争），并且发布订阅模式可以指定自己专用的交换机。</p>\n<h2 id=\"Routing-路由模型（交换机类型：direct）\"><a href=\"#Routing-路由模型（交换机类型：direct）\" class=\"headerlink\" title=\"Routing 路由模型（交换机类型：direct）\"></a>Routing 路由模型（交换机类型：direct）</h2><img src=\"/2020/04/12/rabbitmq-messages/b-4.png\">\n<p>_P_：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p>\n<p>_X_：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p>\n<p>_C1_：消费者，其所在队列指定了需要routing key 为 error 的消息</p>\n<p>_C2_：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p>\n<p>例子：</p>\n<p>发送者sender：</p>\n<pre><code>public class Send {\n    private final static String EXCHANGE_NAME = &quot;test_direct_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明exchange，指定类型为direct\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n        // 消息内容，\n        String message = &quot;注册成功！请短信回复[T]退订&quot;;\n        // 发送消息，并且指定routing key 为：sms，只有短信服务能接收到消息\n        channel.basicPublish(EXCHANGE_NAME, &quot;sms&quot;, null, message.getBytes());\n        System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);\n\n        channel.close();\n        connection.close();\n    }\n}\n</code></pre><p>消费者1：</p>\n<pre><code>public class Recv {\n    private final static String QUEUE_NAME = &quot;direct_exchange_queue_sms&quot;;//短信队列\n    private final static String EXCHANGE_NAME = &quot;test_direct_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;sms&quot;);//指定接收发送方指定routing key为sms的消息\n        //channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;email&quot;);\n\n        // 定义队列的消费者\n        DefaultConsumer consumer = new DefaultConsumer(channel) {\n            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                       byte[] body) throws IOException {\n                // body 即消息体\n                String msg = new String(body);\n                System.out.println(&quot; [短信服务] received : &quot; + msg + &quot;!&quot;);\n            }\n        };\n        // 监听队列，自动ACK\n        channel.basicConsume(QUEUE_NAME, true, consumer);\n    }\n}    \n</code></pre><p>消费者2：</p>\n<pre><code>public class Recv2 {\n    private final static String QUEUE_NAME = &quot;direct_exchange_queue_email&quot;;//邮件队列\n    private final static String EXCHANGE_NAME = &quot;test_direct_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;email&quot;);//指定接收发送方指定routing key为email的消息\n\n        // 定义队列的消费者\n        DefaultConsumer consumer = new DefaultConsumer(channel) {\n            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                       byte[] body) throws IOException {\n                // body 即消息体\n                String msg = new String(body);\n                System.out.println(&quot; [邮件服务] received : &quot; + msg + &quot;!&quot;);\n            }\n        };\n        // 监听队列，自动ACK\n        channel.basicConsume(QUEUE_NAME, true, consumer);\n    }\n}  \n</code></pre><p>我们发送sms的RoutingKey，发现结果：只有指定短信的消费者1收到消息了。</p>\n<h2 id=\"Topics-通配符模式（交换机类型：topics）\"><a href=\"#Topics-通配符模式（交换机类型：topics）\" class=\"headerlink\" title=\"Topics 通配符模式（交换机类型：topics）\"></a>Topics 通配符模式（交换机类型：topics）</h2><p> 每个消费者监听自己的队列，并且设置带统配符的routingkey,生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。</p>\n<p>Routingkey一般都是有一个或者多个单词组成，多个单词之间以“.”分割，例如：inform.sms</p>\n<p>通配符规则：</p>\n<p><code>#</code>：匹配一个或多个词</p>\n<p><code>*</code>：匹配不多不少恰好1个词</p>\n<p>举例：</p>\n<p>audit.#：能够匹配audit.irs.corporate 或者 audit.irs</p>\n<p>audit.*：只能匹配audit.irs</p>\n<p>从示意图可知，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的Routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</species></color></speed></p>\n<p>我们创建了三个绑定：Q1绑定了“<em>.orange.</em>”，Q2绑定了“.<em>.</em>.rabbit”和“lazy.＃”。</p>\n<p>Q1匹配所有的橙色动物。</p>\n<p>Q2匹配关于兔子以及懒惰动物的消息。</p>\n<p> 下面做个小练习，假如生产者发送如下消息，会进入哪个队列：</p>\n<p>quick.orange.rabbit       Q1 Q2   routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2</p>\n<p>lazy.orange.elephant    Q1 Q2</p>\n<p>quick.orange.fox           Q1</p>\n<p>lazy.pink.rabbit              Q2  (值得注意的是，虽然这个routingKey与Q2的两个bindingKey都匹配，但是只会投递Q2一次)</p>\n<p>quick.brown.fox            不匹配任意队列，被丢弃</p>\n<p>quick.orange.male.rabbit   不匹配任意队列，被丢弃</p>\n<p>orange         不匹配任意队列，被丢弃</p>\n<p>下面我们以指定Routing key=”quick.orange.rabbit”为例，验证上面的答案</p>\n<p>生产者：</p>\n<pre><code>public class Send {\n    private final static String EXCHANGE_NAME = &quot;test_topic_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明exchange，指定类型为topic\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        // 消息内容\n        String message = &quot;这是一只行动迅速的橙色的兔子&quot;;\n        // 发送消息，并且指定routing key为：quick.orange.rabbit\n        channel.basicPublish(EXCHANGE_NAME, &quot;quick.orange.rabbit&quot;, null, message.getBytes());\n        System.out.println(&quot; [动物描述：] Sent &apos;&quot; + message + &quot;&apos;&quot;);\n\n        channel.close();\n        connection.close();\n    }\n}\n</code></pre><p>消费者1：</p>\n<pre><code>public class Recv {\n    private final static String QUEUE_NAME = &quot;topic_exchange_queue_Q1&quot;;\n    private final static String EXCHANGE_NAME = &quot;test_topic_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 绑定队列到交换机，同时指定需要订阅的routing key。订阅所有的橙色动物\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.orange.*&quot;);\n\n        // 定义队列的消费者\n        DefaultConsumer consumer = new DefaultConsumer(channel) {\n            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                       byte[] body) throws IOException {\n                // body 即消息体\n                String msg = new String(body);\n                System.out.println(&quot; [消费者1] received : &quot; + msg + &quot;!&quot;);\n            }\n        };\n        // 监听队列，自动ACK\n        channel.basicConsume(QUEUE_NAME, true, consumer);\n    }\n}\n</code></pre><p>消费者2：</p>\n<pre><code>public class Recv2 {\n    private final static String QUEUE_NAME = &quot;topic_exchange_queue_Q2&quot;;\n    private final static String EXCHANGE_NAME = &quot;test_topic_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 绑定队列到交换机，同时指定需要订阅的routing key。订阅关于兔子以及懒惰动物的消息\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*.rabbit&quot;);\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;lazy.＃&quot;);\n\n        // 定义队列的消费者\n        DefaultConsumer consumer = new DefaultConsumer(channel) {\n            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                       byte[] body) throws IOException {\n                // body 即消息体\n                String msg = new String(body);\n                System.out.println(&quot; [消费者2] received : &quot; + msg + &quot;!&quot;);\n            }\n        };\n        // 监听队列，自动ACK\n        channel.basicConsume(QUEUE_NAME, true, consumer);\n    }\n}\n</code></pre><p>结果C1、C2是都接收到消息了。</p>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2>\n<p>基本概念：</p>\n<p>Callback queue 回调队列，客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址reply_to。</p>\n<p>Correlation id 关联标识，客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有correlation_id属性，这样客户端在回调队列中根据correlation_id字段的值就可以分辨此响应属于哪个请求。</p>\n<p>流程说明：</p>\n<p>当客户端启动的时候，它创建一个匿名独享的回调队列。<br>在 RPC 请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性。<br>将请求发送到一个 rpc_queue 队列中。<br>服务器等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。<br>客户端等待回调队列里的数据。当有消息出现的时候，它会检查 correlation_id 属性。如果此属性的值与请求匹配，将它返回给应用</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍消息类型，共用六种消息类型……</p>\n<h2 id=\"基本消息模型\"><a href=\"#基本消息模型\" class=\"headerlink\" title=\"基本消息模型\"></a>基本消息模型</h2><img src=\"/2020/04/12/rabbitmq-messages/b-1.png\">\n<p>上图中：</p>\n<ul>\n<li>P： 生产者，发送消息的程序。   </li>\n<li>C： 消费者，消息的接收者，会一直等待消息的到来，并消费。</li>\n<li>queue： 消息队列，上图红色部分，一般存在内存，也可以持久化到磁盘。存储消息的媒介，生产者投递消息过来，消费者从中获取。</li>\n</ul>\n<p>_例子_：</p>\n<p>略……</p>\n<h4 id=\"消息确认机制（ACK）\"><a href=\"#消息确认机制（ACK）\" class=\"headerlink\" title=\"消息确认机制（ACK）\"></a>消息确认机制（ACK）</h4><p>上面的案例中，消息一旦被消费者消费，队列中的消息就会被删除。</p>\n<p>那么问题是，RabbitMQ是怎么知道消息已经被接收了的呢？</p>\n<p>如果消费者接收到消息后，还没来得及处理就宕机了或者程序抛出异常，消息消费失败，RabbitMQ服务器无从知道，这样消息就丢失了。</p>\n<p>因此，RabbitMQ有个ACK机制。当消费之接收到消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。</p>\n<p>ACK有两种方式：</p>\n<p>1.自动ACK：消息一旦被接收，消费者自动发送ACK。<br>2.手动ACK: 消息被接收后，消费者不自动发送ACK，要程序手动发送ACK。</p>\n<p>以上两种方式的选择：</p>\n<ul>\n<li>如果消息不那么重要，允许消息丢失的情况，那么就选择自动发送ACK方便些。</li>\n<li>如果消息非常重要，不允许丢失的情况，那么就要在正确的处理好接收的消息后，再手动发送ACK告知RabbitMQ。否则，消息可能丢失。</li>\n</ul>\n<p><em>示例：</em></p>\n<p>略……</p>\n<p>生产者避免数据丢失：<a href=\"https://www.cnblogs.com/vipstone/p/9350075.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/vipstone/p/9350075.html</a></p>\n<h2 id=\"work消息模型\"><a href=\"#work消息模型\" class=\"headerlink\" title=\"work消息模型\"></a>work消息模型</h2><p>工作队列或者竞争消费者模式。</p>\n<img src=\"/2020/04/12/rabbitmq-messages/b-2.png\">\n<p>该模式与上面的入门模式相比，多了个消费者，两个消费者共同消费同一个队列中的消息，但是一个消息只能被一个消费者消费。</p>\n<p>这个消息模式在web应用中特别有用，在复杂http请求中，可以开启多个消费者，相当于开启多个任务处理处理消息，提高响应速度。</p>\n<blockquote>\n<p>消息分配给消费的方式有两种：</p>\n<ul>\n<li>一种是平均的分给每个消费者。哪怕一个消费者很忙，一个很空闲，但是最终，各个消费者消费的消息条数一样。</li>\n<li>另外一种方式就是，能者多劳。消费的越快的消费者，消费更多的消息。这种模式下，手动ack的情况下才生效，自动ack不生效。</li>\n</ul>\n</blockquote>\n<h2 id=\"Publish-subscribe（交换机类型：Fanout，也称为广播-）\"><a href=\"#Publish-subscribe（交换机类型：Fanout，也称为广播-）\" class=\"headerlink\" title=\"Publish/subscribe（交换机类型：Fanout，也称为广播 ）\"></a>Publish/subscribe（交换机类型：Fanout，也称为广播 ）</h2><img src=\"/2020/04/12/rabbitmq-messages/b-3.png\">\n<p>说民：</p>\n<p>1.一个生产者，多个消费者。<br>2.每个消费者都有自己的一个队列。<br>3.生产者没有将消息直接发送给队列，而是发送给exchange(交换机、转发器)。<br>4.每个队列都需要绑定到交换机上。<br>5.生产者发送的消息，经过交换机到达队列，实现一个消息被多个消费者消费</p>\n<p>例子：注册-&gt;发邮件、发短信</p>\n<p>X（Exchanges）：交换机一方面：接收生产者发送的消息。另一方面：知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。</p>\n<p>Exchange类型有以下几种：</p>\n<p>Fanout：广播，将消息交给所有绑定到交换机的队列</p>\n<p>Direct：定向，把消息交给符合指定routing key 的队列</p>\n<p>Topic：通配符，把消息交给符合routing pattern（路由模式） 的队列</p>\n<p>Header：header模式与routing不同的地方在于，header模式取消routingkey，使用header中的 key/value（键值对）匹配队列。</p>\n<p>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>\n<p><em>示例：</em></p>\n<p>略……</p>\n<p><em>思考：</em></p>\n<p>1、publish/subscribe与work queues有什么区别。</p>\n<p>区别：</p>\n<p>1）work queues不用定义交换机，而publish/subscribe需要定义交换机。</p>\n<p>2）publish/subscribe的生产方是面向交换机发送消息，work queues的生产方是面向队列发送消息(底层使用默认交换机)。</p>\n<p>3）publish/subscribe需要设置队列和交换机的绑定，work queues不需要设置，实际上work queues会将队列绑定到默认的交换机 。</p>\n<p>相同点：</p>\n<p>所以两者实现的发布/订阅的效果是一样的，多个消费端监听同一个队列不会重复消费消息。</p>\n<p>2、实际工作用 publish/subscribe还是work queues。</p>\n<p>建议使用 publish/subscribe，发布订阅模式比工作队列模式更强大（也可以做到同一队列竞争），并且发布订阅模式可以指定自己专用的交换机。</p>\n<h2 id=\"Routing-路由模型（交换机类型：direct）\"><a href=\"#Routing-路由模型（交换机类型：direct）\" class=\"headerlink\" title=\"Routing 路由模型（交换机类型：direct）\"></a>Routing 路由模型（交换机类型：direct）</h2><img src=\"/2020/04/12/rabbitmq-messages/b-4.png\">\n<p>_P_：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p>\n<p>_X_：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p>\n<p>_C1_：消费者，其所在队列指定了需要routing key 为 error 的消息</p>\n<p>_C2_：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p>\n<p>例子：</p>\n<p>发送者sender：</p>\n<pre><code>public class Send {\n    private final static String EXCHANGE_NAME = &quot;test_direct_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明exchange，指定类型为direct\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.DIRECT);\n        // 消息内容，\n        String message = &quot;注册成功！请短信回复[T]退订&quot;;\n        // 发送消息，并且指定routing key 为：sms，只有短信服务能接收到消息\n        channel.basicPublish(EXCHANGE_NAME, &quot;sms&quot;, null, message.getBytes());\n        System.out.println(&quot; [x] Sent &apos;&quot; + message + &quot;&apos;&quot;);\n\n        channel.close();\n        connection.close();\n    }\n}\n</code></pre><p>消费者1：</p>\n<pre><code>public class Recv {\n    private final static String QUEUE_NAME = &quot;direct_exchange_queue_sms&quot;;//短信队列\n    private final static String EXCHANGE_NAME = &quot;test_direct_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;sms&quot;);//指定接收发送方指定routing key为sms的消息\n        //channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;email&quot;);\n\n        // 定义队列的消费者\n        DefaultConsumer consumer = new DefaultConsumer(channel) {\n            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                       byte[] body) throws IOException {\n                // body 即消息体\n                String msg = new String(body);\n                System.out.println(&quot; [短信服务] received : &quot; + msg + &quot;!&quot;);\n            }\n        };\n        // 监听队列，自动ACK\n        channel.basicConsume(QUEUE_NAME, true, consumer);\n    }\n}    \n</code></pre><p>消费者2：</p>\n<pre><code>public class Recv2 {\n    private final static String QUEUE_NAME = &quot;direct_exchange_queue_email&quot;;//邮件队列\n    private final static String EXCHANGE_NAME = &quot;test_direct_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 绑定队列到交换机，同时指定需要订阅的routing key。可以指定多个\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;email&quot;);//指定接收发送方指定routing key为email的消息\n\n        // 定义队列的消费者\n        DefaultConsumer consumer = new DefaultConsumer(channel) {\n            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                       byte[] body) throws IOException {\n                // body 即消息体\n                String msg = new String(body);\n                System.out.println(&quot; [邮件服务] received : &quot; + msg + &quot;!&quot;);\n            }\n        };\n        // 监听队列，自动ACK\n        channel.basicConsume(QUEUE_NAME, true, consumer);\n    }\n}  \n</code></pre><p>我们发送sms的RoutingKey，发现结果：只有指定短信的消费者1收到消息了。</p>\n<h2 id=\"Topics-通配符模式（交换机类型：topics）\"><a href=\"#Topics-通配符模式（交换机类型：topics）\" class=\"headerlink\" title=\"Topics 通配符模式（交换机类型：topics）\"></a>Topics 通配符模式（交换机类型：topics）</h2><p> 每个消费者监听自己的队列，并且设置带统配符的routingkey,生产者将消息发给broker，由交换机根据routingkey来转发消息到指定的队列。</p>\n<p>Routingkey一般都是有一个或者多个单词组成，多个单词之间以“.”分割，例如：inform.sms</p>\n<p>通配符规则：</p>\n<p><code>#</code>：匹配一个或多个词</p>\n<p><code>*</code>：匹配不多不少恰好1个词</p>\n<p>举例：</p>\n<p>audit.#：能够匹配audit.irs.corporate 或者 audit.irs</p>\n<p>audit.*：只能匹配audit.irs</p>\n<p>从示意图可知，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的Routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：“<speed>.<color>.<species>”。</species></color></speed></p>\n<p>我们创建了三个绑定：Q1绑定了“<em>.orange.</em>”，Q2绑定了“.<em>.</em>.rabbit”和“lazy.＃”。</p>\n<p>Q1匹配所有的橙色动物。</p>\n<p>Q2匹配关于兔子以及懒惰动物的消息。</p>\n<p> 下面做个小练习，假如生产者发送如下消息，会进入哪个队列：</p>\n<p>quick.orange.rabbit       Q1 Q2   routingKey=”quick.orange.rabbit”的消息会同时路由到Q1与Q2</p>\n<p>lazy.orange.elephant    Q1 Q2</p>\n<p>quick.orange.fox           Q1</p>\n<p>lazy.pink.rabbit              Q2  (值得注意的是，虽然这个routingKey与Q2的两个bindingKey都匹配，但是只会投递Q2一次)</p>\n<p>quick.brown.fox            不匹配任意队列，被丢弃</p>\n<p>quick.orange.male.rabbit   不匹配任意队列，被丢弃</p>\n<p>orange         不匹配任意队列，被丢弃</p>\n<p>下面我们以指定Routing key=”quick.orange.rabbit”为例，验证上面的答案</p>\n<p>生产者：</p>\n<pre><code>public class Send {\n    private final static String EXCHANGE_NAME = &quot;test_topic_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明exchange，指定类型为topic\n        channel.exchangeDeclare(EXCHANGE_NAME, BuiltinExchangeType.TOPIC);\n        // 消息内容\n        String message = &quot;这是一只行动迅速的橙色的兔子&quot;;\n        // 发送消息，并且指定routing key为：quick.orange.rabbit\n        channel.basicPublish(EXCHANGE_NAME, &quot;quick.orange.rabbit&quot;, null, message.getBytes());\n        System.out.println(&quot; [动物描述：] Sent &apos;&quot; + message + &quot;&apos;&quot;);\n\n        channel.close();\n        connection.close();\n    }\n}\n</code></pre><p>消费者1：</p>\n<pre><code>public class Recv {\n    private final static String QUEUE_NAME = &quot;topic_exchange_queue_Q1&quot;;\n    private final static String EXCHANGE_NAME = &quot;test_topic_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 绑定队列到交换机，同时指定需要订阅的routing key。订阅所有的橙色动物\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.orange.*&quot;);\n\n        // 定义队列的消费者\n        DefaultConsumer consumer = new DefaultConsumer(channel) {\n            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                       byte[] body) throws IOException {\n                // body 即消息体\n                String msg = new String(body);\n                System.out.println(&quot; [消费者1] received : &quot; + msg + &quot;!&quot;);\n            }\n        };\n        // 监听队列，自动ACK\n        channel.basicConsume(QUEUE_NAME, true, consumer);\n    }\n}\n</code></pre><p>消费者2：</p>\n<pre><code>public class Recv2 {\n    private final static String QUEUE_NAME = &quot;topic_exchange_queue_Q2&quot;;\n    private final static String EXCHANGE_NAME = &quot;test_topic_exchange&quot;;\n\n    public static void main(String[] argv) throws Exception {\n        // 获取到连接\n        Connection connection = ConnectionUtil.getConnection();\n        // 获取通道\n        Channel channel = connection.createChannel();\n        // 声明队列\n        channel.queueDeclare(QUEUE_NAME, false, false, false, null);\n\n        // 绑定队列到交换机，同时指定需要订阅的routing key。订阅关于兔子以及懒惰动物的消息\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;*.*.rabbit&quot;);\n        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, &quot;lazy.＃&quot;);\n\n        // 定义队列的消费者\n        DefaultConsumer consumer = new DefaultConsumer(channel) {\n            // 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties,\n                                       byte[] body) throws IOException {\n                // body 即消息体\n                String msg = new String(body);\n                System.out.println(&quot; [消费者2] received : &quot; + msg + &quot;!&quot;);\n            }\n        };\n        // 监听队列，自动ACK\n        channel.basicConsume(QUEUE_NAME, true, consumer);\n    }\n}\n</code></pre><p>结果C1、C2是都接收到消息了。</p>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2>\n<p>基本概念：</p>\n<p>Callback queue 回调队列，客户端向服务器发送请求，服务器端处理请求后，将其处理结果保存在一个存储体中。而客户端为了获得处理结果，那么客户在向服务器发送请求时，同时发送一个回调队列地址reply_to。</p>\n<p>Correlation id 关联标识，客户端可能会发送多个请求给服务器，当服务器处理完后，客户端无法辨别在回调队列中的响应具体和那个请求时对应的。为了处理这种情况，客户端在发送每个请求时，同时会附带一个独有correlation_id属性，这样客户端在回调队列中根据correlation_id字段的值就可以分辨此响应属于哪个请求。</p>\n<p>流程说明：</p>\n<p>当客户端启动的时候，它创建一个匿名独享的回调队列。<br>在 RPC 请求中，客户端发送带有两个属性的消息：一个是设置回调队列的 reply_to 属性，另一个是设置唯一值的 correlation_id 属性。<br>将请求发送到一个 rpc_queue 队列中。<br>服务器等待请求发送到这个队列中来。当请求出现的时候，它执行他的工作并且将带有执行结果的消息发送给 reply_to 字段指定的队列。<br>客户端等待回调队列里的数据。当有消息出现的时候，它会检查 correlation_id 属性。如果此属性的值与请求匹配，将它返回给应用</p>\n"},{"title":"redis命令搜集","date":"2018-03-23T09:36:34.000Z","_content":"\n1.查看所有的key\n\n`> KEYS *`\n\n2.清空所有key和数据\n\n`> flushall`","source":"_posts/redis-common.md","raw":"---\ntitle: redis命令搜集\ndate: 2018-03-23 17:36:34\ncategories: redis\ntags: redis命令\n---\n\n1.查看所有的key\n\n`> KEYS *`\n\n2.清空所有key和数据\n\n`> flushall`","slug":"redis-common","published":1,"updated":"2019-06-16T14:38:33.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqeh008vg4var46wmpmz","content":"<p>1.查看所有的key</p>\n<p><code>&gt; KEYS *</code></p>\n<p>2.清空所有key和数据</p>\n<p><code>&gt; flushall</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.查看所有的key</p>\n<p><code>&gt; KEYS *</code></p>\n<p>2.清空所有key和数据</p>\n<p><code>&gt; flushall</code></p>\n"},{"title":"redis一主多从集群配置","date":"2017-09-21T05:46:08.000Z","_content":"","source":"_posts/redis-cluster-centos.md","raw":"---\ntitle: redis一主多从集群配置\ndate: 2017-09-21 13:46:08\ncategories: redis\ntags:   redis,主从,集群\n---\n","slug":"redis-cluster-centos","published":1,"updated":"2019-06-16T14:38:33.437Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqei008xg4vai0cl1rir","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redis实现分布式锁","date":"2018-06-11T09:22:58.000Z","_content":"","source":"_posts/redis-distributed-lock.md","raw":"---\ntitle: redis实现分布式锁\ndate: 2018-06-11 17:22:58\ncategories: redis\ntags: redis分布式锁\n---\n","slug":"redis-distributed-lock","published":1,"updated":"2019-06-16T14:38:33.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqej0091g4vavg0s8adr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redis配置","date":"2017-12-06T06:13:01.000Z","_content":"","source":"_posts/redis-conf.md","raw":"---\ntitle: redis配置\ndate: 2017-12-06 14:13:01\ncategories: redis\ntags: redis,密码,安全\n---\n","slug":"redis-conf","published":1,"updated":"2019-06-16T14:38:33.439Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqek0093g4vayydkmybd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redis安装","date":"2018-01-18T12:55:18.000Z","_content":"\n本文介绍在linux系统下redis的安装使用……\n\n## redis在ubuntu系统下的安装\n\n### 一、下载，安装，测试\n\nDownload, extract and compile Redis with:\n\n    $ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n    $ tar xzf redis-3.2.0.tar.gz\n    $ cd redis-3.2.0\n    $ make\n\nThe binaries that are now compiled are available in the src directory. Run Redis with:\n\n    $ src/redis-server\n\nYou can interact with Redis using the built-in client:\n\n    $ src/redis-cli redis> set foo bar OK redis> get foo \"bar\"\n\n### 二、设置直接使用redis的启动，客户端命令\nmake编译redis后，执行命令\n\n       $ cd redis-3.2.0\n       $ sudo make install\n       \nsrc中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：\n\n    xiaocao@xiaocao-pc:~$ redis-cli\n     127.0.0.1:6379> get foo\n     \"123456\"\n     127.0.0.1:6379>\n启动服务：`xiaocao@xiaocao-pc:~$ redis-server`\n\n### 三、src目录下执行文件说明：\n\nredis-check-aof //AOF文件修复工具\nredis-cli //Redis命令行客户端，最常用\nredis-server //Redis服务器，最常用\nredis-benchmark //Redis性能测试工具\nredis-check-rdb //\nredis-sentinel     //Sentinel服务器，2.8版本后\n\n### 四、启动，停止redis服务\n\n1、直接启动：make install后\n执行命令：`$ redis-server`     //默认端口是6379\n自定义端口启动：\n执行命令：`$ redis-server --port 6380`\n2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）\n(1)配置初始化脚本。\n>a. `$ cd ~/java/redis-3.2.0/utils`\n将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，\n客户端连接的端口号。\n\n>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。\n\n（2）建立需要的文件夹：\n>/etc/redis      //存放Redis的配置文件\n/var/redis/端口号     //存放Redis的持久化文件\n\n(3)修改配置文件：\n\n    a、$ cd  ~/java/redis-3.2.0\n    b、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\n    c、修改参数( 6380.conf )：\n    参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n         pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n         port                  端口号                                    设置redis监听的端口号\n         dir                    /var/redis/端口号                设置持久化文件存放位置\n    d、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\n    e、执行下面命令使得redis随系统自动启动：\n    $ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n\n### 3、正确停止redis服务命令：\n$ redis-cli SHUTDOWN /默认的  或者\n$ redis-cli -p 6380 SHUTDOWN\n当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。\n\n### 4、关闭后再启动：\n\nservice redis_6380 -p 6380 start  #启动6380端口实例的redis\n\n$ cd /etc/init.d && ./redis_6380 start  #默认启动6379端口实例的redis\n\n## centos7下安装redis\n\n1. 下载源码。\n\n2. 编译安装：\n\n\n    编译前需要安装依赖 yum install -y gcc tcl\n    然后再编译 make -j 4 MALLOC=libc\n    \n    如果要自动启动：`make install -j 4 MALLOC=libc`","source":"_posts/redis-install.md","raw":"---\ntitle: redis安装\ndate: 2018-01-18 20:55:18\ncategories: redis\ntags: redis-install\n---\n\n本文介绍在linux系统下redis的安装使用……\n\n## redis在ubuntu系统下的安装\n\n### 一、下载，安装，测试\n\nDownload, extract and compile Redis with:\n\n    $ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n    $ tar xzf redis-3.2.0.tar.gz\n    $ cd redis-3.2.0\n    $ make\n\nThe binaries that are now compiled are available in the src directory. Run Redis with:\n\n    $ src/redis-server\n\nYou can interact with Redis using the built-in client:\n\n    $ src/redis-cli redis> set foo bar OK redis> get foo \"bar\"\n\n### 二、设置直接使用redis的启动，客户端命令\nmake编译redis后，执行命令\n\n       $ cd redis-3.2.0\n       $ sudo make install\n       \nsrc中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：\n\n    xiaocao@xiaocao-pc:~$ redis-cli\n     127.0.0.1:6379> get foo\n     \"123456\"\n     127.0.0.1:6379>\n启动服务：`xiaocao@xiaocao-pc:~$ redis-server`\n\n### 三、src目录下执行文件说明：\n\nredis-check-aof //AOF文件修复工具\nredis-cli //Redis命令行客户端，最常用\nredis-server //Redis服务器，最常用\nredis-benchmark //Redis性能测试工具\nredis-check-rdb //\nredis-sentinel     //Sentinel服务器，2.8版本后\n\n### 四、启动，停止redis服务\n\n1、直接启动：make install后\n执行命令：`$ redis-server`     //默认端口是6379\n自定义端口启动：\n执行命令：`$ redis-server --port 6380`\n2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）\n(1)配置初始化脚本。\n>a. `$ cd ~/java/redis-3.2.0/utils`\n将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，\n客户端连接的端口号。\n\n>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。\n\n（2）建立需要的文件夹：\n>/etc/redis      //存放Redis的配置文件\n/var/redis/端口号     //存放Redis的持久化文件\n\n(3)修改配置文件：\n\n    a、$ cd  ~/java/redis-3.2.0\n    b、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\n    c、修改参数( 6380.conf )：\n    参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n         pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n         port                  端口号                                    设置redis监听的端口号\n         dir                    /var/redis/端口号                设置持久化文件存放位置\n    d、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\n    e、执行下面命令使得redis随系统自动启动：\n    $ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n\n### 3、正确停止redis服务命令：\n$ redis-cli SHUTDOWN /默认的  或者\n$ redis-cli -p 6380 SHUTDOWN\n当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。\n\n### 4、关闭后再启动：\n\nservice redis_6380 -p 6380 start  #启动6380端口实例的redis\n\n$ cd /etc/init.d && ./redis_6380 start  #默认启动6379端口实例的redis\n\n## centos7下安装redis\n\n1. 下载源码。\n\n2. 编译安装：\n\n\n    编译前需要安装依赖 yum install -y gcc tcl\n    然后再编译 make -j 4 MALLOC=libc\n    \n    如果要自动启动：`make install -j 4 MALLOC=libc`","slug":"redis-install","published":1,"updated":"2019-06-16T14:38:33.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqem0097g4vabentt5ll","content":"<p>本文介绍在linux系统下redis的安装使用……</p>\n<h2 id=\"redis在ubuntu系统下的安装\"><a href=\"#redis在ubuntu系统下的安装\" class=\"headerlink\" title=\"redis在ubuntu系统下的安装\"></a>redis在ubuntu系统下的安装</h2><h3 id=\"一、下载，安装，测试\"><a href=\"#一、下载，安装，测试\" class=\"headerlink\" title=\"一、下载，安装，测试\"></a>一、下载，安装，测试</h3><p>Download, extract and compile Redis with:</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n$ tar xzf redis-3.2.0.tar.gz\n$ cd redis-3.2.0\n$ make\n</code></pre><p>The binaries that are now compiled are available in the src directory. Run Redis with:</p>\n<pre><code>$ src/redis-server\n</code></pre><p>You can interact with Redis using the built-in client:</p>\n<pre><code>$ src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot;\n</code></pre><h3 id=\"二、设置直接使用redis的启动，客户端命令\"><a href=\"#二、设置直接使用redis的启动，客户端命令\" class=\"headerlink\" title=\"二、设置直接使用redis的启动，客户端命令\"></a>二、设置直接使用redis的启动，客户端命令</h3><p>make编译redis后，执行命令</p>\n<pre><code>$ cd redis-3.2.0\n$ sudo make install\n</code></pre><p>src中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：</p>\n<pre><code>xiaocao@xiaocao-pc:~$ redis-cli\n 127.0.0.1:6379&gt; get foo\n &quot;123456&quot;\n 127.0.0.1:6379&gt;\n</code></pre><p>启动服务：<code>xiaocao@xiaocao-pc:~$ redis-server</code></p>\n<h3 id=\"三、src目录下执行文件说明：\"><a href=\"#三、src目录下执行文件说明：\" class=\"headerlink\" title=\"三、src目录下执行文件说明：\"></a>三、src目录下执行文件说明：</h3><p>redis-check-aof //AOF文件修复工具<br>redis-cli //Redis命令行客户端，最常用<br>redis-server //Redis服务器，最常用<br>redis-benchmark //Redis性能测试工具<br>redis-check-rdb //<br>redis-sentinel     //Sentinel服务器，2.8版本后</p>\n<h3 id=\"四、启动，停止redis服务\"><a href=\"#四、启动，停止redis服务\" class=\"headerlink\" title=\"四、启动，停止redis服务\"></a>四、启动，停止redis服务</h3><p>1、直接启动：make install后<br>执行命令：<code>$ redis-server</code>     //默认端口是6379<br>自定义端口启动：<br>执行命令：<code>$ redis-server --port 6380</code><br>2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）<br>(1)配置初始化脚本。</p>\n<blockquote>\n<p>a. <code>$ cd ~/java/redis-3.2.0/utils</code><br>将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，<br>客户端连接的端口号。</p>\n</blockquote>\n<blockquote>\n<p>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。</p>\n</blockquote>\n<p>（2）建立需要的文件夹：</p>\n<blockquote>\n<p>/etc/redis      //存放Redis的配置文件<br>/var/redis/端口号     //存放Redis的持久化文件</p>\n</blockquote>\n<p>(3)修改配置文件：</p>\n<pre><code>a、$ cd  ~/java/redis-3.2.0\nb、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\nc、修改参数( 6380.conf )：\n参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n     pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n     port                  端口号                                    设置redis监听的端口号\n     dir                    /var/redis/端口号                设置持久化文件存放位置\nd、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\ne、执行下面命令使得redis随系统自动启动：\n$ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n</code></pre><h3 id=\"3、正确停止redis服务命令：\"><a href=\"#3、正确停止redis服务命令：\" class=\"headerlink\" title=\"3、正确停止redis服务命令：\"></a>3、正确停止redis服务命令：</h3><p>$ redis-cli SHUTDOWN /默认的  或者<br>$ redis-cli -p 6380 SHUTDOWN<br>当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。</p>\n<h3 id=\"4、关闭后再启动：\"><a href=\"#4、关闭后再启动：\" class=\"headerlink\" title=\"4、关闭后再启动：\"></a>4、关闭后再启动：</h3><p>service redis_6380 -p 6380 start  #启动6380端口实例的redis</p>\n<p>$ cd /etc/init.d &amp;&amp; ./redis_6380 start  #默认启动6379端口实例的redis</p>\n<h2 id=\"centos7下安装redis\"><a href=\"#centos7下安装redis\" class=\"headerlink\" title=\"centos7下安装redis\"></a>centos7下安装redis</h2><ol>\n<li><p>下载源码。</p>\n</li>\n<li><p>编译安装：</p>\n</li>\n</ol>\n<pre><code>编译前需要安装依赖 yum install -y gcc tcl\n然后再编译 make -j 4 MALLOC=libc\n\n如果要自动启动：`make install -j 4 MALLOC=libc`\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍在linux系统下redis的安装使用……</p>\n<h2 id=\"redis在ubuntu系统下的安装\"><a href=\"#redis在ubuntu系统下的安装\" class=\"headerlink\" title=\"redis在ubuntu系统下的安装\"></a>redis在ubuntu系统下的安装</h2><h3 id=\"一、下载，安装，测试\"><a href=\"#一、下载，安装，测试\" class=\"headerlink\" title=\"一、下载，安装，测试\"></a>一、下载，安装，测试</h3><p>Download, extract and compile Redis with:</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n$ tar xzf redis-3.2.0.tar.gz\n$ cd redis-3.2.0\n$ make\n</code></pre><p>The binaries that are now compiled are available in the src directory. Run Redis with:</p>\n<pre><code>$ src/redis-server\n</code></pre><p>You can interact with Redis using the built-in client:</p>\n<pre><code>$ src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot;\n</code></pre><h3 id=\"二、设置直接使用redis的启动，客户端命令\"><a href=\"#二、设置直接使用redis的启动，客户端命令\" class=\"headerlink\" title=\"二、设置直接使用redis的启动，客户端命令\"></a>二、设置直接使用redis的启动，客户端命令</h3><p>make编译redis后，执行命令</p>\n<pre><code>$ cd redis-3.2.0\n$ sudo make install\n</code></pre><p>src中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：</p>\n<pre><code>xiaocao@xiaocao-pc:~$ redis-cli\n 127.0.0.1:6379&gt; get foo\n &quot;123456&quot;\n 127.0.0.1:6379&gt;\n</code></pre><p>启动服务：<code>xiaocao@xiaocao-pc:~$ redis-server</code></p>\n<h3 id=\"三、src目录下执行文件说明：\"><a href=\"#三、src目录下执行文件说明：\" class=\"headerlink\" title=\"三、src目录下执行文件说明：\"></a>三、src目录下执行文件说明：</h3><p>redis-check-aof //AOF文件修复工具<br>redis-cli //Redis命令行客户端，最常用<br>redis-server //Redis服务器，最常用<br>redis-benchmark //Redis性能测试工具<br>redis-check-rdb //<br>redis-sentinel     //Sentinel服务器，2.8版本后</p>\n<h3 id=\"四、启动，停止redis服务\"><a href=\"#四、启动，停止redis服务\" class=\"headerlink\" title=\"四、启动，停止redis服务\"></a>四、启动，停止redis服务</h3><p>1、直接启动：make install后<br>执行命令：<code>$ redis-server</code>     //默认端口是6379<br>自定义端口启动：<br>执行命令：<code>$ redis-server --port 6380</code><br>2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）<br>(1)配置初始化脚本。</p>\n<blockquote>\n<p>a. <code>$ cd ~/java/redis-3.2.0/utils</code><br>将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，<br>客户端连接的端口号。</p>\n</blockquote>\n<blockquote>\n<p>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。</p>\n</blockquote>\n<p>（2）建立需要的文件夹：</p>\n<blockquote>\n<p>/etc/redis      //存放Redis的配置文件<br>/var/redis/端口号     //存放Redis的持久化文件</p>\n</blockquote>\n<p>(3)修改配置文件：</p>\n<pre><code>a、$ cd  ~/java/redis-3.2.0\nb、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\nc、修改参数( 6380.conf )：\n参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n     pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n     port                  端口号                                    设置redis监听的端口号\n     dir                    /var/redis/端口号                设置持久化文件存放位置\nd、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\ne、执行下面命令使得redis随系统自动启动：\n$ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n</code></pre><h3 id=\"3、正确停止redis服务命令：\"><a href=\"#3、正确停止redis服务命令：\" class=\"headerlink\" title=\"3、正确停止redis服务命令：\"></a>3、正确停止redis服务命令：</h3><p>$ redis-cli SHUTDOWN /默认的  或者<br>$ redis-cli -p 6380 SHUTDOWN<br>当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。</p>\n<h3 id=\"4、关闭后再启动：\"><a href=\"#4、关闭后再启动：\" class=\"headerlink\" title=\"4、关闭后再启动：\"></a>4、关闭后再启动：</h3><p>service redis_6380 -p 6380 start  #启动6380端口实例的redis</p>\n<p>$ cd /etc/init.d &amp;&amp; ./redis_6380 start  #默认启动6379端口实例的redis</p>\n<h2 id=\"centos7下安装redis\"><a href=\"#centos7下安装redis\" class=\"headerlink\" title=\"centos7下安装redis\"></a>centos7下安装redis</h2><ol>\n<li><p>下载源码。</p>\n</li>\n<li><p>编译安装：</p>\n</li>\n</ol>\n<pre><code>编译前需要安装依赖 yum install -y gcc tcl\n然后再编译 make -j 4 MALLOC=libc\n\n如果要自动启动：`make install -j 4 MALLOC=libc`\n</code></pre>"},{"title":"redis发布订阅特性介绍","date":"2018-06-11T09:24:37.000Z","_content":"","source":"_posts/redis-pub-sub.md","raw":"---\ntitle: redis发布订阅特性介绍\ndate: 2018-06-11 17:24:37\ncategories: redis\ntags: redis发布订阅\n---\n","slug":"redis-pub-sub","published":1,"updated":"2019-06-16T14:38:33.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqen0099g4vau92x8j5w","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redis哨兵模式","date":"2018-06-11T09:27:25.000Z","_content":"","source":"_posts/redis-sentinel.md","raw":"---\ntitle: redis哨兵模式\ndate: 2018-06-11 17:27:25\ncategories: redis\ntags: redis哨兵模式\n---\n","slug":"redis-sentinel","published":1,"updated":"2019-06-16T14:38:33.440Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqep009cg4va8nt29kew","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Redmine通过域名访问慢的问题解决","date":"2018-11-16T09:14:25.000Z","_content":"\n按照之前章节在服务器安装好Redmine后，通过ngxin代理访问，发现巨慢，心塞！  \n于是开始了各种搜，搜，搜……  \n下面，把整个踩坑的过程记录下来！    \n\n## Mongrel服务器启动Redmine\n由于Redmine自带的Webrick Web服务器，听说是要进行域名代理解析，所以会特别慢。于是想确认下，通过翻墙访问，真他妹的变得快一些。唉，毕竟老外开发的东西呀，再加上咱国度的网络问题，呵呵了……   \n还有，万能的网络告知还有个Mongrel的东东。    \nMongrel是一种快速的针对Ruby的Http服务器，专门为部署发布ROR应用而产生的。Mongrel相比Rails自带的纯Ruby服务器Webrick速度快很多并支持并发访问，有望成为Ruby的Tomcat.  \n\n于是，开始各种google，百度，按照Mongrel\n\n1.替换其自带的服务器webrick为mongrel，方法：  \n`gem install mongrel`\nrails 3.1以上执行:\n`gem install mongrel --pre`\n\n查看rails版本：\n    \n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# rails -v\n    Rails 4.2.8\n\n2.编辑`Gemfile.local`\n\n进入Redmine安装目录下，新建文件`Gemfile.local`并编辑：\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# cat Gemfile.local \n    # Gemfile.local \n    #gem 'thin'\n    gem 'mongrel','~> 1.2.0.pre2'\n    \n3.删除gemfile.lock文件，重新执行:    \n`bundle install`\n\n4.重新启动Redmine：  \n`ruby bin/rails server mongrel -e production -p 8889 -d`\n\n## 配置Nginx代理\n\n    upstream pm.xcsqjr.com{\n        server localhost:8889;\n        #server 10.162.71.10:5050;\n        fair;\n    }  \n    server{\n            listen 80;\n            server_name pm.xcsqjr.com;\n    \taccess_log  /server/java/nginx/logs/pm.xcsqjr.com.access.log;\n            location ~ ${\n                  server_name_in_redirect off;\n    \t      proxy_redirect off;\n                  proxy_set_header Host $host;\n                  proxy_set_header X-Real-IP $remote_addr;\n                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                  proxy_pass http://pm.xcsqjr.com;\n                  client_max_body_size    100m;\n                  index index.html index.htm;\n            }\n            error_page  404              /404.html;\n            error_page  500 502 503 504  /50x.html;\n            location = /50x.html {\n                    root   html;\n            }\n    }\n    \n重启nginx，使配置生效。\n\n激动人心的时刻即将到来，在浏览器输入：http://pm.xcsqjr.com/    \n哎呀，他妹的，还是慢，慢，慢……    \n\n于是，各种继续搜，搜，搜……，各种尝试，还是不行呀！！\n \n哎呦，好像有点新发现了，在这里：    \nhttps://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine    \n\n好吧，就这样，把ngxin代理的配置改下，只能碰碰运气了：   \n\n     upstream redmine {\n             server 127.0.0.1:8889;\n             #server 127.0.0.1:8001;\n             #server 127.0.0.1:8002;\n     }\n     \n     server {\n             server_name pm.xcsqjr.com;\n             root /server/java/redmine/redmine-3.4.6/public;\n     \n             location / {\n                     try_files $uri @redmine;\n             }\n     \n             location @redmine {\n                     proxy_set_header  X-Forwarded-For $remote_addr;\n                     proxy_pass http://redmine;\n             }\n     }\n\n没抱大希望咯，还是打开浏览器大神访问看看吧：http://pm.xcsqjr.com/     \n\n啊，大爷的，飞速的快呀！那一刻，激动的泪水……\n\n可以下班回家煮饭了，感谢上帝！！！","source":"_posts/redmine-mongrel-nginx.md","raw":"---\ntitle: Redmine通过域名访问慢的问题解决\ndate: 2018-11-16 17:14:25\ncategories: redmine\ntags: redmine-mongrel-nginx\n---\n\n按照之前章节在服务器安装好Redmine后，通过ngxin代理访问，发现巨慢，心塞！  \n于是开始了各种搜，搜，搜……  \n下面，把整个踩坑的过程记录下来！    \n\n## Mongrel服务器启动Redmine\n由于Redmine自带的Webrick Web服务器，听说是要进行域名代理解析，所以会特别慢。于是想确认下，通过翻墙访问，真他妹的变得快一些。唉，毕竟老外开发的东西呀，再加上咱国度的网络问题，呵呵了……   \n还有，万能的网络告知还有个Mongrel的东东。    \nMongrel是一种快速的针对Ruby的Http服务器，专门为部署发布ROR应用而产生的。Mongrel相比Rails自带的纯Ruby服务器Webrick速度快很多并支持并发访问，有望成为Ruby的Tomcat.  \n\n于是，开始各种google，百度，按照Mongrel\n\n1.替换其自带的服务器webrick为mongrel，方法：  \n`gem install mongrel`\nrails 3.1以上执行:\n`gem install mongrel --pre`\n\n查看rails版本：\n    \n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# rails -v\n    Rails 4.2.8\n\n2.编辑`Gemfile.local`\n\n进入Redmine安装目录下，新建文件`Gemfile.local`并编辑：\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# cat Gemfile.local \n    # Gemfile.local \n    #gem 'thin'\n    gem 'mongrel','~> 1.2.0.pre2'\n    \n3.删除gemfile.lock文件，重新执行:    \n`bundle install`\n\n4.重新启动Redmine：  \n`ruby bin/rails server mongrel -e production -p 8889 -d`\n\n## 配置Nginx代理\n\n    upstream pm.xcsqjr.com{\n        server localhost:8889;\n        #server 10.162.71.10:5050;\n        fair;\n    }  \n    server{\n            listen 80;\n            server_name pm.xcsqjr.com;\n    \taccess_log  /server/java/nginx/logs/pm.xcsqjr.com.access.log;\n            location ~ ${\n                  server_name_in_redirect off;\n    \t      proxy_redirect off;\n                  proxy_set_header Host $host;\n                  proxy_set_header X-Real-IP $remote_addr;\n                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                  proxy_pass http://pm.xcsqjr.com;\n                  client_max_body_size    100m;\n                  index index.html index.htm;\n            }\n            error_page  404              /404.html;\n            error_page  500 502 503 504  /50x.html;\n            location = /50x.html {\n                    root   html;\n            }\n    }\n    \n重启nginx，使配置生效。\n\n激动人心的时刻即将到来，在浏览器输入：http://pm.xcsqjr.com/    \n哎呀，他妹的，还是慢，慢，慢……    \n\n于是，各种继续搜，搜，搜……，各种尝试，还是不行呀！！\n \n哎呦，好像有点新发现了，在这里：    \nhttps://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine    \n\n好吧，就这样，把ngxin代理的配置改下，只能碰碰运气了：   \n\n     upstream redmine {\n             server 127.0.0.1:8889;\n             #server 127.0.0.1:8001;\n             #server 127.0.0.1:8002;\n     }\n     \n     server {\n             server_name pm.xcsqjr.com;\n             root /server/java/redmine/redmine-3.4.6/public;\n     \n             location / {\n                     try_files $uri @redmine;\n             }\n     \n             location @redmine {\n                     proxy_set_header  X-Forwarded-For $remote_addr;\n                     proxy_pass http://redmine;\n             }\n     }\n\n没抱大希望咯，还是打开浏览器大神访问看看吧：http://pm.xcsqjr.com/     \n\n啊，大爷的，飞速的快呀！那一刻，激动的泪水……\n\n可以下班回家煮饭了，感谢上帝！！！","slug":"redmine-mongrel-nginx","published":1,"updated":"2019-06-16T14:38:33.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqer009fg4vak3u7yg6p","content":"<p>按照之前章节在服务器安装好Redmine后，通过ngxin代理访问，发现巨慢，心塞！<br>于是开始了各种搜，搜，搜……<br>下面，把整个踩坑的过程记录下来！    </p>\n<h2 id=\"Mongrel服务器启动Redmine\"><a href=\"#Mongrel服务器启动Redmine\" class=\"headerlink\" title=\"Mongrel服务器启动Redmine\"></a>Mongrel服务器启动Redmine</h2><p>由于Redmine自带的Webrick Web服务器，听说是要进行域名代理解析，所以会特别慢。于是想确认下，通过翻墙访问，真他妹的变得快一些。唉，毕竟老外开发的东西呀，再加上咱国度的网络问题，呵呵了……<br>还有，万能的网络告知还有个Mongrel的东东。<br>Mongrel是一种快速的针对Ruby的Http服务器，专门为部署发布ROR应用而产生的。Mongrel相比Rails自带的纯Ruby服务器Webrick速度快很多并支持并发访问，有望成为Ruby的Tomcat.  </p>\n<p>于是，开始各种google，百度，按照Mongrel</p>\n<p>1.替换其自带的服务器webrick为mongrel，方法：<br><code>gem install mongrel</code><br>rails 3.1以上执行:<br><code>gem install mongrel --pre</code></p>\n<p>查看rails版本：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# rails -v\nRails 4.2.8\n</code></pre><p>2.编辑<code>Gemfile.local</code></p>\n<p>进入Redmine安装目录下，新建文件<code>Gemfile.local</code>并编辑：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# cat Gemfile.local \n# Gemfile.local \n#gem &apos;thin&apos;\ngem &apos;mongrel&apos;,&apos;~&gt; 1.2.0.pre2&apos;\n</code></pre><p>3.删除gemfile.lock文件，重新执行:<br><code>bundle install</code></p>\n<p>4.重新启动Redmine：<br><code>ruby bin/rails server mongrel -e production -p 8889 -d</code></p>\n<h2 id=\"配置Nginx代理\"><a href=\"#配置Nginx代理\" class=\"headerlink\" title=\"配置Nginx代理\"></a>配置Nginx代理</h2><pre><code>upstream pm.xcsqjr.com{\n    server localhost:8889;\n    #server 10.162.71.10:5050;\n    fair;\n}  \nserver{\n        listen 80;\n        server_name pm.xcsqjr.com;\n    access_log  /server/java/nginx/logs/pm.xcsqjr.com.access.log;\n        location ~ ${\n              server_name_in_redirect off;\n          proxy_redirect off;\n              proxy_set_header Host $host;\n              proxy_set_header X-Real-IP $remote_addr;\n              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n              proxy_pass http://pm.xcsqjr.com;\n              client_max_body_size    100m;\n              index index.html index.htm;\n        }\n        error_page  404              /404.html;\n        error_page  500 502 503 504  /50x.html;\n        location = /50x.html {\n                root   html;\n        }\n}\n</code></pre><p>重启nginx，使配置生效。</p>\n<p>激动人心的时刻即将到来，在浏览器输入：<a href=\"http://pm.xcsqjr.com/\" target=\"_blank\" rel=\"noopener\">http://pm.xcsqjr.com/</a><br>哎呀，他妹的，还是慢，慢，慢……    </p>\n<p>于是，各种继续搜，搜，搜……，各种尝试，还是不行呀！！</p>\n<p>哎呦，好像有点新发现了，在这里：<br><a href=\"https://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine\" target=\"_blank\" rel=\"noopener\">https://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine</a>    </p>\n<p>好吧，就这样，把ngxin代理的配置改下，只能碰碰运气了：   </p>\n<pre><code>upstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n\nserver {\n        server_name pm.xcsqjr.com;\n        root /server/java/redmine/redmine-3.4.6/public;\n\n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n}\n</code></pre><p>没抱大希望咯，还是打开浏览器大神访问看看吧：<a href=\"http://pm.xcsqjr.com/\" target=\"_blank\" rel=\"noopener\">http://pm.xcsqjr.com/</a>     </p>\n<p>啊，大爷的，飞速的快呀！那一刻，激动的泪水……</p>\n<p>可以下班回家煮饭了，感谢上帝！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>按照之前章节在服务器安装好Redmine后，通过ngxin代理访问，发现巨慢，心塞！<br>于是开始了各种搜，搜，搜……<br>下面，把整个踩坑的过程记录下来！    </p>\n<h2 id=\"Mongrel服务器启动Redmine\"><a href=\"#Mongrel服务器启动Redmine\" class=\"headerlink\" title=\"Mongrel服务器启动Redmine\"></a>Mongrel服务器启动Redmine</h2><p>由于Redmine自带的Webrick Web服务器，听说是要进行域名代理解析，所以会特别慢。于是想确认下，通过翻墙访问，真他妹的变得快一些。唉，毕竟老外开发的东西呀，再加上咱国度的网络问题，呵呵了……<br>还有，万能的网络告知还有个Mongrel的东东。<br>Mongrel是一种快速的针对Ruby的Http服务器，专门为部署发布ROR应用而产生的。Mongrel相比Rails自带的纯Ruby服务器Webrick速度快很多并支持并发访问，有望成为Ruby的Tomcat.  </p>\n<p>于是，开始各种google，百度，按照Mongrel</p>\n<p>1.替换其自带的服务器webrick为mongrel，方法：<br><code>gem install mongrel</code><br>rails 3.1以上执行:<br><code>gem install mongrel --pre</code></p>\n<p>查看rails版本：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# rails -v\nRails 4.2.8\n</code></pre><p>2.编辑<code>Gemfile.local</code></p>\n<p>进入Redmine安装目录下，新建文件<code>Gemfile.local</code>并编辑：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# cat Gemfile.local \n# Gemfile.local \n#gem &apos;thin&apos;\ngem &apos;mongrel&apos;,&apos;~&gt; 1.2.0.pre2&apos;\n</code></pre><p>3.删除gemfile.lock文件，重新执行:<br><code>bundle install</code></p>\n<p>4.重新启动Redmine：<br><code>ruby bin/rails server mongrel -e production -p 8889 -d</code></p>\n<h2 id=\"配置Nginx代理\"><a href=\"#配置Nginx代理\" class=\"headerlink\" title=\"配置Nginx代理\"></a>配置Nginx代理</h2><pre><code>upstream pm.xcsqjr.com{\n    server localhost:8889;\n    #server 10.162.71.10:5050;\n    fair;\n}  \nserver{\n        listen 80;\n        server_name pm.xcsqjr.com;\n    access_log  /server/java/nginx/logs/pm.xcsqjr.com.access.log;\n        location ~ ${\n              server_name_in_redirect off;\n          proxy_redirect off;\n              proxy_set_header Host $host;\n              proxy_set_header X-Real-IP $remote_addr;\n              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n              proxy_pass http://pm.xcsqjr.com;\n              client_max_body_size    100m;\n              index index.html index.htm;\n        }\n        error_page  404              /404.html;\n        error_page  500 502 503 504  /50x.html;\n        location = /50x.html {\n                root   html;\n        }\n}\n</code></pre><p>重启nginx，使配置生效。</p>\n<p>激动人心的时刻即将到来，在浏览器输入：<a href=\"http://pm.xcsqjr.com/\" target=\"_blank\" rel=\"noopener\">http://pm.xcsqjr.com/</a><br>哎呀，他妹的，还是慢，慢，慢……    </p>\n<p>于是，各种继续搜，搜，搜……，各种尝试，还是不行呀！！</p>\n<p>哎呦，好像有点新发现了，在这里：<br><a href=\"https://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine\" target=\"_blank\" rel=\"noopener\">https://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine</a>    </p>\n<p>好吧，就这样，把ngxin代理的配置改下，只能碰碰运气了：   </p>\n<pre><code>upstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n\nserver {\n        server_name pm.xcsqjr.com;\n        root /server/java/redmine/redmine-3.4.6/public;\n\n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n}\n</code></pre><p>没抱大希望咯，还是打开浏览器大神访问看看吧：<a href=\"http://pm.xcsqjr.com/\" target=\"_blank\" rel=\"noopener\">http://pm.xcsqjr.com/</a>     </p>\n<p>啊，大爷的，飞速的快呀！那一刻，激动的泪水……</p>\n<p>可以下班回家煮饭了，感谢上帝！！！</p>\n"},{"title":"redmine常见插件安装使用","date":"2018-08-24T08:04:35.000Z","_content":"\nredmine项目管理系统之所以强大并让大家喜欢，正是其插件化的管理模式。各种插件为其增添了不少上天入地的能力！     \n因此，我们在这里就来介绍redmine的插件功能的使用，以及收集一些在开发管理中常用的插件功能。\n\n## redmine插件的安装\n\n1.查找插件并下载(官方仓库)：\n\n官网地址：http://www.redmine.org/plugins?page=1\n\n为了避免下载的插件版本和redmine（3.4.*）的版本冲突，必须选定对应版本下的插件下载。       \n{%asset_img a.png%}         \n\n2.其它途径下载，比如github上。\n\n \n- 安装： \n\n下载插件到plugins目录下，然后执行`bundle exec rake redmine:plugins:migrate RAILS_ENV=production`，再然后重启即可。\n    \n- 卸载： \n\n先执行`bundle exec rake redmine:plugins:migrate NAME=plugin_name VERSION=0 RAILS_ENV=production`，然后删除plugins目录下相应的插件目录，重启就可以了。 \n\n\n## 切图粘贴插件`redmine_image_clipboard_paste`(推荐)\n\n下载网址：https://github.com/thorin/redmine_image_clipboard_paste    \n\n这个是人家改过的新版本，兼容redmine`3.3.*`版本，旧的版本`redmine_image_clipboard_paste`不可用\n1.安装：\n\n    cd /path/to/redmine/\n    git clone git://github.com/thorin/redmine_image_clipboard_paste.git plugins/redmine_image_clipboard_paste\n    bundle exec rake redmine:plugins:migrate RAILS_ENV=production\n    \n2.卸载：\n    \n    cd /path/to/redmine/\n    bundle exec rake redmine:plugins:migrate NAME=redmine_image_clipboard_paste VERSION=0 RAILS_ENV=production\n    rm -rf plugins/redmine_image_clipboard_paste\n    \n## 方便查看问题中的图片`Lightbox Plugin 2`\n\n在Lightbox更加方便的查看问题中的图片，那些小的图片，就不用再点击进去了，直接鼠标放上去就能看。 \n    \n    \n## 代码审查插件`Code Review`\n\n参考网址：http://www.redmine.org/plugins/redmine_code_review\n\n代码审查插件允许对代码仓库中的代码进行审查批阅，做注释。有效地对项目成员写的代码质量做出把控。 \n\n具体使用：\n\n## 工时单插件\n\n可以方便查看各个人的各个项目的工时情况\n\n地址：http://www.redmine.org/plugins/timesheet\n\n## 添加表情插件`Emoji Button`\n\n添加几个表情，使枯燥的编程工作变得更加有趣！  \n\n地址：http://www.redmine.org/plugins/redmine_emojibutton\n\n## office文档查看插件\n\n地址：https://www.redmine.org/plugins/redmine_preview_office\n\n### 安装\n\n实验环境：\n系统：centos7 64位  \nredmine：3.4.6   \nruby：2.3.6  \nrails：4.2.8\n\n#### 一.安装[libreoffice](https://www.libreoffice.org)\n\nlibreoffice提供命令把word文档，excel文档转成pdf格式等。这里同时提供了一个思路，开发应用时候，文档格式转换可以采用它。\n\n下载下面安装包到服务器：\n\n    wget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm_sdk.tar.gz\n    wget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm_langpack_zh-CN.tar.gz\n    wget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm.tar.gz    \n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ LibreOffice]# ls\n    LibreOffice_6.1.3.2_Linux_x86-64_rpm                 LibreOffice_6.1.3.2_Linux_x86-64_rpm_sdk                  LibreOffice_6.1.3_Linux_x86-64_rpm_sdk.tar.gz\n    LibreOffice_6.1.3.2_Linux_x86-64_rpm_langpack_zh-CN  LibreOffice_6.1.3_Linux_x86-64_rpm_langpack_zh-CN.tar.gz  LibreOffice_6.1.3_Linux_x86-64_rpm.tar.gz\n\n解压上面安装包，解压后，里面都有目录`RPMS`,安装里面的rpm包即可：   \n\n    yum localinstall *.rpm\n    \n很顺利的安装成功。    \n    \n下面检查libreoffice是否可用：    \n\n    把test.doc转换成html，保存在test目录\n    libreoffice6.0 --invisible --convert-to html --outdir ./test test.doc \n\n彻底卸载libreoffice：    \n\n    yum  erase libreoffice\\*\n \n#### 二.安装[redmine_preview_office](https://www.redmine.org/plugins/redmine_preview_office)插件\n \n进入redmine安装的根目录：   \n \n    # git clone https://github.com/HugoHasenbein/redmine_preview_office.git plugins/redmine_preview_office\n    # bundle exec rake redmine:plugins:migrate RAILS_ENV=production \n\n然后重启redmine即可。如下图：  \n\n{%asset_img b-1.png%}  \n\n说明插件安装成功了。\n\n卸载插件：\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# bundle exec rake redmine:plugins:migrate NAME=redmine_preview_office VERSION=0 RAILS_ENV=production\n    Migrating redmine_preview_office (Redmine Preview Office)...\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# rm -rf plugins/redmine_preview_office/\n\n重启redmine即可。\n\n#### 三.直接浏览文档\n\n点开一个问题的word文档，很遗憾，没能成功显示……\n\n坑爹……待续\n\n\n   \n        ","source":"_posts/redmine-plugins.md","raw":"---\ntitle: redmine常见插件安装使用\ndate: 2018-08-24 16:04:35\ncategories: redmine\ntags: redmine插件\n---\n\nredmine项目管理系统之所以强大并让大家喜欢，正是其插件化的管理模式。各种插件为其增添了不少上天入地的能力！     \n因此，我们在这里就来介绍redmine的插件功能的使用，以及收集一些在开发管理中常用的插件功能。\n\n## redmine插件的安装\n\n1.查找插件并下载(官方仓库)：\n\n官网地址：http://www.redmine.org/plugins?page=1\n\n为了避免下载的插件版本和redmine（3.4.*）的版本冲突，必须选定对应版本下的插件下载。       \n{%asset_img a.png%}         \n\n2.其它途径下载，比如github上。\n\n \n- 安装： \n\n下载插件到plugins目录下，然后执行`bundle exec rake redmine:plugins:migrate RAILS_ENV=production`，再然后重启即可。\n    \n- 卸载： \n\n先执行`bundle exec rake redmine:plugins:migrate NAME=plugin_name VERSION=0 RAILS_ENV=production`，然后删除plugins目录下相应的插件目录，重启就可以了。 \n\n\n## 切图粘贴插件`redmine_image_clipboard_paste`(推荐)\n\n下载网址：https://github.com/thorin/redmine_image_clipboard_paste    \n\n这个是人家改过的新版本，兼容redmine`3.3.*`版本，旧的版本`redmine_image_clipboard_paste`不可用\n1.安装：\n\n    cd /path/to/redmine/\n    git clone git://github.com/thorin/redmine_image_clipboard_paste.git plugins/redmine_image_clipboard_paste\n    bundle exec rake redmine:plugins:migrate RAILS_ENV=production\n    \n2.卸载：\n    \n    cd /path/to/redmine/\n    bundle exec rake redmine:plugins:migrate NAME=redmine_image_clipboard_paste VERSION=0 RAILS_ENV=production\n    rm -rf plugins/redmine_image_clipboard_paste\n    \n## 方便查看问题中的图片`Lightbox Plugin 2`\n\n在Lightbox更加方便的查看问题中的图片，那些小的图片，就不用再点击进去了，直接鼠标放上去就能看。 \n    \n    \n## 代码审查插件`Code Review`\n\n参考网址：http://www.redmine.org/plugins/redmine_code_review\n\n代码审查插件允许对代码仓库中的代码进行审查批阅，做注释。有效地对项目成员写的代码质量做出把控。 \n\n具体使用：\n\n## 工时单插件\n\n可以方便查看各个人的各个项目的工时情况\n\n地址：http://www.redmine.org/plugins/timesheet\n\n## 添加表情插件`Emoji Button`\n\n添加几个表情，使枯燥的编程工作变得更加有趣！  \n\n地址：http://www.redmine.org/plugins/redmine_emojibutton\n\n## office文档查看插件\n\n地址：https://www.redmine.org/plugins/redmine_preview_office\n\n### 安装\n\n实验环境：\n系统：centos7 64位  \nredmine：3.4.6   \nruby：2.3.6  \nrails：4.2.8\n\n#### 一.安装[libreoffice](https://www.libreoffice.org)\n\nlibreoffice提供命令把word文档，excel文档转成pdf格式等。这里同时提供了一个思路，开发应用时候，文档格式转换可以采用它。\n\n下载下面安装包到服务器：\n\n    wget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm_sdk.tar.gz\n    wget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm_langpack_zh-CN.tar.gz\n    wget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm.tar.gz    \n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ LibreOffice]# ls\n    LibreOffice_6.1.3.2_Linux_x86-64_rpm                 LibreOffice_6.1.3.2_Linux_x86-64_rpm_sdk                  LibreOffice_6.1.3_Linux_x86-64_rpm_sdk.tar.gz\n    LibreOffice_6.1.3.2_Linux_x86-64_rpm_langpack_zh-CN  LibreOffice_6.1.3_Linux_x86-64_rpm_langpack_zh-CN.tar.gz  LibreOffice_6.1.3_Linux_x86-64_rpm.tar.gz\n\n解压上面安装包，解压后，里面都有目录`RPMS`,安装里面的rpm包即可：   \n\n    yum localinstall *.rpm\n    \n很顺利的安装成功。    \n    \n下面检查libreoffice是否可用：    \n\n    把test.doc转换成html，保存在test目录\n    libreoffice6.0 --invisible --convert-to html --outdir ./test test.doc \n\n彻底卸载libreoffice：    \n\n    yum  erase libreoffice\\*\n \n#### 二.安装[redmine_preview_office](https://www.redmine.org/plugins/redmine_preview_office)插件\n \n进入redmine安装的根目录：   \n \n    # git clone https://github.com/HugoHasenbein/redmine_preview_office.git plugins/redmine_preview_office\n    # bundle exec rake redmine:plugins:migrate RAILS_ENV=production \n\n然后重启redmine即可。如下图：  \n\n{%asset_img b-1.png%}  \n\n说明插件安装成功了。\n\n卸载插件：\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# bundle exec rake redmine:plugins:migrate NAME=redmine_preview_office VERSION=0 RAILS_ENV=production\n    Migrating redmine_preview_office (Redmine Preview Office)...\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# rm -rf plugins/redmine_preview_office/\n\n重启redmine即可。\n\n#### 三.直接浏览文档\n\n点开一个问题的word文档，很遗憾，没能成功显示……\n\n坑爹……待续\n\n\n   \n        ","slug":"redmine-plugins","published":1,"updated":"2019-06-16T14:38:33.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqes009ig4vairjkr83k","content":"<p>redmine项目管理系统之所以强大并让大家喜欢，正是其插件化的管理模式。各种插件为其增添了不少上天入地的能力！<br>因此，我们在这里就来介绍redmine的插件功能的使用，以及收集一些在开发管理中常用的插件功能。</p>\n<h2 id=\"redmine插件的安装\"><a href=\"#redmine插件的安装\" class=\"headerlink\" title=\"redmine插件的安装\"></a>redmine插件的安装</h2><p>1.查找插件并下载(官方仓库)：</p>\n<p>官网地址：<a href=\"http://www.redmine.org/plugins?page=1\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins?page=1</a></p>\n<p>为了避免下载的插件版本和redmine（3.4.*）的版本冲突，必须选定对应版本下的插件下载。<br><img src=\"/2018/08/24/redmine-plugins/a.png\">         </p>\n<p>2.其它途径下载，比如github上。</p>\n<ul>\n<li>安装： </li>\n</ul>\n<p>下载插件到plugins目录下，然后执行<code>bundle exec rake redmine:plugins:migrate RAILS_ENV=production</code>，再然后重启即可。</p>\n<ul>\n<li>卸载： </li>\n</ul>\n<p>先执行<code>bundle exec rake redmine:plugins:migrate NAME=plugin_name VERSION=0 RAILS_ENV=production</code>，然后删除plugins目录下相应的插件目录，重启就可以了。 </p>\n<h2 id=\"切图粘贴插件redmine-image-clipboard-paste-推荐\"><a href=\"#切图粘贴插件redmine-image-clipboard-paste-推荐\" class=\"headerlink\" title=\"切图粘贴插件redmine_image_clipboard_paste(推荐)\"></a>切图粘贴插件<code>redmine_image_clipboard_paste</code>(推荐)</h2><p>下载网址：<a href=\"https://github.com/thorin/redmine_image_clipboard_paste\" target=\"_blank\" rel=\"noopener\">https://github.com/thorin/redmine_image_clipboard_paste</a>    </p>\n<p>这个是人家改过的新版本，兼容redmine<code>3.3.*</code>版本，旧的版本<code>redmine_image_clipboard_paste</code>不可用<br>1.安装：</p>\n<pre><code>cd /path/to/redmine/\ngit clone git://github.com/thorin/redmine_image_clipboard_paste.git plugins/redmine_image_clipboard_paste\nbundle exec rake redmine:plugins:migrate RAILS_ENV=production\n</code></pre><p>2.卸载：</p>\n<pre><code>cd /path/to/redmine/\nbundle exec rake redmine:plugins:migrate NAME=redmine_image_clipboard_paste VERSION=0 RAILS_ENV=production\nrm -rf plugins/redmine_image_clipboard_paste\n</code></pre><h2 id=\"方便查看问题中的图片Lightbox-Plugin-2\"><a href=\"#方便查看问题中的图片Lightbox-Plugin-2\" class=\"headerlink\" title=\"方便查看问题中的图片Lightbox Plugin 2\"></a>方便查看问题中的图片<code>Lightbox Plugin 2</code></h2><p>在Lightbox更加方便的查看问题中的图片，那些小的图片，就不用再点击进去了，直接鼠标放上去就能看。 </p>\n<h2 id=\"代码审查插件Code-Review\"><a href=\"#代码审查插件Code-Review\" class=\"headerlink\" title=\"代码审查插件Code Review\"></a>代码审查插件<code>Code Review</code></h2><p>参考网址：<a href=\"http://www.redmine.org/plugins/redmine_code_review\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/redmine_code_review</a></p>\n<p>代码审查插件允许对代码仓库中的代码进行审查批阅，做注释。有效地对项目成员写的代码质量做出把控。 </p>\n<p>具体使用：</p>\n<h2 id=\"工时单插件\"><a href=\"#工时单插件\" class=\"headerlink\" title=\"工时单插件\"></a>工时单插件</h2><p>可以方便查看各个人的各个项目的工时情况</p>\n<p>地址：<a href=\"http://www.redmine.org/plugins/timesheet\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/timesheet</a></p>\n<h2 id=\"添加表情插件Emoji-Button\"><a href=\"#添加表情插件Emoji-Button\" class=\"headerlink\" title=\"添加表情插件Emoji Button\"></a>添加表情插件<code>Emoji Button</code></h2><p>添加几个表情，使枯燥的编程工作变得更加有趣！  </p>\n<p>地址：<a href=\"http://www.redmine.org/plugins/redmine_emojibutton\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/redmine_emojibutton</a></p>\n<h2 id=\"office文档查看插件\"><a href=\"#office文档查看插件\" class=\"headerlink\" title=\"office文档查看插件\"></a>office文档查看插件</h2><p>地址：<a href=\"https://www.redmine.org/plugins/redmine_preview_office\" target=\"_blank\" rel=\"noopener\">https://www.redmine.org/plugins/redmine_preview_office</a></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>实验环境：<br>系统：centos7 64位<br>redmine：3.4.6<br>ruby：2.3.6<br>rails：4.2.8</p>\n<h4 id=\"一-安装libreoffice\"><a href=\"#一-安装libreoffice\" class=\"headerlink\" title=\"一.安装libreoffice\"></a>一.安装<a href=\"https://www.libreoffice.org\" target=\"_blank\" rel=\"noopener\">libreoffice</a></h4><p>libreoffice提供命令把word文档，excel文档转成pdf格式等。这里同时提供了一个思路，开发应用时候，文档格式转换可以采用它。</p>\n<p>下载下面安装包到服务器：</p>\n<pre><code>wget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm_sdk.tar.gz\nwget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm_langpack_zh-CN.tar.gz\nwget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm.tar.gz    \n\n[root@iZwz9b0bqrkbhqd5lu2pwhZ LibreOffice]# ls\nLibreOffice_6.1.3.2_Linux_x86-64_rpm                 LibreOffice_6.1.3.2_Linux_x86-64_rpm_sdk                  LibreOffice_6.1.3_Linux_x86-64_rpm_sdk.tar.gz\nLibreOffice_6.1.3.2_Linux_x86-64_rpm_langpack_zh-CN  LibreOffice_6.1.3_Linux_x86-64_rpm_langpack_zh-CN.tar.gz  LibreOffice_6.1.3_Linux_x86-64_rpm.tar.gz\n</code></pre><p>解压上面安装包，解压后，里面都有目录<code>RPMS</code>,安装里面的rpm包即可：   </p>\n<pre><code>yum localinstall *.rpm\n</code></pre><p>很顺利的安装成功。    </p>\n<p>下面检查libreoffice是否可用：    </p>\n<pre><code>把test.doc转换成html，保存在test目录\nlibreoffice6.0 --invisible --convert-to html --outdir ./test test.doc \n</code></pre><p>彻底卸载libreoffice：    </p>\n<pre><code>yum  erase libreoffice\\*\n</code></pre><h4 id=\"二-安装redmine-preview-office插件\"><a href=\"#二-安装redmine-preview-office插件\" class=\"headerlink\" title=\"二.安装redmine_preview_office插件\"></a>二.安装<a href=\"https://www.redmine.org/plugins/redmine_preview_office\" target=\"_blank\" rel=\"noopener\">redmine_preview_office</a>插件</h4><p>进入redmine安装的根目录：   </p>\n<pre><code># git clone https://github.com/HugoHasenbein/redmine_preview_office.git plugins/redmine_preview_office\n# bundle exec rake redmine:plugins:migrate RAILS_ENV=production \n</code></pre><p>然后重启redmine即可。如下图：  </p>\n<img src=\"/2018/08/24/redmine-plugins/b-1.png\">  \n<p>说明插件安装成功了。</p>\n<p>卸载插件：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# bundle exec rake redmine:plugins:migrate NAME=redmine_preview_office VERSION=0 RAILS_ENV=production\nMigrating redmine_preview_office (Redmine Preview Office)...\n[root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# rm -rf plugins/redmine_preview_office/\n</code></pre><p>重启redmine即可。</p>\n<h4 id=\"三-直接浏览文档\"><a href=\"#三-直接浏览文档\" class=\"headerlink\" title=\"三.直接浏览文档\"></a>三.直接浏览文档</h4><p>点开一个问题的word文档，很遗憾，没能成功显示……</p>\n<p>坑爹……待续</p>\n","site":{"data":{}},"excerpt":"","more":"<p>redmine项目管理系统之所以强大并让大家喜欢，正是其插件化的管理模式。各种插件为其增添了不少上天入地的能力！<br>因此，我们在这里就来介绍redmine的插件功能的使用，以及收集一些在开发管理中常用的插件功能。</p>\n<h2 id=\"redmine插件的安装\"><a href=\"#redmine插件的安装\" class=\"headerlink\" title=\"redmine插件的安装\"></a>redmine插件的安装</h2><p>1.查找插件并下载(官方仓库)：</p>\n<p>官网地址：<a href=\"http://www.redmine.org/plugins?page=1\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins?page=1</a></p>\n<p>为了避免下载的插件版本和redmine（3.4.*）的版本冲突，必须选定对应版本下的插件下载。<br><img src=\"/2018/08/24/redmine-plugins/a.png\">         </p>\n<p>2.其它途径下载，比如github上。</p>\n<ul>\n<li>安装： </li>\n</ul>\n<p>下载插件到plugins目录下，然后执行<code>bundle exec rake redmine:plugins:migrate RAILS_ENV=production</code>，再然后重启即可。</p>\n<ul>\n<li>卸载： </li>\n</ul>\n<p>先执行<code>bundle exec rake redmine:plugins:migrate NAME=plugin_name VERSION=0 RAILS_ENV=production</code>，然后删除plugins目录下相应的插件目录，重启就可以了。 </p>\n<h2 id=\"切图粘贴插件redmine-image-clipboard-paste-推荐\"><a href=\"#切图粘贴插件redmine-image-clipboard-paste-推荐\" class=\"headerlink\" title=\"切图粘贴插件redmine_image_clipboard_paste(推荐)\"></a>切图粘贴插件<code>redmine_image_clipboard_paste</code>(推荐)</h2><p>下载网址：<a href=\"https://github.com/thorin/redmine_image_clipboard_paste\" target=\"_blank\" rel=\"noopener\">https://github.com/thorin/redmine_image_clipboard_paste</a>    </p>\n<p>这个是人家改过的新版本，兼容redmine<code>3.3.*</code>版本，旧的版本<code>redmine_image_clipboard_paste</code>不可用<br>1.安装：</p>\n<pre><code>cd /path/to/redmine/\ngit clone git://github.com/thorin/redmine_image_clipboard_paste.git plugins/redmine_image_clipboard_paste\nbundle exec rake redmine:plugins:migrate RAILS_ENV=production\n</code></pre><p>2.卸载：</p>\n<pre><code>cd /path/to/redmine/\nbundle exec rake redmine:plugins:migrate NAME=redmine_image_clipboard_paste VERSION=0 RAILS_ENV=production\nrm -rf plugins/redmine_image_clipboard_paste\n</code></pre><h2 id=\"方便查看问题中的图片Lightbox-Plugin-2\"><a href=\"#方便查看问题中的图片Lightbox-Plugin-2\" class=\"headerlink\" title=\"方便查看问题中的图片Lightbox Plugin 2\"></a>方便查看问题中的图片<code>Lightbox Plugin 2</code></h2><p>在Lightbox更加方便的查看问题中的图片，那些小的图片，就不用再点击进去了，直接鼠标放上去就能看。 </p>\n<h2 id=\"代码审查插件Code-Review\"><a href=\"#代码审查插件Code-Review\" class=\"headerlink\" title=\"代码审查插件Code Review\"></a>代码审查插件<code>Code Review</code></h2><p>参考网址：<a href=\"http://www.redmine.org/plugins/redmine_code_review\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/redmine_code_review</a></p>\n<p>代码审查插件允许对代码仓库中的代码进行审查批阅，做注释。有效地对项目成员写的代码质量做出把控。 </p>\n<p>具体使用：</p>\n<h2 id=\"工时单插件\"><a href=\"#工时单插件\" class=\"headerlink\" title=\"工时单插件\"></a>工时单插件</h2><p>可以方便查看各个人的各个项目的工时情况</p>\n<p>地址：<a href=\"http://www.redmine.org/plugins/timesheet\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/timesheet</a></p>\n<h2 id=\"添加表情插件Emoji-Button\"><a href=\"#添加表情插件Emoji-Button\" class=\"headerlink\" title=\"添加表情插件Emoji Button\"></a>添加表情插件<code>Emoji Button</code></h2><p>添加几个表情，使枯燥的编程工作变得更加有趣！  </p>\n<p>地址：<a href=\"http://www.redmine.org/plugins/redmine_emojibutton\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/redmine_emojibutton</a></p>\n<h2 id=\"office文档查看插件\"><a href=\"#office文档查看插件\" class=\"headerlink\" title=\"office文档查看插件\"></a>office文档查看插件</h2><p>地址：<a href=\"https://www.redmine.org/plugins/redmine_preview_office\" target=\"_blank\" rel=\"noopener\">https://www.redmine.org/plugins/redmine_preview_office</a></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>实验环境：<br>系统：centos7 64位<br>redmine：3.4.6<br>ruby：2.3.6<br>rails：4.2.8</p>\n<h4 id=\"一-安装libreoffice\"><a href=\"#一-安装libreoffice\" class=\"headerlink\" title=\"一.安装libreoffice\"></a>一.安装<a href=\"https://www.libreoffice.org\" target=\"_blank\" rel=\"noopener\">libreoffice</a></h4><p>libreoffice提供命令把word文档，excel文档转成pdf格式等。这里同时提供了一个思路，开发应用时候，文档格式转换可以采用它。</p>\n<p>下载下面安装包到服务器：</p>\n<pre><code>wget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm_sdk.tar.gz\nwget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm_langpack_zh-CN.tar.gz\nwget https://downloadarchive.documentfoundation.org/libreoffice/old/5.3.6.1/rpm/x86_64/LibreOffice_5.3.6.1_Linux_x86-64_rpm.tar.gz    \n\n[root@iZwz9b0bqrkbhqd5lu2pwhZ LibreOffice]# ls\nLibreOffice_6.1.3.2_Linux_x86-64_rpm                 LibreOffice_6.1.3.2_Linux_x86-64_rpm_sdk                  LibreOffice_6.1.3_Linux_x86-64_rpm_sdk.tar.gz\nLibreOffice_6.1.3.2_Linux_x86-64_rpm_langpack_zh-CN  LibreOffice_6.1.3_Linux_x86-64_rpm_langpack_zh-CN.tar.gz  LibreOffice_6.1.3_Linux_x86-64_rpm.tar.gz\n</code></pre><p>解压上面安装包，解压后，里面都有目录<code>RPMS</code>,安装里面的rpm包即可：   </p>\n<pre><code>yum localinstall *.rpm\n</code></pre><p>很顺利的安装成功。    </p>\n<p>下面检查libreoffice是否可用：    </p>\n<pre><code>把test.doc转换成html，保存在test目录\nlibreoffice6.0 --invisible --convert-to html --outdir ./test test.doc \n</code></pre><p>彻底卸载libreoffice：    </p>\n<pre><code>yum  erase libreoffice\\*\n</code></pre><h4 id=\"二-安装redmine-preview-office插件\"><a href=\"#二-安装redmine-preview-office插件\" class=\"headerlink\" title=\"二.安装redmine_preview_office插件\"></a>二.安装<a href=\"https://www.redmine.org/plugins/redmine_preview_office\" target=\"_blank\" rel=\"noopener\">redmine_preview_office</a>插件</h4><p>进入redmine安装的根目录：   </p>\n<pre><code># git clone https://github.com/HugoHasenbein/redmine_preview_office.git plugins/redmine_preview_office\n# bundle exec rake redmine:plugins:migrate RAILS_ENV=production \n</code></pre><p>然后重启redmine即可。如下图：  </p>\n<img src=\"/2018/08/24/redmine-plugins/b-1.png\">  \n<p>说明插件安装成功了。</p>\n<p>卸载插件：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# bundle exec rake redmine:plugins:migrate NAME=redmine_preview_office VERSION=0 RAILS_ENV=production\nMigrating redmine_preview_office (Redmine Preview Office)...\n[root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# rm -rf plugins/redmine_preview_office/\n</code></pre><p>重启redmine即可。</p>\n<h4 id=\"三-直接浏览文档\"><a href=\"#三-直接浏览文档\" class=\"headerlink\" title=\"三.直接浏览文档\"></a>三.直接浏览文档</h4><p>点开一个问题的word文档，很遗憾，没能成功显示……</p>\n<p>坑爹……待续</p>\n"},{"title":"项目管理系统Redmine使用","date":"2018-06-01T13:35:04.000Z","_content":"\n在软件开发过程中，项目管理的有效性直接会影响到项目开发的进度，质量，还有整个团队的协助。总之，没有一个好的项目管理系统，这对项目经理来说就像是上了战场，却没有任何武器一样，必定败仗。  \n\n下面介绍这款比较流行的项目管理工具redmine。有了它，项目经理就可以对整个项目的开发全过程进行管理。任务的分配、bug的跟踪、知识库的建立等等……\n\n[官网](http://www.redmine.org)\n\n## 在ubuntu下安装\n\n参考：http://www.redmine.org/projects/redmine/wiki/Guide\n\n###　下载redmine安装包\n\n网址：http://www.redmine.org/projects/redmine/wiki/Download\n\n    wget http://www.redmine.org/releases/redmine-3.4.5.tar.gz\n    \n\n### 安装Ruby环境\n\n参考官网说明，注意redmine版本对ruby版本的要求。 \n\n1.下载地址：http://ftp.ruby-lang.org/pub/ruby/   \n    \n    //下载\n    zmt@zmt-Lenovo:~/Desktop/work/tools$ wget http://ftp.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz\n    zmt@zmt-Lenovo:~/Desktop/work/tools$ tar -zxvf ruby-2.4.4.tar.gz \n    \n    //查询openssl安装路径\n    zmt@zmt-Lenovo:~$ openssl version -a\n    OpenSSL 1.1.0g  2 Nov 2017\n    built on: reproducible build, date unspecified\n    platform: debian-amd64\n    compiler: gcc -DDSO_DLFCN -DHAVE_DLFCN_H -DNDEBUG -DOPENSSL_THREADS -DOPENSSL_NO_STATIC_ENGINE -DOPENSSL_PIC -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DOPENSSLDIR=\"\\\"/usr/lib/ssl\\\"\" -DENGINESDIR=\"\\\"/usr/lib/x86_64-linux-gnu/engines-1.1\\\"\" \n    OPENSSLDIR: \"/usr/lib/ssl\"\n    ENGINESDIR: \"/usr/lib/x86_64-linux-gnu/engines-1.1\"\n    \n    //看上面结果，确定openssl安装dir为：/usr/lib/ssl\n    \n    //安装：\n    $ cd ruby-2.4.4\n    $ ./configure  --with-openssl-dir=/usr/lib/ssl\n    $ make\n    $ sudo make install\n    \n    \n3.检查是否安装成功：    \n    \n    zmt@zmt-Lenovo:~$ ruby -v\n    ruby 2.4.4p296 (2018-03-28 revision 63013) [x86_64-linux]\n\n看到上面显示说明安装成功。\n\n### 创建空的数据库，并初始化用户\n\n一般数据库名为redmine,但是可以自己更改。\n\n1.MySQL\n\n创建数据库登录用户redmine，密码为redmine\n    \n    //mysql要求５.6或以上版本\n    \n    CREATE DATABASE redmine CHARACTER SET utf8mb4;\n    CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';   \n    \n    //刷新权限\n    flush privileges;\n    \n\n### 数据库连接配置设置\n\n解压下载的`redmine-3.4.5.tar.gz`， 并进入解压包内。 在`config`目录下，可以看到文件`database.yml.example`，复制该文件命名为`database.yml`，放在同一个目录`config`下。下面就可以编辑文件`database.yml`了。  \n\n1.mysql的配置\n\n- 默认端口3306\n\n        production:\n          adapter: mysql2\n          database: redmine\n          host: localhost\n          username: redmine\n          password: redmine\n\n- 不是3306端口，如下配置：\n\n        production:\n          adapter: mysql2\n          database: redmine\n          host: localhost\n          port: 3307\n          username: redmine\n          password: redmine\n          \n按照以上配置修改好，保存并退出。\n\n### redmine运行相关依赖包安装\n\nRedmine uses [Bundler](http://gembundler.com/) to manage gems dependencies.   \n\n1.首先按照Bundler\n\n    sudo gem install bundler\n    \n报错误：\n\n    zmt@zmt-Lenovo:~$ gem install bundler\n    ERROR:  While executing gem ... (Gem::Exception)\n        Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources\n\n意思是，要要求系统按照OpenSSL，然后按上面步骤重新编译安装ruby。\n\n按照openssl：\n    \n    sudo apt-get install openssl\n    \n重新编译按照ruby后再执行`gem install bundler`。      \n\n还是不行，可能是因为不是以root用户安装的缘故。 \n\n_注：_  没关系，我们不通过网络安装，而是直接下载gem安装包安装。\n\n\n    安装RubyGems安装\n    \n    如果第一步能执行成功，不需要另外安装rubygems，因为安装ruby的时候已经安装。 \n    \n    网址：https://rubygems.org/\n    \n    下载并安装：\n    \n        # wget https://rubygems.global.ssl.fastly.net/rubygems/rubygems-2.6.6.tgz\n        # tar zxvf rubygems-2.6.6.tgz\n        # cd rubygems-2.6.6.tgz\n        # ruby setup.rb\n        \n        //显示版本好，说民安装成功\n        zmt@zmt-Lenovo:~/Desktop/work/tools/rubygems-2.6.6$ gem -v\n        2.6.6\n                      \n    安装成功，重新执行步骤1，即安装Bundler，执行：\n    \n        gem install bundler\n\n \n2.然后可以利用bundler安装redmine相关依赖包\n\nThen you can install all the gems required by Redmine using the following command:\n\n    bundle install --without development test\n    \n<<----未完--->>\n\n## Centos7下安装全过程记录\n\n参考网址：http://www.redmine.org/projects/redmine/wiki/RedmineInstall\n\n应用版本信息：\nredmine： redmine-3.4.6.tar.gz   \nruby： ruby-2.3.6.tar.gz\n\n首先安装系统相关包：\n\n    yum -y install patch make gcc gcc-c++ gcc-g77 flex* bison file  \n    yum -y install libtool libtool-libs libtool-ltdl-devel* autoconf kernel-devel automake libmcrypt*  \n    yum -y install libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel  \n    yum -y install freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel  \n    yum -y install glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel  \n    yum -y install ncurses ncurses-devel curl curl-devel e2fsprogs  \n    yum -y install e2fsprogs-devel krb5 krb5-devel libidn libidn-devel  \n    yum -y install openssl openssl-devel vim-minimal nano sendmail  \n    yum -y install fonts-chinese gettext gettext-devel  \n    yum -y install gmp-devel pspell-devel   \n    yum -y install readline* libxslt* pcre* net-snmp* gmp* libtidy*  \n    yum -y install ImageMagick* subversion*  \n\n### 下载redmine安装包\n\n可以在官网下载正式发布的二进制包[下载](http://www.redmine.org/projects/redmine/wiki/Download)。 \n\n### 创建空的数据库以及相关数据库用户\n\n首先要保证已经安装好数据库。下面以mysql为例进行安装。mysql版本>5.5.2。     \n创建脚本：    \n   \n    CREATE DATABASE redmine CHARACTER SET utf8mb4;\n    #CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password'; #这样的，navicat客户端无法登录\n    CREATE USER 'redmine'@'localhost' IDENTIFIED WITH mysql_native_password BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';\n    \n### 为redmine配置数据库\n\n首先，解压redmine包，并进入config目录。  \n\n`[root@ymu config]# cp database.yml.example database.yml`\n\n然后编辑`database.yml`：\n\n    production:\n      adapter: mysql2\n      database: redmine\n      host: localhost\n      port: 3307\n      username: redmine\n      password: redmine\n      \n_注意_: 主机名用`localhost`可能报错，要改成`127.0.0.1`。      \n      \n### 安装依赖包\n\n1.安装ruby环境。\n\n- 安装上面描述方式，ruby源码包安装方式。选择版本安装。\n- 系统源安装。`yum install gem`。会自动安装ruby环境。\n\n下面采用源码编译安装方式。   \n检查是否安装成功：   \n`ruby -v`   `gem -v`\n\n问题解决：安装完ruby却提示`[/usr/bin/ruby: No such file or directory]`\n    \n`ln -s /usr/local/bin/ruby /usr/bin/ruby`   \n`ln -s /usr/local/bin/gem /usr/bin/gem` \n \n\n2.安装`bundler`\n\nredmine的依赖包都通过bundler来安装。   \n\n`gem install bundler`\n\n3.安装所有依赖\n\n执行下面命令前，记得要按照上面方法安装所有系统依赖包。\n\n    [root@ymu ~]# cd /server/tools/redmine-3.4.6/\n    [root@ymu redmine-3.4.6]# bundle install --without development test\n   \n\n### 安全生成存储会话\n\n`bundle exec rake generate_secret_token`\n \n\n### 创建表\n\n    [root@ymu redmine-3.4.6]# bundle exec rake generate_secret_token\n    [root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake db:migrate\n\n查看数据库，可以看到已经创建了很多表。     \n\n### 设置数据库默认数据\n\n    [root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake redmine:load_default_data\n    \n    Select language: ar, az, bg, bs, ca, cs, da, de, el, en, en-GB, es, es-PA, et, eu, fa, fi, fr, gl, he, hr, hu, id, it, ja, ko, lt, lv, mk, mn, nl, no, pl, pt, pt-BR, ro, ru, sk, sl, sq, sr, sr-YU, sv, th, tr, uk, vi, zh, zh-TW [en] zh\n    ====================================\n    Default configuration data loaded.\n\n记得：输入zh，然后按下回车。否则会是英文版本数据。\n\n### 设置文件权限\n\n- 如果上面的所有操作都是root用户，那么就不必要设置文件权限，可以跳过此步骤。 （_上面以root操作，跳过这步骤_）    \n- 如果不是在root超级用户下，则要设置文件权限，否则redmine应用程序无法操作一些文件权限。    \n\n在redmine解压根目录下，这些文件必须赋予权限：  \n\n    files (storage of attachments)\n    log (application log file production.log)\n    tmp and tmp/pdf (create these ones if not present, used to generate PDF documents among other things)\n    public/plugin_assets (assets of plugins)\n    \n如果没有这些文件：     \n    \n    mkdir -p tmp tmp/pdf public/plugin_assets\n    sudo chown -R redmine:redmine files log tmp public/plugin_assets\n    sudo chmod -R 755 files log tmp public/plugin_assets\n    \n如果都有：   \n\n     sudo chown -R redmine:redmine files log tmp public/plugin_assets\n     sudo chmod -R 755 files log tmp public/plugin_assets\n \n_注意_:保证下面目录不包含可执行文件。\n \n    sudo find files log tmp public/plugin_assets -type f -exec chmod -x {} +    \n    \n### 测试是否安装成功\n\n按照下面经验执行操作：\n\n    bundle exec rails server webrick -e production   //在redmine安装目录下执行\n    \n    //注意，服务器端执行上面命令可能报错，可能是端口不可用，可以改变端口：\n    bundle exec rails server webrick -e production -p 8889\n    \n    改变端口执行服务成功，但是在客户机子不能访问，此时要这么执行：\n     bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889\n    \n    ok搞定\n    \n    守护进程模式执行：\n     nohup bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 &\n    或者：\n    bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 -d    \n    \n然后就可以访问：http：//loaclhost:port。  \n\n### 登录redmine\n\n默认账号密码： \nusername=admin  \npwd=admin\n\n打开网址后，用默认账号密码登录后，会要求修改密码。把密码改为： \nusername=admin  \npwd=admin123    \n\n按页面提示，填写修改相关信息即可。   \n\n### 修改配置（不修改则采用默认的配置）\n\nredmine的配置设置文件放在：config/configuration.yml。  \n如果要自己定义配置，则可以`copy config/configuration.yml.example to config/configuration.yml`，然后编辑`configuration.yml`文件即可。 \n\n记得：修改配置文件后重启redmine，否则不生效。  \n\n### 重启redmine\n\n采用直接kill掉：\n\n    lsof -i:3000\n    kill -9 pid\n    \n### 开机自启\n\n编辑启动文件\n\nvi /etc/rc.local\n\n最后一行或者适当的位置，加入一下内容。此处必须用绝对路径。注意根据实际redmine路径来填写。\n\n/usr/local/rvm/rubies/ruby-2.0.0-p598/bin/ruby /root/redmine-2.6.0/script/rails server webrick -e production -d    \n\n### 设置Email/SMTP服务器\n\n项目管理中，分配了任务或者测试提交了bug给某个开发人员，那么可以通过邮件及时的提醒他。    \n\n下面我们就来配置邮件服务器：  \n参考：http://www.redmine.org/projects/redmine/wiki/EmailConfiguration  \n\n1.编辑配置文件：config/configuration.yml\n\n添加邮箱服务器配置，异步发送邮件（qq邮箱为例子）：\n\n    email_delivery:\n        delivery_method: :async_smtp\n        async_smtp_settings:\n          address: \"smtp.qq.com\"\n          port: 25\n          authentication: :login\n          domain: 'qq.com'\n          user_name: '932852117@qq.com'\n          password: '××××××'\n              \n下面是实际操作内容：              \n\n    # default configuration options for all environments\n    default:\n      # Outgoing emails configuration\n      # See the examples below and the Rails guide for more configuration options:\n      # http://guides.rubyonrails.org/action_mailer_basics.html#action-mailer-configuration\n      email_delivery:\n        delivery_method: :async_smtp\n        async_smtp_settings:\n          address: \"smtp.qq.com\"\n          port: 25\n          authentication: :login\n          domain: 'qq.com'\n          user_name: '932852117@qq.com'\n          password: '××××××'\n    \n      # ==== Simple SMTP server at localhost\n\n2.开启邮箱服务器\n\n{%asset_img b.png%}\n\n3.重启redmine并测试是否配置成功。 \n        \n登录redmine，在管理->配置中： \n\n{%asset_img c.png%}\n\n输入配置的邮箱地址后，保存。然后点击右下角的`发送测试邮件`：     \n\n{%asset_img d.png%}\n\n看到绿色提示`邮件已发送至 zhangmutian@xcsqjr.com`。证明配置已成功，可以愉快的使用了。\n\n\n### scm配置\n\n主要是svn和git版本库管理工具。  \n\n如：svn的  \n`scm_subversion_command: \"svn_replacement.exe\"`\n\n只需要安装svn或者git服务端，然后在配置文件指向即可。   \n\n### 其它的配置\n\n一般采用默认的就好了。 \n\n1.附件存储路径。`attachments_storage_path: /var/redmine/files`   \n2.日志保存路径。   \n\n等等……\n\n------------------------------------------------------\n\n恭喜恭喜，到此，你已成功安装redmine了，并且它已经具备了该有的基础功能了。赶紧来看下它帅帅的样子吧：\n\n{%asset_img a.png%}\n\n尽情的去探索redmine很多很多，酷酷的特性吧，让它正真成为你在项目管理中的瑞士军刀……\n\n\n\n\n\n          ","source":"_posts/redmine-start.md","raw":"---\ntitle: 项目管理系统Redmine使用\ndate: 2018-06-01 21:35:04\ncategories: redmine\ntags: \n---\n\n在软件开发过程中，项目管理的有效性直接会影响到项目开发的进度，质量，还有整个团队的协助。总之，没有一个好的项目管理系统，这对项目经理来说就像是上了战场，却没有任何武器一样，必定败仗。  \n\n下面介绍这款比较流行的项目管理工具redmine。有了它，项目经理就可以对整个项目的开发全过程进行管理。任务的分配、bug的跟踪、知识库的建立等等……\n\n[官网](http://www.redmine.org)\n\n## 在ubuntu下安装\n\n参考：http://www.redmine.org/projects/redmine/wiki/Guide\n\n###　下载redmine安装包\n\n网址：http://www.redmine.org/projects/redmine/wiki/Download\n\n    wget http://www.redmine.org/releases/redmine-3.4.5.tar.gz\n    \n\n### 安装Ruby环境\n\n参考官网说明，注意redmine版本对ruby版本的要求。 \n\n1.下载地址：http://ftp.ruby-lang.org/pub/ruby/   \n    \n    //下载\n    zmt@zmt-Lenovo:~/Desktop/work/tools$ wget http://ftp.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz\n    zmt@zmt-Lenovo:~/Desktop/work/tools$ tar -zxvf ruby-2.4.4.tar.gz \n    \n    //查询openssl安装路径\n    zmt@zmt-Lenovo:~$ openssl version -a\n    OpenSSL 1.1.0g  2 Nov 2017\n    built on: reproducible build, date unspecified\n    platform: debian-amd64\n    compiler: gcc -DDSO_DLFCN -DHAVE_DLFCN_H -DNDEBUG -DOPENSSL_THREADS -DOPENSSL_NO_STATIC_ENGINE -DOPENSSL_PIC -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DOPENSSLDIR=\"\\\"/usr/lib/ssl\\\"\" -DENGINESDIR=\"\\\"/usr/lib/x86_64-linux-gnu/engines-1.1\\\"\" \n    OPENSSLDIR: \"/usr/lib/ssl\"\n    ENGINESDIR: \"/usr/lib/x86_64-linux-gnu/engines-1.1\"\n    \n    //看上面结果，确定openssl安装dir为：/usr/lib/ssl\n    \n    //安装：\n    $ cd ruby-2.4.4\n    $ ./configure  --with-openssl-dir=/usr/lib/ssl\n    $ make\n    $ sudo make install\n    \n    \n3.检查是否安装成功：    \n    \n    zmt@zmt-Lenovo:~$ ruby -v\n    ruby 2.4.4p296 (2018-03-28 revision 63013) [x86_64-linux]\n\n看到上面显示说明安装成功。\n\n### 创建空的数据库，并初始化用户\n\n一般数据库名为redmine,但是可以自己更改。\n\n1.MySQL\n\n创建数据库登录用户redmine，密码为redmine\n    \n    //mysql要求５.6或以上版本\n    \n    CREATE DATABASE redmine CHARACTER SET utf8mb4;\n    CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';   \n    \n    //刷新权限\n    flush privileges;\n    \n\n### 数据库连接配置设置\n\n解压下载的`redmine-3.4.5.tar.gz`， 并进入解压包内。 在`config`目录下，可以看到文件`database.yml.example`，复制该文件命名为`database.yml`，放在同一个目录`config`下。下面就可以编辑文件`database.yml`了。  \n\n1.mysql的配置\n\n- 默认端口3306\n\n        production:\n          adapter: mysql2\n          database: redmine\n          host: localhost\n          username: redmine\n          password: redmine\n\n- 不是3306端口，如下配置：\n\n        production:\n          adapter: mysql2\n          database: redmine\n          host: localhost\n          port: 3307\n          username: redmine\n          password: redmine\n          \n按照以上配置修改好，保存并退出。\n\n### redmine运行相关依赖包安装\n\nRedmine uses [Bundler](http://gembundler.com/) to manage gems dependencies.   \n\n1.首先按照Bundler\n\n    sudo gem install bundler\n    \n报错误：\n\n    zmt@zmt-Lenovo:~$ gem install bundler\n    ERROR:  While executing gem ... (Gem::Exception)\n        Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources\n\n意思是，要要求系统按照OpenSSL，然后按上面步骤重新编译安装ruby。\n\n按照openssl：\n    \n    sudo apt-get install openssl\n    \n重新编译按照ruby后再执行`gem install bundler`。      \n\n还是不行，可能是因为不是以root用户安装的缘故。 \n\n_注：_  没关系，我们不通过网络安装，而是直接下载gem安装包安装。\n\n\n    安装RubyGems安装\n    \n    如果第一步能执行成功，不需要另外安装rubygems，因为安装ruby的时候已经安装。 \n    \n    网址：https://rubygems.org/\n    \n    下载并安装：\n    \n        # wget https://rubygems.global.ssl.fastly.net/rubygems/rubygems-2.6.6.tgz\n        # tar zxvf rubygems-2.6.6.tgz\n        # cd rubygems-2.6.6.tgz\n        # ruby setup.rb\n        \n        //显示版本好，说民安装成功\n        zmt@zmt-Lenovo:~/Desktop/work/tools/rubygems-2.6.6$ gem -v\n        2.6.6\n                      \n    安装成功，重新执行步骤1，即安装Bundler，执行：\n    \n        gem install bundler\n\n \n2.然后可以利用bundler安装redmine相关依赖包\n\nThen you can install all the gems required by Redmine using the following command:\n\n    bundle install --without development test\n    \n<<----未完--->>\n\n## Centos7下安装全过程记录\n\n参考网址：http://www.redmine.org/projects/redmine/wiki/RedmineInstall\n\n应用版本信息：\nredmine： redmine-3.4.6.tar.gz   \nruby： ruby-2.3.6.tar.gz\n\n首先安装系统相关包：\n\n    yum -y install patch make gcc gcc-c++ gcc-g77 flex* bison file  \n    yum -y install libtool libtool-libs libtool-ltdl-devel* autoconf kernel-devel automake libmcrypt*  \n    yum -y install libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel  \n    yum -y install freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel  \n    yum -y install glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel  \n    yum -y install ncurses ncurses-devel curl curl-devel e2fsprogs  \n    yum -y install e2fsprogs-devel krb5 krb5-devel libidn libidn-devel  \n    yum -y install openssl openssl-devel vim-minimal nano sendmail  \n    yum -y install fonts-chinese gettext gettext-devel  \n    yum -y install gmp-devel pspell-devel   \n    yum -y install readline* libxslt* pcre* net-snmp* gmp* libtidy*  \n    yum -y install ImageMagick* subversion*  \n\n### 下载redmine安装包\n\n可以在官网下载正式发布的二进制包[下载](http://www.redmine.org/projects/redmine/wiki/Download)。 \n\n### 创建空的数据库以及相关数据库用户\n\n首先要保证已经安装好数据库。下面以mysql为例进行安装。mysql版本>5.5.2。     \n创建脚本：    \n   \n    CREATE DATABASE redmine CHARACTER SET utf8mb4;\n    #CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password'; #这样的，navicat客户端无法登录\n    CREATE USER 'redmine'@'localhost' IDENTIFIED WITH mysql_native_password BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';\n    \n### 为redmine配置数据库\n\n首先，解压redmine包，并进入config目录。  \n\n`[root@ymu config]# cp database.yml.example database.yml`\n\n然后编辑`database.yml`：\n\n    production:\n      adapter: mysql2\n      database: redmine\n      host: localhost\n      port: 3307\n      username: redmine\n      password: redmine\n      \n_注意_: 主机名用`localhost`可能报错，要改成`127.0.0.1`。      \n      \n### 安装依赖包\n\n1.安装ruby环境。\n\n- 安装上面描述方式，ruby源码包安装方式。选择版本安装。\n- 系统源安装。`yum install gem`。会自动安装ruby环境。\n\n下面采用源码编译安装方式。   \n检查是否安装成功：   \n`ruby -v`   `gem -v`\n\n问题解决：安装完ruby却提示`[/usr/bin/ruby: No such file or directory]`\n    \n`ln -s /usr/local/bin/ruby /usr/bin/ruby`   \n`ln -s /usr/local/bin/gem /usr/bin/gem` \n \n\n2.安装`bundler`\n\nredmine的依赖包都通过bundler来安装。   \n\n`gem install bundler`\n\n3.安装所有依赖\n\n执行下面命令前，记得要按照上面方法安装所有系统依赖包。\n\n    [root@ymu ~]# cd /server/tools/redmine-3.4.6/\n    [root@ymu redmine-3.4.6]# bundle install --without development test\n   \n\n### 安全生成存储会话\n\n`bundle exec rake generate_secret_token`\n \n\n### 创建表\n\n    [root@ymu redmine-3.4.6]# bundle exec rake generate_secret_token\n    [root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake db:migrate\n\n查看数据库，可以看到已经创建了很多表。     \n\n### 设置数据库默认数据\n\n    [root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake redmine:load_default_data\n    \n    Select language: ar, az, bg, bs, ca, cs, da, de, el, en, en-GB, es, es-PA, et, eu, fa, fi, fr, gl, he, hr, hu, id, it, ja, ko, lt, lv, mk, mn, nl, no, pl, pt, pt-BR, ro, ru, sk, sl, sq, sr, sr-YU, sv, th, tr, uk, vi, zh, zh-TW [en] zh\n    ====================================\n    Default configuration data loaded.\n\n记得：输入zh，然后按下回车。否则会是英文版本数据。\n\n### 设置文件权限\n\n- 如果上面的所有操作都是root用户，那么就不必要设置文件权限，可以跳过此步骤。 （_上面以root操作，跳过这步骤_）    \n- 如果不是在root超级用户下，则要设置文件权限，否则redmine应用程序无法操作一些文件权限。    \n\n在redmine解压根目录下，这些文件必须赋予权限：  \n\n    files (storage of attachments)\n    log (application log file production.log)\n    tmp and tmp/pdf (create these ones if not present, used to generate PDF documents among other things)\n    public/plugin_assets (assets of plugins)\n    \n如果没有这些文件：     \n    \n    mkdir -p tmp tmp/pdf public/plugin_assets\n    sudo chown -R redmine:redmine files log tmp public/plugin_assets\n    sudo chmod -R 755 files log tmp public/plugin_assets\n    \n如果都有：   \n\n     sudo chown -R redmine:redmine files log tmp public/plugin_assets\n     sudo chmod -R 755 files log tmp public/plugin_assets\n \n_注意_:保证下面目录不包含可执行文件。\n \n    sudo find files log tmp public/plugin_assets -type f -exec chmod -x {} +    \n    \n### 测试是否安装成功\n\n按照下面经验执行操作：\n\n    bundle exec rails server webrick -e production   //在redmine安装目录下执行\n    \n    //注意，服务器端执行上面命令可能报错，可能是端口不可用，可以改变端口：\n    bundle exec rails server webrick -e production -p 8889\n    \n    改变端口执行服务成功，但是在客户机子不能访问，此时要这么执行：\n     bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889\n    \n    ok搞定\n    \n    守护进程模式执行：\n     nohup bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 &\n    或者：\n    bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 -d    \n    \n然后就可以访问：http：//loaclhost:port。  \n\n### 登录redmine\n\n默认账号密码： \nusername=admin  \npwd=admin\n\n打开网址后，用默认账号密码登录后，会要求修改密码。把密码改为： \nusername=admin  \npwd=admin123    \n\n按页面提示，填写修改相关信息即可。   \n\n### 修改配置（不修改则采用默认的配置）\n\nredmine的配置设置文件放在：config/configuration.yml。  \n如果要自己定义配置，则可以`copy config/configuration.yml.example to config/configuration.yml`，然后编辑`configuration.yml`文件即可。 \n\n记得：修改配置文件后重启redmine，否则不生效。  \n\n### 重启redmine\n\n采用直接kill掉：\n\n    lsof -i:3000\n    kill -9 pid\n    \n### 开机自启\n\n编辑启动文件\n\nvi /etc/rc.local\n\n最后一行或者适当的位置，加入一下内容。此处必须用绝对路径。注意根据实际redmine路径来填写。\n\n/usr/local/rvm/rubies/ruby-2.0.0-p598/bin/ruby /root/redmine-2.6.0/script/rails server webrick -e production -d    \n\n### 设置Email/SMTP服务器\n\n项目管理中，分配了任务或者测试提交了bug给某个开发人员，那么可以通过邮件及时的提醒他。    \n\n下面我们就来配置邮件服务器：  \n参考：http://www.redmine.org/projects/redmine/wiki/EmailConfiguration  \n\n1.编辑配置文件：config/configuration.yml\n\n添加邮箱服务器配置，异步发送邮件（qq邮箱为例子）：\n\n    email_delivery:\n        delivery_method: :async_smtp\n        async_smtp_settings:\n          address: \"smtp.qq.com\"\n          port: 25\n          authentication: :login\n          domain: 'qq.com'\n          user_name: '932852117@qq.com'\n          password: '××××××'\n              \n下面是实际操作内容：              \n\n    # default configuration options for all environments\n    default:\n      # Outgoing emails configuration\n      # See the examples below and the Rails guide for more configuration options:\n      # http://guides.rubyonrails.org/action_mailer_basics.html#action-mailer-configuration\n      email_delivery:\n        delivery_method: :async_smtp\n        async_smtp_settings:\n          address: \"smtp.qq.com\"\n          port: 25\n          authentication: :login\n          domain: 'qq.com'\n          user_name: '932852117@qq.com'\n          password: '××××××'\n    \n      # ==== Simple SMTP server at localhost\n\n2.开启邮箱服务器\n\n{%asset_img b.png%}\n\n3.重启redmine并测试是否配置成功。 \n        \n登录redmine，在管理->配置中： \n\n{%asset_img c.png%}\n\n输入配置的邮箱地址后，保存。然后点击右下角的`发送测试邮件`：     \n\n{%asset_img d.png%}\n\n看到绿色提示`邮件已发送至 zhangmutian@xcsqjr.com`。证明配置已成功，可以愉快的使用了。\n\n\n### scm配置\n\n主要是svn和git版本库管理工具。  \n\n如：svn的  \n`scm_subversion_command: \"svn_replacement.exe\"`\n\n只需要安装svn或者git服务端，然后在配置文件指向即可。   \n\n### 其它的配置\n\n一般采用默认的就好了。 \n\n1.附件存储路径。`attachments_storage_path: /var/redmine/files`   \n2.日志保存路径。   \n\n等等……\n\n------------------------------------------------------\n\n恭喜恭喜，到此，你已成功安装redmine了，并且它已经具备了该有的基础功能了。赶紧来看下它帅帅的样子吧：\n\n{%asset_img a.png%}\n\n尽情的去探索redmine很多很多，酷酷的特性吧，让它正真成为你在项目管理中的瑞士军刀……\n\n\n\n\n\n          ","slug":"redmine-start","published":1,"updated":"2019-06-16T14:38:33.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqet009kg4vaeyfojoki","content":"<p>在软件开发过程中，项目管理的有效性直接会影响到项目开发的进度，质量，还有整个团队的协助。总之，没有一个好的项目管理系统，这对项目经理来说就像是上了战场，却没有任何武器一样，必定败仗。  </p>\n<p>下面介绍这款比较流行的项目管理工具redmine。有了它，项目经理就可以对整个项目的开发全过程进行管理。任务的分配、bug的跟踪、知识库的建立等等……</p>\n<p><a href=\"http://www.redmine.org\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"在ubuntu下安装\"><a href=\"#在ubuntu下安装\" class=\"headerlink\" title=\"在ubuntu下安装\"></a>在ubuntu下安装</h2><p>参考：<a href=\"http://www.redmine.org/projects/redmine/wiki/Guide\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/Guide</a></p>\n<p>###　下载redmine安装包</p>\n<p>网址：<a href=\"http://www.redmine.org/projects/redmine/wiki/Download\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/Download</a></p>\n<pre><code>wget http://www.redmine.org/releases/redmine-3.4.5.tar.gz\n</code></pre><h3 id=\"安装Ruby环境\"><a href=\"#安装Ruby环境\" class=\"headerlink\" title=\"安装Ruby环境\"></a>安装Ruby环境</h3><p>参考官网说明，注意redmine版本对ruby版本的要求。 </p>\n<p>1.下载地址：<a href=\"http://ftp.ruby-lang.org/pub/ruby/\" target=\"_blank\" rel=\"noopener\">http://ftp.ruby-lang.org/pub/ruby/</a>   </p>\n<pre><code>//下载\nzmt@zmt-Lenovo:~/Desktop/work/tools$ wget http://ftp.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz\nzmt@zmt-Lenovo:~/Desktop/work/tools$ tar -zxvf ruby-2.4.4.tar.gz \n\n//查询openssl安装路径\nzmt@zmt-Lenovo:~$ openssl version -a\nOpenSSL 1.1.0g  2 Nov 2017\nbuilt on: reproducible build, date unspecified\nplatform: debian-amd64\ncompiler: gcc -DDSO_DLFCN -DHAVE_DLFCN_H -DNDEBUG -DOPENSSL_THREADS -DOPENSSL_NO_STATIC_ENGINE -DOPENSSL_PIC -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DOPENSSLDIR=&quot;\\&quot;/usr/lib/ssl\\&quot;&quot; -DENGINESDIR=&quot;\\&quot;/usr/lib/x86_64-linux-gnu/engines-1.1\\&quot;&quot; \nOPENSSLDIR: &quot;/usr/lib/ssl&quot;\nENGINESDIR: &quot;/usr/lib/x86_64-linux-gnu/engines-1.1&quot;\n\n//看上面结果，确定openssl安装dir为：/usr/lib/ssl\n\n//安装：\n$ cd ruby-2.4.4\n$ ./configure  --with-openssl-dir=/usr/lib/ssl\n$ make\n$ sudo make install\n</code></pre><p>3.检查是否安装成功：    </p>\n<pre><code>zmt@zmt-Lenovo:~$ ruby -v\nruby 2.4.4p296 (2018-03-28 revision 63013) [x86_64-linux]\n</code></pre><p>看到上面显示说明安装成功。</p>\n<h3 id=\"创建空的数据库，并初始化用户\"><a href=\"#创建空的数据库，并初始化用户\" class=\"headerlink\" title=\"创建空的数据库，并初始化用户\"></a>创建空的数据库，并初始化用户</h3><p>一般数据库名为redmine,但是可以自己更改。</p>\n<p>1.MySQL</p>\n<p>创建数据库登录用户redmine，密码为redmine</p>\n<pre><code>//mysql要求５.6或以上版本\n\nCREATE DATABASE redmine CHARACTER SET utf8mb4;\nCREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;   \n\n//刷新权限\nflush privileges;\n</code></pre><h3 id=\"数据库连接配置设置\"><a href=\"#数据库连接配置设置\" class=\"headerlink\" title=\"数据库连接配置设置\"></a>数据库连接配置设置</h3><p>解压下载的<code>redmine-3.4.5.tar.gz</code>， 并进入解压包内。 在<code>config</code>目录下，可以看到文件<code>database.yml.example</code>，复制该文件命名为<code>database.yml</code>，放在同一个目录<code>config</code>下。下面就可以编辑文件<code>database.yml</code>了。  </p>\n<p>1.mysql的配置</p>\n<ul>\n<li><p>默认端口3306</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  username: redmine\n  password: redmine\n</code></pre></li>\n<li><p>不是3306端口，如下配置：</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  port: 3307\n  username: redmine\n  password: redmine\n</code></pre></li>\n</ul>\n<p>按照以上配置修改好，保存并退出。</p>\n<h3 id=\"redmine运行相关依赖包安装\"><a href=\"#redmine运行相关依赖包安装\" class=\"headerlink\" title=\"redmine运行相关依赖包安装\"></a>redmine运行相关依赖包安装</h3><p>Redmine uses <a href=\"http://gembundler.com/\" target=\"_blank\" rel=\"noopener\">Bundler</a> to manage gems dependencies.   </p>\n<p>1.首先按照Bundler</p>\n<pre><code>sudo gem install bundler\n</code></pre><p>报错误：</p>\n<pre><code>zmt@zmt-Lenovo:~$ gem install bundler\nERROR:  While executing gem ... (Gem::Exception)\n    Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources\n</code></pre><p>意思是，要要求系统按照OpenSSL，然后按上面步骤重新编译安装ruby。</p>\n<p>按照openssl：</p>\n<pre><code>sudo apt-get install openssl\n</code></pre><p>重新编译按照ruby后再执行<code>gem install bundler</code>。      </p>\n<p>还是不行，可能是因为不是以root用户安装的缘故。 </p>\n<p>_注：_  没关系，我们不通过网络安装，而是直接下载gem安装包安装。</p>\n<pre><code>安装RubyGems安装\n\n如果第一步能执行成功，不需要另外安装rubygems，因为安装ruby的时候已经安装。 \n\n网址：https://rubygems.org/\n\n下载并安装：\n\n    # wget https://rubygems.global.ssl.fastly.net/rubygems/rubygems-2.6.6.tgz\n    # tar zxvf rubygems-2.6.6.tgz\n    # cd rubygems-2.6.6.tgz\n    # ruby setup.rb\n\n    //显示版本好，说民安装成功\n    zmt@zmt-Lenovo:~/Desktop/work/tools/rubygems-2.6.6$ gem -v\n    2.6.6\n\n安装成功，重新执行步骤1，即安装Bundler，执行：\n\n    gem install bundler\n</code></pre><p>2.然后可以利用bundler安装redmine相关依赖包</p>\n<p>Then you can install all the gems required by Redmine using the following command:</p>\n<pre><code>bundle install --without development test\n</code></pre><p>&lt;&lt;—-未完—&gt;&gt;</p>\n<h2 id=\"Centos7下安装全过程记录\"><a href=\"#Centos7下安装全过程记录\" class=\"headerlink\" title=\"Centos7下安装全过程记录\"></a>Centos7下安装全过程记录</h2><p>参考网址：<a href=\"http://www.redmine.org/projects/redmine/wiki/RedmineInstall\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/RedmineInstall</a></p>\n<p>应用版本信息：<br>redmine： redmine-3.4.6.tar.gz<br>ruby： ruby-2.3.6.tar.gz</p>\n<p>首先安装系统相关包：</p>\n<pre><code>yum -y install patch make gcc gcc-c++ gcc-g77 flex* bison file  \nyum -y install libtool libtool-libs libtool-ltdl-devel* autoconf kernel-devel automake libmcrypt*  \nyum -y install libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel  \nyum -y install freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel  \nyum -y install glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel  \nyum -y install ncurses ncurses-devel curl curl-devel e2fsprogs  \nyum -y install e2fsprogs-devel krb5 krb5-devel libidn libidn-devel  \nyum -y install openssl openssl-devel vim-minimal nano sendmail  \nyum -y install fonts-chinese gettext gettext-devel  \nyum -y install gmp-devel pspell-devel   \nyum -y install readline* libxslt* pcre* net-snmp* gmp* libtidy*  \nyum -y install ImageMagick* subversion*  \n</code></pre><h3 id=\"下载redmine安装包\"><a href=\"#下载redmine安装包\" class=\"headerlink\" title=\"下载redmine安装包\"></a>下载redmine安装包</h3><p>可以在官网下载正式发布的二进制包<a href=\"http://www.redmine.org/projects/redmine/wiki/Download\" target=\"_blank\" rel=\"noopener\">下载</a>。 </p>\n<h3 id=\"创建空的数据库以及相关数据库用户\"><a href=\"#创建空的数据库以及相关数据库用户\" class=\"headerlink\" title=\"创建空的数据库以及相关数据库用户\"></a>创建空的数据库以及相关数据库用户</h3><p>首先要保证已经安装好数据库。下面以mysql为例进行安装。mysql版本&gt;5.5.2。<br>创建脚本：    </p>\n<pre><code>CREATE DATABASE redmine CHARACTER SET utf8mb4;\n#CREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;; #这样的，navicat客户端无法登录\nCREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;\n</code></pre><h3 id=\"为redmine配置数据库\"><a href=\"#为redmine配置数据库\" class=\"headerlink\" title=\"为redmine配置数据库\"></a>为redmine配置数据库</h3><p>首先，解压redmine包，并进入config目录。  </p>\n<p><code>[root@ymu config]# cp database.yml.example database.yml</code></p>\n<p>然后编辑<code>database.yml</code>：</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  port: 3307\n  username: redmine\n  password: redmine\n</code></pre><p>_注意_: 主机名用<code>localhost</code>可能报错，要改成<code>127.0.0.1</code>。      </p>\n<h3 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h3><p>1.安装ruby环境。</p>\n<ul>\n<li>安装上面描述方式，ruby源码包安装方式。选择版本安装。</li>\n<li>系统源安装。<code>yum install gem</code>。会自动安装ruby环境。</li>\n</ul>\n<p>下面采用源码编译安装方式。<br>检查是否安装成功：<br><code>ruby -v</code>   <code>gem -v</code></p>\n<p>问题解决：安装完ruby却提示<code>[/usr/bin/ruby: No such file or directory]</code></p>\n<p><code>ln -s /usr/local/bin/ruby /usr/bin/ruby</code><br><code>ln -s /usr/local/bin/gem /usr/bin/gem</code> </p>\n<p>2.安装<code>bundler</code></p>\n<p>redmine的依赖包都通过bundler来安装。   </p>\n<p><code>gem install bundler</code></p>\n<p>3.安装所有依赖</p>\n<p>执行下面命令前，记得要按照上面方法安装所有系统依赖包。</p>\n<pre><code>[root@ymu ~]# cd /server/tools/redmine-3.4.6/\n[root@ymu redmine-3.4.6]# bundle install --without development test\n</code></pre><h3 id=\"安全生成存储会话\"><a href=\"#安全生成存储会话\" class=\"headerlink\" title=\"安全生成存储会话\"></a>安全生成存储会话</h3><p><code>bundle exec rake generate_secret_token</code></p>\n<h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><pre><code>[root@ymu redmine-3.4.6]# bundle exec rake generate_secret_token\n[root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake db:migrate\n</code></pre><p>查看数据库，可以看到已经创建了很多表。     </p>\n<h3 id=\"设置数据库默认数据\"><a href=\"#设置数据库默认数据\" class=\"headerlink\" title=\"设置数据库默认数据\"></a>设置数据库默认数据</h3><pre><code>[root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake redmine:load_default_data\n\nSelect language: ar, az, bg, bs, ca, cs, da, de, el, en, en-GB, es, es-PA, et, eu, fa, fi, fr, gl, he, hr, hu, id, it, ja, ko, lt, lv, mk, mn, nl, no, pl, pt, pt-BR, ro, ru, sk, sl, sq, sr, sr-YU, sv, th, tr, uk, vi, zh, zh-TW [en] zh\n====================================\nDefault configuration data loaded.\n</code></pre><p>记得：输入zh，然后按下回车。否则会是英文版本数据。</p>\n<h3 id=\"设置文件权限\"><a href=\"#设置文件权限\" class=\"headerlink\" title=\"设置文件权限\"></a>设置文件权限</h3><ul>\n<li>如果上面的所有操作都是root用户，那么就不必要设置文件权限，可以跳过此步骤。 （<em>上面以root操作，跳过这步骤</em>）    </li>\n<li>如果不是在root超级用户下，则要设置文件权限，否则redmine应用程序无法操作一些文件权限。    </li>\n</ul>\n<p>在redmine解压根目录下，这些文件必须赋予权限：  </p>\n<pre><code>files (storage of attachments)\nlog (application log file production.log)\ntmp and tmp/pdf (create these ones if not present, used to generate PDF documents among other things)\npublic/plugin_assets (assets of plugins)\n</code></pre><p>如果没有这些文件：     </p>\n<pre><code>mkdir -p tmp tmp/pdf public/plugin_assets\nsudo chown -R redmine:redmine files log tmp public/plugin_assets\nsudo chmod -R 755 files log tmp public/plugin_assets\n</code></pre><p>如果都有：   </p>\n<pre><code>sudo chown -R redmine:redmine files log tmp public/plugin_assets\nsudo chmod -R 755 files log tmp public/plugin_assets\n</code></pre><p>_注意_:保证下面目录不包含可执行文件。</p>\n<pre><code>sudo find files log tmp public/plugin_assets -type f -exec chmod -x {} +    \n</code></pre><h3 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h3><p>按照下面经验执行操作：</p>\n<pre><code>bundle exec rails server webrick -e production   //在redmine安装目录下执行\n\n//注意，服务器端执行上面命令可能报错，可能是端口不可用，可以改变端口：\nbundle exec rails server webrick -e production -p 8889\n\n改变端口执行服务成功，但是在客户机子不能访问，此时要这么执行：\n bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889\n\nok搞定\n\n守护进程模式执行：\n nohup bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 &amp;\n或者：\nbundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 -d    \n</code></pre><p>然后就可以访问：http：//loaclhost:port。  </p>\n<h3 id=\"登录redmine\"><a href=\"#登录redmine\" class=\"headerlink\" title=\"登录redmine\"></a>登录redmine</h3><p>默认账号密码：<br>username=admin<br>pwd=admin</p>\n<p>打开网址后，用默认账号密码登录后，会要求修改密码。把密码改为：<br>username=admin<br>pwd=admin123    </p>\n<p>按页面提示，填写修改相关信息即可。   </p>\n<h3 id=\"修改配置（不修改则采用默认的配置）\"><a href=\"#修改配置（不修改则采用默认的配置）\" class=\"headerlink\" title=\"修改配置（不修改则采用默认的配置）\"></a>修改配置（不修改则采用默认的配置）</h3><p>redmine的配置设置文件放在：config/configuration.yml。<br>如果要自己定义配置，则可以<code>copy config/configuration.yml.example to config/configuration.yml</code>，然后编辑<code>configuration.yml</code>文件即可。 </p>\n<p>记得：修改配置文件后重启redmine，否则不生效。  </p>\n<h3 id=\"重启redmine\"><a href=\"#重启redmine\" class=\"headerlink\" title=\"重启redmine\"></a>重启redmine</h3><p>采用直接kill掉：</p>\n<pre><code>lsof -i:3000\nkill -9 pid\n</code></pre><h3 id=\"开机自启\"><a href=\"#开机自启\" class=\"headerlink\" title=\"开机自启\"></a>开机自启</h3><p>编辑启动文件</p>\n<p>vi /etc/rc.local</p>\n<p>最后一行或者适当的位置，加入一下内容。此处必须用绝对路径。注意根据实际redmine路径来填写。</p>\n<p>/usr/local/rvm/rubies/ruby-2.0.0-p598/bin/ruby /root/redmine-2.6.0/script/rails server webrick -e production -d    </p>\n<h3 id=\"设置Email-SMTP服务器\"><a href=\"#设置Email-SMTP服务器\" class=\"headerlink\" title=\"设置Email/SMTP服务器\"></a>设置Email/SMTP服务器</h3><p>项目管理中，分配了任务或者测试提交了bug给某个开发人员，那么可以通过邮件及时的提醒他。    </p>\n<p>下面我们就来配置邮件服务器：<br>参考：<a href=\"http://www.redmine.org/projects/redmine/wiki/EmailConfiguration\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/EmailConfiguration</a>  </p>\n<p>1.编辑配置文件：config/configuration.yml</p>\n<p>添加邮箱服务器配置，异步发送邮件（qq邮箱为例子）：</p>\n<pre><code>email_delivery:\n    delivery_method: :async_smtp\n    async_smtp_settings:\n      address: &quot;smtp.qq.com&quot;\n      port: 25\n      authentication: :login\n      domain: &apos;qq.com&apos;\n      user_name: &apos;932852117@qq.com&apos;\n      password: &apos;××××××&apos;\n</code></pre><p>下面是实际操作内容：              </p>\n<pre><code># default configuration options for all environments\ndefault:\n  # Outgoing emails configuration\n  # See the examples below and the Rails guide for more configuration options:\n  # http://guides.rubyonrails.org/action_mailer_basics.html#action-mailer-configuration\n  email_delivery:\n    delivery_method: :async_smtp\n    async_smtp_settings:\n      address: &quot;smtp.qq.com&quot;\n      port: 25\n      authentication: :login\n      domain: &apos;qq.com&apos;\n      user_name: &apos;932852117@qq.com&apos;\n      password: &apos;××××××&apos;\n\n  # ==== Simple SMTP server at localhost\n</code></pre><p>2.开启邮箱服务器</p>\n<img src=\"/2018/06/01/redmine-start/b.png\">\n<p>3.重启redmine并测试是否配置成功。 </p>\n<p>登录redmine，在管理-&gt;配置中： </p>\n<img src=\"/2018/06/01/redmine-start/c.png\">\n<p>输入配置的邮箱地址后，保存。然后点击右下角的<code>发送测试邮件</code>：     </p>\n<img src=\"/2018/06/01/redmine-start/d.png\">\n<p>看到绿色提示<code>邮件已发送至 zhangmutian@xcsqjr.com</code>。证明配置已成功，可以愉快的使用了。</p>\n<h3 id=\"scm配置\"><a href=\"#scm配置\" class=\"headerlink\" title=\"scm配置\"></a>scm配置</h3><p>主要是svn和git版本库管理工具。  </p>\n<p>如：svn的<br><code>scm_subversion_command: &quot;svn_replacement.exe&quot;</code></p>\n<p>只需要安装svn或者git服务端，然后在配置文件指向即可。   </p>\n<h3 id=\"其它的配置\"><a href=\"#其它的配置\" class=\"headerlink\" title=\"其它的配置\"></a>其它的配置</h3><p>一般采用默认的就好了。 </p>\n<p>1.附件存储路径。<code>attachments_storage_path: /var/redmine/files</code><br>2.日志保存路径。   </p>\n<p>等等……</p>\n<hr>\n<p>恭喜恭喜，到此，你已成功安装redmine了，并且它已经具备了该有的基础功能了。赶紧来看下它帅帅的样子吧：</p>\n<img src=\"/2018/06/01/redmine-start/a.png\">\n<p>尽情的去探索redmine很多很多，酷酷的特性吧，让它正真成为你在项目管理中的瑞士军刀……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在软件开发过程中，项目管理的有效性直接会影响到项目开发的进度，质量，还有整个团队的协助。总之，没有一个好的项目管理系统，这对项目经理来说就像是上了战场，却没有任何武器一样，必定败仗。  </p>\n<p>下面介绍这款比较流行的项目管理工具redmine。有了它，项目经理就可以对整个项目的开发全过程进行管理。任务的分配、bug的跟踪、知识库的建立等等……</p>\n<p><a href=\"http://www.redmine.org\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"在ubuntu下安装\"><a href=\"#在ubuntu下安装\" class=\"headerlink\" title=\"在ubuntu下安装\"></a>在ubuntu下安装</h2><p>参考：<a href=\"http://www.redmine.org/projects/redmine/wiki/Guide\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/Guide</a></p>\n<p>###　下载redmine安装包</p>\n<p>网址：<a href=\"http://www.redmine.org/projects/redmine/wiki/Download\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/Download</a></p>\n<pre><code>wget http://www.redmine.org/releases/redmine-3.4.5.tar.gz\n</code></pre><h3 id=\"安装Ruby环境\"><a href=\"#安装Ruby环境\" class=\"headerlink\" title=\"安装Ruby环境\"></a>安装Ruby环境</h3><p>参考官网说明，注意redmine版本对ruby版本的要求。 </p>\n<p>1.下载地址：<a href=\"http://ftp.ruby-lang.org/pub/ruby/\" target=\"_blank\" rel=\"noopener\">http://ftp.ruby-lang.org/pub/ruby/</a>   </p>\n<pre><code>//下载\nzmt@zmt-Lenovo:~/Desktop/work/tools$ wget http://ftp.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz\nzmt@zmt-Lenovo:~/Desktop/work/tools$ tar -zxvf ruby-2.4.4.tar.gz \n\n//查询openssl安装路径\nzmt@zmt-Lenovo:~$ openssl version -a\nOpenSSL 1.1.0g  2 Nov 2017\nbuilt on: reproducible build, date unspecified\nplatform: debian-amd64\ncompiler: gcc -DDSO_DLFCN -DHAVE_DLFCN_H -DNDEBUG -DOPENSSL_THREADS -DOPENSSL_NO_STATIC_ENGINE -DOPENSSL_PIC -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DOPENSSLDIR=&quot;\\&quot;/usr/lib/ssl\\&quot;&quot; -DENGINESDIR=&quot;\\&quot;/usr/lib/x86_64-linux-gnu/engines-1.1\\&quot;&quot; \nOPENSSLDIR: &quot;/usr/lib/ssl&quot;\nENGINESDIR: &quot;/usr/lib/x86_64-linux-gnu/engines-1.1&quot;\n\n//看上面结果，确定openssl安装dir为：/usr/lib/ssl\n\n//安装：\n$ cd ruby-2.4.4\n$ ./configure  --with-openssl-dir=/usr/lib/ssl\n$ make\n$ sudo make install\n</code></pre><p>3.检查是否安装成功：    </p>\n<pre><code>zmt@zmt-Lenovo:~$ ruby -v\nruby 2.4.4p296 (2018-03-28 revision 63013) [x86_64-linux]\n</code></pre><p>看到上面显示说明安装成功。</p>\n<h3 id=\"创建空的数据库，并初始化用户\"><a href=\"#创建空的数据库，并初始化用户\" class=\"headerlink\" title=\"创建空的数据库，并初始化用户\"></a>创建空的数据库，并初始化用户</h3><p>一般数据库名为redmine,但是可以自己更改。</p>\n<p>1.MySQL</p>\n<p>创建数据库登录用户redmine，密码为redmine</p>\n<pre><code>//mysql要求５.6或以上版本\n\nCREATE DATABASE redmine CHARACTER SET utf8mb4;\nCREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;   \n\n//刷新权限\nflush privileges;\n</code></pre><h3 id=\"数据库连接配置设置\"><a href=\"#数据库连接配置设置\" class=\"headerlink\" title=\"数据库连接配置设置\"></a>数据库连接配置设置</h3><p>解压下载的<code>redmine-3.4.5.tar.gz</code>， 并进入解压包内。 在<code>config</code>目录下，可以看到文件<code>database.yml.example</code>，复制该文件命名为<code>database.yml</code>，放在同一个目录<code>config</code>下。下面就可以编辑文件<code>database.yml</code>了。  </p>\n<p>1.mysql的配置</p>\n<ul>\n<li><p>默认端口3306</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  username: redmine\n  password: redmine\n</code></pre></li>\n<li><p>不是3306端口，如下配置：</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  port: 3307\n  username: redmine\n  password: redmine\n</code></pre></li>\n</ul>\n<p>按照以上配置修改好，保存并退出。</p>\n<h3 id=\"redmine运行相关依赖包安装\"><a href=\"#redmine运行相关依赖包安装\" class=\"headerlink\" title=\"redmine运行相关依赖包安装\"></a>redmine运行相关依赖包安装</h3><p>Redmine uses <a href=\"http://gembundler.com/\" target=\"_blank\" rel=\"noopener\">Bundler</a> to manage gems dependencies.   </p>\n<p>1.首先按照Bundler</p>\n<pre><code>sudo gem install bundler\n</code></pre><p>报错误：</p>\n<pre><code>zmt@zmt-Lenovo:~$ gem install bundler\nERROR:  While executing gem ... (Gem::Exception)\n    Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources\n</code></pre><p>意思是，要要求系统按照OpenSSL，然后按上面步骤重新编译安装ruby。</p>\n<p>按照openssl：</p>\n<pre><code>sudo apt-get install openssl\n</code></pre><p>重新编译按照ruby后再执行<code>gem install bundler</code>。      </p>\n<p>还是不行，可能是因为不是以root用户安装的缘故。 </p>\n<p>_注：_  没关系，我们不通过网络安装，而是直接下载gem安装包安装。</p>\n<pre><code>安装RubyGems安装\n\n如果第一步能执行成功，不需要另外安装rubygems，因为安装ruby的时候已经安装。 \n\n网址：https://rubygems.org/\n\n下载并安装：\n\n    # wget https://rubygems.global.ssl.fastly.net/rubygems/rubygems-2.6.6.tgz\n    # tar zxvf rubygems-2.6.6.tgz\n    # cd rubygems-2.6.6.tgz\n    # ruby setup.rb\n\n    //显示版本好，说民安装成功\n    zmt@zmt-Lenovo:~/Desktop/work/tools/rubygems-2.6.6$ gem -v\n    2.6.6\n\n安装成功，重新执行步骤1，即安装Bundler，执行：\n\n    gem install bundler\n</code></pre><p>2.然后可以利用bundler安装redmine相关依赖包</p>\n<p>Then you can install all the gems required by Redmine using the following command:</p>\n<pre><code>bundle install --without development test\n</code></pre><p>&lt;&lt;—-未完—&gt;&gt;</p>\n<h2 id=\"Centos7下安装全过程记录\"><a href=\"#Centos7下安装全过程记录\" class=\"headerlink\" title=\"Centos7下安装全过程记录\"></a>Centos7下安装全过程记录</h2><p>参考网址：<a href=\"http://www.redmine.org/projects/redmine/wiki/RedmineInstall\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/RedmineInstall</a></p>\n<p>应用版本信息：<br>redmine： redmine-3.4.6.tar.gz<br>ruby： ruby-2.3.6.tar.gz</p>\n<p>首先安装系统相关包：</p>\n<pre><code>yum -y install patch make gcc gcc-c++ gcc-g77 flex* bison file  \nyum -y install libtool libtool-libs libtool-ltdl-devel* autoconf kernel-devel automake libmcrypt*  \nyum -y install libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel  \nyum -y install freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel  \nyum -y install glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel  \nyum -y install ncurses ncurses-devel curl curl-devel e2fsprogs  \nyum -y install e2fsprogs-devel krb5 krb5-devel libidn libidn-devel  \nyum -y install openssl openssl-devel vim-minimal nano sendmail  \nyum -y install fonts-chinese gettext gettext-devel  \nyum -y install gmp-devel pspell-devel   \nyum -y install readline* libxslt* pcre* net-snmp* gmp* libtidy*  \nyum -y install ImageMagick* subversion*  \n</code></pre><h3 id=\"下载redmine安装包\"><a href=\"#下载redmine安装包\" class=\"headerlink\" title=\"下载redmine安装包\"></a>下载redmine安装包</h3><p>可以在官网下载正式发布的二进制包<a href=\"http://www.redmine.org/projects/redmine/wiki/Download\" target=\"_blank\" rel=\"noopener\">下载</a>。 </p>\n<h3 id=\"创建空的数据库以及相关数据库用户\"><a href=\"#创建空的数据库以及相关数据库用户\" class=\"headerlink\" title=\"创建空的数据库以及相关数据库用户\"></a>创建空的数据库以及相关数据库用户</h3><p>首先要保证已经安装好数据库。下面以mysql为例进行安装。mysql版本&gt;5.5.2。<br>创建脚本：    </p>\n<pre><code>CREATE DATABASE redmine CHARACTER SET utf8mb4;\n#CREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;; #这样的，navicat客户端无法登录\nCREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;\n</code></pre><h3 id=\"为redmine配置数据库\"><a href=\"#为redmine配置数据库\" class=\"headerlink\" title=\"为redmine配置数据库\"></a>为redmine配置数据库</h3><p>首先，解压redmine包，并进入config目录。  </p>\n<p><code>[root@ymu config]# cp database.yml.example database.yml</code></p>\n<p>然后编辑<code>database.yml</code>：</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  port: 3307\n  username: redmine\n  password: redmine\n</code></pre><p>_注意_: 主机名用<code>localhost</code>可能报错，要改成<code>127.0.0.1</code>。      </p>\n<h3 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h3><p>1.安装ruby环境。</p>\n<ul>\n<li>安装上面描述方式，ruby源码包安装方式。选择版本安装。</li>\n<li>系统源安装。<code>yum install gem</code>。会自动安装ruby环境。</li>\n</ul>\n<p>下面采用源码编译安装方式。<br>检查是否安装成功：<br><code>ruby -v</code>   <code>gem -v</code></p>\n<p>问题解决：安装完ruby却提示<code>[/usr/bin/ruby: No such file or directory]</code></p>\n<p><code>ln -s /usr/local/bin/ruby /usr/bin/ruby</code><br><code>ln -s /usr/local/bin/gem /usr/bin/gem</code> </p>\n<p>2.安装<code>bundler</code></p>\n<p>redmine的依赖包都通过bundler来安装。   </p>\n<p><code>gem install bundler</code></p>\n<p>3.安装所有依赖</p>\n<p>执行下面命令前，记得要按照上面方法安装所有系统依赖包。</p>\n<pre><code>[root@ymu ~]# cd /server/tools/redmine-3.4.6/\n[root@ymu redmine-3.4.6]# bundle install --without development test\n</code></pre><h3 id=\"安全生成存储会话\"><a href=\"#安全生成存储会话\" class=\"headerlink\" title=\"安全生成存储会话\"></a>安全生成存储会话</h3><p><code>bundle exec rake generate_secret_token</code></p>\n<h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><pre><code>[root@ymu redmine-3.4.6]# bundle exec rake generate_secret_token\n[root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake db:migrate\n</code></pre><p>查看数据库，可以看到已经创建了很多表。     </p>\n<h3 id=\"设置数据库默认数据\"><a href=\"#设置数据库默认数据\" class=\"headerlink\" title=\"设置数据库默认数据\"></a>设置数据库默认数据</h3><pre><code>[root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake redmine:load_default_data\n\nSelect language: ar, az, bg, bs, ca, cs, da, de, el, en, en-GB, es, es-PA, et, eu, fa, fi, fr, gl, he, hr, hu, id, it, ja, ko, lt, lv, mk, mn, nl, no, pl, pt, pt-BR, ro, ru, sk, sl, sq, sr, sr-YU, sv, th, tr, uk, vi, zh, zh-TW [en] zh\n====================================\nDefault configuration data loaded.\n</code></pre><p>记得：输入zh，然后按下回车。否则会是英文版本数据。</p>\n<h3 id=\"设置文件权限\"><a href=\"#设置文件权限\" class=\"headerlink\" title=\"设置文件权限\"></a>设置文件权限</h3><ul>\n<li>如果上面的所有操作都是root用户，那么就不必要设置文件权限，可以跳过此步骤。 （<em>上面以root操作，跳过这步骤</em>）    </li>\n<li>如果不是在root超级用户下，则要设置文件权限，否则redmine应用程序无法操作一些文件权限。    </li>\n</ul>\n<p>在redmine解压根目录下，这些文件必须赋予权限：  </p>\n<pre><code>files (storage of attachments)\nlog (application log file production.log)\ntmp and tmp/pdf (create these ones if not present, used to generate PDF documents among other things)\npublic/plugin_assets (assets of plugins)\n</code></pre><p>如果没有这些文件：     </p>\n<pre><code>mkdir -p tmp tmp/pdf public/plugin_assets\nsudo chown -R redmine:redmine files log tmp public/plugin_assets\nsudo chmod -R 755 files log tmp public/plugin_assets\n</code></pre><p>如果都有：   </p>\n<pre><code>sudo chown -R redmine:redmine files log tmp public/plugin_assets\nsudo chmod -R 755 files log tmp public/plugin_assets\n</code></pre><p>_注意_:保证下面目录不包含可执行文件。</p>\n<pre><code>sudo find files log tmp public/plugin_assets -type f -exec chmod -x {} +    \n</code></pre><h3 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h3><p>按照下面经验执行操作：</p>\n<pre><code>bundle exec rails server webrick -e production   //在redmine安装目录下执行\n\n//注意，服务器端执行上面命令可能报错，可能是端口不可用，可以改变端口：\nbundle exec rails server webrick -e production -p 8889\n\n改变端口执行服务成功，但是在客户机子不能访问，此时要这么执行：\n bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889\n\nok搞定\n\n守护进程模式执行：\n nohup bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 &amp;\n或者：\nbundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 -d    \n</code></pre><p>然后就可以访问：http：//loaclhost:port。  </p>\n<h3 id=\"登录redmine\"><a href=\"#登录redmine\" class=\"headerlink\" title=\"登录redmine\"></a>登录redmine</h3><p>默认账号密码：<br>username=admin<br>pwd=admin</p>\n<p>打开网址后，用默认账号密码登录后，会要求修改密码。把密码改为：<br>username=admin<br>pwd=admin123    </p>\n<p>按页面提示，填写修改相关信息即可。   </p>\n<h3 id=\"修改配置（不修改则采用默认的配置）\"><a href=\"#修改配置（不修改则采用默认的配置）\" class=\"headerlink\" title=\"修改配置（不修改则采用默认的配置）\"></a>修改配置（不修改则采用默认的配置）</h3><p>redmine的配置设置文件放在：config/configuration.yml。<br>如果要自己定义配置，则可以<code>copy config/configuration.yml.example to config/configuration.yml</code>，然后编辑<code>configuration.yml</code>文件即可。 </p>\n<p>记得：修改配置文件后重启redmine，否则不生效。  </p>\n<h3 id=\"重启redmine\"><a href=\"#重启redmine\" class=\"headerlink\" title=\"重启redmine\"></a>重启redmine</h3><p>采用直接kill掉：</p>\n<pre><code>lsof -i:3000\nkill -9 pid\n</code></pre><h3 id=\"开机自启\"><a href=\"#开机自启\" class=\"headerlink\" title=\"开机自启\"></a>开机自启</h3><p>编辑启动文件</p>\n<p>vi /etc/rc.local</p>\n<p>最后一行或者适当的位置，加入一下内容。此处必须用绝对路径。注意根据实际redmine路径来填写。</p>\n<p>/usr/local/rvm/rubies/ruby-2.0.0-p598/bin/ruby /root/redmine-2.6.0/script/rails server webrick -e production -d    </p>\n<h3 id=\"设置Email-SMTP服务器\"><a href=\"#设置Email-SMTP服务器\" class=\"headerlink\" title=\"设置Email/SMTP服务器\"></a>设置Email/SMTP服务器</h3><p>项目管理中，分配了任务或者测试提交了bug给某个开发人员，那么可以通过邮件及时的提醒他。    </p>\n<p>下面我们就来配置邮件服务器：<br>参考：<a href=\"http://www.redmine.org/projects/redmine/wiki/EmailConfiguration\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/EmailConfiguration</a>  </p>\n<p>1.编辑配置文件：config/configuration.yml</p>\n<p>添加邮箱服务器配置，异步发送邮件（qq邮箱为例子）：</p>\n<pre><code>email_delivery:\n    delivery_method: :async_smtp\n    async_smtp_settings:\n      address: &quot;smtp.qq.com&quot;\n      port: 25\n      authentication: :login\n      domain: &apos;qq.com&apos;\n      user_name: &apos;932852117@qq.com&apos;\n      password: &apos;××××××&apos;\n</code></pre><p>下面是实际操作内容：              </p>\n<pre><code># default configuration options for all environments\ndefault:\n  # Outgoing emails configuration\n  # See the examples below and the Rails guide for more configuration options:\n  # http://guides.rubyonrails.org/action_mailer_basics.html#action-mailer-configuration\n  email_delivery:\n    delivery_method: :async_smtp\n    async_smtp_settings:\n      address: &quot;smtp.qq.com&quot;\n      port: 25\n      authentication: :login\n      domain: &apos;qq.com&apos;\n      user_name: &apos;932852117@qq.com&apos;\n      password: &apos;××××××&apos;\n\n  # ==== Simple SMTP server at localhost\n</code></pre><p>2.开启邮箱服务器</p>\n<img src=\"/2018/06/01/redmine-start/b.png\">\n<p>3.重启redmine并测试是否配置成功。 </p>\n<p>登录redmine，在管理-&gt;配置中： </p>\n<img src=\"/2018/06/01/redmine-start/c.png\">\n<p>输入配置的邮箱地址后，保存。然后点击右下角的<code>发送测试邮件</code>：     </p>\n<img src=\"/2018/06/01/redmine-start/d.png\">\n<p>看到绿色提示<code>邮件已发送至 zhangmutian@xcsqjr.com</code>。证明配置已成功，可以愉快的使用了。</p>\n<h3 id=\"scm配置\"><a href=\"#scm配置\" class=\"headerlink\" title=\"scm配置\"></a>scm配置</h3><p>主要是svn和git版本库管理工具。  </p>\n<p>如：svn的<br><code>scm_subversion_command: &quot;svn_replacement.exe&quot;</code></p>\n<p>只需要安装svn或者git服务端，然后在配置文件指向即可。   </p>\n<h3 id=\"其它的配置\"><a href=\"#其它的配置\" class=\"headerlink\" title=\"其它的配置\"></a>其它的配置</h3><p>一般采用默认的就好了。 </p>\n<p>1.附件存储路径。<code>attachments_storage_path: /var/redmine/files</code><br>2.日志保存路径。   </p>\n<p>等等……</p>\n<hr>\n<p>恭喜恭喜，到此，你已成功安装redmine了，并且它已经具备了该有的基础功能了。赶紧来看下它帅帅的样子吧：</p>\n<img src=\"/2018/06/01/redmine-start/a.png\">\n<p>尽情的去探索redmine很多很多，酷酷的特性吧，让它正真成为你在项目管理中的瑞士军刀……</p>\n"},{"title":"redmine使用踩坑记","date":"2018-11-23T01:14:54.000Z","_content":"\n### 附件图片加载不全，中文附件下载空白\n\n问题描述：   \n在浏览器，域名访问redmine系统，图片显示不全，中文附件下载后空白。琢磨老半天，上服务器查看了下，附件都已经上传到服务器，从服务器把对应的图片拉取下来后，用工具打开，正常。我去，那是啥子问题咧，开始以为是Redmine系统编码问题，各种百度，么用。后来在本地环境装个Redmine环境，直接访问，不经过Nginx，不存在显示不了图片的问题，尴尬咯。那就只有一种可能了，Nginx配置的问题了，似乎看到了光明……\n\n折腾了老半天，真他妈的是nginx的配置造成的。我去……     \n\n原来配置：\n\n    upstream redmine {\n            server 127.0.0.1:8889;\n            #server 127.0.0.1:8001;\n            #server 127.0.0.1:8002;\n    }\n    \n    server {\n    \tlisten 80;\n        server_name pm.xcsqjr.com;\n        root /server/java/redmine/redmine-3.4.6/public;\n    \n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n    }\n    \n改为：\n\n在conf中新增文件夹`sites`并添加文件`proxy.include`\n\n    proxy_set_header   Host $http_host;                                                                                                                     \n    proxy_set_header   X-Real-IP $remote_addr;                                                                                                                   \n    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header   X-Forwarded-Proto $scheme;\n    \n    client_max_body_size       10m;\n    client_body_buffer_size    128k;\n    \n    proxy_connect_timeout      90;\n    proxy_send_timeout         90;\n    proxy_read_timeout         90;\n    \n    proxy_buffer_size          4k;\n    proxy_buffers              4 32k;\n    proxy_busy_buffers_size    64k;\n    proxy_temp_file_write_size 64k;\n\n\n    upstream redmine {\n            server 127.0.0.1:8889;\n            #server 127.0.0.1:8001;\n            #server 127.0.0.1:8002;\n    }\n\n编辑配置：\n   \n    server {\n    \tlisten 80;\n        server_name pm.xcsqjr.com;\n    \tcharset utf-8;\n    \tinclude sites/proxy.include;\n         root /server/java/redmine/redmine-3.4.6/public;\n    \t#proxy_redirect off; #加上这行跳转会有问题\n    \n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n    } \n          ","source":"_posts/redmine-use-record.md","raw":"---\ntitle: redmine使用踩坑记\ndate: 2018-11-23 09:14:54\ncategories: redmine\ntags:\n---\n\n### 附件图片加载不全，中文附件下载空白\n\n问题描述：   \n在浏览器，域名访问redmine系统，图片显示不全，中文附件下载后空白。琢磨老半天，上服务器查看了下，附件都已经上传到服务器，从服务器把对应的图片拉取下来后，用工具打开，正常。我去，那是啥子问题咧，开始以为是Redmine系统编码问题，各种百度，么用。后来在本地环境装个Redmine环境，直接访问，不经过Nginx，不存在显示不了图片的问题，尴尬咯。那就只有一种可能了，Nginx配置的问题了，似乎看到了光明……\n\n折腾了老半天，真他妈的是nginx的配置造成的。我去……     \n\n原来配置：\n\n    upstream redmine {\n            server 127.0.0.1:8889;\n            #server 127.0.0.1:8001;\n            #server 127.0.0.1:8002;\n    }\n    \n    server {\n    \tlisten 80;\n        server_name pm.xcsqjr.com;\n        root /server/java/redmine/redmine-3.4.6/public;\n    \n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n    }\n    \n改为：\n\n在conf中新增文件夹`sites`并添加文件`proxy.include`\n\n    proxy_set_header   Host $http_host;                                                                                                                     \n    proxy_set_header   X-Real-IP $remote_addr;                                                                                                                   \n    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header   X-Forwarded-Proto $scheme;\n    \n    client_max_body_size       10m;\n    client_body_buffer_size    128k;\n    \n    proxy_connect_timeout      90;\n    proxy_send_timeout         90;\n    proxy_read_timeout         90;\n    \n    proxy_buffer_size          4k;\n    proxy_buffers              4 32k;\n    proxy_busy_buffers_size    64k;\n    proxy_temp_file_write_size 64k;\n\n\n    upstream redmine {\n            server 127.0.0.1:8889;\n            #server 127.0.0.1:8001;\n            #server 127.0.0.1:8002;\n    }\n\n编辑配置：\n   \n    server {\n    \tlisten 80;\n        server_name pm.xcsqjr.com;\n    \tcharset utf-8;\n    \tinclude sites/proxy.include;\n         root /server/java/redmine/redmine-3.4.6/public;\n    \t#proxy_redirect off; #加上这行跳转会有问题\n    \n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n    } \n          ","slug":"redmine-use-record","published":1,"updated":"2019-06-16T14:38:33.448Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqev009og4va499pwn17","content":"<h3 id=\"附件图片加载不全，中文附件下载空白\"><a href=\"#附件图片加载不全，中文附件下载空白\" class=\"headerlink\" title=\"附件图片加载不全，中文附件下载空白\"></a>附件图片加载不全，中文附件下载空白</h3><p>问题描述：<br>在浏览器，域名访问redmine系统，图片显示不全，中文附件下载后空白。琢磨老半天，上服务器查看了下，附件都已经上传到服务器，从服务器把对应的图片拉取下来后，用工具打开，正常。我去，那是啥子问题咧，开始以为是Redmine系统编码问题，各种百度，么用。后来在本地环境装个Redmine环境，直接访问，不经过Nginx，不存在显示不了图片的问题，尴尬咯。那就只有一种可能了，Nginx配置的问题了，似乎看到了光明……</p>\n<p>折腾了老半天，真他妈的是nginx的配置造成的。我去……     </p>\n<p>原来配置：</p>\n<pre><code>upstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n\nserver {\n    listen 80;\n    server_name pm.xcsqjr.com;\n    root /server/java/redmine/redmine-3.4.6/public;\n\n    location / {\n            try_files $uri @redmine;\n    }\n\n    location @redmine {\n            proxy_set_header  X-Forwarded-For $remote_addr;\n            proxy_pass http://redmine;\n    }\n}\n</code></pre><p>改为：</p>\n<p>在conf中新增文件夹<code>sites</code>并添加文件<code>proxy.include</code></p>\n<pre><code>proxy_set_header   Host $http_host;                                                                                                                     \nproxy_set_header   X-Real-IP $remote_addr;                                                                                                                   \nproxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header   X-Forwarded-Proto $scheme;\n\nclient_max_body_size       10m;\nclient_body_buffer_size    128k;\n\nproxy_connect_timeout      90;\nproxy_send_timeout         90;\nproxy_read_timeout         90;\n\nproxy_buffer_size          4k;\nproxy_buffers              4 32k;\nproxy_busy_buffers_size    64k;\nproxy_temp_file_write_size 64k;\n\n\nupstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n</code></pre><p>编辑配置：</p>\n<pre><code>server {\n    listen 80;\n    server_name pm.xcsqjr.com;\n    charset utf-8;\n    include sites/proxy.include;\n     root /server/java/redmine/redmine-3.4.6/public;\n    #proxy_redirect off; #加上这行跳转会有问题\n\n    location / {\n            try_files $uri @redmine;\n    }\n\n    location @redmine {\n            proxy_set_header  X-Forwarded-For $remote_addr;\n            proxy_pass http://redmine;\n    }\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"附件图片加载不全，中文附件下载空白\"><a href=\"#附件图片加载不全，中文附件下载空白\" class=\"headerlink\" title=\"附件图片加载不全，中文附件下载空白\"></a>附件图片加载不全，中文附件下载空白</h3><p>问题描述：<br>在浏览器，域名访问redmine系统，图片显示不全，中文附件下载后空白。琢磨老半天，上服务器查看了下，附件都已经上传到服务器，从服务器把对应的图片拉取下来后，用工具打开，正常。我去，那是啥子问题咧，开始以为是Redmine系统编码问题，各种百度，么用。后来在本地环境装个Redmine环境，直接访问，不经过Nginx，不存在显示不了图片的问题，尴尬咯。那就只有一种可能了，Nginx配置的问题了，似乎看到了光明……</p>\n<p>折腾了老半天，真他妈的是nginx的配置造成的。我去……     </p>\n<p>原来配置：</p>\n<pre><code>upstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n\nserver {\n    listen 80;\n    server_name pm.xcsqjr.com;\n    root /server/java/redmine/redmine-3.4.6/public;\n\n    location / {\n            try_files $uri @redmine;\n    }\n\n    location @redmine {\n            proxy_set_header  X-Forwarded-For $remote_addr;\n            proxy_pass http://redmine;\n    }\n}\n</code></pre><p>改为：</p>\n<p>在conf中新增文件夹<code>sites</code>并添加文件<code>proxy.include</code></p>\n<pre><code>proxy_set_header   Host $http_host;                                                                                                                     \nproxy_set_header   X-Real-IP $remote_addr;                                                                                                                   \nproxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header   X-Forwarded-Proto $scheme;\n\nclient_max_body_size       10m;\nclient_body_buffer_size    128k;\n\nproxy_connect_timeout      90;\nproxy_send_timeout         90;\nproxy_read_timeout         90;\n\nproxy_buffer_size          4k;\nproxy_buffers              4 32k;\nproxy_busy_buffers_size    64k;\nproxy_temp_file_write_size 64k;\n\n\nupstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n</code></pre><p>编辑配置：</p>\n<pre><code>server {\n    listen 80;\n    server_name pm.xcsqjr.com;\n    charset utf-8;\n    include sites/proxy.include;\n     root /server/java/redmine/redmine-3.4.6/public;\n    #proxy_redirect off; #加上这行跳转会有问题\n\n    location / {\n            try_files $uri @redmine;\n    }\n\n    location @redmine {\n            proxy_set_header  X-Forwarded-For $remote_addr;\n            proxy_pass http://redmine;\n    }\n} \n</code></pre>"},{"title":"restful-api设计摘要","date":"2017-09-29T14:07:54.000Z","_content":"本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","source":"_posts/restful-api-dev.md","raw":"---\ntitle: restful-api设计摘要\ndate: 2017-09-29 22:07:54\ncategories: api-manage\ntags: restful-api\n---\n本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","slug":"restful-api-dev","published":1,"updated":"2019-06-16T14:38:33.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqew009qg4vawaed6p3r","content":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"noopener\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"noopener\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"noopener\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"noopener\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"noopener\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"noopener\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n"},{"title":"rocketmq入门","date":"2018-08-13T07:34:20.000Z","_content":"\n官网：rocketmq.apache.org\n","source":"_posts/rocketmq-start.md","raw":"---\ntitle: rocketmq入门\ndate: 2018-08-13 15:34:20\ncategories: rocketmq\ntags: rocketmq入门\n---\n\n官网：rocketmq.apache.org\n","slug":"rocketmq-start","published":1,"updated":"2019-06-16T14:38:33.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqex009tg4vaxnqynjf0","content":"<p>官网：rocketmq.apache.org</p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：rocketmq.apache.org</p>\n"},{"title":"spring-boot更改ContextPath方法","date":"2017-09-28T06:03:23.000Z","_content":"在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","source":"_posts/sboot-change-contextpath.md","raw":"---\ntitle: spring-boot更改ContextPath方法\ndate: 2017-09-28 14:03:23\ncategories: spring-boot\ntags: change-contextpath-way\n---\n在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","slug":"sboot-change-contextpath","published":1,"updated":"2019-06-16T14:38:33.450Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqez009wg4vaalptfvq1","content":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n"},{"title":"Spring cloud微服务：分布式配置中心-加密解密","date":"2018-04-21T14:22:30.000Z","_content":"\n在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。\n但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。\n\n\n## 安装JCE\n\n在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：\n\n    README.txt\n    local_policy.jar\n    US_export_policy.jar\n\n我们需要将local_policy.jar和US_export_policy.jar两个文件复制到`$JAVA_HOME/jre/lib/security`目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。\n\nJCE下载地址：[Java 8 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)\n\n## 查看相关端点\n\n安装后，重启config-server。可以通过浏览器查看一些相关信息：\n\n- /encrypt/status：查看加密功能状态的端点\n- /key：查看密钥的端点\n- /encrypt：对请求的body内容进行加密的端点\n- /decrypt：对请求的body内容进行解密的端点\n\n## 配置密钥\n\n### 对称加解密\n\n暂时不做介绍。推荐直接用下面非对称方式！\n\n### 非对称加解密\n\n使用非对称加解密具有更高安全性……\n\n- 使用JDK工具keytool生成密钥对。\n\n它的位置在： %JAVA_HOME%\\bin\\keytool.exe。\n\n使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：\n\n    keytool -genkeypair -alias config-server -keyalg RSA \\ \n      -dname \"CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china\" \\\n      -keypass 222222 \\\n      -keystore config-server.jks \\\n      -storepass 111111 \\\n      -validity 365 \\\n\n参考：\nhttp://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\n\n## 配置bootstrap.yml\n\n把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：\n\n    encrypt:\n      keyStore:\n        location: classpath:/config-server.jks\n        password: 11111\n        alias: config-server\n        secret: 222222\n\n*注*：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：\n\n    ENCRYPT_KEY_STORE_LOCATION\n    ENCRYPT_KEY_STORE_ALIAS\n    ENCRYPT_KEY_STORE_PASSWORD\n    ENCRYPT_KEY_STORE_SECRET\n    \n重新启动项目，浏览：http://192.168.1.104:3331/encrypt/status  \n\n    {\n        \"status\": \"OK\"\n    }\n    \n说明配置成功了。\n\n## 对配置加密\n\n先在命令窗口对具体配置明文进行加密,如：\n\n对明文zmt加密（认证用户名为admin、密码为123456）\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/encrypt -d zmt\n    AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n    \n对密文解密：\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\n    zmt   \n    \n在配置文件中配置密文：\n\n通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。`{cipher}`代表是密文，需要解密。\n\n    api:\n      password: '{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io='\n\n调用显示：\n\n    @Value(\"${api.password}\")\n    private String apiPwd;\n\n    @Override\n    public VTestResp test3(@SensitiveFormat String name) {\n        VTestResp testResp = new VTestResp();\n        testResp.setName(name + \">>>>\" + apiPwd);\n        return testResp;\n    }\n    \n    结果：\n    {\n        \"name\": \"abc>>>>ymu123456\",\n        \"sex\": 0\n    }\n    \n## 对特殊字符加密问题\n\n参考：http://blog.didispace.com/spring-cloud-config-sp-char-encryp         ","source":"_posts/scloud-config-server-encrypt-decrypt.md","raw":"---\ntitle: Spring cloud微服务：分布式配置中心-加密解密\ndate: 2018-04-21 22:22:30\ncategories: spring-cloud\ntags: spring-cloud(配置中心加解密)\n---\n\n在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。\n但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。\n\n\n## 安装JCE\n\n在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：\n\n    README.txt\n    local_policy.jar\n    US_export_policy.jar\n\n我们需要将local_policy.jar和US_export_policy.jar两个文件复制到`$JAVA_HOME/jre/lib/security`目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。\n\nJCE下载地址：[Java 8 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)\n\n## 查看相关端点\n\n安装后，重启config-server。可以通过浏览器查看一些相关信息：\n\n- /encrypt/status：查看加密功能状态的端点\n- /key：查看密钥的端点\n- /encrypt：对请求的body内容进行加密的端点\n- /decrypt：对请求的body内容进行解密的端点\n\n## 配置密钥\n\n### 对称加解密\n\n暂时不做介绍。推荐直接用下面非对称方式！\n\n### 非对称加解密\n\n使用非对称加解密具有更高安全性……\n\n- 使用JDK工具keytool生成密钥对。\n\n它的位置在： %JAVA_HOME%\\bin\\keytool.exe。\n\n使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：\n\n    keytool -genkeypair -alias config-server -keyalg RSA \\ \n      -dname \"CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china\" \\\n      -keypass 222222 \\\n      -keystore config-server.jks \\\n      -storepass 111111 \\\n      -validity 365 \\\n\n参考：\nhttp://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\n\n## 配置bootstrap.yml\n\n把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：\n\n    encrypt:\n      keyStore:\n        location: classpath:/config-server.jks\n        password: 11111\n        alias: config-server\n        secret: 222222\n\n*注*：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：\n\n    ENCRYPT_KEY_STORE_LOCATION\n    ENCRYPT_KEY_STORE_ALIAS\n    ENCRYPT_KEY_STORE_PASSWORD\n    ENCRYPT_KEY_STORE_SECRET\n    \n重新启动项目，浏览：http://192.168.1.104:3331/encrypt/status  \n\n    {\n        \"status\": \"OK\"\n    }\n    \n说明配置成功了。\n\n## 对配置加密\n\n先在命令窗口对具体配置明文进行加密,如：\n\n对明文zmt加密（认证用户名为admin、密码为123456）\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/encrypt -d zmt\n    AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n    \n对密文解密：\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\n    zmt   \n    \n在配置文件中配置密文：\n\n通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。`{cipher}`代表是密文，需要解密。\n\n    api:\n      password: '{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io='\n\n调用显示：\n\n    @Value(\"${api.password}\")\n    private String apiPwd;\n\n    @Override\n    public VTestResp test3(@SensitiveFormat String name) {\n        VTestResp testResp = new VTestResp();\n        testResp.setName(name + \">>>>\" + apiPwd);\n        return testResp;\n    }\n    \n    结果：\n    {\n        \"name\": \"abc>>>>ymu123456\",\n        \"sex\": 0\n    }\n    \n## 对特殊字符加密问题\n\n参考：http://blog.didispace.com/spring-cloud-config-sp-char-encryp         ","slug":"scloud-config-server-encrypt-decrypt","published":1,"updated":"2019-06-16T14:38:33.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqf1009yg4vavb7kv3jh","content":"<p>在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。<br>但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。</p>\n<h2 id=\"安装JCE\"><a href=\"#安装JCE\" class=\"headerlink\" title=\"安装JCE\"></a>安装JCE</h2><p>在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：</p>\n<pre><code>README.txt\nlocal_policy.jar\nUS_export_policy.jar\n</code></pre><p>我们需要将local_policy.jar和US_export_policy.jar两个文件复制到<code>$JAVA_HOME/jre/lib/security</code>目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。</p>\n<p>JCE下载地址：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html\" target=\"_blank\" rel=\"noopener\">Java 8 JCE</a></p>\n<h2 id=\"查看相关端点\"><a href=\"#查看相关端点\" class=\"headerlink\" title=\"查看相关端点\"></a>查看相关端点</h2><p>安装后，重启config-server。可以通过浏览器查看一些相关信息：</p>\n<ul>\n<li>/encrypt/status：查看加密功能状态的端点</li>\n<li>/key：查看密钥的端点</li>\n<li>/encrypt：对请求的body内容进行加密的端点</li>\n<li>/decrypt：对请求的body内容进行解密的端点</li>\n</ul>\n<h2 id=\"配置密钥\"><a href=\"#配置密钥\" class=\"headerlink\" title=\"配置密钥\"></a>配置密钥</h2><h3 id=\"对称加解密\"><a href=\"#对称加解密\" class=\"headerlink\" title=\"对称加解密\"></a>对称加解密</h3><p>暂时不做介绍。推荐直接用下面非对称方式！</p>\n<h3 id=\"非对称加解密\"><a href=\"#非对称加解密\" class=\"headerlink\" title=\"非对称加解密\"></a>非对称加解密</h3><p>使用非对称加解密具有更高安全性……</p>\n<ul>\n<li>使用JDK工具keytool生成密钥对。</li>\n</ul>\n<p>它的位置在： %JAVA_HOME%\\bin\\keytool.exe。</p>\n<p>使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：</p>\n<pre><code>keytool -genkeypair -alias config-server -keyalg RSA \\ \n  -dname &quot;CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china&quot; \\\n  -keypass 222222 \\\n  -keystore config-server.jks \\\n  -storepass 111111 \\\n  -validity 365 \\\n</code></pre><p>参考：<br><a href=\"http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\" target=\"_blank\" rel=\"noopener\">http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing</a></p>\n<h2 id=\"配置bootstrap-yml\"><a href=\"#配置bootstrap-yml\" class=\"headerlink\" title=\"配置bootstrap.yml\"></a>配置bootstrap.yml</h2><p>把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：</p>\n<pre><code>encrypt:\n  keyStore:\n    location: classpath:/config-server.jks\n    password: 11111\n    alias: config-server\n    secret: 222222\n</code></pre><p><em>注</em>：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：</p>\n<pre><code>ENCRYPT_KEY_STORE_LOCATION\nENCRYPT_KEY_STORE_ALIAS\nENCRYPT_KEY_STORE_PASSWORD\nENCRYPT_KEY_STORE_SECRET\n</code></pre><p>重新启动项目，浏览：<a href=\"http://192.168.1.104:3331/encrypt/status\" target=\"_blank\" rel=\"noopener\">http://192.168.1.104:3331/encrypt/status</a>  </p>\n<pre><code>{\n    &quot;status&quot;: &quot;OK&quot;\n}\n</code></pre><p>说明配置成功了。</p>\n<h2 id=\"对配置加密\"><a href=\"#对配置加密\" class=\"headerlink\" title=\"对配置加密\"></a>对配置加密</h2><p>先在命令窗口对具体配置明文进行加密,如：</p>\n<p>对明文zmt加密（认证用户名为admin、密码为123456）</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/encrypt -d zmt\nAQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n</code></pre><p>对密文解密：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\nzmt   \n</code></pre><p>在配置文件中配置密文：</p>\n<p>通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。<code>{cipher}</code>代表是密文，需要解密。</p>\n<pre><code>api:\n  password: &apos;{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io=&apos;\n</code></pre><p>调用显示：</p>\n<pre><code>@Value(&quot;${api.password}&quot;)\nprivate String apiPwd;\n\n@Override\npublic VTestResp test3(@SensitiveFormat String name) {\n    VTestResp testResp = new VTestResp();\n    testResp.setName(name + &quot;&gt;&gt;&gt;&gt;&quot; + apiPwd);\n    return testResp;\n}\n\n结果：\n{\n    &quot;name&quot;: &quot;abc&gt;&gt;&gt;&gt;ymu123456&quot;,\n    &quot;sex&quot;: 0\n}\n</code></pre><h2 id=\"对特殊字符加密问题\"><a href=\"#对特殊字符加密问题\" class=\"headerlink\" title=\"对特殊字符加密问题\"></a>对特殊字符加密问题</h2><p>参考：<a href=\"http://blog.didispace.com/spring-cloud-config-sp-char-encryp\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/spring-cloud-config-sp-char-encryp</a>         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。<br>但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。</p>\n<h2 id=\"安装JCE\"><a href=\"#安装JCE\" class=\"headerlink\" title=\"安装JCE\"></a>安装JCE</h2><p>在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：</p>\n<pre><code>README.txt\nlocal_policy.jar\nUS_export_policy.jar\n</code></pre><p>我们需要将local_policy.jar和US_export_policy.jar两个文件复制到<code>$JAVA_HOME/jre/lib/security</code>目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。</p>\n<p>JCE下载地址：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html\" target=\"_blank\" rel=\"noopener\">Java 8 JCE</a></p>\n<h2 id=\"查看相关端点\"><a href=\"#查看相关端点\" class=\"headerlink\" title=\"查看相关端点\"></a>查看相关端点</h2><p>安装后，重启config-server。可以通过浏览器查看一些相关信息：</p>\n<ul>\n<li>/encrypt/status：查看加密功能状态的端点</li>\n<li>/key：查看密钥的端点</li>\n<li>/encrypt：对请求的body内容进行加密的端点</li>\n<li>/decrypt：对请求的body内容进行解密的端点</li>\n</ul>\n<h2 id=\"配置密钥\"><a href=\"#配置密钥\" class=\"headerlink\" title=\"配置密钥\"></a>配置密钥</h2><h3 id=\"对称加解密\"><a href=\"#对称加解密\" class=\"headerlink\" title=\"对称加解密\"></a>对称加解密</h3><p>暂时不做介绍。推荐直接用下面非对称方式！</p>\n<h3 id=\"非对称加解密\"><a href=\"#非对称加解密\" class=\"headerlink\" title=\"非对称加解密\"></a>非对称加解密</h3><p>使用非对称加解密具有更高安全性……</p>\n<ul>\n<li>使用JDK工具keytool生成密钥对。</li>\n</ul>\n<p>它的位置在： %JAVA_HOME%\\bin\\keytool.exe。</p>\n<p>使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：</p>\n<pre><code>keytool -genkeypair -alias config-server -keyalg RSA \\ \n  -dname &quot;CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china&quot; \\\n  -keypass 222222 \\\n  -keystore config-server.jks \\\n  -storepass 111111 \\\n  -validity 365 \\\n</code></pre><p>参考：<br><a href=\"http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\" target=\"_blank\" rel=\"noopener\">http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing</a></p>\n<h2 id=\"配置bootstrap-yml\"><a href=\"#配置bootstrap-yml\" class=\"headerlink\" title=\"配置bootstrap.yml\"></a>配置bootstrap.yml</h2><p>把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：</p>\n<pre><code>encrypt:\n  keyStore:\n    location: classpath:/config-server.jks\n    password: 11111\n    alias: config-server\n    secret: 222222\n</code></pre><p><em>注</em>：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：</p>\n<pre><code>ENCRYPT_KEY_STORE_LOCATION\nENCRYPT_KEY_STORE_ALIAS\nENCRYPT_KEY_STORE_PASSWORD\nENCRYPT_KEY_STORE_SECRET\n</code></pre><p>重新启动项目，浏览：<a href=\"http://192.168.1.104:3331/encrypt/status\" target=\"_blank\" rel=\"noopener\">http://192.168.1.104:3331/encrypt/status</a>  </p>\n<pre><code>{\n    &quot;status&quot;: &quot;OK&quot;\n}\n</code></pre><p>说明配置成功了。</p>\n<h2 id=\"对配置加密\"><a href=\"#对配置加密\" class=\"headerlink\" title=\"对配置加密\"></a>对配置加密</h2><p>先在命令窗口对具体配置明文进行加密,如：</p>\n<p>对明文zmt加密（认证用户名为admin、密码为123456）</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/encrypt -d zmt\nAQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n</code></pre><p>对密文解密：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\nzmt   \n</code></pre><p>在配置文件中配置密文：</p>\n<p>通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。<code>{cipher}</code>代表是密文，需要解密。</p>\n<pre><code>api:\n  password: &apos;{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io=&apos;\n</code></pre><p>调用显示：</p>\n<pre><code>@Value(&quot;${api.password}&quot;)\nprivate String apiPwd;\n\n@Override\npublic VTestResp test3(@SensitiveFormat String name) {\n    VTestResp testResp = new VTestResp();\n    testResp.setName(name + &quot;&gt;&gt;&gt;&gt;&quot; + apiPwd);\n    return testResp;\n}\n\n结果：\n{\n    &quot;name&quot;: &quot;abc&gt;&gt;&gt;&gt;ymu123456&quot;,\n    &quot;sex&quot;: 0\n}\n</code></pre><h2 id=\"对特殊字符加密问题\"><a href=\"#对特殊字符加密问题\" class=\"headerlink\" title=\"对特殊字符加密问题\"></a>对特殊字符加密问题</h2><p>参考：<a href=\"http://blog.didispace.com/spring-cloud-config-sp-char-encryp\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/spring-cloud-config-sp-char-encryp</a>         </p>\n"},{"title":"spring-cloud-feign在使用中遇到的一些问题","date":"2017-09-24T13:53:46.000Z","_content":"\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","source":"_posts/scloud-feign-anyquestion.md","raw":"---\ntitle: spring-cloud-feign在使用中遇到的一些问题\ndate: 2017-09-24 21:53:46\ncategories: spring-cloud\ntags: feign使用常见问题\n---\n\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","slug":"scloud-feign-anyquestion","published":1,"updated":"2019-06-16T14:38:33.452Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqf200a1g4vafxagr6oz","content":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n"},{"title":"Spring Cloud Sleuth使用ELK收集&分析日志","date":"2019-09-04T14:15:36.000Z","_content":"\n在分布式系统中，每个应用的实例都会在不同的物理机上产生日志。以往，系统出现问题需要查看日志的时候，就要到每台物理机对应的日志目录下查看相应的日志，这会非常的麻烦，特别是很多个实例的时候。      \n另外，微服务场景下，各个服务的日志链也都很分散，无法追踪，不知道实际的错误出现在哪个服务。      \n所以，就非常有必要把各个服务的各个实例所产生的日志都发送到统一的服务器上，并进行可视化的查看，分析。这就是我们这里要介绍的ELK能做的事情了。\n\n## ELK是什么东西\n\n实际就是三个软件系统：\n\n- E：指的Elasticsearch,一个强大的搜索引擎。\n- L：指的Logstash，解析并收集日志的系统。\n- K：指的Kibana，一个可以可视化查看日志文件的系统。\n\n## 基本原理\n\n- Sleuth打印JSON格式的日志。\n- logstash中配置语法，解析并收集JSON格式的日志，然后存储到Elasticsearch系统中去。\n- Kibana可视化分析日志。集成Elasticsearch强大的搜索功能，找到任意输出的日志，并查看和分析。\n\n## ELK环境的搭建\n\n这里介绍采用的单机模式。利用docker和docker-compose来部署。\n\n首先要在某台服务器上安装docker引擎和docker-compose服务。\n\n- 在服务器新建文件夹ELK。然后进入该文件夹，并创建文件`docker-compose.yml`，内容如下：\n\n\n        version: '3'\n        services:\n          elasticsearch:\n            image: elasticsearch:7.3.1\n            environment:\n              discovery.type: single-node\n            ports:\n              - \"9200:9200\"\n              - \"9300:9300\"\n          logstash:\n            image: logstash:7.3.1\n            command: logstash -f /etc/logstash/conf.d/logstash.conf\n            volumes:\n              # 挂载logstash配置文件\n              - ./config:/etc/logstash/conf.d\n              - /opt/build:/opt/build\n            ports:\n              - \"5000:5000\"\n              - \"8088:8088\"\n          kibana:\n            image: kibana:7.3.1\n            environment:\n              - ELASTICSEARCH_URL=http://120.79.2.30:9200\n            ports:\n              - \"5601:5601\"\n          \n- 在ELK中再创建目录config，并进入config目录，然后创建文件`logstash.conf`,文件内容如下：\n\n    \n    input {\n        tcp {\n            port => 8088\n            mode => \"server\"\n            ssl_enable => false\n            type => \"tcplog\"\n            codec => json_lines {\n                charset => \"UTF-8\"\n            }\n        }\n    }\n    filter {\n        grok {\n            match => { \"message\" => \"%{TIMESTAMP_ISO8601:timestamp}\\s+%{LOGLEVEL:severity}\\s+\\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\\]\\s+%{DATA:pid}\\s+---\\s+\\[%{DATA:thread}\\]\\s+%{DATA:class}\\s+:\\s+%{GREEDYDATA:rest}\" }\n        }\n    }\n    output {\n        elasticsearch {\n            hosts => \"120.79.2.30:9200\"\n            index => \"logstash\"\n        }\n    }\n    \n- 在ELK目下，启动ELK服务：\n\n\n    docker-compose up \n    \n## spring cloud 服务配置调整\n\n### pom.xml文件中添加依赖\n\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-sleuth</artifactId>\n    </dependency>\n    <!--必须要和logback版本对应，这个版本对应logback的1.2.3-->\n    <dependency>\n        <groupId>net.logstash.logback</groupId>\n        <artifactId>logstash-logback-encoder</artifactId>\n        <version>6.1</version>\n    </dependency> \n    \n _注意_: logstash-logback-encoder 的版本务必和Logback兼容，否则会导致应用启动不起来，而且不会打印任何日志！可前往 `https://github.com/logstash/logstash-logback-encoder` 查看和Logback的兼容性。                \n\n\n### 添加logback-spring.xml文件\n\n在 resources 目录下创建配置文件：logback-spring.xml，文件内容如下：\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <configuration>\n        <include resource=\"org/springframework/boot/logging/logback/defaults.xml\"/>\n    \n        <springProperty scope=\"context\" name=\"springAppName\" source=\"spring.application.name\"/>\n        <!-- Example for logging into the build folder of your project -->\n        <property name=\"LOG_FILE\" value=\"./logs/${springAppName}/${springAppName}\"/>\n    \n        <!-- You can override this to have a custom pattern -->\n        <property name=\"CONSOLE_LOG_PATTERN\"\n                  value=\"%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}\"/>\n    \n        <property name=\"FILE_LOG_PATTERN\" value=\"${FILE_LOG_PATTERN:-%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } --- [%t] %-40.40logger{39} : %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/>\n    \n        <!-- Appender to log to console -->\n        <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n            <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\">\n                <!-- Minimum logging level to be presented in the console logs-->\n                <level>DEBUG</level>\n            </filter>\n            <encoder>\n                <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n                <charset>utf8</charset>\n            </encoder>\n        </appender>\n    \n        <!-- Appender to log to file -->\n        <appender name=\"flatfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n            <file>${LOG_FILE}.log</file>\n            <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n                <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.gz</fileNamePattern>\n                <maxHistory>7</maxHistory>\n            </rollingPolicy>\n            <encoder>\n                <pattern>${FILE_LOG_PATTERN}</pattern>\n                <charset>utf8</charset>\n            </encoder>\n        </appender>\n    \n        <!--通过网络，把日志发送到ELK服务器-->\n        <appender name=\"logstash\" class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\">\n            <destination>120.79.2.30:8088</destination>\n            <writeBufferSize>16384</writeBufferSize>\n            <!-- encoder is required -->\n            <encoder class=\"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\">\n                <providers>\n                    <timestamp>\n                        <timeZone>UTC</timeZone>\n                    </timestamp>\n                    <pattern>\n                        <pattern>\n                            {\n                            \"severity\": \"%level\",\n                            \"service\": \"${springAppName:-}\",\n                            \"trace\": \"%X{X-B3-TraceId:-}\",\n                            \"span\": \"%X{X-B3-SpanId:-}\",\n                            \"parent\": \"%X{X-B3-ParentSpanId:-}\",\n                            \"exportable\": \"%X{X-Span-Export:-}\",\n                            \"pid\": \"${PID:-}\",\n                            \"thread\": \"%thread\",\n                            \"class\": \"%logger{40}\",\n                            \"rest\": \"%message\"\n                            }\n                        </pattern>\n                    </pattern>\n                </providers>\n            </encoder>\n        </appender>\n    \n        <root level=\"INFO\">\n            <appender-ref ref=\"console\"/>\n            <!-- uncomment this to have also JSON logs -->\n            <appender-ref ref=\"logstash\"/>\n            <appender-ref ref=\"flatfile\"/>\n        </root>\n    </configuration>\n    \n_注意：_ 应用名称`spring.application.name`必须放在配置文件`bootstrap.yml`中，否则`logback-spring.xml`将读取不到该变量。\n\n## 测试Sleuth & ELK\n\n- 启动你的微服务，并访问相关API产生一些输出日志。\n\n- 访问 http://localhost:5601 （Kibana地址），可看到类似如下的界面，按照如图配置Kibana。\n\n{% asset_img kibana1.png %}\n\n按下面图画红框步骤继续配置：\n\n{% asset_img kibana2.png %}\n\n输入查询条件，就可查询日志了：\n\n{% asset_img kibana3.png %}\n","source":"_posts/scloud-elk.md","raw":"---\ntitle: Spring Cloud Sleuth使用ELK收集&分析日志\ndate: 2019-09-04 22:15:36\ncategories: spring-cloud\ntags: ELK\n---\n\n在分布式系统中，每个应用的实例都会在不同的物理机上产生日志。以往，系统出现问题需要查看日志的时候，就要到每台物理机对应的日志目录下查看相应的日志，这会非常的麻烦，特别是很多个实例的时候。      \n另外，微服务场景下，各个服务的日志链也都很分散，无法追踪，不知道实际的错误出现在哪个服务。      \n所以，就非常有必要把各个服务的各个实例所产生的日志都发送到统一的服务器上，并进行可视化的查看，分析。这就是我们这里要介绍的ELK能做的事情了。\n\n## ELK是什么东西\n\n实际就是三个软件系统：\n\n- E：指的Elasticsearch,一个强大的搜索引擎。\n- L：指的Logstash，解析并收集日志的系统。\n- K：指的Kibana，一个可以可视化查看日志文件的系统。\n\n## 基本原理\n\n- Sleuth打印JSON格式的日志。\n- logstash中配置语法，解析并收集JSON格式的日志，然后存储到Elasticsearch系统中去。\n- Kibana可视化分析日志。集成Elasticsearch强大的搜索功能，找到任意输出的日志，并查看和分析。\n\n## ELK环境的搭建\n\n这里介绍采用的单机模式。利用docker和docker-compose来部署。\n\n首先要在某台服务器上安装docker引擎和docker-compose服务。\n\n- 在服务器新建文件夹ELK。然后进入该文件夹，并创建文件`docker-compose.yml`，内容如下：\n\n\n        version: '3'\n        services:\n          elasticsearch:\n            image: elasticsearch:7.3.1\n            environment:\n              discovery.type: single-node\n            ports:\n              - \"9200:9200\"\n              - \"9300:9300\"\n          logstash:\n            image: logstash:7.3.1\n            command: logstash -f /etc/logstash/conf.d/logstash.conf\n            volumes:\n              # 挂载logstash配置文件\n              - ./config:/etc/logstash/conf.d\n              - /opt/build:/opt/build\n            ports:\n              - \"5000:5000\"\n              - \"8088:8088\"\n          kibana:\n            image: kibana:7.3.1\n            environment:\n              - ELASTICSEARCH_URL=http://120.79.2.30:9200\n            ports:\n              - \"5601:5601\"\n          \n- 在ELK中再创建目录config，并进入config目录，然后创建文件`logstash.conf`,文件内容如下：\n\n    \n    input {\n        tcp {\n            port => 8088\n            mode => \"server\"\n            ssl_enable => false\n            type => \"tcplog\"\n            codec => json_lines {\n                charset => \"UTF-8\"\n            }\n        }\n    }\n    filter {\n        grok {\n            match => { \"message\" => \"%{TIMESTAMP_ISO8601:timestamp}\\s+%{LOGLEVEL:severity}\\s+\\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\\]\\s+%{DATA:pid}\\s+---\\s+\\[%{DATA:thread}\\]\\s+%{DATA:class}\\s+:\\s+%{GREEDYDATA:rest}\" }\n        }\n    }\n    output {\n        elasticsearch {\n            hosts => \"120.79.2.30:9200\"\n            index => \"logstash\"\n        }\n    }\n    \n- 在ELK目下，启动ELK服务：\n\n\n    docker-compose up \n    \n## spring cloud 服务配置调整\n\n### pom.xml文件中添加依赖\n\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-sleuth</artifactId>\n    </dependency>\n    <!--必须要和logback版本对应，这个版本对应logback的1.2.3-->\n    <dependency>\n        <groupId>net.logstash.logback</groupId>\n        <artifactId>logstash-logback-encoder</artifactId>\n        <version>6.1</version>\n    </dependency> \n    \n _注意_: logstash-logback-encoder 的版本务必和Logback兼容，否则会导致应用启动不起来，而且不会打印任何日志！可前往 `https://github.com/logstash/logstash-logback-encoder` 查看和Logback的兼容性。                \n\n\n### 添加logback-spring.xml文件\n\n在 resources 目录下创建配置文件：logback-spring.xml，文件内容如下：\n\n    <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n    <configuration>\n        <include resource=\"org/springframework/boot/logging/logback/defaults.xml\"/>\n    \n        <springProperty scope=\"context\" name=\"springAppName\" source=\"spring.application.name\"/>\n        <!-- Example for logging into the build folder of your project -->\n        <property name=\"LOG_FILE\" value=\"./logs/${springAppName}/${springAppName}\"/>\n    \n        <!-- You can override this to have a custom pattern -->\n        <property name=\"CONSOLE_LOG_PATTERN\"\n                  value=\"%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}\"/>\n    \n        <property name=\"FILE_LOG_PATTERN\" value=\"${FILE_LOG_PATTERN:-%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } --- [%t] %-40.40logger{39} : %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}\"/>\n    \n        <!-- Appender to log to console -->\n        <appender name=\"console\" class=\"ch.qos.logback.core.ConsoleAppender\">\n            <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\">\n                <!-- Minimum logging level to be presented in the console logs-->\n                <level>DEBUG</level>\n            </filter>\n            <encoder>\n                <pattern>${CONSOLE_LOG_PATTERN}</pattern>\n                <charset>utf8</charset>\n            </encoder>\n        </appender>\n    \n        <!-- Appender to log to file -->\n        <appender name=\"flatfile\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\">\n            <file>${LOG_FILE}.log</file>\n            <rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\">\n                <fileNamePattern>${LOG_FILE}.%d{yyyy-MM-dd}.gz</fileNamePattern>\n                <maxHistory>7</maxHistory>\n            </rollingPolicy>\n            <encoder>\n                <pattern>${FILE_LOG_PATTERN}</pattern>\n                <charset>utf8</charset>\n            </encoder>\n        </appender>\n    \n        <!--通过网络，把日志发送到ELK服务器-->\n        <appender name=\"logstash\" class=\"net.logstash.logback.appender.LogstashTcpSocketAppender\">\n            <destination>120.79.2.30:8088</destination>\n            <writeBufferSize>16384</writeBufferSize>\n            <!-- encoder is required -->\n            <encoder class=\"net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder\">\n                <providers>\n                    <timestamp>\n                        <timeZone>UTC</timeZone>\n                    </timestamp>\n                    <pattern>\n                        <pattern>\n                            {\n                            \"severity\": \"%level\",\n                            \"service\": \"${springAppName:-}\",\n                            \"trace\": \"%X{X-B3-TraceId:-}\",\n                            \"span\": \"%X{X-B3-SpanId:-}\",\n                            \"parent\": \"%X{X-B3-ParentSpanId:-}\",\n                            \"exportable\": \"%X{X-Span-Export:-}\",\n                            \"pid\": \"${PID:-}\",\n                            \"thread\": \"%thread\",\n                            \"class\": \"%logger{40}\",\n                            \"rest\": \"%message\"\n                            }\n                        </pattern>\n                    </pattern>\n                </providers>\n            </encoder>\n        </appender>\n    \n        <root level=\"INFO\">\n            <appender-ref ref=\"console\"/>\n            <!-- uncomment this to have also JSON logs -->\n            <appender-ref ref=\"logstash\"/>\n            <appender-ref ref=\"flatfile\"/>\n        </root>\n    </configuration>\n    \n_注意：_ 应用名称`spring.application.name`必须放在配置文件`bootstrap.yml`中，否则`logback-spring.xml`将读取不到该变量。\n\n## 测试Sleuth & ELK\n\n- 启动你的微服务，并访问相关API产生一些输出日志。\n\n- 访问 http://localhost:5601 （Kibana地址），可看到类似如下的界面，按照如图配置Kibana。\n\n{% asset_img kibana1.png %}\n\n按下面图画红框步骤继续配置：\n\n{% asset_img kibana2.png %}\n\n输入查询条件，就可查询日志了：\n\n{% asset_img kibana3.png %}\n","slug":"scloud-elk","published":1,"updated":"2019-09-08T01:47:29.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqf300a5g4vas3usybfq","content":"<p>在分布式系统中，每个应用的实例都会在不同的物理机上产生日志。以往，系统出现问题需要查看日志的时候，就要到每台物理机对应的日志目录下查看相应的日志，这会非常的麻烦，特别是很多个实例的时候。<br>另外，微服务场景下，各个服务的日志链也都很分散，无法追踪，不知道实际的错误出现在哪个服务。<br>所以，就非常有必要把各个服务的各个实例所产生的日志都发送到统一的服务器上，并进行可视化的查看，分析。这就是我们这里要介绍的ELK能做的事情了。</p>\n<h2 id=\"ELK是什么东西\"><a href=\"#ELK是什么东西\" class=\"headerlink\" title=\"ELK是什么东西\"></a>ELK是什么东西</h2><p>实际就是三个软件系统：</p>\n<ul>\n<li>E：指的Elasticsearch,一个强大的搜索引擎。</li>\n<li>L：指的Logstash，解析并收集日志的系统。</li>\n<li>K：指的Kibana，一个可以可视化查看日志文件的系统。</li>\n</ul>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><ul>\n<li>Sleuth打印JSON格式的日志。</li>\n<li>logstash中配置语法，解析并收集JSON格式的日志，然后存储到Elasticsearch系统中去。</li>\n<li>Kibana可视化分析日志。集成Elasticsearch强大的搜索功能，找到任意输出的日志，并查看和分析。</li>\n</ul>\n<h2 id=\"ELK环境的搭建\"><a href=\"#ELK环境的搭建\" class=\"headerlink\" title=\"ELK环境的搭建\"></a>ELK环境的搭建</h2><p>这里介绍采用的单机模式。利用docker和docker-compose来部署。</p>\n<p>首先要在某台服务器上安装docker引擎和docker-compose服务。</p>\n<ul>\n<li>在服务器新建文件夹ELK。然后进入该文件夹，并创建文件<code>docker-compose.yml</code>，内容如下：</li>\n</ul>\n<pre><code>version: &apos;3&apos;\nservices:\n  elasticsearch:\n    image: elasticsearch:7.3.1\n    environment:\n      discovery.type: single-node\n    ports:\n      - &quot;9200:9200&quot;\n      - &quot;9300:9300&quot;\n  logstash:\n    image: logstash:7.3.1\n    command: logstash -f /etc/logstash/conf.d/logstash.conf\n    volumes:\n      # 挂载logstash配置文件\n      - ./config:/etc/logstash/conf.d\n      - /opt/build:/opt/build\n    ports:\n      - &quot;5000:5000&quot;\n      - &quot;8088:8088&quot;\n  kibana:\n    image: kibana:7.3.1\n    environment:\n      - ELASTICSEARCH_URL=http://120.79.2.30:9200\n    ports:\n      - &quot;5601:5601&quot;\n</code></pre><ul>\n<li>在ELK中再创建目录config，并进入config目录，然后创建文件<code>logstash.conf</code>,文件内容如下：</li>\n</ul>\n<pre><code>input {\n    tcp {\n        port =&gt; 8088\n        mode =&gt; &quot;server&quot;\n        ssl_enable =&gt; false\n        type =&gt; &quot;tcplog&quot;\n        codec =&gt; json_lines {\n            charset =&gt; &quot;UTF-8&quot;\n        }\n    }\n}\nfilter {\n    grok {\n        match =&gt; { &quot;message&quot; =&gt; &quot;%{TIMESTAMP_ISO8601:timestamp}\\s+%{LOGLEVEL:severity}\\s+\\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\\]\\s+%{DATA:pid}\\s+---\\s+\\[%{DATA:thread}\\]\\s+%{DATA:class}\\s+:\\s+%{GREEDYDATA:rest}&quot; }\n    }\n}\noutput {\n    elasticsearch {\n        hosts =&gt; &quot;120.79.2.30:9200&quot;\n        index =&gt; &quot;logstash&quot;\n    }\n}\n</code></pre><ul>\n<li>在ELK目下，启动ELK服务：</li>\n</ul>\n<pre><code>docker-compose up \n</code></pre><h2 id=\"spring-cloud-服务配置调整\"><a href=\"#spring-cloud-服务配置调整\" class=\"headerlink\" title=\"spring cloud 服务配置调整\"></a>spring cloud 服务配置调整</h2><h3 id=\"pom-xml文件中添加依赖\"><a href=\"#pom-xml文件中添加依赖\" class=\"headerlink\" title=\"pom.xml文件中添加依赖\"></a>pom.xml文件中添加依赖</h3><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--必须要和logback版本对应，这个版本对应logback的1.2.3--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;\n    &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;\n    &lt;version&gt;6.1&lt;/version&gt;\n&lt;/dependency&gt; \n</code></pre><p> _注意_: logstash-logback-encoder 的版本务必和Logback兼容，否则会导致应用启动不起来，而且不会打印任何日志！可前往 <code>https://github.com/logstash/logstash-logback-encoder</code> 查看和Logback的兼容性。                </p>\n<h3 id=\"添加logback-spring-xml文件\"><a href=\"#添加logback-spring-xml文件\" class=\"headerlink\" title=\"添加logback-spring.xml文件\"></a>添加logback-spring.xml文件</h3><p>在 resources 目录下创建配置文件：logback-spring.xml，文件内容如下：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;configuration&gt;\n    &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot;/&gt;\n\n    &lt;springProperty scope=&quot;context&quot; name=&quot;springAppName&quot; source=&quot;spring.application.name&quot;/&gt;\n    &lt;!-- Example for logging into the build folder of your project --&gt;\n    &lt;property name=&quot;LOG_FILE&quot; value=&quot;./logs/${springAppName}/${springAppName}&quot;/&gt;\n\n    &lt;!-- You can override this to have a custom pattern --&gt;\n    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;\n              value=&quot;%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}&quot;/&gt;\n\n    &lt;property name=&quot;FILE_LOG_PATTERN&quot; value=&quot;${FILE_LOG_PATTERN:-%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } --- [%t] %-40.40logger{39} : %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot;/&gt;\n\n    &lt;!-- Appender to log to console --&gt;\n    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;\n            &lt;!-- Minimum logging level to be presented in the console logs--&gt;\n            &lt;level&gt;DEBUG&lt;/level&gt;\n        &lt;/filter&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt;\n            &lt;charset&gt;utf8&lt;/charset&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- Appender to log to file --&gt;\n    &lt;appender name=&quot;flatfile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n        &lt;file&gt;${LOG_FILE}.log&lt;/file&gt;\n        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n            &lt;fileNamePattern&gt;${LOG_FILE}.%d{yyyy-MM-dd}.gz&lt;/fileNamePattern&gt;\n            &lt;maxHistory&gt;7&lt;/maxHistory&gt;\n        &lt;/rollingPolicy&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt;\n            &lt;charset&gt;utf8&lt;/charset&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!--通过网络，把日志发送到ELK服务器--&gt;\n    &lt;appender name=&quot;logstash&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;\n        &lt;destination&gt;120.79.2.30:8088&lt;/destination&gt;\n        &lt;writeBufferSize&gt;16384&lt;/writeBufferSize&gt;\n        &lt;!-- encoder is required --&gt;\n        &lt;encoder class=&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;&gt;\n            &lt;providers&gt;\n                &lt;timestamp&gt;\n                    &lt;timeZone&gt;UTC&lt;/timeZone&gt;\n                &lt;/timestamp&gt;\n                &lt;pattern&gt;\n                    &lt;pattern&gt;\n                        {\n                        &quot;severity&quot;: &quot;%level&quot;,\n                        &quot;service&quot;: &quot;${springAppName:-}&quot;,\n                        &quot;trace&quot;: &quot;%X{X-B3-TraceId:-}&quot;,\n                        &quot;span&quot;: &quot;%X{X-B3-SpanId:-}&quot;,\n                        &quot;parent&quot;: &quot;%X{X-B3-ParentSpanId:-}&quot;,\n                        &quot;exportable&quot;: &quot;%X{X-Span-Export:-}&quot;,\n                        &quot;pid&quot;: &quot;${PID:-}&quot;,\n                        &quot;thread&quot;: &quot;%thread&quot;,\n                        &quot;class&quot;: &quot;%logger{40}&quot;,\n                        &quot;rest&quot;: &quot;%message&quot;\n                        }\n                    &lt;/pattern&gt;\n                &lt;/pattern&gt;\n            &lt;/providers&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=&quot;INFO&quot;&gt;\n        &lt;appender-ref ref=&quot;console&quot;/&gt;\n        &lt;!-- uncomment this to have also JSON logs --&gt;\n        &lt;appender-ref ref=&quot;logstash&quot;/&gt;\n        &lt;appender-ref ref=&quot;flatfile&quot;/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre><p><em>注意：</em> 应用名称<code>spring.application.name</code>必须放在配置文件<code>bootstrap.yml</code>中，否则<code>logback-spring.xml</code>将读取不到该变量。</p>\n<h2 id=\"测试Sleuth-amp-ELK\"><a href=\"#测试Sleuth-amp-ELK\" class=\"headerlink\" title=\"测试Sleuth &amp; ELK\"></a>测试Sleuth &amp; ELK</h2><ul>\n<li><p>启动你的微服务，并访问相关API产生一些输出日志。</p>\n</li>\n<li><p>访问 <a href=\"http://localhost:5601\" target=\"_blank\" rel=\"noopener\">http://localhost:5601</a> （Kibana地址），可看到类似如下的界面，按照如图配置Kibana。</p>\n</li>\n</ul>\n<img src=\"/2019/09/04/scloud-elk/kibana1.png\">\n<p>按下面图画红框步骤继续配置：</p>\n<img src=\"/2019/09/04/scloud-elk/kibana2.png\">\n<p>输入查询条件，就可查询日志了：</p>\n<img src=\"/2019/09/04/scloud-elk/kibana3.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>在分布式系统中，每个应用的实例都会在不同的物理机上产生日志。以往，系统出现问题需要查看日志的时候，就要到每台物理机对应的日志目录下查看相应的日志，这会非常的麻烦，特别是很多个实例的时候。<br>另外，微服务场景下，各个服务的日志链也都很分散，无法追踪，不知道实际的错误出现在哪个服务。<br>所以，就非常有必要把各个服务的各个实例所产生的日志都发送到统一的服务器上，并进行可视化的查看，分析。这就是我们这里要介绍的ELK能做的事情了。</p>\n<h2 id=\"ELK是什么东西\"><a href=\"#ELK是什么东西\" class=\"headerlink\" title=\"ELK是什么东西\"></a>ELK是什么东西</h2><p>实际就是三个软件系统：</p>\n<ul>\n<li>E：指的Elasticsearch,一个强大的搜索引擎。</li>\n<li>L：指的Logstash，解析并收集日志的系统。</li>\n<li>K：指的Kibana，一个可以可视化查看日志文件的系统。</li>\n</ul>\n<h2 id=\"基本原理\"><a href=\"#基本原理\" class=\"headerlink\" title=\"基本原理\"></a>基本原理</h2><ul>\n<li>Sleuth打印JSON格式的日志。</li>\n<li>logstash中配置语法，解析并收集JSON格式的日志，然后存储到Elasticsearch系统中去。</li>\n<li>Kibana可视化分析日志。集成Elasticsearch强大的搜索功能，找到任意输出的日志，并查看和分析。</li>\n</ul>\n<h2 id=\"ELK环境的搭建\"><a href=\"#ELK环境的搭建\" class=\"headerlink\" title=\"ELK环境的搭建\"></a>ELK环境的搭建</h2><p>这里介绍采用的单机模式。利用docker和docker-compose来部署。</p>\n<p>首先要在某台服务器上安装docker引擎和docker-compose服务。</p>\n<ul>\n<li>在服务器新建文件夹ELK。然后进入该文件夹，并创建文件<code>docker-compose.yml</code>，内容如下：</li>\n</ul>\n<pre><code>version: &apos;3&apos;\nservices:\n  elasticsearch:\n    image: elasticsearch:7.3.1\n    environment:\n      discovery.type: single-node\n    ports:\n      - &quot;9200:9200&quot;\n      - &quot;9300:9300&quot;\n  logstash:\n    image: logstash:7.3.1\n    command: logstash -f /etc/logstash/conf.d/logstash.conf\n    volumes:\n      # 挂载logstash配置文件\n      - ./config:/etc/logstash/conf.d\n      - /opt/build:/opt/build\n    ports:\n      - &quot;5000:5000&quot;\n      - &quot;8088:8088&quot;\n  kibana:\n    image: kibana:7.3.1\n    environment:\n      - ELASTICSEARCH_URL=http://120.79.2.30:9200\n    ports:\n      - &quot;5601:5601&quot;\n</code></pre><ul>\n<li>在ELK中再创建目录config，并进入config目录，然后创建文件<code>logstash.conf</code>,文件内容如下：</li>\n</ul>\n<pre><code>input {\n    tcp {\n        port =&gt; 8088\n        mode =&gt; &quot;server&quot;\n        ssl_enable =&gt; false\n        type =&gt; &quot;tcplog&quot;\n        codec =&gt; json_lines {\n            charset =&gt; &quot;UTF-8&quot;\n        }\n    }\n}\nfilter {\n    grok {\n        match =&gt; { &quot;message&quot; =&gt; &quot;%{TIMESTAMP_ISO8601:timestamp}\\s+%{LOGLEVEL:severity}\\s+\\[%{DATA:service},%{DATA:trace},%{DATA:span},%{DATA:exportable}\\]\\s+%{DATA:pid}\\s+---\\s+\\[%{DATA:thread}\\]\\s+%{DATA:class}\\s+:\\s+%{GREEDYDATA:rest}&quot; }\n    }\n}\noutput {\n    elasticsearch {\n        hosts =&gt; &quot;120.79.2.30:9200&quot;\n        index =&gt; &quot;logstash&quot;\n    }\n}\n</code></pre><ul>\n<li>在ELK目下，启动ELK服务：</li>\n</ul>\n<pre><code>docker-compose up \n</code></pre><h2 id=\"spring-cloud-服务配置调整\"><a href=\"#spring-cloud-服务配置调整\" class=\"headerlink\" title=\"spring cloud 服务配置调整\"></a>spring cloud 服务配置调整</h2><h3 id=\"pom-xml文件中添加依赖\"><a href=\"#pom-xml文件中添加依赖\" class=\"headerlink\" title=\"pom.xml文件中添加依赖\"></a>pom.xml文件中添加依赖</h3><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--必须要和logback版本对应，这个版本对应logback的1.2.3--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;net.logstash.logback&lt;/groupId&gt;\n    &lt;artifactId&gt;logstash-logback-encoder&lt;/artifactId&gt;\n    &lt;version&gt;6.1&lt;/version&gt;\n&lt;/dependency&gt; \n</code></pre><p> _注意_: logstash-logback-encoder 的版本务必和Logback兼容，否则会导致应用启动不起来，而且不会打印任何日志！可前往 <code>https://github.com/logstash/logstash-logback-encoder</code> 查看和Logback的兼容性。                </p>\n<h3 id=\"添加logback-spring-xml文件\"><a href=\"#添加logback-spring-xml文件\" class=\"headerlink\" title=\"添加logback-spring.xml文件\"></a>添加logback-spring.xml文件</h3><p>在 resources 目录下创建配置文件：logback-spring.xml，文件内容如下：</p>\n<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;configuration&gt;\n    &lt;include resource=&quot;org/springframework/boot/logging/logback/defaults.xml&quot;/&gt;\n\n    &lt;springProperty scope=&quot;context&quot; name=&quot;springAppName&quot; source=&quot;spring.application.name&quot;/&gt;\n    &lt;!-- Example for logging into the build folder of your project --&gt;\n    &lt;property name=&quot;LOG_FILE&quot; value=&quot;./logs/${springAppName}/${springAppName}&quot;/&gt;\n\n    &lt;!-- You can override this to have a custom pattern --&gt;\n    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot;\n              value=&quot;%clr(%d{yyyy-MM-dd HH:mm:ss.SSS}){faint} %clr(${LOG_LEVEL_PATTERN:-%5p}) %clr(${PID:- }){magenta} %clr(---){faint} %clr([%15.15t]){faint} %clr(%-40.40logger{39}){cyan} %clr(:){faint} %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}&quot;/&gt;\n\n    &lt;property name=&quot;FILE_LOG_PATTERN&quot; value=&quot;${FILE_LOG_PATTERN:-%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}} ${LOG_LEVEL_PATTERN:-%5p} ${PID:- } --- [%t] %-40.40logger{39} : %m%n${LOG_EXCEPTION_CONVERSION_WORD:-%wEx}}&quot;/&gt;\n\n    &lt;!-- Appender to log to console --&gt;\n    &lt;appender name=&quot;console&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;\n        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;\n            &lt;!-- Minimum logging level to be presented in the console logs--&gt;\n            &lt;level&gt;DEBUG&lt;/level&gt;\n        &lt;/filter&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;${CONSOLE_LOG_PATTERN}&lt;/pattern&gt;\n            &lt;charset&gt;utf8&lt;/charset&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!-- Appender to log to file --&gt;\n    &lt;appender name=&quot;flatfile&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;\n        &lt;file&gt;${LOG_FILE}.log&lt;/file&gt;\n        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;\n            &lt;fileNamePattern&gt;${LOG_FILE}.%d{yyyy-MM-dd}.gz&lt;/fileNamePattern&gt;\n            &lt;maxHistory&gt;7&lt;/maxHistory&gt;\n        &lt;/rollingPolicy&gt;\n        &lt;encoder&gt;\n            &lt;pattern&gt;${FILE_LOG_PATTERN}&lt;/pattern&gt;\n            &lt;charset&gt;utf8&lt;/charset&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;!--通过网络，把日志发送到ELK服务器--&gt;\n    &lt;appender name=&quot;logstash&quot; class=&quot;net.logstash.logback.appender.LogstashTcpSocketAppender&quot;&gt;\n        &lt;destination&gt;120.79.2.30:8088&lt;/destination&gt;\n        &lt;writeBufferSize&gt;16384&lt;/writeBufferSize&gt;\n        &lt;!-- encoder is required --&gt;\n        &lt;encoder class=&quot;net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder&quot;&gt;\n            &lt;providers&gt;\n                &lt;timestamp&gt;\n                    &lt;timeZone&gt;UTC&lt;/timeZone&gt;\n                &lt;/timestamp&gt;\n                &lt;pattern&gt;\n                    &lt;pattern&gt;\n                        {\n                        &quot;severity&quot;: &quot;%level&quot;,\n                        &quot;service&quot;: &quot;${springAppName:-}&quot;,\n                        &quot;trace&quot;: &quot;%X{X-B3-TraceId:-}&quot;,\n                        &quot;span&quot;: &quot;%X{X-B3-SpanId:-}&quot;,\n                        &quot;parent&quot;: &quot;%X{X-B3-ParentSpanId:-}&quot;,\n                        &quot;exportable&quot;: &quot;%X{X-Span-Export:-}&quot;,\n                        &quot;pid&quot;: &quot;${PID:-}&quot;,\n                        &quot;thread&quot;: &quot;%thread&quot;,\n                        &quot;class&quot;: &quot;%logger{40}&quot;,\n                        &quot;rest&quot;: &quot;%message&quot;\n                        }\n                    &lt;/pattern&gt;\n                &lt;/pattern&gt;\n            &lt;/providers&gt;\n        &lt;/encoder&gt;\n    &lt;/appender&gt;\n\n    &lt;root level=&quot;INFO&quot;&gt;\n        &lt;appender-ref ref=&quot;console&quot;/&gt;\n        &lt;!-- uncomment this to have also JSON logs --&gt;\n        &lt;appender-ref ref=&quot;logstash&quot;/&gt;\n        &lt;appender-ref ref=&quot;flatfile&quot;/&gt;\n    &lt;/root&gt;\n&lt;/configuration&gt;\n</code></pre><p><em>注意：</em> 应用名称<code>spring.application.name</code>必须放在配置文件<code>bootstrap.yml</code>中，否则<code>logback-spring.xml</code>将读取不到该变量。</p>\n<h2 id=\"测试Sleuth-amp-ELK\"><a href=\"#测试Sleuth-amp-ELK\" class=\"headerlink\" title=\"测试Sleuth &amp; ELK\"></a>测试Sleuth &amp; ELK</h2><ul>\n<li><p>启动你的微服务，并访问相关API产生一些输出日志。</p>\n</li>\n<li><p>访问 <a href=\"http://localhost:5601\" target=\"_blank\" rel=\"noopener\">http://localhost:5601</a> （Kibana地址），可看到类似如下的界面，按照如图配置Kibana。</p>\n</li>\n</ul>\n<img src=\"/2019/09/04/scloud-elk/kibana1.png\">\n<p>按下面图画红框步骤继续配置：</p>\n<img src=\"/2019/09/04/scloud-elk/kibana2.png\">\n<p>输入查询条件，就可查询日志了：</p>\n<img src=\"/2019/09/04/scloud-elk/kibana3.png\">\n"},{"title":"spring cloud feign自定义","date":"2018-05-08T12:36:02.000Z","_content":"\n参考：https://www.jianshu.com/p/755b15ff0249","source":"_posts/scloud-feign-config.md","raw":"---\ntitle: spring cloud feign自定义\ndate: 2018-05-08 20:36:02\ncategories: spring-cloud\ntags: feign\n---\n\n参考：https://www.jianshu.com/p/755b15ff0249","slug":"scloud-feign-config","published":1,"updated":"2019-06-16T14:38:33.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqf400a8g4va532dq1sa","content":"<p>参考：<a href=\"https://www.jianshu.com/p/755b15ff0249\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/755b15ff0249</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://www.jianshu.com/p/755b15ff0249\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/755b15ff0249</a></p>\n"},{"title":"spring cloud Hystrix监控","date":"2018-05-08T07:30:31.000Z","_content":"\n参考：https://www.jianshu.com/p/b7b20fc09ca9\n\nhttps://blog.csdn.net/liaokailin/article/details/51344281\n\n\n## 单个节点监控\n\n\n## 聚合监控","source":"_posts/scloud-hystrix-dashboard.md","raw":"---\ntitle: spring cloud Hystrix监控\ndate: 2018-05-08 15:30:31\ncategories: spring-cloud\ntags: hystrix,dashboard\n---\n\n参考：https://www.jianshu.com/p/b7b20fc09ca9\n\nhttps://blog.csdn.net/liaokailin/article/details/51344281\n\n\n## 单个节点监控\n\n\n## 聚合监控","slug":"scloud-hystrix-dashboard","published":1,"updated":"2019-06-16T14:38:33.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqf500aag4va9og65zlz","content":"<p>参考：<a href=\"https://www.jianshu.com/p/b7b20fc09ca9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b7b20fc09ca9</a></p>\n<p><a href=\"https://blog.csdn.net/liaokailin/article/details/51344281\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liaokailin/article/details/51344281</a></p>\n<h2 id=\"单个节点监控\"><a href=\"#单个节点监控\" class=\"headerlink\" title=\"单个节点监控\"></a>单个节点监控</h2><h2 id=\"聚合监控\"><a href=\"#聚合监控\" class=\"headerlink\" title=\"聚合监控\"></a>聚合监控</h2>","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://www.jianshu.com/p/b7b20fc09ca9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b7b20fc09ca9</a></p>\n<p><a href=\"https://blog.csdn.net/liaokailin/article/details/51344281\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liaokailin/article/details/51344281</a></p>\n<h2 id=\"单个节点监控\"><a href=\"#单个节点监控\" class=\"headerlink\" title=\"单个节点监控\"></a>单个节点监控</h2><h2 id=\"聚合监控\"><a href=\"#聚合监控\" class=\"headerlink\" title=\"聚合监控\"></a>聚合监控</h2>"},{"title":"spring cloud 熔断器,服务降级","date":"2018-05-08T03:21:35.000Z","_content":"\n## ","source":"_posts/scloud-hystrix.md","raw":"---\ntitle: spring cloud 熔断器,服务降级\ndate: 2018-05-08 11:21:35\ncategories: spring-cloud\ntags: hystrix\n---\n\n## ","slug":"scloud-hystrix","published":1,"updated":"2019-06-16T14:38:33.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqf800aeg4vai16ayno8","content":"<p>## </p>\n","site":{"data":{}},"excerpt":"","more":"<p>## </p>\n"},{"title":"Spring Cloud使用问题记录","date":"2019-05-31T10:20:21.000Z","_content":"\n## Zuul问题\n\n1、max-threads：需要根据具体的硬件环境进行调整\n2、max-threads：并不是线程数越大越好，线程数增加会增加内存开销同时大量线程切换会浪费不少时间，并且容易造成内存溢出\n3、如果单一网关不能满足并发量，网关可以集群，使用nginx分发请求给多个网关\n4、可以使用spring-session、redis解决session一致性问题\n\n#### header信息路由到服务后丢失\n\n解决问题\n \n- 保留请求header信息。全部配置\nzuul.sensitive-headers=\n或者具体服务配置\nzuul.routes.xxx.sensitive-headers=\nzuul.routes.xxx.custom-sensitive-headers=true\n\n参考这篇文章\n\nSpring Cloud实战小贴士：Zuul处理Cookie和重定向\n\nhttp://blog.csdn.net/dream8062/article/details/71169628\n\nhttp://blog.didispace.com/spring-cloud-zuul-cookie-redirect/\n\n#### 跨域问题\n\n_问题描述：_\n\n正常情况下，跨域是这样的：\n1. 微服务配置跨域+zuul不配置=有跨域问题\n2. 微服务配置+zuul配置=有跨域问题\n3. 微服务不配置+zuul不配置=有跨域问题\n4. 微服务不配置+zuul配置=ok\n\n然而云环境中每个服务自己有跨域解决方案，而网关需要做最外层的跨域解决方案.如果服务已有跨域配置网关也有，会出现*多次配置问题。\n\n    Access-Control-Allow-Origin:\"*,*\"\n    \n    也就是multiple Access-Control-Allow-Origin\n    \n！！！所以我们就要，微服务配置+zuul配置=解决跨域问题\n\n_问题解决：_\n\n使用ZUUL配置忽略头部信息\n\n    zuul:\n      #需要忽略的头部信息，不再传播到其他服务。\n      ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken    \n\n\n#### cookie无法跨域，会话无法保持的问题\n\n_问题：_\n\n当我们解决了上面的头路由到服务，跨域的问题后。但是又出现了另外的问题，浏览器无法保存cookie信息，导致每次发起请求，都会重新创建不同的session会话。 \n这样的话，客户端频繁的请求将会在服务端创建大量的session对象，这对服务器是个很大的负担，会话无法保持，每次都新建会话。\n\n_解决：_\n\n1.在zuul网关层更改跨域配置：\n\n    # cors跨域设置\n    custom:\n      cors:\n        mapping: /**\n        allowCredentials: true #允许cookie跨域\n        allowedOrigins: \"*\" #允许的域，多个用逗号隔开。*允许全部的域通过。一定要用双引号，否则配置文件报错。\n        #    allowedMethods: POST,GET,DELETE,PUT #这样设置，静态资源将不能跨域\n        allowedMethods: \"*\"\n        allowedHeaders: \"*\"\n        \n关键是：`allowCredentials: true`,设置为true，即允许cookie跨域。\n\n2.前端配置\n\n前端跨域设置 withCredentials: true\n\n- angular2应用\n\n        const httpOptions = {\n          headers: new HttpHeaders({\n            'Content-Version': '0',\n            'Content-Type':  'application/json'\n          }),\n          params: new HttpParams(),\n          withCredentials: true\n        };\n    \n关键：`withCredentials: true`。 \n\n- ajax请求\n\n在ajax请求里加上xhrFields: {withCredentials: true}, crossDomain: true。\n    \n\n即在http请求中，options参数中添加参数`withCredentials: true`。\n\n这样配置后，经过测试，发现，每次通过zuul路由到具体服务后，在具体服务中的sessionId都是一样的。只创建一次会话，一直保持，知道会话断开。\n\n3.补充（配置）\n\nzuul配置：\n\n    zuul:\n      add-host-header: true #重定向问题\n      sensitive-headers: #保留所有头信息传递，解决多个服务在转发中sessionId不一致的问题，到了服务层，缺少头信息的问题。注意：每个具体的服务的sessionId还是不一样的?\n      ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken         \n      \n具体服务跨域配置：\n\n    # cors跨域设置\n    custom:\n      cors:\n        mapping: /**\n        allowCredentials: false # 不循序cookie跨域\n        allowedOrigins: \"*\" #允许的域，多个用逗号隔开。*允许全部的域通过。一定要用双引号，否则配置文件报错。\n        #    allowedMethods: POST,GET,DELETE,PUT #这样设置，静态资源将不能跨域\n        allowedMethods: \"*\"\n        allowedHeaders: \"*\"        \n\n\n","source":"_posts/scloud-issu-record.md","raw":"---\ntitle: Spring Cloud使用问题记录\ndate: 2019-05-31 18:20:21\ncategories: spring-cloud\ntags:\n---\n\n## Zuul问题\n\n1、max-threads：需要根据具体的硬件环境进行调整\n2、max-threads：并不是线程数越大越好，线程数增加会增加内存开销同时大量线程切换会浪费不少时间，并且容易造成内存溢出\n3、如果单一网关不能满足并发量，网关可以集群，使用nginx分发请求给多个网关\n4、可以使用spring-session、redis解决session一致性问题\n\n#### header信息路由到服务后丢失\n\n解决问题\n \n- 保留请求header信息。全部配置\nzuul.sensitive-headers=\n或者具体服务配置\nzuul.routes.xxx.sensitive-headers=\nzuul.routes.xxx.custom-sensitive-headers=true\n\n参考这篇文章\n\nSpring Cloud实战小贴士：Zuul处理Cookie和重定向\n\nhttp://blog.csdn.net/dream8062/article/details/71169628\n\nhttp://blog.didispace.com/spring-cloud-zuul-cookie-redirect/\n\n#### 跨域问题\n\n_问题描述：_\n\n正常情况下，跨域是这样的：\n1. 微服务配置跨域+zuul不配置=有跨域问题\n2. 微服务配置+zuul配置=有跨域问题\n3. 微服务不配置+zuul不配置=有跨域问题\n4. 微服务不配置+zuul配置=ok\n\n然而云环境中每个服务自己有跨域解决方案，而网关需要做最外层的跨域解决方案.如果服务已有跨域配置网关也有，会出现*多次配置问题。\n\n    Access-Control-Allow-Origin:\"*,*\"\n    \n    也就是multiple Access-Control-Allow-Origin\n    \n！！！所以我们就要，微服务配置+zuul配置=解决跨域问题\n\n_问题解决：_\n\n使用ZUUL配置忽略头部信息\n\n    zuul:\n      #需要忽略的头部信息，不再传播到其他服务。\n      ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken    \n\n\n#### cookie无法跨域，会话无法保持的问题\n\n_问题：_\n\n当我们解决了上面的头路由到服务，跨域的问题后。但是又出现了另外的问题，浏览器无法保存cookie信息，导致每次发起请求，都会重新创建不同的session会话。 \n这样的话，客户端频繁的请求将会在服务端创建大量的session对象，这对服务器是个很大的负担，会话无法保持，每次都新建会话。\n\n_解决：_\n\n1.在zuul网关层更改跨域配置：\n\n    # cors跨域设置\n    custom:\n      cors:\n        mapping: /**\n        allowCredentials: true #允许cookie跨域\n        allowedOrigins: \"*\" #允许的域，多个用逗号隔开。*允许全部的域通过。一定要用双引号，否则配置文件报错。\n        #    allowedMethods: POST,GET,DELETE,PUT #这样设置，静态资源将不能跨域\n        allowedMethods: \"*\"\n        allowedHeaders: \"*\"\n        \n关键是：`allowCredentials: true`,设置为true，即允许cookie跨域。\n\n2.前端配置\n\n前端跨域设置 withCredentials: true\n\n- angular2应用\n\n        const httpOptions = {\n          headers: new HttpHeaders({\n            'Content-Version': '0',\n            'Content-Type':  'application/json'\n          }),\n          params: new HttpParams(),\n          withCredentials: true\n        };\n    \n关键：`withCredentials: true`。 \n\n- ajax请求\n\n在ajax请求里加上xhrFields: {withCredentials: true}, crossDomain: true。\n    \n\n即在http请求中，options参数中添加参数`withCredentials: true`。\n\n这样配置后，经过测试，发现，每次通过zuul路由到具体服务后，在具体服务中的sessionId都是一样的。只创建一次会话，一直保持，知道会话断开。\n\n3.补充（配置）\n\nzuul配置：\n\n    zuul:\n      add-host-header: true #重定向问题\n      sensitive-headers: #保留所有头信息传递，解决多个服务在转发中sessionId不一致的问题，到了服务层，缺少头信息的问题。注意：每个具体的服务的sessionId还是不一样的?\n      ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken         \n      \n具体服务跨域配置：\n\n    # cors跨域设置\n    custom:\n      cors:\n        mapping: /**\n        allowCredentials: false # 不循序cookie跨域\n        allowedOrigins: \"*\" #允许的域，多个用逗号隔开。*允许全部的域通过。一定要用双引号，否则配置文件报错。\n        #    allowedMethods: POST,GET,DELETE,PUT #这样设置，静态资源将不能跨域\n        allowedMethods: \"*\"\n        allowedHeaders: \"*\"        \n\n\n","slug":"scloud-issu-record","published":1,"updated":"2020-05-30T11:28:23.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqf900agg4va812rs2xg","content":"<h2 id=\"Zuul问题\"><a href=\"#Zuul问题\" class=\"headerlink\" title=\"Zuul问题\"></a>Zuul问题</h2><p>1、max-threads：需要根据具体的硬件环境进行调整<br>2、max-threads：并不是线程数越大越好，线程数增加会增加内存开销同时大量线程切换会浪费不少时间，并且容易造成内存溢出<br>3、如果单一网关不能满足并发量，网关可以集群，使用nginx分发请求给多个网关<br>4、可以使用spring-session、redis解决session一致性问题</p>\n<h4 id=\"header信息路由到服务后丢失\"><a href=\"#header信息路由到服务后丢失\" class=\"headerlink\" title=\"header信息路由到服务后丢失\"></a>header信息路由到服务后丢失</h4><p>解决问题</p>\n<ul>\n<li>保留请求header信息。全部配置<br>zuul.sensitive-headers=<br>或者具体服务配置<br>zuul.routes.xxx.sensitive-headers=<br>zuul.routes.xxx.custom-sensitive-headers=true</li>\n</ul>\n<p>参考这篇文章</p>\n<p>Spring Cloud实战小贴士：Zuul处理Cookie和重定向</p>\n<p><a href=\"http://blog.csdn.net/dream8062/article/details/71169628\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/dream8062/article/details/71169628</a></p>\n<p><a href=\"http://blog.didispace.com/spring-cloud-zuul-cookie-redirect/\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/spring-cloud-zuul-cookie-redirect/</a></p>\n<h4 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h4><p><em>问题描述：</em></p>\n<p>正常情况下，跨域是这样的：</p>\n<ol>\n<li>微服务配置跨域+zuul不配置=有跨域问题</li>\n<li>微服务配置+zuul配置=有跨域问题</li>\n<li>微服务不配置+zuul不配置=有跨域问题</li>\n<li>微服务不配置+zuul配置=ok</li>\n</ol>\n<p>然而云环境中每个服务自己有跨域解决方案，而网关需要做最外层的跨域解决方案.如果服务已有跨域配置网关也有，会出现*多次配置问题。</p>\n<pre><code>Access-Control-Allow-Origin:&quot;*,*&quot;\n\n也就是multiple Access-Control-Allow-Origin\n</code></pre><p>！！！所以我们就要，微服务配置+zuul配置=解决跨域问题</p>\n<p><em>问题解决：</em></p>\n<p>使用ZUUL配置忽略头部信息</p>\n<pre><code>zuul:\n  #需要忽略的头部信息，不再传播到其他服务。\n  ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken    \n</code></pre><h4 id=\"cookie无法跨域，会话无法保持的问题\"><a href=\"#cookie无法跨域，会话无法保持的问题\" class=\"headerlink\" title=\"cookie无法跨域，会话无法保持的问题\"></a>cookie无法跨域，会话无法保持的问题</h4><p><em>问题：</em></p>\n<p>当我们解决了上面的头路由到服务，跨域的问题后。但是又出现了另外的问题，浏览器无法保存cookie信息，导致每次发起请求，都会重新创建不同的session会话。<br>这样的话，客户端频繁的请求将会在服务端创建大量的session对象，这对服务器是个很大的负担，会话无法保持，每次都新建会话。</p>\n<p><em>解决：</em></p>\n<p>1.在zuul网关层更改跨域配置：</p>\n<pre><code># cors跨域设置\ncustom:\n  cors:\n    mapping: /**\n    allowCredentials: true #允许cookie跨域\n    allowedOrigins: &quot;*&quot; #允许的域，多个用逗号隔开。*允许全部的域通过。一定要用双引号，否则配置文件报错。\n    #    allowedMethods: POST,GET,DELETE,PUT #这样设置，静态资源将不能跨域\n    allowedMethods: &quot;*&quot;\n    allowedHeaders: &quot;*&quot;\n</code></pre><p>关键是：<code>allowCredentials: true</code>,设置为true，即允许cookie跨域。</p>\n<p>2.前端配置</p>\n<p>前端跨域设置 withCredentials: true</p>\n<ul>\n<li><p>angular2应用</p>\n<pre><code>const httpOptions = {\n  headers: new HttpHeaders({\n    &apos;Content-Version&apos;: &apos;0&apos;,\n    &apos;Content-Type&apos;:  &apos;application/json&apos;\n  }),\n  params: new HttpParams(),\n  withCredentials: true\n};\n</code></pre></li>\n</ul>\n<p>关键：<code>withCredentials: true</code>。 </p>\n<ul>\n<li>ajax请求</li>\n</ul>\n<p>在ajax请求里加上xhrFields: {withCredentials: true}, crossDomain: true。</p>\n<p>即在http请求中，options参数中添加参数<code>withCredentials: true</code>。</p>\n<p>这样配置后，经过测试，发现，每次通过zuul路由到具体服务后，在具体服务中的sessionId都是一样的。只创建一次会话，一直保持，知道会话断开。</p>\n<p>3.补充（配置）</p>\n<p>zuul配置：</p>\n<pre><code>zuul:\n  add-host-header: true #重定向问题\n  sensitive-headers: #保留所有头信息传递，解决多个服务在转发中sessionId不一致的问题，到了服务层，缺少头信息的问题。注意：每个具体的服务的sessionId还是不一样的?\n  ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken         \n</code></pre><p>具体服务跨域配置：</p>\n<pre><code># cors跨域设置\ncustom:\n  cors:\n    mapping: /**\n    allowCredentials: false # 不循序cookie跨域\n    allowedOrigins: &quot;*&quot; #允许的域，多个用逗号隔开。*允许全部的域通过。一定要用双引号，否则配置文件报错。\n    #    allowedMethods: POST,GET,DELETE,PUT #这样设置，静态资源将不能跨域\n    allowedMethods: &quot;*&quot;\n    allowedHeaders: &quot;*&quot;        \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Zuul问题\"><a href=\"#Zuul问题\" class=\"headerlink\" title=\"Zuul问题\"></a>Zuul问题</h2><p>1、max-threads：需要根据具体的硬件环境进行调整<br>2、max-threads：并不是线程数越大越好，线程数增加会增加内存开销同时大量线程切换会浪费不少时间，并且容易造成内存溢出<br>3、如果单一网关不能满足并发量，网关可以集群，使用nginx分发请求给多个网关<br>4、可以使用spring-session、redis解决session一致性问题</p>\n<h4 id=\"header信息路由到服务后丢失\"><a href=\"#header信息路由到服务后丢失\" class=\"headerlink\" title=\"header信息路由到服务后丢失\"></a>header信息路由到服务后丢失</h4><p>解决问题</p>\n<ul>\n<li>保留请求header信息。全部配置<br>zuul.sensitive-headers=<br>或者具体服务配置<br>zuul.routes.xxx.sensitive-headers=<br>zuul.routes.xxx.custom-sensitive-headers=true</li>\n</ul>\n<p>参考这篇文章</p>\n<p>Spring Cloud实战小贴士：Zuul处理Cookie和重定向</p>\n<p><a href=\"http://blog.csdn.net/dream8062/article/details/71169628\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/dream8062/article/details/71169628</a></p>\n<p><a href=\"http://blog.didispace.com/spring-cloud-zuul-cookie-redirect/\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/spring-cloud-zuul-cookie-redirect/</a></p>\n<h4 id=\"跨域问题\"><a href=\"#跨域问题\" class=\"headerlink\" title=\"跨域问题\"></a>跨域问题</h4><p><em>问题描述：</em></p>\n<p>正常情况下，跨域是这样的：</p>\n<ol>\n<li>微服务配置跨域+zuul不配置=有跨域问题</li>\n<li>微服务配置+zuul配置=有跨域问题</li>\n<li>微服务不配置+zuul不配置=有跨域问题</li>\n<li>微服务不配置+zuul配置=ok</li>\n</ol>\n<p>然而云环境中每个服务自己有跨域解决方案，而网关需要做最外层的跨域解决方案.如果服务已有跨域配置网关也有，会出现*多次配置问题。</p>\n<pre><code>Access-Control-Allow-Origin:&quot;*,*&quot;\n\n也就是multiple Access-Control-Allow-Origin\n</code></pre><p>！！！所以我们就要，微服务配置+zuul配置=解决跨域问题</p>\n<p><em>问题解决：</em></p>\n<p>使用ZUUL配置忽略头部信息</p>\n<pre><code>zuul:\n  #需要忽略的头部信息，不再传播到其他服务。\n  ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken    \n</code></pre><h4 id=\"cookie无法跨域，会话无法保持的问题\"><a href=\"#cookie无法跨域，会话无法保持的问题\" class=\"headerlink\" title=\"cookie无法跨域，会话无法保持的问题\"></a>cookie无法跨域，会话无法保持的问题</h4><p><em>问题：</em></p>\n<p>当我们解决了上面的头路由到服务，跨域的问题后。但是又出现了另外的问题，浏览器无法保存cookie信息，导致每次发起请求，都会重新创建不同的session会话。<br>这样的话，客户端频繁的请求将会在服务端创建大量的session对象，这对服务器是个很大的负担，会话无法保持，每次都新建会话。</p>\n<p><em>解决：</em></p>\n<p>1.在zuul网关层更改跨域配置：</p>\n<pre><code># cors跨域设置\ncustom:\n  cors:\n    mapping: /**\n    allowCredentials: true #允许cookie跨域\n    allowedOrigins: &quot;*&quot; #允许的域，多个用逗号隔开。*允许全部的域通过。一定要用双引号，否则配置文件报错。\n    #    allowedMethods: POST,GET,DELETE,PUT #这样设置，静态资源将不能跨域\n    allowedMethods: &quot;*&quot;\n    allowedHeaders: &quot;*&quot;\n</code></pre><p>关键是：<code>allowCredentials: true</code>,设置为true，即允许cookie跨域。</p>\n<p>2.前端配置</p>\n<p>前端跨域设置 withCredentials: true</p>\n<ul>\n<li><p>angular2应用</p>\n<pre><code>const httpOptions = {\n  headers: new HttpHeaders({\n    &apos;Content-Version&apos;: &apos;0&apos;,\n    &apos;Content-Type&apos;:  &apos;application/json&apos;\n  }),\n  params: new HttpParams(),\n  withCredentials: true\n};\n</code></pre></li>\n</ul>\n<p>关键：<code>withCredentials: true</code>。 </p>\n<ul>\n<li>ajax请求</li>\n</ul>\n<p>在ajax请求里加上xhrFields: {withCredentials: true}, crossDomain: true。</p>\n<p>即在http请求中，options参数中添加参数<code>withCredentials: true</code>。</p>\n<p>这样配置后，经过测试，发现，每次通过zuul路由到具体服务后，在具体服务中的sessionId都是一样的。只创建一次会话，一直保持，知道会话断开。</p>\n<p>3.补充（配置）</p>\n<p>zuul配置：</p>\n<pre><code>zuul:\n  add-host-header: true #重定向问题\n  sensitive-headers: #保留所有头信息传递，解决多个服务在转发中sessionId不一致的问题，到了服务层，缺少头信息的问题。注意：每个具体的服务的sessionId还是不一样的?\n  ignored-headers: Access-Control-Allow-Origin,H-APP-Id,Token,APPToken         \n</code></pre><p>具体服务跨域配置：</p>\n<pre><code># cors跨域设置\ncustom:\n  cors:\n    mapping: /**\n    allowCredentials: false # 不循序cookie跨域\n    allowedOrigins: &quot;*&quot; #允许的域，多个用逗号隔开。*允许全部的域通过。一定要用双引号，否则配置文件报错。\n    #    allowedMethods: POST,GET,DELETE,PUT #这样设置，静态资源将不能跨域\n    allowedMethods: &quot;*&quot;\n    allowedHeaders: &quot;*&quot;        \n</code></pre>"},{"title":"spring-cloud-zuul网关统一异常处理","date":"2017-09-23T09:48:05.000Z","_content":"","source":"_posts/scloud-zuul-exception.md","raw":"---\ntitle: spring-cloud-zuul网关统一异常处理\ndate: 2017-09-23 17:48:05\ncategories: spring-cloud\ntags: zuul-exception\n---\n","slug":"scloud-zuul-exception","published":1,"updated":"2019-06-16T14:38:33.458Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfb00akg4vahskgtv6a","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"scloud-zuul-filters网关过滤","date":"2017-10-11T08:56:22.000Z","_content":"在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","source":"_posts/scloud-zuul-filters.md","raw":"---\ntitle: scloud-zuul-filters网关过滤\ndate: 2017-10-11 16:56:22\ncategories: spring-cloud\ntags: zuul-filters\n---\n在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","slug":"scloud-zuul-filters","published":1,"updated":"2019-06-16T14:38:33.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfc00amg4vaul9hhk4b","content":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n"},{"title":"Spring Cloud外部环境配置刷新","date":"2019-04-20T14:55:37.000Z","_content":"\n本文介绍在spring cloud架构中，如何做配置外部化以及更改配置属性并实时刷新的问题。      \n实验环境：\nspring boot：2.1.4.RELEASE   \nspring cloud: Greenwich.SR1 \ngithub  \nrabbitmq: 3.7.8\n\n## 服务注册发现中心eureka-server\n\n关键依赖：\n\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n    </dependency>\n    \napplication.yml：\n\n    server:\n      port: 1112\n    spring:\n      application:\n        name: eureka-server\n      profiles:\n        active: dev\n    logging:\n      level:\n        com:\n          netflix:\n            eureka: off\n            discovery: off\n      file: logs/${spring.application.name}.log\n\n\napplication-dev.yml：\n\n    eureka:\n      instance:\n        instance-id: ${spring.application.name}:${spring.cloud.client.ip_address}:${server.port}\n        hostname: localhost\n      client:\n        fetch-registry: false\n        register-with-eureka: false  #不注册自己\n        service-url:\n          defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n      server:\n          enable-self-preservation: false #设为false，关闭自我保护\n          eviction-interval-timer-in-ms: 4000  # 清理间隔（单位毫秒，默认是60*1000）\n    \n该服务没什么需要注意的，按正常的来就可以。\n\n\n## 配置中心config-server    \n\n### 关键依赖：\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-server</artifactId>\n    </dependency>\n    <!--实时刷新配置 start -->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-monitor</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n    </dependency>\n    <!--实时刷新配置 end -->\n\n    <!--作为服务注册到服务注册中心 -->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n\n要配置刷新，只需要添加：\n \n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-monitor</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n    </dependency>\n\n### 配置\n\nbootstrap.yml：\n\n    server:\n      port: 3331\n    spring:\n      application:\n        name: config-server\n      profiles:\n        active: dev\n    ## 非对称加解密,该段配置只能放在bootstrap.yml中\n    encrypt:\n      key-store:\n        location: classpath:/config-server.jks\n        password: 111111  # storepass\n        alias: config-server    # alias\n        secret: 222222   # keypass\n    \napplication.yml：\n\n    management:\n      endpoints:\n        web:\n          exposure:\n            include: \"*\"\n\n`management.endpoints.web.exposure.include`这个配置一定要加上，关键。默认是指暴露站点：info，health。改成星号，代表暴露全部。\n\napplication-dev.yml：\n\n    #作为服务注册到注册中心\n    eureka:\n      server:\n        ip: localhost\n        port: 1112\n      instance:\n        instance-id: ${spring.application.name}:${spring.cloud.client.ip-address}:${server.port}\n        prefer-ip-address: true #显示ip,浏览器以ip方式请求。\n        #域名\n    #    hostname: localhost\n        #查看健康运行状态\n        health-check-url-path: /actuator/health\n        status-page-url-path: /actuator/info\n      client:\n        service-url:\n          defaultZone: http://${eureka.server.ip}:${eureka.server.port}/eureka/\n    spring:\n      security:\n          user:\n            name: admin\n            password: 123456\n      cloud:\n        #git配置中心\n        config:\n          server:\n            git:\n              uri: https://github.com/xrlj/config-repo-dev\n              #git的配置文件会加载到本地的目录\n              basedir: target/config\n              # 设置超时\n              timeout: 4\n              force-pull: true  #每次都强制拉取远程git的配置更新本地。\n              default-label: master\n        bus:\n          enabled: true\n          trace:\n            enabled: true\n      #          search-paths:\n      # spring-cloud-bus刷新配置\n      #http://localhost:15672/\n      rabbitmq:\n          host: 172.31.31.31\n          port: 5672\n          username: admin\n          password: 123456\n          publisher-confirms: true\n          virtual-host: xr_vhost\n    \n    encrypt:\n      fail-on-error: false\n    \n注意开启：`spring.cloud.bus.enable=true`,`spring.cloud.bus.trace.enable=true`。\n\n### 温馨提醒\n\n由于添加了安全依赖：\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    \n所以config-server的请求是要先登陆验证的。那么，就要要配置`spring-security`，否则后面的`post`请求将会被拒绝。添加配置类如下：    \n\n    package com.xrlj.configserver;\n    \n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n    \n    @Configuration\n    @EnableWebSecurity\n    public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    \n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n            http.csrf().disable().authorizeRequests()\n                    .anyRequest().authenticated().and()\n                    .httpBasic();\n        }\n    }\n\n\n## 其它业务服务service-sys-common\n\n添加与配置刷新相关依赖：\n\n     <!-- 用户修改git文件，调用接口自动刷新： -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    <!--rabbitmq实时刷新配置-->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n    </dependency>\n    \n关键配置：\n\n    spring:\n      cloud:\n        bus:\n          enabled: true\n          trace:\n            enabled: true\n    #    refresh:\n    #      extra-refreshable: javax.sql.DataSource  #该版本中，默认数据源是HikariDataSource，不配置这个，刷新配置报错。\n    management:\n      endpoints:\n        web:\n          exposure:\n            include: \"*\"\n    \n和config-server中一样，星号暴露所有站点，还要bus的一些配置开启。这里有个不同点，`spring.cloud.refresh.extra-refreshable=javax.sql.DataSource`,这里先注释掉，后面再补充说明下。\n\n\n##  验证配置刷新\n\n1.在`service-sys-common`服务中新建`TestController.java`\n\n    @RefreshScope\n    @RestController\n    public class TestController {\n    \n         @Value(\"${foo}\")\n         String foo;\n    \n        @RequestMapping(value = \"/hi\")\n        public String hi(){\n            return foo;\n        }\n    }\n\n注意添加注解`@RefreshScope`。在配置仓库中对应文件添加属性`foo:version1`。 \n\n打开浏览器请求：http://localhost:9010/hi.正常会返回`foo`的值。  \n\n更改foo的值，`foo:version2`,再次请求，看到返回还是version1，证明没刷新。下面刷新下，打开postman发送post刷新请求：localhost:9010/actuator/refresh\n\n然后我们会看到一个错误：    \n\n    2018-02-04 22:11:02.236 DEBUG 6104 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : Application failed to start due to an exception\n    \n    org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under 'spring.datasource.hikari' to com.zaxxer.hikari.HikariDataSource\n    \tat org.springframework.boot.context.properties.bind.Binder.handleBindError(Binder.java:227) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:203) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:187) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:169) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.ConfigurationPropertiesBinder.bind(ConfigurationPropertiesBinder.java:79) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor.postProcessBeforeInitialization(ConfigurationPropertiesBindingPostProcessor.java:167) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:423) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1702) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:414) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:101) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:84) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:132) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:50) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:399) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:353) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration.afterSingletonsInstantiated(ConfigurationPropertiesRebinderAutoConfiguration.java:77) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:778) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:868) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:138) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:752) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:388) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1246) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1234) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat uk.co.vhome.clubbed.svc.enquiryhandler.ClubbedSvcEnquiryHandlerApplication.main(ClubbedSvcEnquiryHandlerApplication.java:23) [classes/:na]\n    Caused by: java.lang.IllegalStateException: Unable to set value for property schema\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder$BeanProperty.setValue(JavaBeanBinder.java:306) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:76) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:59) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:51) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.lambda$null$5(Binder.java:321) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) ~[na:na]\n    \tat java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1471) ~[na:na]\n    \tat java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:127) ~[na:na]\n    \tat java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:502) ~[na:na]\n    \tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:488) ~[na:na]\n    \tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) ~[na:na]\n    \tat java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:152) ~[na:na]\n    \tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:na]\n    \tat java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:476) ~[na:na]\n    \tat org.springframework.boot.context.properties.bind.Binder.lambda$bindBean$6(Binder.java:322) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder$Context.withIncreasedDepth(Binder.java:415) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder$Context.withBean(Binder.java:405) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bindBean(Binder.java:319) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bindObject(Binder.java:261) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:198) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \t... 27 common frames omitted\n    Caused by: java.lang.reflect.InvocationTargetException: null\n    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]\n    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]\n    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]\n    \tat java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder$BeanProperty.setValue(JavaBeanBinder.java:303) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \t... 46 common frames omitted\n    Caused by: java.lang.IllegalStateException: The configuration of the pool is sealed once started.  Use HikariConfigMXBean for runtime changes.\n    \tat com.zaxxer.hikari.HikariConfig.setSchema(HikariConfig.java:951) ~[HikariCP-2.7.6.jar:na]\n    \t... 51 common frames omitted\n    \n    2018-02-04 22:11:02.237 ERROR 6104 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : \n    \n    ***************************\n    APPLICATION FAILED TO START\n    ***************************\n    \n    Description:\n    \n    Failed to bind properties under 'spring.datasource.hikari' to com.zaxxer.hikari.HikariDataSource:\n    \n        Property: spring.datasource.hikari.schema\n        Value: ${application.database.schema}\n        Origin: class path resource [application.properties]:11:33\n        Reason: Unable to set value for property schema\n    \n    Action:\n    \n    Update your application's configuration\n    \n    \n    Process finished with exit code 1\n    \n爆出该异常源码地方：类ConfigurationPropertiesRebinder\n\n    @ManagedOperation\n    public boolean rebind(String name) {\n        if (!this.beans.getBeanNames().contains(name)) {\n            return false;\n        }\n        if (this.applicationContext != null) {\n            try {\n                Object bean = this.applicationContext.getBean(name);\n                if (AopUtils.isAopProxy(bean)) {\n                    bean = ProxyUtils.getTargetObject(bean);\n                }\n                if (bean != null) {\n                    this.applicationContext.getAutowireCapableBeanFactory()\n                            .destroyBean(bean);\n                    this.applicationContext.getAutowireCapableBeanFactory()\n                            .initializeBean(bean, name);\n                    return true;\n                }\n            }\n            catch (RuntimeException e) {\n                this.errors.put(name, e);\n                throw e;\n            }\n            catch (Exception e) {\n                this.errors.put(name, e);\n                throw new IllegalStateException(\"Cannot rebind to \" + name, e);\n            }\n        }\n        return false;\n    }    \n    \n 问题原因：  \n 那是因为，我们在项目里自定义了动态数据源，采用了默认的数据库连接池HikariDataSource，该连接池，一旦创建，讲不可更改，所以当你刷新配置的时候，是一起连同数据源的相关配置也要刷新的，所以报错了。    \n 数据源配置如下：   \n \n    package com.xrlj.framework.spring.config.ds.myself;\n    \n    import com.xrlj.framework.dao.ds.DynamicDataSource;\n    import com.zaxxer.hikari.HikariDataSource;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.context.properties.ConfigurationProperties;\n    import org.springframework.boot.jdbc.DataSourceBuilder;\n    import org.springframework.context.annotation.*;\n    \n    /**\n     * 按规则定死的数据源。一主双从。适用所有服务。\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        @Bean(name = \"masterDataSource\")\n        @Qualifier(\"masterDataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.master\")\n        public DataSource masterDataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        @Bean(name = \"slave1DataSource\")\n        @Qualifier(\"slave1DataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.slave1\")\n        public DataSource slave1DataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        @Bean(name = \"slave2DataSource\")\n        @Qualifier(\"slave2DataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.slave2\")\n        public DataSource slave2DataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dynamicDataSource\")\n        @Qualifier(\"dynamicDataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"masterDataSource\",\"slave1DataSource\",\"slave2DataSource\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"masterDataSource\") DataSource masterDataSource,\n                                            @Qualifier(\"slave1DataSource\") DataSource slave1DataSource,@Qualifier(\"slave2DataSource\") DataSource slave2DataSource) {\n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            return dynamicDataSource.setMultipleDataSource(masterDataSource,slave1DataSource,slave2DataSource);\n        }\n    }\n\n折腾了半天，终于在官网wiki中找到答案。   \n参考：     \nhttps://github.com/spring-cloud/spring-cloud-commons/pull/395   \nhttps://github.com/spring-cloud/spring-cloud-commons/issues/318 \n\n其中有一段问题解决的描述如下： \n\nAfter trying to implement this, we are going to add a documentation note, but you should either set spring.cloud.refresh.extra-refreshable=javax.sql.DataSource or, more appropriately, strongly type your DataSource bean\n\n    @Primary\n    @Bean(name = \"dbDataSource\")\n    @ConfigurationProperties(prefix = \"datasource.db\")\n    public HikariDataSource dbDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n意思是说，解决该问题有两种方式：    \n\n1.添加配置：`spring.cloud.refresh.extra-refreshable=javax.sql.DataSource`    \n2.配置数据源时，指定最终的类型，而不是接口类型。如下：    \n把  \n \n    @Bean(name = \"masterDataSource\")\n    @Qualifier(\"masterDataSource\")\n    @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.master\")\n    public DataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n    \n改成：     \n\n    @Bean(name = \"masterDataSource\")\n    @Qualifier(\"masterDataSource\")\n    @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.master\")\n    public DataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n每个地方都改成明确的类型。   \n\n如果采用第一种方式，会出现另外一个问题，在后面代码中DynamicDataSource转型为DataSource将会报错。纳闷，狗日的……\n\n因此，只能采用方式二了。把数据源配置改如下：\n\n    package com.xrlj.framework.spring.config.ds.myself;\n    \n    import com.xrlj.framework.dao.ds.DynamicDataSource;\n    import com.zaxxer.hikari.HikariDataSource;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.context.properties.ConfigurationProperties;\n    import org.springframework.boot.jdbc.DataSourceBuilder;\n    import org.springframework.context.annotation.*;\n    \n    /**\n     * 按规则定死的数据源。一主双从。适用所有服务。\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        @Bean(name = \"masterDataSource\")\n        @Qualifier(\"masterDataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.master\")\n        public HikariDataSource masterDataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        @Bean(name = \"slave1DataSource\")\n        @Qualifier(\"slave1DataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.slave1\")\n        public HikariDataSource slave1DataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        @Bean(name = \"slave2DataSource\")\n        @Qualifier(\"slave2DataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.slave2\")\n        public HikariDataSource slave2DataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dynamicDataSource\")\n        @Qualifier(\"dynamicDataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"masterDataSource\",\"slave1DataSource\",\"slave2DataSource\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DynamicDataSource dynamicDataSource(@Qualifier(\"masterDataSource\") HikariDataSource masterDataSource,\n                                            @Qualifier(\"slave1DataSource\") HikariDataSource slave1DataSource,@Qualifier(\"slave2DataSource\") HikariDataSource slave2DataSource) {\n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            return dynamicDataSource.setMultipleDataSource(masterDataSource,slave1DataSource,slave2DataSource);\n        }\n    \n    }\n\n再重新启动各服务，测试：    \n改动foo的值，刷新页面（post）： localhost:9010/actuator/refresh：\n\n{% asset_img a-1.png %}\n\n再请求`/hi`:   \n\n{% asset_img a-2.png %}\n\n我们看到，foo的值已经在线刷新。无需重启服务。    \n\n如果是多个实例，只要任何一个实例执行了刷新请求，所有实例都会同步刷新的。\n\n\n## 统一在config-server端刷新配置\n\n上面我们的测试，都是对每个业务服务进行配置刷新的。如果业务服务很多的话，就做不到统一刷新了，所以我们这里介绍在配置中心端刷新配置。   \n\n流程是，请求config-server的刷新请求，它会向mq发送配置刷新通知，然后，所有参与订阅的服务的配置都会收到刷新的通知时间，然后自动刷新。当然，也可以指定只刷新某个服务的。  \n\n更改foo的值，发起刷新请求，注意，请求的是config-server的地址：\n\nhttp://localhost:3331/actuator/bus-refresh   \n\n注意请求地址，是`bus-refresh`，而不是`refresh`。否则不成功。\n\n{%asset_img b-1.png%}\n\n这里要注意下，请求里面要添加认证信息。因为config-server里面引入了`spring-security`模块，而且要添加安全配置`WebSecurityConfiguration`,否则会出现请求需要验证或者请求拒绝导致不成功。  \n\n看请求结果图，请求返回状态为204 No Content,显示请求成功，但是没有返回内容。不知道为啥……\n\n再次请求业务服务的`/hi`,可以看到，配置已经在线刷新。成功了！\n\n## 利用github的Webhooks功能自动刷新\n\n达到的目的是，改动配置后，提交到git仓库，然后触发事件发起请求config-server的刷新请求。达到自动目的。\n\nwebhooks的使用，这里不做介绍。\n\n略……\n","source":"_posts/scloud-properties-refresh.md","raw":"---\ntitle: Spring Cloud外部环境配置刷新\ndate: 2019-04-20 22:55:37\ncategories: spring-cloud\ntags:\n---\n\n本文介绍在spring cloud架构中，如何做配置外部化以及更改配置属性并实时刷新的问题。      \n实验环境：\nspring boot：2.1.4.RELEASE   \nspring cloud: Greenwich.SR1 \ngithub  \nrabbitmq: 3.7.8\n\n## 服务注册发现中心eureka-server\n\n关键依赖：\n\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n    </dependency>\n    \napplication.yml：\n\n    server:\n      port: 1112\n    spring:\n      application:\n        name: eureka-server\n      profiles:\n        active: dev\n    logging:\n      level:\n        com:\n          netflix:\n            eureka: off\n            discovery: off\n      file: logs/${spring.application.name}.log\n\n\napplication-dev.yml：\n\n    eureka:\n      instance:\n        instance-id: ${spring.application.name}:${spring.cloud.client.ip_address}:${server.port}\n        hostname: localhost\n      client:\n        fetch-registry: false\n        register-with-eureka: false  #不注册自己\n        service-url:\n          defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n      server:\n          enable-self-preservation: false #设为false，关闭自我保护\n          eviction-interval-timer-in-ms: 4000  # 清理间隔（单位毫秒，默认是60*1000）\n    \n该服务没什么需要注意的，按正常的来就可以。\n\n\n## 配置中心config-server    \n\n### 关键依赖：\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-server</artifactId>\n    </dependency>\n    <!--实时刷新配置 start -->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-monitor</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n    </dependency>\n    <!--实时刷新配置 end -->\n\n    <!--作为服务注册到服务注册中心 -->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n\n要配置刷新，只需要添加：\n \n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-monitor</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n    </dependency>\n\n### 配置\n\nbootstrap.yml：\n\n    server:\n      port: 3331\n    spring:\n      application:\n        name: config-server\n      profiles:\n        active: dev\n    ## 非对称加解密,该段配置只能放在bootstrap.yml中\n    encrypt:\n      key-store:\n        location: classpath:/config-server.jks\n        password: 111111  # storepass\n        alias: config-server    # alias\n        secret: 222222   # keypass\n    \napplication.yml：\n\n    management:\n      endpoints:\n        web:\n          exposure:\n            include: \"*\"\n\n`management.endpoints.web.exposure.include`这个配置一定要加上，关键。默认是指暴露站点：info，health。改成星号，代表暴露全部。\n\napplication-dev.yml：\n\n    #作为服务注册到注册中心\n    eureka:\n      server:\n        ip: localhost\n        port: 1112\n      instance:\n        instance-id: ${spring.application.name}:${spring.cloud.client.ip-address}:${server.port}\n        prefer-ip-address: true #显示ip,浏览器以ip方式请求。\n        #域名\n    #    hostname: localhost\n        #查看健康运行状态\n        health-check-url-path: /actuator/health\n        status-page-url-path: /actuator/info\n      client:\n        service-url:\n          defaultZone: http://${eureka.server.ip}:${eureka.server.port}/eureka/\n    spring:\n      security:\n          user:\n            name: admin\n            password: 123456\n      cloud:\n        #git配置中心\n        config:\n          server:\n            git:\n              uri: https://github.com/xrlj/config-repo-dev\n              #git的配置文件会加载到本地的目录\n              basedir: target/config\n              # 设置超时\n              timeout: 4\n              force-pull: true  #每次都强制拉取远程git的配置更新本地。\n              default-label: master\n        bus:\n          enabled: true\n          trace:\n            enabled: true\n      #          search-paths:\n      # spring-cloud-bus刷新配置\n      #http://localhost:15672/\n      rabbitmq:\n          host: 172.31.31.31\n          port: 5672\n          username: admin\n          password: 123456\n          publisher-confirms: true\n          virtual-host: xr_vhost\n    \n    encrypt:\n      fail-on-error: false\n    \n注意开启：`spring.cloud.bus.enable=true`,`spring.cloud.bus.trace.enable=true`。\n\n### 温馨提醒\n\n由于添加了安全依赖：\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-security</artifactId>\n    </dependency>\n    \n所以config-server的请求是要先登陆验证的。那么，就要要配置`spring-security`，否则后面的`post`请求将会被拒绝。添加配置类如下：    \n\n    package com.xrlj.configserver;\n    \n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.security.config.annotation.web.builders.HttpSecurity;\n    import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\n    import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n    \n    @Configuration\n    @EnableWebSecurity\n    public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n    \n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n            http.csrf().disable().authorizeRequests()\n                    .anyRequest().authenticated().and()\n                    .httpBasic();\n        }\n    }\n\n\n## 其它业务服务service-sys-common\n\n添加与配置刷新相关依赖：\n\n     <!-- 用户修改git文件，调用接口自动刷新： -->\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    <!--rabbitmq实时刷新配置-->\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-bus-amqp</artifactId>\n    </dependency>\n    \n关键配置：\n\n    spring:\n      cloud:\n        bus:\n          enabled: true\n          trace:\n            enabled: true\n    #    refresh:\n    #      extra-refreshable: javax.sql.DataSource  #该版本中，默认数据源是HikariDataSource，不配置这个，刷新配置报错。\n    management:\n      endpoints:\n        web:\n          exposure:\n            include: \"*\"\n    \n和config-server中一样，星号暴露所有站点，还要bus的一些配置开启。这里有个不同点，`spring.cloud.refresh.extra-refreshable=javax.sql.DataSource`,这里先注释掉，后面再补充说明下。\n\n\n##  验证配置刷新\n\n1.在`service-sys-common`服务中新建`TestController.java`\n\n    @RefreshScope\n    @RestController\n    public class TestController {\n    \n         @Value(\"${foo}\")\n         String foo;\n    \n        @RequestMapping(value = \"/hi\")\n        public String hi(){\n            return foo;\n        }\n    }\n\n注意添加注解`@RefreshScope`。在配置仓库中对应文件添加属性`foo:version1`。 \n\n打开浏览器请求：http://localhost:9010/hi.正常会返回`foo`的值。  \n\n更改foo的值，`foo:version2`,再次请求，看到返回还是version1，证明没刷新。下面刷新下，打开postman发送post刷新请求：localhost:9010/actuator/refresh\n\n然后我们会看到一个错误：    \n\n    2018-02-04 22:11:02.236 DEBUG 6104 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : Application failed to start due to an exception\n    \n    org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under 'spring.datasource.hikari' to com.zaxxer.hikari.HikariDataSource\n    \tat org.springframework.boot.context.properties.bind.Binder.handleBindError(Binder.java:227) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:203) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:187) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:169) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.ConfigurationPropertiesBinder.bind(ConfigurationPropertiesBinder.java:79) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor.postProcessBeforeInitialization(ConfigurationPropertiesBindingPostProcessor.java:167) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:423) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1702) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:414) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:101) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:84) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:132) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:50) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:399) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:353) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration.afterSingletonsInstantiated(ConfigurationPropertiesRebinderAutoConfiguration.java:77) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    \tat org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:778) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:868) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    \tat org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:138) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.refresh(SpringApplication.java:752) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:388) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1246) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.SpringApplication.run(SpringApplication.java:1234) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat uk.co.vhome.clubbed.svc.enquiryhandler.ClubbedSvcEnquiryHandlerApplication.main(ClubbedSvcEnquiryHandlerApplication.java:23) [classes/:na]\n    Caused by: java.lang.IllegalStateException: Unable to set value for property schema\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder$BeanProperty.setValue(JavaBeanBinder.java:306) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:76) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:59) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:51) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.lambda$null$5(Binder.java:321) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) ~[na:na]\n    \tat java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1471) ~[na:na]\n    \tat java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:127) ~[na:na]\n    \tat java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:502) ~[na:na]\n    \tat java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:488) ~[na:na]\n    \tat java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) ~[na:na]\n    \tat java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:152) ~[na:na]\n    \tat java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:na]\n    \tat java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:476) ~[na:na]\n    \tat org.springframework.boot.context.properties.bind.Binder.lambda$bindBean$6(Binder.java:322) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder$Context.withIncreasedDepth(Binder.java:415) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder$Context.withBean(Binder.java:405) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bindBean(Binder.java:319) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bindObject(Binder.java:261) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \tat org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:198) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \t... 27 common frames omitted\n    Caused by: java.lang.reflect.InvocationTargetException: null\n    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]\n    \tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]\n    \tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]\n    \tat java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]\n    \tat org.springframework.boot.context.properties.bind.JavaBeanBinder$BeanProperty.setValue(JavaBeanBinder.java:303) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    \t... 46 common frames omitted\n    Caused by: java.lang.IllegalStateException: The configuration of the pool is sealed once started.  Use HikariConfigMXBean for runtime changes.\n    \tat com.zaxxer.hikari.HikariConfig.setSchema(HikariConfig.java:951) ~[HikariCP-2.7.6.jar:na]\n    \t... 51 common frames omitted\n    \n    2018-02-04 22:11:02.237 ERROR 6104 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : \n    \n    ***************************\n    APPLICATION FAILED TO START\n    ***************************\n    \n    Description:\n    \n    Failed to bind properties under 'spring.datasource.hikari' to com.zaxxer.hikari.HikariDataSource:\n    \n        Property: spring.datasource.hikari.schema\n        Value: ${application.database.schema}\n        Origin: class path resource [application.properties]:11:33\n        Reason: Unable to set value for property schema\n    \n    Action:\n    \n    Update your application's configuration\n    \n    \n    Process finished with exit code 1\n    \n爆出该异常源码地方：类ConfigurationPropertiesRebinder\n\n    @ManagedOperation\n    public boolean rebind(String name) {\n        if (!this.beans.getBeanNames().contains(name)) {\n            return false;\n        }\n        if (this.applicationContext != null) {\n            try {\n                Object bean = this.applicationContext.getBean(name);\n                if (AopUtils.isAopProxy(bean)) {\n                    bean = ProxyUtils.getTargetObject(bean);\n                }\n                if (bean != null) {\n                    this.applicationContext.getAutowireCapableBeanFactory()\n                            .destroyBean(bean);\n                    this.applicationContext.getAutowireCapableBeanFactory()\n                            .initializeBean(bean, name);\n                    return true;\n                }\n            }\n            catch (RuntimeException e) {\n                this.errors.put(name, e);\n                throw e;\n            }\n            catch (Exception e) {\n                this.errors.put(name, e);\n                throw new IllegalStateException(\"Cannot rebind to \" + name, e);\n            }\n        }\n        return false;\n    }    \n    \n 问题原因：  \n 那是因为，我们在项目里自定义了动态数据源，采用了默认的数据库连接池HikariDataSource，该连接池，一旦创建，讲不可更改，所以当你刷新配置的时候，是一起连同数据源的相关配置也要刷新的，所以报错了。    \n 数据源配置如下：   \n \n    package com.xrlj.framework.spring.config.ds.myself;\n    \n    import com.xrlj.framework.dao.ds.DynamicDataSource;\n    import com.zaxxer.hikari.HikariDataSource;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.context.properties.ConfigurationProperties;\n    import org.springframework.boot.jdbc.DataSourceBuilder;\n    import org.springframework.context.annotation.*;\n    \n    /**\n     * 按规则定死的数据源。一主双从。适用所有服务。\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        @Bean(name = \"masterDataSource\")\n        @Qualifier(\"masterDataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.master\")\n        public DataSource masterDataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        @Bean(name = \"slave1DataSource\")\n        @Qualifier(\"slave1DataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.slave1\")\n        public DataSource slave1DataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        @Bean(name = \"slave2DataSource\")\n        @Qualifier(\"slave2DataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.slave2\")\n        public DataSource slave2DataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dynamicDataSource\")\n        @Qualifier(\"dynamicDataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"masterDataSource\",\"slave1DataSource\",\"slave2DataSource\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"masterDataSource\") DataSource masterDataSource,\n                                            @Qualifier(\"slave1DataSource\") DataSource slave1DataSource,@Qualifier(\"slave2DataSource\") DataSource slave2DataSource) {\n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            return dynamicDataSource.setMultipleDataSource(masterDataSource,slave1DataSource,slave2DataSource);\n        }\n    }\n\n折腾了半天，终于在官网wiki中找到答案。   \n参考：     \nhttps://github.com/spring-cloud/spring-cloud-commons/pull/395   \nhttps://github.com/spring-cloud/spring-cloud-commons/issues/318 \n\n其中有一段问题解决的描述如下： \n\nAfter trying to implement this, we are going to add a documentation note, but you should either set spring.cloud.refresh.extra-refreshable=javax.sql.DataSource or, more appropriately, strongly type your DataSource bean\n\n    @Primary\n    @Bean(name = \"dbDataSource\")\n    @ConfigurationProperties(prefix = \"datasource.db\")\n    public HikariDataSource dbDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n意思是说，解决该问题有两种方式：    \n\n1.添加配置：`spring.cloud.refresh.extra-refreshable=javax.sql.DataSource`    \n2.配置数据源时，指定最终的类型，而不是接口类型。如下：    \n把  \n \n    @Bean(name = \"masterDataSource\")\n    @Qualifier(\"masterDataSource\")\n    @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.master\")\n    public DataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n    \n改成：     \n\n    @Bean(name = \"masterDataSource\")\n    @Qualifier(\"masterDataSource\")\n    @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.master\")\n    public DataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n每个地方都改成明确的类型。   \n\n如果采用第一种方式，会出现另外一个问题，在后面代码中DynamicDataSource转型为DataSource将会报错。纳闷，狗日的……\n\n因此，只能采用方式二了。把数据源配置改如下：\n\n    package com.xrlj.framework.spring.config.ds.myself;\n    \n    import com.xrlj.framework.dao.ds.DynamicDataSource;\n    import com.zaxxer.hikari.HikariDataSource;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.context.properties.ConfigurationProperties;\n    import org.springframework.boot.jdbc.DataSourceBuilder;\n    import org.springframework.context.annotation.*;\n    \n    /**\n     * 按规则定死的数据源。一主双从。适用所有服务。\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        @Bean(name = \"masterDataSource\")\n        @Qualifier(\"masterDataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.master\")\n        public HikariDataSource masterDataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        @Bean(name = \"slave1DataSource\")\n        @Qualifier(\"slave1DataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.slave1\")\n        public HikariDataSource slave1DataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        @Bean(name = \"slave2DataSource\")\n        @Qualifier(\"slave2DataSource\")\n        @ConfigurationProperties(prefix=\"spring.myself-db.datasource.hikari.slave2\")\n        public HikariDataSource slave2DataSource() {\n            return DataSourceBuilder.create().type(HikariDataSource.class).build();\n        }\n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dynamicDataSource\")\n        @Qualifier(\"dynamicDataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"masterDataSource\",\"slave1DataSource\",\"slave2DataSource\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DynamicDataSource dynamicDataSource(@Qualifier(\"masterDataSource\") HikariDataSource masterDataSource,\n                                            @Qualifier(\"slave1DataSource\") HikariDataSource slave1DataSource,@Qualifier(\"slave2DataSource\") HikariDataSource slave2DataSource) {\n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            return dynamicDataSource.setMultipleDataSource(masterDataSource,slave1DataSource,slave2DataSource);\n        }\n    \n    }\n\n再重新启动各服务，测试：    \n改动foo的值，刷新页面（post）： localhost:9010/actuator/refresh：\n\n{% asset_img a-1.png %}\n\n再请求`/hi`:   \n\n{% asset_img a-2.png %}\n\n我们看到，foo的值已经在线刷新。无需重启服务。    \n\n如果是多个实例，只要任何一个实例执行了刷新请求，所有实例都会同步刷新的。\n\n\n## 统一在config-server端刷新配置\n\n上面我们的测试，都是对每个业务服务进行配置刷新的。如果业务服务很多的话，就做不到统一刷新了，所以我们这里介绍在配置中心端刷新配置。   \n\n流程是，请求config-server的刷新请求，它会向mq发送配置刷新通知，然后，所有参与订阅的服务的配置都会收到刷新的通知时间，然后自动刷新。当然，也可以指定只刷新某个服务的。  \n\n更改foo的值，发起刷新请求，注意，请求的是config-server的地址：\n\nhttp://localhost:3331/actuator/bus-refresh   \n\n注意请求地址，是`bus-refresh`，而不是`refresh`。否则不成功。\n\n{%asset_img b-1.png%}\n\n这里要注意下，请求里面要添加认证信息。因为config-server里面引入了`spring-security`模块，而且要添加安全配置`WebSecurityConfiguration`,否则会出现请求需要验证或者请求拒绝导致不成功。  \n\n看请求结果图，请求返回状态为204 No Content,显示请求成功，但是没有返回内容。不知道为啥……\n\n再次请求业务服务的`/hi`,可以看到，配置已经在线刷新。成功了！\n\n## 利用github的Webhooks功能自动刷新\n\n达到的目的是，改动配置后，提交到git仓库，然后触发事件发起请求config-server的刷新请求。达到自动目的。\n\nwebhooks的使用，这里不做介绍。\n\n略……\n","slug":"scloud-properties-refresh","published":1,"updated":"2019-06-16T14:38:33.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfe00aqg4vaozvqrni2","content":"<p>本文介绍在spring cloud架构中，如何做配置外部化以及更改配置属性并实时刷新的问题。<br>实验环境：<br>spring boot：2.1.4.RELEASE<br>spring cloud: Greenwich.SR1<br>github<br>rabbitmq: 3.7.8</p>\n<h2 id=\"服务注册发现中心eureka-server\"><a href=\"#服务注册发现中心eureka-server\" class=\"headerlink\" title=\"服务注册发现中心eureka-server\"></a>服务注册发现中心eureka-server</h2><p>关键依赖：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>application.yml：</p>\n<pre><code>server:\n  port: 1112\nspring:\n  application:\n    name: eureka-server\n  profiles:\n    active: dev\nlogging:\n  level:\n    com:\n      netflix:\n        eureka: off\n        discovery: off\n  file: logs/${spring.application.name}.log\n</code></pre><p>application-dev.yml：</p>\n<pre><code>eureka:\n  instance:\n    instance-id: ${spring.application.name}:${spring.cloud.client.ip_address}:${server.port}\n    hostname: localhost\n  client:\n    fetch-registry: false\n    register-with-eureka: false  #不注册自己\n    service-url:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n  server:\n      enable-self-preservation: false #设为false，关闭自我保护\n      eviction-interval-timer-in-ms: 4000  # 清理间隔（单位毫秒，默认是60*1000）\n</code></pre><p>该服务没什么需要注意的，按正常的来就可以。</p>\n<h2 id=\"配置中心config-server\"><a href=\"#配置中心config-server\" class=\"headerlink\" title=\"配置中心config-server\"></a>配置中心config-server</h2><h3 id=\"关键依赖：\"><a href=\"#关键依赖：\" class=\"headerlink\" title=\"关键依赖：\"></a>关键依赖：</h3><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--实时刷新配置 start --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-config-monitor&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--实时刷新配置 end --&gt;\n\n&lt;!--作为服务注册到服务注册中心 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>要配置刷新，只需要添加：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-config-monitor&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>bootstrap.yml：</p>\n<pre><code>server:\n  port: 3331\nspring:\n  application:\n    name: config-server\n  profiles:\n    active: dev\n## 非对称加解密,该段配置只能放在bootstrap.yml中\nencrypt:\n  key-store:\n    location: classpath:/config-server.jks\n    password: 111111  # storepass\n    alias: config-server    # alias\n    secret: 222222   # keypass\n</code></pre><p>application.yml：</p>\n<pre><code>management:\n  endpoints:\n    web:\n      exposure:\n        include: &quot;*&quot;\n</code></pre><p><code>management.endpoints.web.exposure.include</code>这个配置一定要加上，关键。默认是指暴露站点：info，health。改成星号，代表暴露全部。</p>\n<p>application-dev.yml：</p>\n<pre><code>#作为服务注册到注册中心\neureka:\n  server:\n    ip: localhost\n    port: 1112\n  instance:\n    instance-id: ${spring.application.name}:${spring.cloud.client.ip-address}:${server.port}\n    prefer-ip-address: true #显示ip,浏览器以ip方式请求。\n    #域名\n#    hostname: localhost\n    #查看健康运行状态\n    health-check-url-path: /actuator/health\n    status-page-url-path: /actuator/info\n  client:\n    service-url:\n      defaultZone: http://${eureka.server.ip}:${eureka.server.port}/eureka/\nspring:\n  security:\n      user:\n        name: admin\n        password: 123456\n  cloud:\n    #git配置中心\n    config:\n      server:\n        git:\n          uri: https://github.com/xrlj/config-repo-dev\n          #git的配置文件会加载到本地的目录\n          basedir: target/config\n          # 设置超时\n          timeout: 4\n          force-pull: true  #每次都强制拉取远程git的配置更新本地。\n          default-label: master\n    bus:\n      enabled: true\n      trace:\n        enabled: true\n  #          search-paths:\n  # spring-cloud-bus刷新配置\n  #http://localhost:15672/\n  rabbitmq:\n      host: 172.31.31.31\n      port: 5672\n      username: admin\n      password: 123456\n      publisher-confirms: true\n      virtual-host: xr_vhost\n\nencrypt:\n  fail-on-error: false\n</code></pre><p>注意开启：<code>spring.cloud.bus.enable=true</code>,<code>spring.cloud.bus.trace.enable=true</code>。</p>\n<h3 id=\"温馨提醒\"><a href=\"#温馨提醒\" class=\"headerlink\" title=\"温馨提醒\"></a>温馨提醒</h3><p>由于添加了安全依赖：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>所以config-server的请求是要先登陆验证的。那么，就要要配置<code>spring-security</code>，否则后面的<code>post</code>请求将会被拒绝。添加配置类如下：    </p>\n<pre><code>package com.xrlj.configserver;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable().authorizeRequests()\n                .anyRequest().authenticated().and()\n                .httpBasic();\n    }\n}\n</code></pre><h2 id=\"其它业务服务service-sys-common\"><a href=\"#其它业务服务service-sys-common\" class=\"headerlink\" title=\"其它业务服务service-sys-common\"></a>其它业务服务service-sys-common</h2><p>添加与配置刷新相关依赖：</p>\n<pre><code> &lt;!-- 用户修改git文件，调用接口自动刷新： --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--rabbitmq实时刷新配置--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>关键配置：</p>\n<pre><code>spring:\n  cloud:\n    bus:\n      enabled: true\n      trace:\n        enabled: true\n#    refresh:\n#      extra-refreshable: javax.sql.DataSource  #该版本中，默认数据源是HikariDataSource，不配置这个，刷新配置报错。\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &quot;*&quot;\n</code></pre><p>和config-server中一样，星号暴露所有站点，还要bus的一些配置开启。这里有个不同点，<code>spring.cloud.refresh.extra-refreshable=javax.sql.DataSource</code>,这里先注释掉，后面再补充说明下。</p>\n<h2 id=\"验证配置刷新\"><a href=\"#验证配置刷新\" class=\"headerlink\" title=\"验证配置刷新\"></a>验证配置刷新</h2><p>1.在<code>service-sys-common</code>服务中新建<code>TestController.java</code></p>\n<pre><code>@RefreshScope\n@RestController\npublic class TestController {\n\n     @Value(&quot;${foo}&quot;)\n     String foo;\n\n    @RequestMapping(value = &quot;/hi&quot;)\n    public String hi(){\n        return foo;\n    }\n}\n</code></pre><p>注意添加注解<code>@RefreshScope</code>。在配置仓库中对应文件添加属性<code>foo:version1</code>。 </p>\n<p>打开浏览器请求：<a href=\"http://localhost:9010/hi.正常会返回`foo`的值。\" target=\"_blank\" rel=\"noopener\">http://localhost:9010/hi.正常会返回`foo`的值。</a>  </p>\n<p>更改foo的值，<code>foo:version2</code>,再次请求，看到返回还是version1，证明没刷新。下面刷新下，打开postman发送post刷新请求：localhost:9010/actuator/refresh</p>\n<p>然后我们会看到一个错误：    </p>\n<pre><code>2018-02-04 22:11:02.236 DEBUG 6104 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : Application failed to start due to an exception\n\norg.springframework.boot.context.properties.bind.BindException: Failed to bind properties under &apos;spring.datasource.hikari&apos; to com.zaxxer.hikari.HikariDataSource\n    at org.springframework.boot.context.properties.bind.Binder.handleBindError(Binder.java:227) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:203) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:187) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:169) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.ConfigurationPropertiesBinder.bind(ConfigurationPropertiesBinder.java:79) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor.postProcessBeforeInitialization(ConfigurationPropertiesBindingPostProcessor.java:167) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:423) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1702) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:414) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:101) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:84) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:132) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:50) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:399) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:353) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration.afterSingletonsInstantiated(ConfigurationPropertiesRebinderAutoConfiguration.java:77) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:778) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:868) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:138) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:752) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:388) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1246) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1234) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at uk.co.vhome.clubbed.svc.enquiryhandler.ClubbedSvcEnquiryHandlerApplication.main(ClubbedSvcEnquiryHandlerApplication.java:23) [classes/:na]\nCaused by: java.lang.IllegalStateException: Unable to set value for property schema\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder$BeanProperty.setValue(JavaBeanBinder.java:306) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:76) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:59) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:51) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.lambda$null$5(Binder.java:321) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) ~[na:na]\n    at java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1471) ~[na:na]\n    at java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:127) ~[na:na]\n    at java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:502) ~[na:na]\n    at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:488) ~[na:na]\n    at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) ~[na:na]\n    at java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:152) ~[na:na]\n    at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:na]\n    at java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:476) ~[na:na]\n    at org.springframework.boot.context.properties.bind.Binder.lambda$bindBean$6(Binder.java:322) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder$Context.withIncreasedDepth(Binder.java:415) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder$Context.withBean(Binder.java:405) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bindBean(Binder.java:319) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bindObject(Binder.java:261) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:198) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    ... 27 common frames omitted\nCaused by: java.lang.reflect.InvocationTargetException: null\n    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]\n    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]\n    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]\n    at java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder$BeanProperty.setValue(JavaBeanBinder.java:303) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    ... 46 common frames omitted\nCaused by: java.lang.IllegalStateException: The configuration of the pool is sealed once started.  Use HikariConfigMXBean for runtime changes.\n    at com.zaxxer.hikari.HikariConfig.setSchema(HikariConfig.java:951) ~[HikariCP-2.7.6.jar:na]\n    ... 51 common frames omitted\n\n2018-02-04 22:11:02.237 ERROR 6104 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : \n\n***************************\nAPPLICATION FAILED TO START\n***************************\n\nDescription:\n\nFailed to bind properties under &apos;spring.datasource.hikari&apos; to com.zaxxer.hikari.HikariDataSource:\n\n    Property: spring.datasource.hikari.schema\n    Value: ${application.database.schema}\n    Origin: class path resource [application.properties]:11:33\n    Reason: Unable to set value for property schema\n\nAction:\n\nUpdate your application&apos;s configuration\n\n\nProcess finished with exit code 1\n</code></pre><p>爆出该异常源码地方：类ConfigurationPropertiesRebinder</p>\n<pre><code>@ManagedOperation\npublic boolean rebind(String name) {\n    if (!this.beans.getBeanNames().contains(name)) {\n        return false;\n    }\n    if (this.applicationContext != null) {\n        try {\n            Object bean = this.applicationContext.getBean(name);\n            if (AopUtils.isAopProxy(bean)) {\n                bean = ProxyUtils.getTargetObject(bean);\n            }\n            if (bean != null) {\n                this.applicationContext.getAutowireCapableBeanFactory()\n                        .destroyBean(bean);\n                this.applicationContext.getAutowireCapableBeanFactory()\n                        .initializeBean(bean, name);\n                return true;\n            }\n        }\n        catch (RuntimeException e) {\n            this.errors.put(name, e);\n            throw e;\n        }\n        catch (Exception e) {\n            this.errors.put(name, e);\n            throw new IllegalStateException(&quot;Cannot rebind to &quot; + name, e);\n        }\n    }\n    return false;\n}    \n</code></pre><p> 问题原因：<br> 那是因为，我们在项目里自定义了动态数据源，采用了默认的数据库连接池HikariDataSource，该连接池，一旦创建，讲不可更改，所以当你刷新配置的时候，是一起连同数据源的相关配置也要刷新的，所以报错了。<br> 数据源配置如下：   </p>\n<pre><code>package com.xrlj.framework.spring.config.ds.myself;\n\nimport com.xrlj.framework.dao.ds.DynamicDataSource;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.*;\n\n/**\n * 按规则定死的数据源。一主双从。适用所有服务。\n */\n@Configuration\npublic class DataSourceConfig {\n\n    @Bean(name = &quot;masterDataSource&quot;)\n    @Qualifier(&quot;masterDataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.master&quot;)\n    public DataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    @Bean(name = &quot;slave1DataSource&quot;)\n    @Qualifier(&quot;slave1DataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.slave1&quot;)\n    public DataSource slave1DataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    @Bean(name = &quot;slave2DataSource&quot;)\n    @Qualifier(&quot;slave2DataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.slave2&quot;)\n    public DataSource slave2DataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dynamicDataSource&quot;)\n    @Qualifier(&quot;dynamicDataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;masterDataSource&quot;,&quot;slave1DataSource&quot;,&quot;slave2DataSource&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource,\n                                        @Qualifier(&quot;slave1DataSource&quot;) DataSource slave1DataSource,@Qualifier(&quot;slave2DataSource&quot;) DataSource slave2DataSource) {\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        return dynamicDataSource.setMultipleDataSource(masterDataSource,slave1DataSource,slave2DataSource);\n    }\n}\n</code></pre><p>折腾了半天，终于在官网wiki中找到答案。<br>参考：<br><a href=\"https://github.com/spring-cloud/spring-cloud-commons/pull/395\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-cloud/spring-cloud-commons/pull/395</a><br><a href=\"https://github.com/spring-cloud/spring-cloud-commons/issues/318\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-cloud/spring-cloud-commons/issues/318</a> </p>\n<p>其中有一段问题解决的描述如下： </p>\n<p>After trying to implement this, we are going to add a documentation note, but you should either set spring.cloud.refresh.extra-refreshable=javax.sql.DataSource or, more appropriately, strongly type your DataSource bean</p>\n<pre><code>@Primary\n@Bean(name = &quot;dbDataSource&quot;)\n@ConfigurationProperties(prefix = &quot;datasource.db&quot;)\npublic HikariDataSource dbDataSource() {\n    return DataSourceBuilder.create().type(HikariDataSource.class).build();\n}\n</code></pre><p>意思是说，解决该问题有两种方式：    </p>\n<p>1.添加配置：<code>spring.cloud.refresh.extra-refreshable=javax.sql.DataSource</code><br>2.配置数据源时，指定最终的类型，而不是接口类型。如下：<br>把  </p>\n<pre><code>@Bean(name = &quot;masterDataSource&quot;)\n@Qualifier(&quot;masterDataSource&quot;)\n@ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.master&quot;)\npublic DataSource masterDataSource() {\n    return DataSourceBuilder.create().type(HikariDataSource.class).build();\n}\n</code></pre><p>改成：     </p>\n<pre><code>@Bean(name = &quot;masterDataSource&quot;)\n@Qualifier(&quot;masterDataSource&quot;)\n@ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.master&quot;)\npublic DataSource masterDataSource() {\n    return DataSourceBuilder.create().type(HikariDataSource.class).build();\n}\n</code></pre><p>每个地方都改成明确的类型。   </p>\n<p>如果采用第一种方式，会出现另外一个问题，在后面代码中DynamicDataSource转型为DataSource将会报错。纳闷，狗日的……</p>\n<p>因此，只能采用方式二了。把数据源配置改如下：</p>\n<pre><code>package com.xrlj.framework.spring.config.ds.myself;\n\nimport com.xrlj.framework.dao.ds.DynamicDataSource;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.*;\n\n/**\n * 按规则定死的数据源。一主双从。适用所有服务。\n */\n@Configuration\npublic class DataSourceConfig {\n\n    @Bean(name = &quot;masterDataSource&quot;)\n    @Qualifier(&quot;masterDataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.master&quot;)\n    public HikariDataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    @Bean(name = &quot;slave1DataSource&quot;)\n    @Qualifier(&quot;slave1DataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.slave1&quot;)\n    public HikariDataSource slave1DataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    @Bean(name = &quot;slave2DataSource&quot;)\n    @Qualifier(&quot;slave2DataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.slave2&quot;)\n    public HikariDataSource slave2DataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dynamicDataSource&quot;)\n    @Qualifier(&quot;dynamicDataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;masterDataSource&quot;,&quot;slave1DataSource&quot;,&quot;slave2DataSource&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DynamicDataSource dynamicDataSource(@Qualifier(&quot;masterDataSource&quot;) HikariDataSource masterDataSource,\n                                        @Qualifier(&quot;slave1DataSource&quot;) HikariDataSource slave1DataSource,@Qualifier(&quot;slave2DataSource&quot;) HikariDataSource slave2DataSource) {\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        return dynamicDataSource.setMultipleDataSource(masterDataSource,slave1DataSource,slave2DataSource);\n    }\n\n}\n</code></pre><p>再重新启动各服务，测试：<br>改动foo的值，刷新页面（post）： localhost:9010/actuator/refresh：</p>\n<img src=\"/2019/04/20/scloud-properties-refresh/a-1.png\">\n<p>再请求<code>/hi</code>:   </p>\n<img src=\"/2019/04/20/scloud-properties-refresh/a-2.png\">\n<p>我们看到，foo的值已经在线刷新。无需重启服务。    </p>\n<p>如果是多个实例，只要任何一个实例执行了刷新请求，所有实例都会同步刷新的。</p>\n<h2 id=\"统一在config-server端刷新配置\"><a href=\"#统一在config-server端刷新配置\" class=\"headerlink\" title=\"统一在config-server端刷新配置\"></a>统一在config-server端刷新配置</h2><p>上面我们的测试，都是对每个业务服务进行配置刷新的。如果业务服务很多的话，就做不到统一刷新了，所以我们这里介绍在配置中心端刷新配置。   </p>\n<p>流程是，请求config-server的刷新请求，它会向mq发送配置刷新通知，然后，所有参与订阅的服务的配置都会收到刷新的通知时间，然后自动刷新。当然，也可以指定只刷新某个服务的。  </p>\n<p>更改foo的值，发起刷新请求，注意，请求的是config-server的地址：</p>\n<p><a href=\"http://localhost:3331/actuator/bus-refresh\" target=\"_blank\" rel=\"noopener\">http://localhost:3331/actuator/bus-refresh</a>   </p>\n<p>注意请求地址，是<code>bus-refresh</code>，而不是<code>refresh</code>。否则不成功。</p>\n<img src=\"/2019/04/20/scloud-properties-refresh/b-1.png\">\n<p>这里要注意下，请求里面要添加认证信息。因为config-server里面引入了<code>spring-security</code>模块，而且要添加安全配置<code>WebSecurityConfiguration</code>,否则会出现请求需要验证或者请求拒绝导致不成功。  </p>\n<p>看请求结果图，请求返回状态为204 No Content,显示请求成功，但是没有返回内容。不知道为啥……</p>\n<p>再次请求业务服务的<code>/hi</code>,可以看到，配置已经在线刷新。成功了！</p>\n<h2 id=\"利用github的Webhooks功能自动刷新\"><a href=\"#利用github的Webhooks功能自动刷新\" class=\"headerlink\" title=\"利用github的Webhooks功能自动刷新\"></a>利用github的Webhooks功能自动刷新</h2><p>达到的目的是，改动配置后，提交到git仓库，然后触发事件发起请求config-server的刷新请求。达到自动目的。</p>\n<p>webhooks的使用，这里不做介绍。</p>\n<p>略……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍在spring cloud架构中，如何做配置外部化以及更改配置属性并实时刷新的问题。<br>实验环境：<br>spring boot：2.1.4.RELEASE<br>spring cloud: Greenwich.SR1<br>github<br>rabbitmq: 3.7.8</p>\n<h2 id=\"服务注册发现中心eureka-server\"><a href=\"#服务注册发现中心eureka-server\" class=\"headerlink\" title=\"服务注册发现中心eureka-server\"></a>服务注册发现中心eureka-server</h2><p>关键依赖：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>application.yml：</p>\n<pre><code>server:\n  port: 1112\nspring:\n  application:\n    name: eureka-server\n  profiles:\n    active: dev\nlogging:\n  level:\n    com:\n      netflix:\n        eureka: off\n        discovery: off\n  file: logs/${spring.application.name}.log\n</code></pre><p>application-dev.yml：</p>\n<pre><code>eureka:\n  instance:\n    instance-id: ${spring.application.name}:${spring.cloud.client.ip_address}:${server.port}\n    hostname: localhost\n  client:\n    fetch-registry: false\n    register-with-eureka: false  #不注册自己\n    service-url:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/\n  server:\n      enable-self-preservation: false #设为false，关闭自我保护\n      eviction-interval-timer-in-ms: 4000  # 清理间隔（单位毫秒，默认是60*1000）\n</code></pre><p>该服务没什么需要注意的，按正常的来就可以。</p>\n<h2 id=\"配置中心config-server\"><a href=\"#配置中心config-server\" class=\"headerlink\" title=\"配置中心config-server\"></a>配置中心config-server</h2><h3 id=\"关键依赖：\"><a href=\"#关键依赖：\" class=\"headerlink\" title=\"关键依赖：\"></a>关键依赖：</h3><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--实时刷新配置 start --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-config-monitor&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--实时刷新配置 end --&gt;\n\n&lt;!--作为服务注册到服务注册中心 --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>要配置刷新，只需要添加：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-config-monitor&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><p>bootstrap.yml：</p>\n<pre><code>server:\n  port: 3331\nspring:\n  application:\n    name: config-server\n  profiles:\n    active: dev\n## 非对称加解密,该段配置只能放在bootstrap.yml中\nencrypt:\n  key-store:\n    location: classpath:/config-server.jks\n    password: 111111  # storepass\n    alias: config-server    # alias\n    secret: 222222   # keypass\n</code></pre><p>application.yml：</p>\n<pre><code>management:\n  endpoints:\n    web:\n      exposure:\n        include: &quot;*&quot;\n</code></pre><p><code>management.endpoints.web.exposure.include</code>这个配置一定要加上，关键。默认是指暴露站点：info，health。改成星号，代表暴露全部。</p>\n<p>application-dev.yml：</p>\n<pre><code>#作为服务注册到注册中心\neureka:\n  server:\n    ip: localhost\n    port: 1112\n  instance:\n    instance-id: ${spring.application.name}:${spring.cloud.client.ip-address}:${server.port}\n    prefer-ip-address: true #显示ip,浏览器以ip方式请求。\n    #域名\n#    hostname: localhost\n    #查看健康运行状态\n    health-check-url-path: /actuator/health\n    status-page-url-path: /actuator/info\n  client:\n    service-url:\n      defaultZone: http://${eureka.server.ip}:${eureka.server.port}/eureka/\nspring:\n  security:\n      user:\n        name: admin\n        password: 123456\n  cloud:\n    #git配置中心\n    config:\n      server:\n        git:\n          uri: https://github.com/xrlj/config-repo-dev\n          #git的配置文件会加载到本地的目录\n          basedir: target/config\n          # 设置超时\n          timeout: 4\n          force-pull: true  #每次都强制拉取远程git的配置更新本地。\n          default-label: master\n    bus:\n      enabled: true\n      trace:\n        enabled: true\n  #          search-paths:\n  # spring-cloud-bus刷新配置\n  #http://localhost:15672/\n  rabbitmq:\n      host: 172.31.31.31\n      port: 5672\n      username: admin\n      password: 123456\n      publisher-confirms: true\n      virtual-host: xr_vhost\n\nencrypt:\n  fail-on-error: false\n</code></pre><p>注意开启：<code>spring.cloud.bus.enable=true</code>,<code>spring.cloud.bus.trace.enable=true</code>。</p>\n<h3 id=\"温馨提醒\"><a href=\"#温馨提醒\" class=\"headerlink\" title=\"温馨提醒\"></a>温馨提醒</h3><p>由于添加了安全依赖：</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>所以config-server的请求是要先登陆验证的。那么，就要要配置<code>spring-security</code>，否则后面的<code>post</code>请求将会被拒绝。添加配置类如下：    </p>\n<pre><code>package com.xrlj.configserver;\n\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.csrf().disable().authorizeRequests()\n                .anyRequest().authenticated().and()\n                .httpBasic();\n    }\n}\n</code></pre><h2 id=\"其它业务服务service-sys-common\"><a href=\"#其它业务服务service-sys-common\" class=\"headerlink\" title=\"其它业务服务service-sys-common\"></a>其它业务服务service-sys-common</h2><p>添加与配置刷新相关依赖：</p>\n<pre><code> &lt;!-- 用户修改git文件，调用接口自动刷新： --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;!--rabbitmq实时刷新配置--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;\n&lt;/dependency&gt;\n</code></pre><p>关键配置：</p>\n<pre><code>spring:\n  cloud:\n    bus:\n      enabled: true\n      trace:\n        enabled: true\n#    refresh:\n#      extra-refreshable: javax.sql.DataSource  #该版本中，默认数据源是HikariDataSource，不配置这个，刷新配置报错。\nmanagement:\n  endpoints:\n    web:\n      exposure:\n        include: &quot;*&quot;\n</code></pre><p>和config-server中一样，星号暴露所有站点，还要bus的一些配置开启。这里有个不同点，<code>spring.cloud.refresh.extra-refreshable=javax.sql.DataSource</code>,这里先注释掉，后面再补充说明下。</p>\n<h2 id=\"验证配置刷新\"><a href=\"#验证配置刷新\" class=\"headerlink\" title=\"验证配置刷新\"></a>验证配置刷新</h2><p>1.在<code>service-sys-common</code>服务中新建<code>TestController.java</code></p>\n<pre><code>@RefreshScope\n@RestController\npublic class TestController {\n\n     @Value(&quot;${foo}&quot;)\n     String foo;\n\n    @RequestMapping(value = &quot;/hi&quot;)\n    public String hi(){\n        return foo;\n    }\n}\n</code></pre><p>注意添加注解<code>@RefreshScope</code>。在配置仓库中对应文件添加属性<code>foo:version1</code>。 </p>\n<p>打开浏览器请求：<a href=\"http://localhost:9010/hi.正常会返回`foo`的值。\" target=\"_blank\" rel=\"noopener\">http://localhost:9010/hi.正常会返回`foo`的值。</a>  </p>\n<p>更改foo的值，<code>foo:version2</code>,再次请求，看到返回还是version1，证明没刷新。下面刷新下，打开postman发送post刷新请求：localhost:9010/actuator/refresh</p>\n<p>然后我们会看到一个错误：    </p>\n<pre><code>2018-02-04 22:11:02.236 DEBUG 6104 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : Application failed to start due to an exception\n\norg.springframework.boot.context.properties.bind.BindException: Failed to bind properties under &apos;spring.datasource.hikari&apos; to com.zaxxer.hikari.HikariDataSource\n    at org.springframework.boot.context.properties.bind.Binder.handleBindError(Binder.java:227) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:203) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:187) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:169) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.ConfigurationPropertiesBinder.bind(ConfigurationPropertiesBinder.java:79) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor.postProcessBeforeInitialization(ConfigurationPropertiesBindingPostProcessor.java:167) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:423) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1702) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:414) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:101) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.rebind(ConfigurationPropertiesRebinder.java:84) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:132) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.cloud.context.properties.ConfigurationPropertiesRebinder.onApplicationEvent(ConfigurationPropertiesRebinder.java:50) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.context.event.SimpleApplicationEventMulticaster.doInvokeListener(SimpleApplicationEventMulticaster.java:172) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.event.SimpleApplicationEventMulticaster.invokeListener(SimpleApplicationEventMulticaster.java:165) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.event.SimpleApplicationEventMulticaster.multicastEvent(SimpleApplicationEventMulticaster.java:139) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:399) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.publishEvent(AbstractApplicationContext.java:353) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration.afterSingletonsInstantiated(ConfigurationPropertiesRebinderAutoConfiguration.java:77) ~[spring-cloud-context-2.0.0.M5.jar:2.0.0.M5]\n    at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:778) ~[spring-beans-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:868) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:549) ~[spring-context-5.0.3.RELEASE.jar:5.0.3.RELEASE]\n    at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:138) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:752) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:388) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:327) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1246) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.SpringApplication.run(SpringApplication.java:1234) [spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at uk.co.vhome.clubbed.svc.enquiryhandler.ClubbedSvcEnquiryHandlerApplication.main(ClubbedSvcEnquiryHandlerApplication.java:23) [classes/:na]\nCaused by: java.lang.IllegalStateException: Unable to set value for property schema\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder$BeanProperty.setValue(JavaBeanBinder.java:306) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:76) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:59) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder.bind(JavaBeanBinder.java:51) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.lambda$null$5(Binder.java:321) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at java.base/java.util.stream.ReferencePipeline$3$1.accept(ReferencePipeline.java:195) ~[na:na]\n    at java.base/java.util.ArrayList$ArrayListSpliterator.tryAdvance(ArrayList.java:1471) ~[na:na]\n    at java.base/java.util.stream.ReferencePipeline.forEachWithCancel(ReferencePipeline.java:127) ~[na:na]\n    at java.base/java.util.stream.AbstractPipeline.copyIntoWithCancel(AbstractPipeline.java:502) ~[na:na]\n    at java.base/java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:488) ~[na:na]\n    at java.base/java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:474) ~[na:na]\n    at java.base/java.util.stream.FindOps$FindOp.evaluateSequential(FindOps.java:152) ~[na:na]\n    at java.base/java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) ~[na:na]\n    at java.base/java.util.stream.ReferencePipeline.findFirst(ReferencePipeline.java:476) ~[na:na]\n    at org.springframework.boot.context.properties.bind.Binder.lambda$bindBean$6(Binder.java:322) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder$Context.withIncreasedDepth(Binder.java:415) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder$Context.withBean(Binder.java:405) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bindBean(Binder.java:319) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bindObject(Binder.java:261) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    at org.springframework.boot.context.properties.bind.Binder.bind(Binder.java:198) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    ... 27 common frames omitted\nCaused by: java.lang.reflect.InvocationTargetException: null\n    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method) ~[na:na]\n    at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) ~[na:na]\n    at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) ~[na:na]\n    at java.base/java.lang.reflect.Method.invoke(Method.java:564) ~[na:na]\n    at org.springframework.boot.context.properties.bind.JavaBeanBinder$BeanProperty.setValue(JavaBeanBinder.java:303) ~[spring-boot-2.0.0.RC1.jar:2.0.0.RC1]\n    ... 46 common frames omitted\nCaused by: java.lang.IllegalStateException: The configuration of the pool is sealed once started.  Use HikariConfigMXBean for runtime changes.\n    at com.zaxxer.hikari.HikariConfig.setSchema(HikariConfig.java:951) ~[HikariCP-2.7.6.jar:na]\n    ... 51 common frames omitted\n\n2018-02-04 22:11:02.237 ERROR 6104 --- [           main] o.s.b.d.LoggingFailureAnalysisReporter   : \n\n***************************\nAPPLICATION FAILED TO START\n***************************\n\nDescription:\n\nFailed to bind properties under &apos;spring.datasource.hikari&apos; to com.zaxxer.hikari.HikariDataSource:\n\n    Property: spring.datasource.hikari.schema\n    Value: ${application.database.schema}\n    Origin: class path resource [application.properties]:11:33\n    Reason: Unable to set value for property schema\n\nAction:\n\nUpdate your application&apos;s configuration\n\n\nProcess finished with exit code 1\n</code></pre><p>爆出该异常源码地方：类ConfigurationPropertiesRebinder</p>\n<pre><code>@ManagedOperation\npublic boolean rebind(String name) {\n    if (!this.beans.getBeanNames().contains(name)) {\n        return false;\n    }\n    if (this.applicationContext != null) {\n        try {\n            Object bean = this.applicationContext.getBean(name);\n            if (AopUtils.isAopProxy(bean)) {\n                bean = ProxyUtils.getTargetObject(bean);\n            }\n            if (bean != null) {\n                this.applicationContext.getAutowireCapableBeanFactory()\n                        .destroyBean(bean);\n                this.applicationContext.getAutowireCapableBeanFactory()\n                        .initializeBean(bean, name);\n                return true;\n            }\n        }\n        catch (RuntimeException e) {\n            this.errors.put(name, e);\n            throw e;\n        }\n        catch (Exception e) {\n            this.errors.put(name, e);\n            throw new IllegalStateException(&quot;Cannot rebind to &quot; + name, e);\n        }\n    }\n    return false;\n}    \n</code></pre><p> 问题原因：<br> 那是因为，我们在项目里自定义了动态数据源，采用了默认的数据库连接池HikariDataSource，该连接池，一旦创建，讲不可更改，所以当你刷新配置的时候，是一起连同数据源的相关配置也要刷新的，所以报错了。<br> 数据源配置如下：   </p>\n<pre><code>package com.xrlj.framework.spring.config.ds.myself;\n\nimport com.xrlj.framework.dao.ds.DynamicDataSource;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.*;\n\n/**\n * 按规则定死的数据源。一主双从。适用所有服务。\n */\n@Configuration\npublic class DataSourceConfig {\n\n    @Bean(name = &quot;masterDataSource&quot;)\n    @Qualifier(&quot;masterDataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.master&quot;)\n    public DataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    @Bean(name = &quot;slave1DataSource&quot;)\n    @Qualifier(&quot;slave1DataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.slave1&quot;)\n    public DataSource slave1DataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    @Bean(name = &quot;slave2DataSource&quot;)\n    @Qualifier(&quot;slave2DataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.slave2&quot;)\n    public DataSource slave2DataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dynamicDataSource&quot;)\n    @Qualifier(&quot;dynamicDataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;masterDataSource&quot;,&quot;slave1DataSource&quot;,&quot;slave2DataSource&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;masterDataSource&quot;) DataSource masterDataSource,\n                                        @Qualifier(&quot;slave1DataSource&quot;) DataSource slave1DataSource,@Qualifier(&quot;slave2DataSource&quot;) DataSource slave2DataSource) {\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        return dynamicDataSource.setMultipleDataSource(masterDataSource,slave1DataSource,slave2DataSource);\n    }\n}\n</code></pre><p>折腾了半天，终于在官网wiki中找到答案。<br>参考：<br><a href=\"https://github.com/spring-cloud/spring-cloud-commons/pull/395\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-cloud/spring-cloud-commons/pull/395</a><br><a href=\"https://github.com/spring-cloud/spring-cloud-commons/issues/318\" target=\"_blank\" rel=\"noopener\">https://github.com/spring-cloud/spring-cloud-commons/issues/318</a> </p>\n<p>其中有一段问题解决的描述如下： </p>\n<p>After trying to implement this, we are going to add a documentation note, but you should either set spring.cloud.refresh.extra-refreshable=javax.sql.DataSource or, more appropriately, strongly type your DataSource bean</p>\n<pre><code>@Primary\n@Bean(name = &quot;dbDataSource&quot;)\n@ConfigurationProperties(prefix = &quot;datasource.db&quot;)\npublic HikariDataSource dbDataSource() {\n    return DataSourceBuilder.create().type(HikariDataSource.class).build();\n}\n</code></pre><p>意思是说，解决该问题有两种方式：    </p>\n<p>1.添加配置：<code>spring.cloud.refresh.extra-refreshable=javax.sql.DataSource</code><br>2.配置数据源时，指定最终的类型，而不是接口类型。如下：<br>把  </p>\n<pre><code>@Bean(name = &quot;masterDataSource&quot;)\n@Qualifier(&quot;masterDataSource&quot;)\n@ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.master&quot;)\npublic DataSource masterDataSource() {\n    return DataSourceBuilder.create().type(HikariDataSource.class).build();\n}\n</code></pre><p>改成：     </p>\n<pre><code>@Bean(name = &quot;masterDataSource&quot;)\n@Qualifier(&quot;masterDataSource&quot;)\n@ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.master&quot;)\npublic DataSource masterDataSource() {\n    return DataSourceBuilder.create().type(HikariDataSource.class).build();\n}\n</code></pre><p>每个地方都改成明确的类型。   </p>\n<p>如果采用第一种方式，会出现另外一个问题，在后面代码中DynamicDataSource转型为DataSource将会报错。纳闷，狗日的……</p>\n<p>因此，只能采用方式二了。把数据源配置改如下：</p>\n<pre><code>package com.xrlj.framework.spring.config.ds.myself;\n\nimport com.xrlj.framework.dao.ds.DynamicDataSource;\nimport com.zaxxer.hikari.HikariDataSource;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.boot.jdbc.DataSourceBuilder;\nimport org.springframework.context.annotation.*;\n\n/**\n * 按规则定死的数据源。一主双从。适用所有服务。\n */\n@Configuration\npublic class DataSourceConfig {\n\n    @Bean(name = &quot;masterDataSource&quot;)\n    @Qualifier(&quot;masterDataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.master&quot;)\n    public HikariDataSource masterDataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    @Bean(name = &quot;slave1DataSource&quot;)\n    @Qualifier(&quot;slave1DataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.slave1&quot;)\n    public HikariDataSource slave1DataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    @Bean(name = &quot;slave2DataSource&quot;)\n    @Qualifier(&quot;slave2DataSource&quot;)\n    @ConfigurationProperties(prefix=&quot;spring.myself-db.datasource.hikari.slave2&quot;)\n    public HikariDataSource slave2DataSource() {\n        return DataSourceBuilder.create().type(HikariDataSource.class).build();\n    }\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dynamicDataSource&quot;)\n    @Qualifier(&quot;dynamicDataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;masterDataSource&quot;,&quot;slave1DataSource&quot;,&quot;slave2DataSource&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DynamicDataSource dynamicDataSource(@Qualifier(&quot;masterDataSource&quot;) HikariDataSource masterDataSource,\n                                        @Qualifier(&quot;slave1DataSource&quot;) HikariDataSource slave1DataSource,@Qualifier(&quot;slave2DataSource&quot;) HikariDataSource slave2DataSource) {\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        return dynamicDataSource.setMultipleDataSource(masterDataSource,slave1DataSource,slave2DataSource);\n    }\n\n}\n</code></pre><p>再重新启动各服务，测试：<br>改动foo的值，刷新页面（post）： localhost:9010/actuator/refresh：</p>\n<img src=\"/2019/04/20/scloud-properties-refresh/a-1.png\">\n<p>再请求<code>/hi</code>:   </p>\n<img src=\"/2019/04/20/scloud-properties-refresh/a-2.png\">\n<p>我们看到，foo的值已经在线刷新。无需重启服务。    </p>\n<p>如果是多个实例，只要任何一个实例执行了刷新请求，所有实例都会同步刷新的。</p>\n<h2 id=\"统一在config-server端刷新配置\"><a href=\"#统一在config-server端刷新配置\" class=\"headerlink\" title=\"统一在config-server端刷新配置\"></a>统一在config-server端刷新配置</h2><p>上面我们的测试，都是对每个业务服务进行配置刷新的。如果业务服务很多的话，就做不到统一刷新了，所以我们这里介绍在配置中心端刷新配置。   </p>\n<p>流程是，请求config-server的刷新请求，它会向mq发送配置刷新通知，然后，所有参与订阅的服务的配置都会收到刷新的通知时间，然后自动刷新。当然，也可以指定只刷新某个服务的。  </p>\n<p>更改foo的值，发起刷新请求，注意，请求的是config-server的地址：</p>\n<p><a href=\"http://localhost:3331/actuator/bus-refresh\" target=\"_blank\" rel=\"noopener\">http://localhost:3331/actuator/bus-refresh</a>   </p>\n<p>注意请求地址，是<code>bus-refresh</code>，而不是<code>refresh</code>。否则不成功。</p>\n<img src=\"/2019/04/20/scloud-properties-refresh/b-1.png\">\n<p>这里要注意下，请求里面要添加认证信息。因为config-server里面引入了<code>spring-security</code>模块，而且要添加安全配置<code>WebSecurityConfiguration</code>,否则会出现请求需要验证或者请求拒绝导致不成功。  </p>\n<p>看请求结果图，请求返回状态为204 No Content,显示请求成功，但是没有返回内容。不知道为啥……</p>\n<p>再次请求业务服务的<code>/hi</code>,可以看到，配置已经在线刷新。成功了！</p>\n<h2 id=\"利用github的Webhooks功能自动刷新\"><a href=\"#利用github的Webhooks功能自动刷新\" class=\"headerlink\" title=\"利用github的Webhooks功能自动刷新\"></a>利用github的Webhooks功能自动刷新</h2><p>达到的目的是，改动配置后，提交到git仓库，然后触发事件发起请求config-server的刷新请求。达到自动目的。</p>\n<p>webhooks的使用，这里不做介绍。</p>\n<p>略……</p>\n"},{"title":"spring-cloud-zuul网关入门","date":"2017-10-11T07:42:53.000Z","_content":"## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","source":"_posts/scloud-zuul-start.md","raw":"---\ntitle: spring-cloud-zuul网关入门\ndate: 2017-10-11 15:42:53\ncategories: spring-cloud\ntags: zuul-start\n---\n## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","slug":"scloud-zuul-start","published":1,"updated":"2019-06-16T14:38:33.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfe00arg4vaw3585awf","content":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>"},{"title":"session 机制学习","date":"2019-05-09T09:30:18.000Z","_content":"\nhttps://www.cnblogs.com/woshimrf/p/5317776.html \n\nhttps://www.cnblogs.com/sharpxiajun/p/3395607.html","source":"_posts/session-start.md","raw":"---\ntitle: session 机制学习\ndate: 2019-05-09 17:30:18\ncategories: servlet\ntags:\n---\n\nhttps://www.cnblogs.com/woshimrf/p/5317776.html \n\nhttps://www.cnblogs.com/sharpxiajun/p/3395607.html","slug":"session-start","published":1,"updated":"2019-06-16T14:38:33.463Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfg00awg4vadd0h7gmx","content":"<p><a href=\"https://www.cnblogs.com/woshimrf/p/5317776.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/woshimrf/p/5317776.html</a> </p>\n<p><a href=\"https://www.cnblogs.com/sharpxiajun/p/3395607.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sharpxiajun/p/3395607.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.cnblogs.com/woshimrf/p/5317776.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/woshimrf/p/5317776.html</a> </p>\n<p><a href=\"https://www.cnblogs.com/sharpxiajun/p/3395607.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/sharpxiajun/p/3395607.html</a></p>\n"},{"title":"shadowsocks-go代理服务器搭建","date":"2017-11-11T09:05:31.000Z","_content":"\n这是用来干嘛的，你懂的。 \n\n网址：\n\n[shadowsocks](https://github.com/shadowsocks)\n\n[sadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)\n\n## 服务端\n\n编译好执行文件：{% asset_link server.tar.gz Shadowsocks-server %}  \n放到服务器，更改.json文件配置，解压直接执行.sh文件即可。\n\n1. 首先，买个国外的服务器再说吧……\n   \n2. 在服务器安装golang环境。\n    安装包：{% asset_link go1.9.2.linux-amd64.tar.gz go1.9.2 %}\n    \n    这里不做介绍……\n    \n3. 在服务器安装git环境。\n\n    这里不做介绍……\n    \n4. 下载服务端代码shadowsocks-go.\n\n        # on server\n        go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n    \n    golang环境会自动编译可执行代码到${GOPATH}/bin  \n      \n5.  执行启动\n\n- *创建配置文件*：\n`touch /server/shadowsocks/shadowsocks.json`\n- *编辑shadowsocks.json*：\n    \n        {\t \n            \"server\":\"30.12.6.2\",\n            \"server_port\":8388,\n            \"local_port\":1080,\n            \"password\":\"123456\",\n            \"method\": \"aes-256-cfb\",\n            \"timeout\":600\n        }\n\n> 说明：       \n`server`:服务器ip地址；\n`server_port`:服务器端口；\n`local_port:`客户端代理端口；\n`method`:加密方式； \n\n- *启动*:\n\n\n    shadowsocks-server -c /server/shadowsocks/shadowsocks.json > /server/shadowsocks/log &.   \n    \n> 说明：\n`-c` 指定配置文件。 \n`log`记录日志。\n`&.` 后台执行    \n\n- *查看是否启动*：\n\n        [root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\n        tcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n\n\n---\n\n## 客户端\n\n### linux系统\n编译好执行文件：{% asset_link client.tar.gz Shadowsocks-client %} \n在linux客户端解压，修改.json配置文件中相关参数，启动即可。\n\n### windows系统\n直接下载客户端。[网址](https://github.com/shadowsocks/shadowsocks-windows)\n安装包：{% asset_link Shadowsocks-4.0.6.zip Shadowsocks-win %}\n双击打开：\n{% asset_img a.png %}\n\n把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。\n\n### ubuntu系统    \n\n- go客户端：\n`go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local`\n由于被墙，客户端下载不了。\n所以要在服务端执行，然后再把可执行二进制文件下拉到本地。\n\n*配置客户端文件*\n创建文件：shadowsocks-local.json\n编辑：\n    \n    {\n    \t\"local_port\": 1081,\n    \t\"server_password\": [\n    \t\t[\"127.0.0.1:8387\", \"foobar\"],\n    \t\t[\"127.0.0.1:8388\", \"barfoo\", \"aes-128-cfb\"]\n    \t]\n    }\n\n可以配置多个服务器，单个服务器，则去掉一个。\n\n启动：类似服务端，用`-c`指定配置文件。    \n\n- qt5客户端：\n\n1. 二进制包安装。[安装网址](https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)  \n\n2. 推荐，命令安装：\n    \n        #Ubuntu 14.04及更高版本\n        #添加ppa源\n        sudo add-apt-repository ppa:hzwhuang/ss-qt5\n        sudo apt-get update\n        sudo apt-get install shadowsocks-qt5\n         \n        #启动shadowsocks-qt5\n        \n        可以通过which shadowsocks-qt5找到可执行文件的位置。\n        \n        执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n\n### 移动\n\n- 安卓客户端：\n\n下载：{%asset_link Shadowsocks_v4.2.5_apkpure.com.apk Shadowsocks_v4.2.5_apkpure.com.apk%}\n\n- 苹果客户端：\n\n安装app：FirstWingy\n\n### 修改浏览器代理\n> SOCKS5 127.0.0.1:local_port\n\n如果可以，在chrome中可以安装代理设置插件       \n{% asset_img b.png %}\n\n然后启动，试下访问：[google](https://www.google.com)\n\n\n\n### linux下全局代理\n\n实验环境：Ubuntu系统\n\n1.安装应用`privoxy`\n\n一款工具，将socks代理转换成http。\n\n`sudo apt-get install privoxy`\n\n2.更改配置\n\n    sudo gedit /etc/privoxy/config\n    \n    ----------------------------------------------------------------\n\n    # 在 froward-socks4下面添加一条socks5的，因为shadowsocks为socks5，\n    # 地址是127.0.0.1:1080。注意他们最后有一个“.”\n    #        forward-socks4   /               socks-gw.example.com:1080  .\n    forward-socks5   /               127.0.0.1:1080 .\n    \n    # 下面还存在以下一条配置，表示privoxy监听本机8118端口，\n    # 把它作为http代理，代理地址为 http://localhost.8118/ 。\n    # 可以把地址改为 0.0.0.0:8118，表示外网也可以通过本机IP作http代理。\n    # 这样，你的外网IP为1.2.3.4，别人就可以设置 http://1.2.3.4:8118/ 为http代理。\n    　listen-address localhost:8118  #端口可以随意设定\n    \n    上面配置可能导致无法启动privoxy,新版本安全问题导致。改为：   \n    listen-address 192.168.1.115:8118  #端口可以随意设定  \n\n3.重启privoxy\n\n    sudo systemctl restart privoxy.serivce\n    \n4.添加环境变量\n\n    vim ~/.bashrc\n    \n    ----\n    添加两行：\n    export http_proxy=http://127.0.0.1:8118/\n    export https_proxy=http://127.0.0.1:8118/  \n    \n5.使环境变量立即生效\n\n    source ~/.bashrc\n    \n说明：如果只是想临时的让当前命令窗口代理，那么只需要添加临时变量，不需要编辑~/.bashrc。  \n只需要在当前命令窗口执行`export http_proxy=http://127.0.0.1:8118/` ` export https_proxy=http://127.0.0.1:8118/ `         ","source":"_posts/shadowsocks-go.md","raw":"---\ntitle: shadowsocks-go代理服务器搭建\ndate: 2017-11-11 17:05:31\ncategories: shadowsocks\ntags: shadowsocks-go\n---\n\n这是用来干嘛的，你懂的。 \n\n网址：\n\n[shadowsocks](https://github.com/shadowsocks)\n\n[sadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)\n\n## 服务端\n\n编译好执行文件：{% asset_link server.tar.gz Shadowsocks-server %}  \n放到服务器，更改.json文件配置，解压直接执行.sh文件即可。\n\n1. 首先，买个国外的服务器再说吧……\n   \n2. 在服务器安装golang环境。\n    安装包：{% asset_link go1.9.2.linux-amd64.tar.gz go1.9.2 %}\n    \n    这里不做介绍……\n    \n3. 在服务器安装git环境。\n\n    这里不做介绍……\n    \n4. 下载服务端代码shadowsocks-go.\n\n        # on server\n        go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n    \n    golang环境会自动编译可执行代码到${GOPATH}/bin  \n      \n5.  执行启动\n\n- *创建配置文件*：\n`touch /server/shadowsocks/shadowsocks.json`\n- *编辑shadowsocks.json*：\n    \n        {\t \n            \"server\":\"30.12.6.2\",\n            \"server_port\":8388,\n            \"local_port\":1080,\n            \"password\":\"123456\",\n            \"method\": \"aes-256-cfb\",\n            \"timeout\":600\n        }\n\n> 说明：       \n`server`:服务器ip地址；\n`server_port`:服务器端口；\n`local_port:`客户端代理端口；\n`method`:加密方式； \n\n- *启动*:\n\n\n    shadowsocks-server -c /server/shadowsocks/shadowsocks.json > /server/shadowsocks/log &.   \n    \n> 说明：\n`-c` 指定配置文件。 \n`log`记录日志。\n`&.` 后台执行    \n\n- *查看是否启动*：\n\n        [root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\n        tcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n\n\n---\n\n## 客户端\n\n### linux系统\n编译好执行文件：{% asset_link client.tar.gz Shadowsocks-client %} \n在linux客户端解压，修改.json配置文件中相关参数，启动即可。\n\n### windows系统\n直接下载客户端。[网址](https://github.com/shadowsocks/shadowsocks-windows)\n安装包：{% asset_link Shadowsocks-4.0.6.zip Shadowsocks-win %}\n双击打开：\n{% asset_img a.png %}\n\n把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。\n\n### ubuntu系统    \n\n- go客户端：\n`go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local`\n由于被墙，客户端下载不了。\n所以要在服务端执行，然后再把可执行二进制文件下拉到本地。\n\n*配置客户端文件*\n创建文件：shadowsocks-local.json\n编辑：\n    \n    {\n    \t\"local_port\": 1081,\n    \t\"server_password\": [\n    \t\t[\"127.0.0.1:8387\", \"foobar\"],\n    \t\t[\"127.0.0.1:8388\", \"barfoo\", \"aes-128-cfb\"]\n    \t]\n    }\n\n可以配置多个服务器，单个服务器，则去掉一个。\n\n启动：类似服务端，用`-c`指定配置文件。    \n\n- qt5客户端：\n\n1. 二进制包安装。[安装网址](https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)  \n\n2. 推荐，命令安装：\n    \n        #Ubuntu 14.04及更高版本\n        #添加ppa源\n        sudo add-apt-repository ppa:hzwhuang/ss-qt5\n        sudo apt-get update\n        sudo apt-get install shadowsocks-qt5\n         \n        #启动shadowsocks-qt5\n        \n        可以通过which shadowsocks-qt5找到可执行文件的位置。\n        \n        执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n\n### 移动\n\n- 安卓客户端：\n\n下载：{%asset_link Shadowsocks_v4.2.5_apkpure.com.apk Shadowsocks_v4.2.5_apkpure.com.apk%}\n\n- 苹果客户端：\n\n安装app：FirstWingy\n\n### 修改浏览器代理\n> SOCKS5 127.0.0.1:local_port\n\n如果可以，在chrome中可以安装代理设置插件       \n{% asset_img b.png %}\n\n然后启动，试下访问：[google](https://www.google.com)\n\n\n\n### linux下全局代理\n\n实验环境：Ubuntu系统\n\n1.安装应用`privoxy`\n\n一款工具，将socks代理转换成http。\n\n`sudo apt-get install privoxy`\n\n2.更改配置\n\n    sudo gedit /etc/privoxy/config\n    \n    ----------------------------------------------------------------\n\n    # 在 froward-socks4下面添加一条socks5的，因为shadowsocks为socks5，\n    # 地址是127.0.0.1:1080。注意他们最后有一个“.”\n    #        forward-socks4   /               socks-gw.example.com:1080  .\n    forward-socks5   /               127.0.0.1:1080 .\n    \n    # 下面还存在以下一条配置，表示privoxy监听本机8118端口，\n    # 把它作为http代理，代理地址为 http://localhost.8118/ 。\n    # 可以把地址改为 0.0.0.0:8118，表示外网也可以通过本机IP作http代理。\n    # 这样，你的外网IP为1.2.3.4，别人就可以设置 http://1.2.3.4:8118/ 为http代理。\n    　listen-address localhost:8118  #端口可以随意设定\n    \n    上面配置可能导致无法启动privoxy,新版本安全问题导致。改为：   \n    listen-address 192.168.1.115:8118  #端口可以随意设定  \n\n3.重启privoxy\n\n    sudo systemctl restart privoxy.serivce\n    \n4.添加环境变量\n\n    vim ~/.bashrc\n    \n    ----\n    添加两行：\n    export http_proxy=http://127.0.0.1:8118/\n    export https_proxy=http://127.0.0.1:8118/  \n    \n5.使环境变量立即生效\n\n    source ~/.bashrc\n    \n说明：如果只是想临时的让当前命令窗口代理，那么只需要添加临时变量，不需要编辑~/.bashrc。  \n只需要在当前命令窗口执行`export http_proxy=http://127.0.0.1:8118/` ` export https_proxy=http://127.0.0.1:8118/ `         ","slug":"shadowsocks-go","published":1,"updated":"2019-08-03T16:12:21.317Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfj00axg4vaentm0358","content":"<p>这是用来干嘛的，你懂的。 </p>\n<p>网址：</p>\n<p><a href=\"https://github.com/shadowsocks\" target=\"_blank\" rel=\"noopener\">shadowsocks</a></p>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">sadowsocks-go</a></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/server.tar.gz\" title=\"Shadowsocks-server\">Shadowsocks-server</a><br>放到服务器，更改.json文件配置，解压直接执行.sh文件即可。</p>\n<ol>\n<li><p>首先，买个国外的服务器再说吧……</p>\n</li>\n<li><p>在服务器安装golang环境。<br> 安装包：<a href=\"/2017/11/11/shadowsocks-go/go1.9.2.linux-amd64.tar.gz\" title=\"go1.9.2\">go1.9.2</a></p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>在服务器安装git环境。</p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>下载服务端代码shadowsocks-go.</p>\n<pre><code># on server\ngo get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n</code></pre><p> golang环境会自动编译可执行代码到${GOPATH}/bin  </p>\n</li>\n<li><p>执行启动</p>\n</li>\n</ol>\n<ul>\n<li><em>创建配置文件</em>：<br><code>touch /server/shadowsocks/shadowsocks.json</code></li>\n<li><p><em>编辑shadowsocks.json</em>：</p>\n<pre><code>{     \n    &quot;server&quot;:&quot;30.12.6.2&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;method&quot;: &quot;aes-256-cfb&quot;,\n    &quot;timeout&quot;:600\n}\n</code></pre></li>\n</ul>\n<blockquote>\n<p>说明：<br><code>server</code>:服务器ip地址；<br><code>server_port</code>:服务器端口；<br><code>local_port:</code>客户端代理端口；<br><code>method</code>:加密方式； </p>\n</blockquote>\n<ul>\n<li><em>启动</em>:</li>\n</ul>\n<pre><code>shadowsocks-server -c /server/shadowsocks/shadowsocks.json &gt; /server/shadowsocks/log &amp;.   \n</code></pre><blockquote>\n<p>说明：<br><code>-c</code> 指定配置文件。<br><code>log</code>记录日志。<br><code>&amp;.</code> 后台执行    </p>\n</blockquote>\n<ul>\n<li><p><em>查看是否启动</em>：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\ntcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h3><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/client.tar.gz\" title=\"Shadowsocks-client\">Shadowsocks-client</a><br>在linux客户端解压，修改.json配置文件中相关参数，启动即可。</p>\n<h3 id=\"windows系统\"><a href=\"#windows系统\" class=\"headerlink\" title=\"windows系统\"></a>windows系统</h3><p>直接下载客户端。<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">网址</a><br>安装包：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks-4.0.6.zip\" title=\"Shadowsocks-win\">Shadowsocks-win</a><br>双击打开：<br><img src=\"/2017/11/11/shadowsocks-go/a.png\"></p>\n<p>把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。</p>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><ul>\n<li>go客户端：<br><code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</code><br>由于被墙，客户端下载不了。<br>所以要在服务端执行，然后再把可执行二进制文件下拉到本地。</li>\n</ul>\n<p><em>配置客户端文件</em><br>创建文件：shadowsocks-local.json<br>编辑：</p>\n<pre><code>{\n    &quot;local_port&quot;: 1081,\n    &quot;server_password&quot;: [\n        [&quot;127.0.0.1:8387&quot;, &quot;foobar&quot;],\n        [&quot;127.0.0.1:8388&quot;, &quot;barfoo&quot;, &quot;aes-128-cfb&quot;]\n    ]\n}\n</code></pre><p>可以配置多个服务器，单个服务器，则去掉一个。</p>\n<p>启动：类似服务端，用<code>-c</code>指定配置文件。    </p>\n<ul>\n<li>qt5客户端：</li>\n</ul>\n<ol>\n<li><p>二进制包安装。<a href=\"https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"noopener\">安装网址</a>  </p>\n</li>\n<li><p>推荐，命令安装：</p>\n<pre><code>#Ubuntu 14.04及更高版本\n#添加ppa源\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n\n#启动shadowsocks-qt5\n\n可以通过which shadowsocks-qt5找到可执行文件的位置。\n\n执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n</code></pre></li>\n</ol>\n<h3 id=\"移动\"><a href=\"#移动\" class=\"headerlink\" title=\"移动\"></a>移动</h3><ul>\n<li>安卓客户端：</li>\n</ul>\n<p>下载：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk\" title=\"Shadowsocks_v4.2.5_apkpure.com.apk\">Shadowsocks_v4.2.5_apkpure.com.apk</a></p>\n<ul>\n<li>苹果客户端：</li>\n</ul>\n<p>安装app：FirstWingy</p>\n<h3 id=\"修改浏览器代理\"><a href=\"#修改浏览器代理\" class=\"headerlink\" title=\"修改浏览器代理\"></a>修改浏览器代理</h3><blockquote>\n<p>SOCKS5 127.0.0.1:local_port</p>\n</blockquote>\n<p>如果可以，在chrome中可以安装代理设置插件<br><img src=\"/2017/11/11/shadowsocks-go/b.png\"></p>\n<p>然后启动，试下访问：<a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener\">google</a></p>\n<h3 id=\"linux下全局代理\"><a href=\"#linux下全局代理\" class=\"headerlink\" title=\"linux下全局代理\"></a>linux下全局代理</h3><p>实验环境：Ubuntu系统</p>\n<p>1.安装应用<code>privoxy</code></p>\n<p>一款工具，将socks代理转换成http。</p>\n<p><code>sudo apt-get install privoxy</code></p>\n<p>2.更改配置</p>\n<pre><code>sudo gedit /etc/privoxy/config\n\n----------------------------------------------------------------\n\n# 在 froward-socks4下面添加一条socks5的，因为shadowsocks为socks5，\n# 地址是127.0.0.1:1080。注意他们最后有一个“.”\n#        forward-socks4   /               socks-gw.example.com:1080  .\nforward-socks5   /               127.0.0.1:1080 .\n\n# 下面还存在以下一条配置，表示privoxy监听本机8118端口，\n# 把它作为http代理，代理地址为 http://localhost.8118/ 。\n# 可以把地址改为 0.0.0.0:8118，表示外网也可以通过本机IP作http代理。\n# 这样，你的外网IP为1.2.3.4，别人就可以设置 http://1.2.3.4:8118/ 为http代理。\n　listen-address localhost:8118  #端口可以随意设定\n\n上面配置可能导致无法启动privoxy,新版本安全问题导致。改为：   \nlisten-address 192.168.1.115:8118  #端口可以随意设定  \n</code></pre><p>3.重启privoxy</p>\n<pre><code>sudo systemctl restart privoxy.serivce\n</code></pre><p>4.添加环境变量</p>\n<pre><code>vim ~/.bashrc\n\n----\n添加两行：\nexport http_proxy=http://127.0.0.1:8118/\nexport https_proxy=http://127.0.0.1:8118/  \n</code></pre><p>5.使环境变量立即生效</p>\n<pre><code>source ~/.bashrc\n</code></pre><p>说明：如果只是想临时的让当前命令窗口代理，那么只需要添加临时变量，不需要编辑~/.bashrc。<br>只需要在当前命令窗口执行<code>export http_proxy=http://127.0.0.1:8118/</code> <code>export https_proxy=http://127.0.0.1:8118/</code>         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是用来干嘛的，你懂的。 </p>\n<p>网址：</p>\n<p><a href=\"https://github.com/shadowsocks\" target=\"_blank\" rel=\"noopener\">shadowsocks</a></p>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">sadowsocks-go</a></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/server.tar.gz\" title=\"Shadowsocks-server\">Shadowsocks-server</a><br>放到服务器，更改.json文件配置，解压直接执行.sh文件即可。</p>\n<ol>\n<li><p>首先，买个国外的服务器再说吧……</p>\n</li>\n<li><p>在服务器安装golang环境。<br> 安装包：<a href=\"/2017/11/11/shadowsocks-go/go1.9.2.linux-amd64.tar.gz\" title=\"go1.9.2\">go1.9.2</a></p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>在服务器安装git环境。</p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>下载服务端代码shadowsocks-go.</p>\n<pre><code># on server\ngo get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n</code></pre><p> golang环境会自动编译可执行代码到${GOPATH}/bin  </p>\n</li>\n<li><p>执行启动</p>\n</li>\n</ol>\n<ul>\n<li><em>创建配置文件</em>：<br><code>touch /server/shadowsocks/shadowsocks.json</code></li>\n<li><p><em>编辑shadowsocks.json</em>：</p>\n<pre><code>{     \n    &quot;server&quot;:&quot;30.12.6.2&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;method&quot;: &quot;aes-256-cfb&quot;,\n    &quot;timeout&quot;:600\n}\n</code></pre></li>\n</ul>\n<blockquote>\n<p>说明：<br><code>server</code>:服务器ip地址；<br><code>server_port</code>:服务器端口；<br><code>local_port:</code>客户端代理端口；<br><code>method</code>:加密方式； </p>\n</blockquote>\n<ul>\n<li><em>启动</em>:</li>\n</ul>\n<pre><code>shadowsocks-server -c /server/shadowsocks/shadowsocks.json &gt; /server/shadowsocks/log &amp;.   \n</code></pre><blockquote>\n<p>说明：<br><code>-c</code> 指定配置文件。<br><code>log</code>记录日志。<br><code>&amp;.</code> 后台执行    </p>\n</blockquote>\n<ul>\n<li><p><em>查看是否启动</em>：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\ntcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h3><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/client.tar.gz\" title=\"Shadowsocks-client\">Shadowsocks-client</a><br>在linux客户端解压，修改.json配置文件中相关参数，启动即可。</p>\n<h3 id=\"windows系统\"><a href=\"#windows系统\" class=\"headerlink\" title=\"windows系统\"></a>windows系统</h3><p>直接下载客户端。<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">网址</a><br>安装包：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks-4.0.6.zip\" title=\"Shadowsocks-win\">Shadowsocks-win</a><br>双击打开：<br><img src=\"/2017/11/11/shadowsocks-go/a.png\"></p>\n<p>把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。</p>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><ul>\n<li>go客户端：<br><code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</code><br>由于被墙，客户端下载不了。<br>所以要在服务端执行，然后再把可执行二进制文件下拉到本地。</li>\n</ul>\n<p><em>配置客户端文件</em><br>创建文件：shadowsocks-local.json<br>编辑：</p>\n<pre><code>{\n    &quot;local_port&quot;: 1081,\n    &quot;server_password&quot;: [\n        [&quot;127.0.0.1:8387&quot;, &quot;foobar&quot;],\n        [&quot;127.0.0.1:8388&quot;, &quot;barfoo&quot;, &quot;aes-128-cfb&quot;]\n    ]\n}\n</code></pre><p>可以配置多个服务器，单个服务器，则去掉一个。</p>\n<p>启动：类似服务端，用<code>-c</code>指定配置文件。    </p>\n<ul>\n<li>qt5客户端：</li>\n</ul>\n<ol>\n<li><p>二进制包安装。<a href=\"https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"noopener\">安装网址</a>  </p>\n</li>\n<li><p>推荐，命令安装：</p>\n<pre><code>#Ubuntu 14.04及更高版本\n#添加ppa源\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n\n#启动shadowsocks-qt5\n\n可以通过which shadowsocks-qt5找到可执行文件的位置。\n\n执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n</code></pre></li>\n</ol>\n<h3 id=\"移动\"><a href=\"#移动\" class=\"headerlink\" title=\"移动\"></a>移动</h3><ul>\n<li>安卓客户端：</li>\n</ul>\n<p>下载：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk\" title=\"Shadowsocks_v4.2.5_apkpure.com.apk\">Shadowsocks_v4.2.5_apkpure.com.apk</a></p>\n<ul>\n<li>苹果客户端：</li>\n</ul>\n<p>安装app：FirstWingy</p>\n<h3 id=\"修改浏览器代理\"><a href=\"#修改浏览器代理\" class=\"headerlink\" title=\"修改浏览器代理\"></a>修改浏览器代理</h3><blockquote>\n<p>SOCKS5 127.0.0.1:local_port</p>\n</blockquote>\n<p>如果可以，在chrome中可以安装代理设置插件<br><img src=\"/2017/11/11/shadowsocks-go/b.png\"></p>\n<p>然后启动，试下访问：<a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener\">google</a></p>\n<h3 id=\"linux下全局代理\"><a href=\"#linux下全局代理\" class=\"headerlink\" title=\"linux下全局代理\"></a>linux下全局代理</h3><p>实验环境：Ubuntu系统</p>\n<p>1.安装应用<code>privoxy</code></p>\n<p>一款工具，将socks代理转换成http。</p>\n<p><code>sudo apt-get install privoxy</code></p>\n<p>2.更改配置</p>\n<pre><code>sudo gedit /etc/privoxy/config\n\n----------------------------------------------------------------\n\n# 在 froward-socks4下面添加一条socks5的，因为shadowsocks为socks5，\n# 地址是127.0.0.1:1080。注意他们最后有一个“.”\n#        forward-socks4   /               socks-gw.example.com:1080  .\nforward-socks5   /               127.0.0.1:1080 .\n\n# 下面还存在以下一条配置，表示privoxy监听本机8118端口，\n# 把它作为http代理，代理地址为 http://localhost.8118/ 。\n# 可以把地址改为 0.0.0.0:8118，表示外网也可以通过本机IP作http代理。\n# 这样，你的外网IP为1.2.3.4，别人就可以设置 http://1.2.3.4:8118/ 为http代理。\n　listen-address localhost:8118  #端口可以随意设定\n\n上面配置可能导致无法启动privoxy,新版本安全问题导致。改为：   \nlisten-address 192.168.1.115:8118  #端口可以随意设定  \n</code></pre><p>3.重启privoxy</p>\n<pre><code>sudo systemctl restart privoxy.serivce\n</code></pre><p>4.添加环境变量</p>\n<pre><code>vim ~/.bashrc\n\n----\n添加两行：\nexport http_proxy=http://127.0.0.1:8118/\nexport https_proxy=http://127.0.0.1:8118/  \n</code></pre><p>5.使环境变量立即生效</p>\n<pre><code>source ~/.bashrc\n</code></pre><p>说明：如果只是想临时的让当前命令窗口代理，那么只需要添加临时变量，不需要编辑~/.bashrc。<br>只需要在当前命令窗口执行<code>export http_proxy=http://127.0.0.1:8118/</code> <code>export https_proxy=http://127.0.0.1:8118/</code>         </p>\n"},{"title":"用Shiro和JWT做认证授权","date":"2019-05-14T07:38:59.000Z","_content":"\n本文介绍使用安全框架shiro和流行的JSON Web Token认证协议，在前后端分离系统中如何做认证授权。\n\n\n","source":"_posts/shiro-jwt.md","raw":"---\ntitle: 用Shiro和JWT做认证授权\ndate: 2019-05-14 15:38:59\ncategories: jwt\ntags:\n---\n\n本文介绍使用安全框架shiro和流行的JSON Web Token认证协议，在前后端分离系统中如何做认证授权。\n\n\n","slug":"shiro-jwt","published":1,"updated":"2019-06-16T14:38:33.964Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfk00b1g4va8oqk0tet","content":"<p>本文介绍使用安全框架shiro和流行的JSON Web Token认证协议，在前后端分离系统中如何做认证授权。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍使用安全框架shiro和流行的JSON Web Token认证协议，在前后端分离系统中如何做认证授权。</p>\n"},{"title":"Spinnaker持续集成初试","date":"2018-08-13T06:56:33.000Z","_content":"\n[官网](https://www.spinnaker.io/)","source":"_posts/spinnaker-start.md","raw":"---\ntitle: Spinnaker持续集成初试\ndate: 2018-08-13 14:56:33\ncategories: 持续集成\ntags: spinnaker-start\n---\n\n[官网](https://www.spinnaker.io/)","slug":"spinnaker-start","published":1,"updated":"2019-06-16T14:38:33.969Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfl00b3g4vamkps5k26","content":"<p><a href=\"https://www.spinnaker.io/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.spinnaker.io/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n"},{"title":"shiro安全框架入门","date":"2018-05-14T03:22:37.000Z","_content":"\nApache Shiro([官网](http://shiro.apache.org))是个java的安全框架，轻便、api简单、功能全面的特性获得 许多开发者的青睐。其提供了认证、授权、加密以及会话管理等功能……\n\n### 一.介绍\n\n#### 1.功能特性\nShiro 包含 10 个内容，如下图：\n\n{%asset_img shiro-01.png%}\n\n- Authentication: 身份认证，拥有合法身份才能登录系统并使用。\n- Authorization： 授权验证。即认证某个已经得到身份认证的用户是否拥有对某个功能或者某种资源的使用权限。\n- Session Manager： 会话管理。用户登录后，没退出之前，为一次会话，所有的信息都在会话中。会话可以是javase环境，也可以是java web环境。\n- Cryptography： 加密，保护数据的安全性。\n- Web Support： web支持，把shiro容易的集成到web环境中。\n- Caching： 缓存，用户登陆后，用户的信息、拥有的角色权限不必每次查，缓存起来。\n- Concurrency： shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。\n- Testing：提供测试支持。\n- Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。\n- Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。\n\n#### 2.运行原理\n1.原理图1（应用程序角度）：\n{%asset_img shiro-02.png%}\n\n- Subject：主体，代表当前“用户”，这里的用户指的不仅仅是登录用户，指的是任何与该系统交互的主体。所有的Subject都和SecurityManager绑定，与Subject的任何交互都委托给SecurityManager来处理。\n- SecurityManager： 安全管理器，是shiro的核心功能。它负责所有的安全操作管理，管理这所有的Subject。类似于SpringMvc中的DispatcherServlet控制器。\n- Realm： 域。所有的安全数据保存，获取都要通过Realm。SecurityManager和它交互，获取相关数据。Realm就类似于数据源DataSource。\n\n2.原理图2（内部架构）：\n{%asset_img shiro-03.png%}\n\n- Subject：主体。\n- SecurityManager：安全管理器。\n- Authenticator： 认证器，负责对主体的身份认证。可以自定义，重新设定认证策略，即什么情况下才算认证通过。\n- Authrizer： 授权器，或者访问控制器。决定主体是否有权限进行相应操作。\n- Realm： 可以一个或者多个。可以是jdbc，redis，内存等实现。\n- SessionManager： 会话管理器。\n- SessionDAO： 数据访问对象，用于会话的CRUD。可以自定义，控制session存储的位置，关系数据库，redis等。另外，可以使用缓存，提高性能。\n- CacheManager： 缓存管理器。\n- Cryptography： 密码模块。提供了一些加解密算法。\n\n#### 3.过滤器\n应用到web系统中时，Shiro会默认创建一些过滤器对客户端请求进行过滤。常用过滤器有：\n\n|  过滤器简称   | 对应的 Java 类 |\n| :------| :------|\n| anon | org.apache.shiro.web.filter.authc.AnonymousFilter |\n| authc | org.apache.shiro.web.filter.authc.FormAuthenticationFilter |\n| authcBasic | org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter |\n| perms | org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter |\n| port | org.apache.shiro.web.filter.authz.PortFilter |\n| rest | org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter |\n| roles | org.apache.shiro.web.filter.authz.RolesAuthorizationFilter |\n| ssl | org.apache.shiro.web.filter.authz.SslFilter |\n| user | org.apache.shiro.web.filter.authc.UserFilter |\n|  logout | org.apache.shiro.web.filter.authc.LogoutFilter |\n| noSessionCreation | org.apache.shiro.web.filter.session.NoSessionCreationFilter |\n\n说明：\n\n    /admins/**=anon               # 表示该 uri 可以匿名访问\n    /admins/**=auth               # 表示该 uri 需要认证才能访问\n    /admins/**=authcBasic         # 表示该 uri 需要 httpBasic 认证\n    /admins/**=perms[user:add:*]  # 表示该 uri 需要认证用户拥有 user:add:* 权限才能访问\n    /admins/**=port[8081]         # 表示该 uri 需要使用 8081 端口\n    /admins/**=rest[user]         # 相当于 /admins/**=perms[user:method]，其中，method 表示  get、post、delete 等\n    /admins/**=roles[admin]       # 表示该 uri 需要认证用户拥有 admin 角色才能访问\n    /admins/**=ssl                # 表示该 uri 需要使用 https 协议\n    /admins/**=user               # 表示该 uri 需要认证或通过记住我认证才能访问\n    /logout=logout                # 表示注销,可以当作固定配置\n    \n _注意_\n anon，authcBasic，auchc，user 是认证过滤器。\n perms，roles，ssl，rest，port 是授权过滤器。   \n\n### 二.认证\n\n1.认证路程图：\n{%asset_img shiro-04.png%} \n\n2.使用代码示例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.SimpleAccountRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class AuthenticationTest {\n\n    SimpleAccountRealm simpleAccoutRealm = new SimpleAccountRealm();\n\n    @Before\n    public void addUser() {\n        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");\n//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");\n    }\n\n    @Test\n    public void  testAuthentication() {\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(simpleAccoutRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.logout();//退出登录\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证\n\n    }\n}\n\n```\n\n### 三.授权\n\n1.流程图：\n{%asset_img shiro-05.png%}\n\n2。代码示例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.SimpleAccountRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class AuthenticationTest {\n\n    SimpleAccountRealm simpleAccoutRealm = new SimpleAccountRealm();\n\n    @Before\n    public void addUser() {\n//        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");\n//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");\n\n        simpleAccoutRealm.addAccount(\"zmt\",\"123456\",\"admin\",\"user\"); //添加角色\n    }\n\n    @Test\n    public void  testAuthentication() {\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(simpleAccoutRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user1\"); //拥有该两个角色\n\n//        subject.logout();//退出登录\n//        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证\n\n    }\n\n\n}\n\n```\n\n\n\n### 四.Shiro自定义Realm\n\n#### 1.IniRealm讲解\n\n代码样例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.text.IniRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class IniRealmTest {\n\n    @Test\n    public void  test1() {\n\n        IniRealm iniRealm = new IniRealm(\"classpath:user.ini\");\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(iniRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:delete\");\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //报错，没有update权限\n    }\n\n\n}\n\n```\n\n```text\n编辑：user.ini\n\n[users]\nzmt=123456,admin,user\n[roles]\nadmin=user:delete,user:update\n```\n#### 2.JdbcRealm讲解\n\n用户、角色、权限数据都在数据库里面。而不是在配置文件里面。 \n两种方式，一种是使用默认查询语句；另外一种是自己设计表，写sql语句，不必遵守默认的。   \n\n##### 2.1.默认方式\n\n- 首先，创建相关默认数据表：   \n```sql\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50718\nSource Host           : localhost:3307\nSource Database       : shiro-test\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50718\nFile Encoding         : 65001\n\nDate: 2018-10-15 17:09:45\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for roles_permissions\n-- ----------------------------\nDROP TABLE IF EXISTS `roles_permissions`;\nCREATE TABLE `roles_permissions` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(255) NOT NULL,\n  `permission` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `role_name` (`role_name`),\n  CONSTRAINT `roles_permissions_ibfk_1` FOREIGN KEY (`role_name`) REFERENCES `user_roles` (`role_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of roles_permissions\n-- ----------------------------\nINSERT INTO `roles_permissions` VALUES ('1', 'admin', 'user:select');\n\n-- ----------------------------\n-- Table structure for user_roles\n-- ----------------------------\nDROP TABLE IF EXISTS `user_roles`;\nCREATE TABLE `user_roles` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) NOT NULL,\n  `role_name` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`username`),\n  KEY `role_name` (`role_name`),\n  CONSTRAINT `user_roles_ibfk_1` FOREIGN KEY (`username`) REFERENCES `users` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of user_roles\n-- ----------------------------\nINSERT INTO `user_roles` VALUES ('1', 'zmt', 'admin');\n\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) NOT NULL,\n  `password` varchar(255) NOT NULL,\n  `password_salt` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'zmt', '123456', 'abcd');\nSET FOREIGN_KEY_CHECKS=1;\n\n```\n- 代码样例：\n```java\npackage com.example.springboot2shirostart;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.jdbc.JdbcRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class JdbcRealmTest {\n\n    DruidDataSource dataSource = new DruidDataSource();\n\n    {\n        dataSource.setUrl(\"jdbc:mysql://localhost:3307/shiro-test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n    }\n\n    /**\n     * 查询默认的数据表做相关操作。\n     */\n    @Test\n    public void  test1() {\n\n        JdbcRealm jdbcRealm = new JdbcRealm();\n        jdbcRealm.setDataSource(dataSource); //设置数据源\n        jdbcRealm.setPermissionsLookupEnabled(true); //是否可以查看权限。默认为false。不打开，则无法查看权限\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(jdbcRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n//        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n//        subject.checkPermission(\"user:update\"); //报错，没有update权限\n    }\n\n\n}\n\n```\n\n##### 2.2.自己设计表写查询语句\n\n- 创建数据表 \n不必遵循默认规范，表名、字段名都可以自定义。  \n\n脚本： \n```sql\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50718\nSource Host           : localhost:3307\nSource Database       : shiro-test\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50718\nFile Encoding         : 65001\n\nDate: 2018-10-17 11:42:25\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for test_role_permissions\n-- ----------------------------\nDROP TABLE IF EXISTS `test_role_permissions`;\nCREATE TABLE `test_role_permissions` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(255) NOT NULL,\n  `permission` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_role_permissions\n-- ----------------------------\nINSERT INTO `test_role_permissions` VALUES ('1', 'caiwu', 'user:update');\n\n-- ----------------------------\n-- Table structure for test_user\n-- ----------------------------\nDROP TABLE IF EXISTS `test_user`;\nCREATE TABLE `test_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `user_name` varchar(255) NOT NULL,\n  `password` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`user_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_user\n-- ----------------------------\nINSERT INTO `test_user` VALUES ('1', 'xr', '123456');\n\n-- ----------------------------\n-- Table structure for test_user_role\n-- ----------------------------\nDROP TABLE IF EXISTS `test_user_role`;\nCREATE TABLE `test_user_role` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `test_user_name` varchar(255) NOT NULL,\n  `role_name` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_user_role\n-- ----------------------------\nINSERT INTO `test_user_role` VALUES ('1', 'xr', 'caiwu');\nSET FOREIGN_KEY_CHECKS=1;\n```\n- 代码样例：\n```java\npackage com.example.springboot2shirostart;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.jdbc.JdbcRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class JdbcRealmTest {\n\n    DruidDataSource dataSource = new DruidDataSource();\n\n    {\n        dataSource.setUrl(\"jdbc:mysql://localhost:3307/shiro-test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n    }\n\n    @Test\n    public void  test2() {\n\n        JdbcRealm jdbcRealm = new JdbcRealm();\n        jdbcRealm.setDataSource(dataSource); //设置数据源\n        jdbcRealm.setPermissionsLookupEnabled(true); //是否可以查看权限。默认为false。不打开，则无法查看权限\n\n        //创建sql语句，使用自己的表、sql来验证\n        String sql_auth = \"SELECT `password` FROM test_user WHERE user_name = ?\";\n        jdbcRealm.setAuthenticationQuery(sql_auth);\n        String sql_role = \"SELECT role_name FROM test_user_role WHERE test_user_name = ?\";\n        jdbcRealm.setUserRolesQuery(sql_role);\n        String sql_permisstion = \"SELECT permission FROM test_role_permissions WHERE role_name = ?\";\n        jdbcRealm.setPermissionsQuery(sql_permisstion);\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(jdbcRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"xr\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"caiwu\");\n\n        //权限\n        subject.checkPermission(\"user:update\");//jdbcRealm.setPermissionsLookupEnabled(true);\n    }\n\n\n}\n\n```\n\n#### 3.自定义Realm\n\n- 创建类CustomRealm\n\n自定义Realm需要继承`AuthorizingRealm`。\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CustomRealm extends AuthorizingRealm {\n\n    final String realmName = this.getClass().getSimpleName(); //自定义realm名称\n\n    Map<String,String> userMap = new HashMap<>(16);\n\n    {\n        userMap.put(\"zmt\",\"123456\");\n        userMap.put(\"xr\",\"654321\");\n\n        super.setName(realmName); //设置名称\n    }\n\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        String username = (String) principals.getPrimaryPrincipal();\n        //从数据库或者缓存中获取角色数据。\n        Set<String> roles = getRolesByUsername(username);\n        Set<String> permissions = getPermissionByUsername(username);\n\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        authorizationInfo.setStringPermissions(permissions); //设置权限\n        authorizationInfo.setRoles(roles); //设置角色\n\n        return authorizationInfo;\n    }\n\n    /**\n     * 模拟通过用户名获取权限。\n     * @param username\n     * @return\n     */\n    private Set<String> getPermissionByUsername(String username) {\n        Set<String> permissions = new HashSet<>();\n        permissions.add(\"admin:delete\");\n        permissions.add(\"user:select\");\n        permissions.add(\"user:update\");\n        return permissions;\n    }\n\n    /**\n     * 模拟获取角色。根据用户名获取角色。\n     * @param username\n     * @return\n     */\n    private Set<String> getRolesByUsername(String username) {\n        Set<String> roles = new HashSet<>();\n        roles.add(\"admin\");\n        roles.add(\"user\");\n        return roles;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        //从主体传过来认证信息,获得用户名\n        String username = (String) token.getPrincipal();\n        System.out.println(\"username:\" + username);\n\n        //通过用户名到数据库中获取凭证\n        String pwd = getPwdByUsername(username);\n        if (pwd == null) {\n            return null;\n        }\n\n        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,pwd,realmName);\n\n        return authenticationInfo;\n    }\n\n    /**\n     * 模拟获取数据库数据。根据用户名获取用户密码\n     * @param username 用户名。\n     * @return\n     */\n    private String getPwdByUsername(String username) {\n        return userMap.get(username);\n    }\n\n}\n\n```\n\n- 测试：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class CustomRealmTest {\n\n\n    @Test\n    public void  test1() {\n\n        CustomRealm customRealm = new CustomRealm();//自定义Realm\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(customRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n//        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //有update权限\n    }\n}\n\n```\n\n### 五.Shiro加密\n\n前面介绍的密码都是明文的，实际的密码在数据库中是加密的。    \n\n下面在自定义的Realm中使用加密。  \n\n- 代码：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.ByteSource;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CustomRealm extends AuthorizingRealm {\n\n    final String realmName = this.getClass().getSimpleName(); //自定义realm名称\n\n    Map<String,String> userMap = new HashMap<>(16);\n\n    {\n//        userMap.put(\"zmt\",\"123456\");\n//        userMap.put(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\"); //数据库的密码是密文，不加盐\n        userMap.put(\"zmt\",\"640a19b710290a9ff4d72e70cdd21913\"); //md5加盐密码\n        userMap.put(\"xr\",\"654321\");\n\n        super.setName(realmName); //设置名称\n    }\n\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        String username = (String) principals.getPrimaryPrincipal();\n        //从数据库或者缓存中获取角色数据。\n        Set<String> roles = getRolesByUsername(username);\n        Set<String> permissions = getPermissionByUsername(username);\n\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        authorizationInfo.setStringPermissions(permissions); //设置权限\n        authorizationInfo.setRoles(roles); //设置角色\n\n        return authorizationInfo;\n    }\n\n    /**\n     * 模拟通过用户名获取权限。\n     * @param username\n     * @return\n     */\n    private Set<String> getPermissionByUsername(String username) {\n        Set<String> permissions = new HashSet<>();\n        permissions.add(\"admin:delete\");\n        permissions.add(\"user:select\");\n        permissions.add(\"user:update\");\n        return permissions;\n    }\n\n    /**\n     * 模拟获取角色。根据用户名获取角色。\n     * @param username\n     * @return\n     */\n    private Set<String> getRolesByUsername(String username) {\n        Set<String> roles = new HashSet<>();\n        roles.add(\"admin\");\n        roles.add(\"user\");\n        return roles;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        //从主体传过来认证信息,获得用户名\n        String username = (String) token.getPrincipal();\n        System.out.println(\"username:\" + username);\n\n        //通过用户名到数据库中获取凭证\n        String pwd = getPwdByUsername(username);\n        if (pwd == null) {\n            return null;\n        }\n\n        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,pwd,realmName);\n        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(\"aaa\")); //密码加盐后，这里要加上这句\n\n        return authenticationInfo;\n    }\n\n    /**\n     * 模拟获取数据库数据。根据用户名获取用户密码\n     * @param username 用户名。\n     * @return\n     */\n    private String getPwdByUsername(String username) {\n        return userMap.get(username);\n    }\n\n\n}\n\n```\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.crypto.hash.Md5Hash;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class CustomRealmTest {\n\n\n    @Test\n    public void  test1() {\n\n        CustomRealm customRealm = new CustomRealm();//自定义Realm\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(customRealm);\n\n        //设置散列加密\n        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();\n        matcher.setHashAlgorithmName(\"md5\");//设置加密方式\n        matcher.setHashIterations(1); //设置加密次数\n        customRealm.setCredentialsMatcher(matcher); //设置加密对象\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\");//用户,密码MD5加密。明文：123456\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n//        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //有update权限\n    }\n\n    @Test\n    public void genPwd() {\n//        Md5Hash md5Hash = new Md5Hash(\"123456\"); //md5加密密码，不加盐\n//        System.out.println(\"md5加密：\" + md5Hash);\n\n        Md5Hash md5Hash = new Md5Hash(\"e10adc3949ba59abbe56e057f20f883e\",\"aaa\"); //md5加密密码，加盐，密码更加难以识破，盐一般用随机数，这里写死\n        System.out.println(\"md5加盐加密：\" + md5Hash);\n    }\n}\n\n```\n\n### 六.shiro会话\n\n\n\n\n","source":"_posts/shiro-start.md","raw":"---\ntitle: shiro安全框架入门\ndate: 2018-05-14 11:22:37\ncategories: shiro\ntags: shiro入门\n---\n\nApache Shiro([官网](http://shiro.apache.org))是个java的安全框架，轻便、api简单、功能全面的特性获得 许多开发者的青睐。其提供了认证、授权、加密以及会话管理等功能……\n\n### 一.介绍\n\n#### 1.功能特性\nShiro 包含 10 个内容，如下图：\n\n{%asset_img shiro-01.png%}\n\n- Authentication: 身份认证，拥有合法身份才能登录系统并使用。\n- Authorization： 授权验证。即认证某个已经得到身份认证的用户是否拥有对某个功能或者某种资源的使用权限。\n- Session Manager： 会话管理。用户登录后，没退出之前，为一次会话，所有的信息都在会话中。会话可以是javase环境，也可以是java web环境。\n- Cryptography： 加密，保护数据的安全性。\n- Web Support： web支持，把shiro容易的集成到web环境中。\n- Caching： 缓存，用户登陆后，用户的信息、拥有的角色权限不必每次查，缓存起来。\n- Concurrency： shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。\n- Testing：提供测试支持。\n- Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。\n- Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。\n\n#### 2.运行原理\n1.原理图1（应用程序角度）：\n{%asset_img shiro-02.png%}\n\n- Subject：主体，代表当前“用户”，这里的用户指的不仅仅是登录用户，指的是任何与该系统交互的主体。所有的Subject都和SecurityManager绑定，与Subject的任何交互都委托给SecurityManager来处理。\n- SecurityManager： 安全管理器，是shiro的核心功能。它负责所有的安全操作管理，管理这所有的Subject。类似于SpringMvc中的DispatcherServlet控制器。\n- Realm： 域。所有的安全数据保存，获取都要通过Realm。SecurityManager和它交互，获取相关数据。Realm就类似于数据源DataSource。\n\n2.原理图2（内部架构）：\n{%asset_img shiro-03.png%}\n\n- Subject：主体。\n- SecurityManager：安全管理器。\n- Authenticator： 认证器，负责对主体的身份认证。可以自定义，重新设定认证策略，即什么情况下才算认证通过。\n- Authrizer： 授权器，或者访问控制器。决定主体是否有权限进行相应操作。\n- Realm： 可以一个或者多个。可以是jdbc，redis，内存等实现。\n- SessionManager： 会话管理器。\n- SessionDAO： 数据访问对象，用于会话的CRUD。可以自定义，控制session存储的位置，关系数据库，redis等。另外，可以使用缓存，提高性能。\n- CacheManager： 缓存管理器。\n- Cryptography： 密码模块。提供了一些加解密算法。\n\n#### 3.过滤器\n应用到web系统中时，Shiro会默认创建一些过滤器对客户端请求进行过滤。常用过滤器有：\n\n|  过滤器简称   | 对应的 Java 类 |\n| :------| :------|\n| anon | org.apache.shiro.web.filter.authc.AnonymousFilter |\n| authc | org.apache.shiro.web.filter.authc.FormAuthenticationFilter |\n| authcBasic | org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter |\n| perms | org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter |\n| port | org.apache.shiro.web.filter.authz.PortFilter |\n| rest | org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter |\n| roles | org.apache.shiro.web.filter.authz.RolesAuthorizationFilter |\n| ssl | org.apache.shiro.web.filter.authz.SslFilter |\n| user | org.apache.shiro.web.filter.authc.UserFilter |\n|  logout | org.apache.shiro.web.filter.authc.LogoutFilter |\n| noSessionCreation | org.apache.shiro.web.filter.session.NoSessionCreationFilter |\n\n说明：\n\n    /admins/**=anon               # 表示该 uri 可以匿名访问\n    /admins/**=auth               # 表示该 uri 需要认证才能访问\n    /admins/**=authcBasic         # 表示该 uri 需要 httpBasic 认证\n    /admins/**=perms[user:add:*]  # 表示该 uri 需要认证用户拥有 user:add:* 权限才能访问\n    /admins/**=port[8081]         # 表示该 uri 需要使用 8081 端口\n    /admins/**=rest[user]         # 相当于 /admins/**=perms[user:method]，其中，method 表示  get、post、delete 等\n    /admins/**=roles[admin]       # 表示该 uri 需要认证用户拥有 admin 角色才能访问\n    /admins/**=ssl                # 表示该 uri 需要使用 https 协议\n    /admins/**=user               # 表示该 uri 需要认证或通过记住我认证才能访问\n    /logout=logout                # 表示注销,可以当作固定配置\n    \n _注意_\n anon，authcBasic，auchc，user 是认证过滤器。\n perms，roles，ssl，rest，port 是授权过滤器。   \n\n### 二.认证\n\n1.认证路程图：\n{%asset_img shiro-04.png%} \n\n2.使用代码示例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.SimpleAccountRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class AuthenticationTest {\n\n    SimpleAccountRealm simpleAccoutRealm = new SimpleAccountRealm();\n\n    @Before\n    public void addUser() {\n        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");\n//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");\n    }\n\n    @Test\n    public void  testAuthentication() {\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(simpleAccoutRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.logout();//退出登录\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证\n\n    }\n}\n\n```\n\n### 三.授权\n\n1.流程图：\n{%asset_img shiro-05.png%}\n\n2。代码示例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.SimpleAccountRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class AuthenticationTest {\n\n    SimpleAccountRealm simpleAccoutRealm = new SimpleAccountRealm();\n\n    @Before\n    public void addUser() {\n//        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");\n//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");\n\n        simpleAccoutRealm.addAccount(\"zmt\",\"123456\",\"admin\",\"user\"); //添加角色\n    }\n\n    @Test\n    public void  testAuthentication() {\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(simpleAccoutRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user1\"); //拥有该两个角色\n\n//        subject.logout();//退出登录\n//        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证\n\n    }\n\n\n}\n\n```\n\n\n\n### 四.Shiro自定义Realm\n\n#### 1.IniRealm讲解\n\n代码样例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.text.IniRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class IniRealmTest {\n\n    @Test\n    public void  test1() {\n\n        IniRealm iniRealm = new IniRealm(\"classpath:user.ini\");\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(iniRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:delete\");\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //报错，没有update权限\n    }\n\n\n}\n\n```\n\n```text\n编辑：user.ini\n\n[users]\nzmt=123456,admin,user\n[roles]\nadmin=user:delete,user:update\n```\n#### 2.JdbcRealm讲解\n\n用户、角色、权限数据都在数据库里面。而不是在配置文件里面。 \n两种方式，一种是使用默认查询语句；另外一种是自己设计表，写sql语句，不必遵守默认的。   \n\n##### 2.1.默认方式\n\n- 首先，创建相关默认数据表：   \n```sql\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50718\nSource Host           : localhost:3307\nSource Database       : shiro-test\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50718\nFile Encoding         : 65001\n\nDate: 2018-10-15 17:09:45\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for roles_permissions\n-- ----------------------------\nDROP TABLE IF EXISTS `roles_permissions`;\nCREATE TABLE `roles_permissions` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(255) NOT NULL,\n  `permission` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `role_name` (`role_name`),\n  CONSTRAINT `roles_permissions_ibfk_1` FOREIGN KEY (`role_name`) REFERENCES `user_roles` (`role_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of roles_permissions\n-- ----------------------------\nINSERT INTO `roles_permissions` VALUES ('1', 'admin', 'user:select');\n\n-- ----------------------------\n-- Table structure for user_roles\n-- ----------------------------\nDROP TABLE IF EXISTS `user_roles`;\nCREATE TABLE `user_roles` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) NOT NULL,\n  `role_name` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`username`),\n  KEY `role_name` (`role_name`),\n  CONSTRAINT `user_roles_ibfk_1` FOREIGN KEY (`username`) REFERENCES `users` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of user_roles\n-- ----------------------------\nINSERT INTO `user_roles` VALUES ('1', 'zmt', 'admin');\n\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) NOT NULL,\n  `password` varchar(255) NOT NULL,\n  `password_salt` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'zmt', '123456', 'abcd');\nSET FOREIGN_KEY_CHECKS=1;\n\n```\n- 代码样例：\n```java\npackage com.example.springboot2shirostart;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.jdbc.JdbcRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class JdbcRealmTest {\n\n    DruidDataSource dataSource = new DruidDataSource();\n\n    {\n        dataSource.setUrl(\"jdbc:mysql://localhost:3307/shiro-test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n    }\n\n    /**\n     * 查询默认的数据表做相关操作。\n     */\n    @Test\n    public void  test1() {\n\n        JdbcRealm jdbcRealm = new JdbcRealm();\n        jdbcRealm.setDataSource(dataSource); //设置数据源\n        jdbcRealm.setPermissionsLookupEnabled(true); //是否可以查看权限。默认为false。不打开，则无法查看权限\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(jdbcRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n//        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n//        subject.checkPermission(\"user:update\"); //报错，没有update权限\n    }\n\n\n}\n\n```\n\n##### 2.2.自己设计表写查询语句\n\n- 创建数据表 \n不必遵循默认规范，表名、字段名都可以自定义。  \n\n脚本： \n```sql\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50718\nSource Host           : localhost:3307\nSource Database       : shiro-test\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50718\nFile Encoding         : 65001\n\nDate: 2018-10-17 11:42:25\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for test_role_permissions\n-- ----------------------------\nDROP TABLE IF EXISTS `test_role_permissions`;\nCREATE TABLE `test_role_permissions` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(255) NOT NULL,\n  `permission` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_role_permissions\n-- ----------------------------\nINSERT INTO `test_role_permissions` VALUES ('1', 'caiwu', 'user:update');\n\n-- ----------------------------\n-- Table structure for test_user\n-- ----------------------------\nDROP TABLE IF EXISTS `test_user`;\nCREATE TABLE `test_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `user_name` varchar(255) NOT NULL,\n  `password` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`user_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_user\n-- ----------------------------\nINSERT INTO `test_user` VALUES ('1', 'xr', '123456');\n\n-- ----------------------------\n-- Table structure for test_user_role\n-- ----------------------------\nDROP TABLE IF EXISTS `test_user_role`;\nCREATE TABLE `test_user_role` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `test_user_name` varchar(255) NOT NULL,\n  `role_name` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_user_role\n-- ----------------------------\nINSERT INTO `test_user_role` VALUES ('1', 'xr', 'caiwu');\nSET FOREIGN_KEY_CHECKS=1;\n```\n- 代码样例：\n```java\npackage com.example.springboot2shirostart;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.jdbc.JdbcRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class JdbcRealmTest {\n\n    DruidDataSource dataSource = new DruidDataSource();\n\n    {\n        dataSource.setUrl(\"jdbc:mysql://localhost:3307/shiro-test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n    }\n\n    @Test\n    public void  test2() {\n\n        JdbcRealm jdbcRealm = new JdbcRealm();\n        jdbcRealm.setDataSource(dataSource); //设置数据源\n        jdbcRealm.setPermissionsLookupEnabled(true); //是否可以查看权限。默认为false。不打开，则无法查看权限\n\n        //创建sql语句，使用自己的表、sql来验证\n        String sql_auth = \"SELECT `password` FROM test_user WHERE user_name = ?\";\n        jdbcRealm.setAuthenticationQuery(sql_auth);\n        String sql_role = \"SELECT role_name FROM test_user_role WHERE test_user_name = ?\";\n        jdbcRealm.setUserRolesQuery(sql_role);\n        String sql_permisstion = \"SELECT permission FROM test_role_permissions WHERE role_name = ?\";\n        jdbcRealm.setPermissionsQuery(sql_permisstion);\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(jdbcRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"xr\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"caiwu\");\n\n        //权限\n        subject.checkPermission(\"user:update\");//jdbcRealm.setPermissionsLookupEnabled(true);\n    }\n\n\n}\n\n```\n\n#### 3.自定义Realm\n\n- 创建类CustomRealm\n\n自定义Realm需要继承`AuthorizingRealm`。\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CustomRealm extends AuthorizingRealm {\n\n    final String realmName = this.getClass().getSimpleName(); //自定义realm名称\n\n    Map<String,String> userMap = new HashMap<>(16);\n\n    {\n        userMap.put(\"zmt\",\"123456\");\n        userMap.put(\"xr\",\"654321\");\n\n        super.setName(realmName); //设置名称\n    }\n\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        String username = (String) principals.getPrimaryPrincipal();\n        //从数据库或者缓存中获取角色数据。\n        Set<String> roles = getRolesByUsername(username);\n        Set<String> permissions = getPermissionByUsername(username);\n\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        authorizationInfo.setStringPermissions(permissions); //设置权限\n        authorizationInfo.setRoles(roles); //设置角色\n\n        return authorizationInfo;\n    }\n\n    /**\n     * 模拟通过用户名获取权限。\n     * @param username\n     * @return\n     */\n    private Set<String> getPermissionByUsername(String username) {\n        Set<String> permissions = new HashSet<>();\n        permissions.add(\"admin:delete\");\n        permissions.add(\"user:select\");\n        permissions.add(\"user:update\");\n        return permissions;\n    }\n\n    /**\n     * 模拟获取角色。根据用户名获取角色。\n     * @param username\n     * @return\n     */\n    private Set<String> getRolesByUsername(String username) {\n        Set<String> roles = new HashSet<>();\n        roles.add(\"admin\");\n        roles.add(\"user\");\n        return roles;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        //从主体传过来认证信息,获得用户名\n        String username = (String) token.getPrincipal();\n        System.out.println(\"username:\" + username);\n\n        //通过用户名到数据库中获取凭证\n        String pwd = getPwdByUsername(username);\n        if (pwd == null) {\n            return null;\n        }\n\n        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,pwd,realmName);\n\n        return authenticationInfo;\n    }\n\n    /**\n     * 模拟获取数据库数据。根据用户名获取用户密码\n     * @param username 用户名。\n     * @return\n     */\n    private String getPwdByUsername(String username) {\n        return userMap.get(username);\n    }\n\n}\n\n```\n\n- 测试：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class CustomRealmTest {\n\n\n    @Test\n    public void  test1() {\n\n        CustomRealm customRealm = new CustomRealm();//自定义Realm\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(customRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n//        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //有update权限\n    }\n}\n\n```\n\n### 五.Shiro加密\n\n前面介绍的密码都是明文的，实际的密码在数据库中是加密的。    \n\n下面在自定义的Realm中使用加密。  \n\n- 代码：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.ByteSource;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CustomRealm extends AuthorizingRealm {\n\n    final String realmName = this.getClass().getSimpleName(); //自定义realm名称\n\n    Map<String,String> userMap = new HashMap<>(16);\n\n    {\n//        userMap.put(\"zmt\",\"123456\");\n//        userMap.put(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\"); //数据库的密码是密文，不加盐\n        userMap.put(\"zmt\",\"640a19b710290a9ff4d72e70cdd21913\"); //md5加盐密码\n        userMap.put(\"xr\",\"654321\");\n\n        super.setName(realmName); //设置名称\n    }\n\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        String username = (String) principals.getPrimaryPrincipal();\n        //从数据库或者缓存中获取角色数据。\n        Set<String> roles = getRolesByUsername(username);\n        Set<String> permissions = getPermissionByUsername(username);\n\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        authorizationInfo.setStringPermissions(permissions); //设置权限\n        authorizationInfo.setRoles(roles); //设置角色\n\n        return authorizationInfo;\n    }\n\n    /**\n     * 模拟通过用户名获取权限。\n     * @param username\n     * @return\n     */\n    private Set<String> getPermissionByUsername(String username) {\n        Set<String> permissions = new HashSet<>();\n        permissions.add(\"admin:delete\");\n        permissions.add(\"user:select\");\n        permissions.add(\"user:update\");\n        return permissions;\n    }\n\n    /**\n     * 模拟获取角色。根据用户名获取角色。\n     * @param username\n     * @return\n     */\n    private Set<String> getRolesByUsername(String username) {\n        Set<String> roles = new HashSet<>();\n        roles.add(\"admin\");\n        roles.add(\"user\");\n        return roles;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        //从主体传过来认证信息,获得用户名\n        String username = (String) token.getPrincipal();\n        System.out.println(\"username:\" + username);\n\n        //通过用户名到数据库中获取凭证\n        String pwd = getPwdByUsername(username);\n        if (pwd == null) {\n            return null;\n        }\n\n        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,pwd,realmName);\n        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(\"aaa\")); //密码加盐后，这里要加上这句\n\n        return authenticationInfo;\n    }\n\n    /**\n     * 模拟获取数据库数据。根据用户名获取用户密码\n     * @param username 用户名。\n     * @return\n     */\n    private String getPwdByUsername(String username) {\n        return userMap.get(username);\n    }\n\n\n}\n\n```\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.crypto.hash.Md5Hash;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class CustomRealmTest {\n\n\n    @Test\n    public void  test1() {\n\n        CustomRealm customRealm = new CustomRealm();//自定义Realm\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(customRealm);\n\n        //设置散列加密\n        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();\n        matcher.setHashAlgorithmName(\"md5\");//设置加密方式\n        matcher.setHashIterations(1); //设置加密次数\n        customRealm.setCredentialsMatcher(matcher); //设置加密对象\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\");//用户,密码MD5加密。明文：123456\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n//        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //有update权限\n    }\n\n    @Test\n    public void genPwd() {\n//        Md5Hash md5Hash = new Md5Hash(\"123456\"); //md5加密密码，不加盐\n//        System.out.println(\"md5加密：\" + md5Hash);\n\n        Md5Hash md5Hash = new Md5Hash(\"e10adc3949ba59abbe56e057f20f883e\",\"aaa\"); //md5加密密码，加盐，密码更加难以识破，盐一般用随机数，这里写死\n        System.out.println(\"md5加盐加密：\" + md5Hash);\n    }\n}\n\n```\n\n### 六.shiro会话\n\n\n\n\n","slug":"shiro-start","published":1,"updated":"2019-06-16T14:38:33.965Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfn00b7g4va35p1pudn","content":"<p>Apache Shiro(<a href=\"http://shiro.apache.org\" target=\"_blank\" rel=\"noopener\">官网</a>)是个java的安全框架，轻便、api简单、功能全面的特性获得 许多开发者的青睐。其提供了认证、授权、加密以及会话管理等功能……</p>\n<h3 id=\"一-介绍\"><a href=\"#一-介绍\" class=\"headerlink\" title=\"一.介绍\"></a>一.介绍</h3><h4 id=\"1-功能特性\"><a href=\"#1-功能特性\" class=\"headerlink\" title=\"1.功能特性\"></a>1.功能特性</h4><p>Shiro 包含 10 个内容，如下图：</p>\n<img src=\"/2018/05/14/shiro-start/shiro-01.png\">\n<ul>\n<li>Authentication: 身份认证，拥有合法身份才能登录系统并使用。</li>\n<li>Authorization： 授权验证。即认证某个已经得到身份认证的用户是否拥有对某个功能或者某种资源的使用权限。</li>\n<li>Session Manager： 会话管理。用户登录后，没退出之前，为一次会话，所有的信息都在会话中。会话可以是javase环境，也可以是java web环境。</li>\n<li>Cryptography： 加密，保护数据的安全性。</li>\n<li>Web Support： web支持，把shiro容易的集成到web环境中。</li>\n<li>Caching： 缓存，用户登陆后，用户的信息、拥有的角色权限不必每次查，缓存起来。</li>\n<li>Concurrency： shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。</li>\n<li>Testing：提供测试支持。</li>\n<li>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。</li>\n<li>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>\n</ul>\n<h4 id=\"2-运行原理\"><a href=\"#2-运行原理\" class=\"headerlink\" title=\"2.运行原理\"></a>2.运行原理</h4><p>1.原理图1（应用程序角度）：<br><img src=\"/2018/05/14/shiro-start/shiro-02.png\"></p>\n<ul>\n<li>Subject：主体，代表当前“用户”，这里的用户指的不仅仅是登录用户，指的是任何与该系统交互的主体。所有的Subject都和SecurityManager绑定，与Subject的任何交互都委托给SecurityManager来处理。</li>\n<li>SecurityManager： 安全管理器，是shiro的核心功能。它负责所有的安全操作管理，管理这所有的Subject。类似于SpringMvc中的DispatcherServlet控制器。</li>\n<li>Realm： 域。所有的安全数据保存，获取都要通过Realm。SecurityManager和它交互，获取相关数据。Realm就类似于数据源DataSource。</li>\n</ul>\n<p>2.原理图2（内部架构）：<br><img src=\"/2018/05/14/shiro-start/shiro-03.png\"></p>\n<ul>\n<li>Subject：主体。</li>\n<li>SecurityManager：安全管理器。</li>\n<li>Authenticator： 认证器，负责对主体的身份认证。可以自定义，重新设定认证策略，即什么情况下才算认证通过。</li>\n<li>Authrizer： 授权器，或者访问控制器。决定主体是否有权限进行相应操作。</li>\n<li>Realm： 可以一个或者多个。可以是jdbc，redis，内存等实现。</li>\n<li>SessionManager： 会话管理器。</li>\n<li>SessionDAO： 数据访问对象，用于会话的CRUD。可以自定义，控制session存储的位置，关系数据库，redis等。另外，可以使用缓存，提高性能。</li>\n<li>CacheManager： 缓存管理器。</li>\n<li>Cryptography： 密码模块。提供了一些加解密算法。</li>\n</ul>\n<h4 id=\"3-过滤器\"><a href=\"#3-过滤器\" class=\"headerlink\" title=\"3.过滤器\"></a>3.过滤器</h4><p>应用到web系统中时，Shiro会默认创建一些过滤器对客户端请求进行过滤。常用过滤器有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">过滤器简称</th>\n<th style=\"text-align:left\">对应的 Java 类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">anon</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.AnonymousFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">authc</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">authcBasic</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">perms</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">port</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.PortFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rest</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">roles</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ssl</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.SslFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">user</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.UserFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">logout</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.LogoutFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">noSessionCreation</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.session.NoSessionCreationFilter</td>\n</tr>\n</tbody>\n</table>\n<p>说明：</p>\n<pre><code>/admins/**=anon               # 表示该 uri 可以匿名访问\n/admins/**=auth               # 表示该 uri 需要认证才能访问\n/admins/**=authcBasic         # 表示该 uri 需要 httpBasic 认证\n/admins/**=perms[user:add:*]  # 表示该 uri 需要认证用户拥有 user:add:* 权限才能访问\n/admins/**=port[8081]         # 表示该 uri 需要使用 8081 端口\n/admins/**=rest[user]         # 相当于 /admins/**=perms[user:method]，其中，method 表示  get、post、delete 等\n/admins/**=roles[admin]       # 表示该 uri 需要认证用户拥有 admin 角色才能访问\n/admins/**=ssl                # 表示该 uri 需要使用 https 协议\n/admins/**=user               # 表示该 uri 需要认证或通过记住我认证才能访问\n/logout=logout                # 表示注销,可以当作固定配置\n</code></pre><p> _注意_<br> anon，authcBasic，auchc，user 是认证过滤器。<br> perms，roles，ssl，rest，port 是授权过滤器。   </p>\n<h3 id=\"二-认证\"><a href=\"#二-认证\" class=\"headerlink\" title=\"二.认证\"></a>二.认证</h3><p>1.认证路程图：<br><img src=\"/2018/05/14/shiro-start/shiro-04.png\"> </p>\n<p>2.使用代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthenticationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleAccountRealm simpleAccoutRealm = <span class=\"keyword\">new</span> SimpleAccountRealm();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        simpleAccoutRealm.addAccount(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">testAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(simpleAccoutRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.logout();<span class=\"comment\">//退出登录</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//未认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-授权\"><a href=\"#三-授权\" class=\"headerlink\" title=\"三.授权\"></a>三.授权</h3><p>1.流程图：<br><img src=\"/2018/05/14/shiro-start/shiro-05.png\"></p>\n<p>2。代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthenticationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleAccountRealm simpleAccoutRealm = <span class=\"keyword\">new</span> SimpleAccountRealm();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");</span></span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">        simpleAccoutRealm.addAccount(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>,<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//添加角色</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">testAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(simpleAccoutRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user1\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.logout();//退出登录</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-Shiro自定义Realm\"><a href=\"#四-Shiro自定义Realm\" class=\"headerlink\" title=\"四.Shiro自定义Realm\"></a>四.Shiro自定义Realm</h3><h4 id=\"1-IniRealm讲解\"><a href=\"#1-IniRealm讲解\" class=\"headerlink\" title=\"1.IniRealm讲解\"></a>1.IniRealm讲解</h4><p>代码样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.text.IniRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IniRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IniRealm iniRealm = <span class=\"keyword\">new</span> IniRealm(<span class=\"string\">\"classpath:user.ini\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(iniRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:delete\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//报错，没有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编辑：user.ini</span><br><span class=\"line\"></span><br><span class=\"line\">[users]</span><br><span class=\"line\">zmt=123456,admin,user</span><br><span class=\"line\">[roles]</span><br><span class=\"line\">admin=user:delete,user:update</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-JdbcRealm讲解\"><a href=\"#2-JdbcRealm讲解\" class=\"headerlink\" title=\"2.JdbcRealm讲解\"></a>2.JdbcRealm讲解</h4><p>用户、角色、权限数据都在数据库里面。而不是在配置文件里面。<br>两种方式，一种是使用默认查询语句；另外一种是自己设计表，写sql语句，不必遵守默认的。   </p>\n<h5 id=\"2-1-默认方式\"><a href=\"#2-1-默认方式\" class=\"headerlink\" title=\"2.1.默认方式\"></a>2.1.默认方式</h5><ul>\n<li><p>首先，创建相关默认数据表：   </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Navicat MySQL Data Transfer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Source Server         : localhost</span></span><br><span class=\"line\"><span class=\"comment\">Source Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">Source Host           : localhost:3307</span></span><br><span class=\"line\"><span class=\"comment\">Source Database       : shiro-test</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Target Server Type    : MYSQL</span></span><br><span class=\"line\"><span class=\"comment\">Target Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">File Encoding         : 65001</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Date: 2018-10-15 17:09:45</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for roles_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`roles_permissions`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`roles_permissions`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`permission`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`role_name`</span> (<span class=\"string\">`role_name`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> <span class=\"string\">`roles_permissions_ibfk_1`</span> <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (<span class=\"string\">`role_name`</span>) <span class=\"keyword\">REFERENCES</span> <span class=\"string\">`user_roles`</span> (<span class=\"string\">`role_name`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of roles_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`roles_permissions`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'admin'</span>, <span class=\"string\">'user:select'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for user_roles</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`user_roles`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`user_roles`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`username`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`role_name`</span> (<span class=\"string\">`role_name`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> <span class=\"string\">`user_roles_ibfk_1`</span> <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (<span class=\"string\">`username`</span>) <span class=\"keyword\">REFERENCES</span> <span class=\"string\">`users`</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of user_roles</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`user_roles`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'zmt'</span>, <span class=\"string\">'admin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for users</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`users`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`users`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password_salt`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of users</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`users`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'zmt'</span>, <span class=\"string\">'123456'</span>, <span class=\"string\">'abcd'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3307/shiro-test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 查询默认的数据表做相关操作。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JdbcRealm jdbcRealm = <span class=\"keyword\">new</span> JdbcRealm();</span><br><span class=\"line\">        jdbcRealm.setDataSource(dataSource); <span class=\"comment\">//设置数据源</span></span><br><span class=\"line\">        jdbcRealm.setPermissionsLookupEnabled(<span class=\"keyword\">true</span>); <span class=\"comment\">//是否可以查看权限。默认为false。不打开，则无法查看权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(jdbcRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:update\"); //报错，没有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"2-2-自己设计表写查询语句\"><a href=\"#2-2-自己设计表写查询语句\" class=\"headerlink\" title=\"2.2.自己设计表写查询语句\"></a>2.2.自己设计表写查询语句</h5><ul>\n<li>创建数据表<br>不必遵循默认规范，表名、字段名都可以自定义。  </li>\n</ul>\n<p>脚本：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Navicat MySQL Data Transfer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Source Server         : localhost</span></span><br><span class=\"line\"><span class=\"comment\">Source Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">Source Host           : localhost:3307</span></span><br><span class=\"line\"><span class=\"comment\">Source Database       : shiro-test</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Target Server Type    : MYSQL</span></span><br><span class=\"line\"><span class=\"comment\">Target Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">File Encoding         : 65001</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Date: 2018-10-17 11:42:25</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_role_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_role_permissions`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_role_permissions`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`permission`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_role_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_role_permissions`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'caiwu'</span>, <span class=\"string\">'user:update'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_user</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_user`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_user`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`user_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`user_name`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_user</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_user`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'xr'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_user_role</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_user_role`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_user_role`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`test_user_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_user_role</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_user_role`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'xr'</span>, <span class=\"string\">'caiwu'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>代码样例：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3307/shiro-test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JdbcRealm jdbcRealm = <span class=\"keyword\">new</span> JdbcRealm();</span><br><span class=\"line\">        jdbcRealm.setDataSource(dataSource); <span class=\"comment\">//设置数据源</span></span><br><span class=\"line\">        jdbcRealm.setPermissionsLookupEnabled(<span class=\"keyword\">true</span>); <span class=\"comment\">//是否可以查看权限。默认为false。不打开，则无法查看权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建sql语句，使用自己的表、sql来验证</span></span><br><span class=\"line\">        String sql_auth = <span class=\"string\">\"SELECT `password` FROM test_user WHERE user_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setAuthenticationQuery(sql_auth);</span><br><span class=\"line\">        String sql_role = <span class=\"string\">\"SELECT role_name FROM test_user_role WHERE test_user_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setUserRolesQuery(sql_role);</span><br><span class=\"line\">        String sql_permisstion = <span class=\"string\">\"SELECT permission FROM test_role_permissions WHERE role_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setPermissionsQuery(sql_permisstion);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(jdbcRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"caiwu\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-自定义Realm\"><a href=\"#3-自定义Realm\" class=\"headerlink\" title=\"3.自定义Realm\"></a>3.自定义Realm</h4><ul>\n<li>创建类CustomRealm</li>\n</ul>\n<p>自定义Realm需要继承<code>AuthorizingRealm</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String realmName = <span class=\"keyword\">this</span>.getClass().getSimpleName(); <span class=\"comment\">//自定义realm名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; userMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"654321\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(realmName); <span class=\"comment\">//设置名称</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">        String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"comment\">//从数据库或者缓存中获取角色数据。</span></span><br><span class=\"line\">        Set&lt;String&gt; roles = getRolesByUsername(username);</span><br><span class=\"line\">        Set&lt;String&gt; permissions = getPermissionByUsername(username);</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(permissions); <span class=\"comment\">//设置权限</span></span><br><span class=\"line\">        authorizationInfo.setRoles(roles); <span class=\"comment\">//设置角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟通过用户名获取权限。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getPermissionByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"admin:delete\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:select\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:update\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> permissions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取角色。根据用户名获取角色。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getRolesByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"admin\"</span>);</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从主体传过来认证信息,获得用户名</span></span><br><span class=\"line\">        String username = (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过用户名到数据库中获取凭证</span></span><br><span class=\"line\">        String pwd = getPwdByUsername(username);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pwd == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,pwd,realmName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取数据库数据。根据用户名获取用户密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getPwdByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userMap.get(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CustomRealm customRealm = <span class=\"keyword\">new</span> CustomRealm();<span class=\"comment\">//自定义Realm</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(customRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRole(\"admin\"); //admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"五-Shiro加密\"><a href=\"#五-Shiro加密\" class=\"headerlink\" title=\"五.Shiro加密\"></a>五.Shiro加密</h3><p>前面介绍的密码都是明文的，实际的密码在数据库中是加密的。    </p>\n<p>下面在自定义的Realm中使用加密。  </p>\n<ul>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.util.ByteSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String realmName = <span class=\"keyword\">this</span>.getClass().getSimpleName(); <span class=\"comment\">//自定义realm名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; userMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"><span class=\"comment\">//        userMap.put(\"zmt\",\"123456\");</span></span><br><span class=\"line\"><span class=\"comment\">//        userMap.put(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\"); //数据库的密码是密文，不加盐</span></span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"640a19b710290a9ff4d72e70cdd21913\"</span>); <span class=\"comment\">//md5加盐密码</span></span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"654321\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(realmName); <span class=\"comment\">//设置名称</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">        String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"comment\">//从数据库或者缓存中获取角色数据。</span></span><br><span class=\"line\">        Set&lt;String&gt; roles = getRolesByUsername(username);</span><br><span class=\"line\">        Set&lt;String&gt; permissions = getPermissionByUsername(username);</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(permissions); <span class=\"comment\">//设置权限</span></span><br><span class=\"line\">        authorizationInfo.setRoles(roles); <span class=\"comment\">//设置角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟通过用户名获取权限。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getPermissionByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"admin:delete\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:select\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:update\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> permissions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取角色。根据用户名获取角色。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getRolesByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"admin\"</span>);</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从主体传过来认证信息,获得用户名</span></span><br><span class=\"line\">        String username = (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过用户名到数据库中获取凭证</span></span><br><span class=\"line\">        String pwd = getPwdByUsername(username);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pwd == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,pwd,realmName);</span><br><span class=\"line\">        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(<span class=\"string\">\"aaa\"</span>)); <span class=\"comment\">//密码加盐后，这里要加上这句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取数据库数据。根据用户名获取用户密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getPwdByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userMap.get(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.crypto.hash.Md5Hash;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CustomRealm customRealm = <span class=\"keyword\">new</span> CustomRealm();<span class=\"comment\">//自定义Realm</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(customRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//设置散列加密</span></span><br><span class=\"line\">        HashedCredentialsMatcher matcher = <span class=\"keyword\">new</span> HashedCredentialsMatcher();</span><br><span class=\"line\">        matcher.setHashAlgorithmName(<span class=\"string\">\"md5\"</span>);<span class=\"comment\">//设置加密方式</span></span><br><span class=\"line\">        matcher.setHashIterations(<span class=\"number\">1</span>); <span class=\"comment\">//设置加密次数</span></span><br><span class=\"line\">        customRealm.setCredentialsMatcher(matcher); <span class=\"comment\">//设置加密对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"e10adc3949ba59abbe56e057f20f883e\"</span>);<span class=\"comment\">//用户,密码MD5加密。明文：123456</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRole(\"admin\"); //admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">genPwd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        Md5Hash md5Hash = new Md5Hash(\"123456\"); //md5加密密码，不加盐</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"md5加密：\" + md5Hash);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Md5Hash md5Hash = <span class=\"keyword\">new</span> Md5Hash(<span class=\"string\">\"e10adc3949ba59abbe56e057f20f883e\"</span>,<span class=\"string\">\"aaa\"</span>); <span class=\"comment\">//md5加密密码，加盐，密码更加难以识破，盐一般用随机数，这里写死</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"md5加盐加密：\"</span> + md5Hash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"六-shiro会话\"><a href=\"#六-shiro会话\" class=\"headerlink\" title=\"六.shiro会话\"></a>六.shiro会话</h3>","site":{"data":{}},"excerpt":"","more":"<p>Apache Shiro(<a href=\"http://shiro.apache.org\" target=\"_blank\" rel=\"noopener\">官网</a>)是个java的安全框架，轻便、api简单、功能全面的特性获得 许多开发者的青睐。其提供了认证、授权、加密以及会话管理等功能……</p>\n<h3 id=\"一-介绍\"><a href=\"#一-介绍\" class=\"headerlink\" title=\"一.介绍\"></a>一.介绍</h3><h4 id=\"1-功能特性\"><a href=\"#1-功能特性\" class=\"headerlink\" title=\"1.功能特性\"></a>1.功能特性</h4><p>Shiro 包含 10 个内容，如下图：</p>\n<img src=\"/2018/05/14/shiro-start/shiro-01.png\">\n<ul>\n<li>Authentication: 身份认证，拥有合法身份才能登录系统并使用。</li>\n<li>Authorization： 授权验证。即认证某个已经得到身份认证的用户是否拥有对某个功能或者某种资源的使用权限。</li>\n<li>Session Manager： 会话管理。用户登录后，没退出之前，为一次会话，所有的信息都在会话中。会话可以是javase环境，也可以是java web环境。</li>\n<li>Cryptography： 加密，保护数据的安全性。</li>\n<li>Web Support： web支持，把shiro容易的集成到web环境中。</li>\n<li>Caching： 缓存，用户登陆后，用户的信息、拥有的角色权限不必每次查，缓存起来。</li>\n<li>Concurrency： shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。</li>\n<li>Testing：提供测试支持。</li>\n<li>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。</li>\n<li>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>\n</ul>\n<h4 id=\"2-运行原理\"><a href=\"#2-运行原理\" class=\"headerlink\" title=\"2.运行原理\"></a>2.运行原理</h4><p>1.原理图1（应用程序角度）：<br><img src=\"/2018/05/14/shiro-start/shiro-02.png\"></p>\n<ul>\n<li>Subject：主体，代表当前“用户”，这里的用户指的不仅仅是登录用户，指的是任何与该系统交互的主体。所有的Subject都和SecurityManager绑定，与Subject的任何交互都委托给SecurityManager来处理。</li>\n<li>SecurityManager： 安全管理器，是shiro的核心功能。它负责所有的安全操作管理，管理这所有的Subject。类似于SpringMvc中的DispatcherServlet控制器。</li>\n<li>Realm： 域。所有的安全数据保存，获取都要通过Realm。SecurityManager和它交互，获取相关数据。Realm就类似于数据源DataSource。</li>\n</ul>\n<p>2.原理图2（内部架构）：<br><img src=\"/2018/05/14/shiro-start/shiro-03.png\"></p>\n<ul>\n<li>Subject：主体。</li>\n<li>SecurityManager：安全管理器。</li>\n<li>Authenticator： 认证器，负责对主体的身份认证。可以自定义，重新设定认证策略，即什么情况下才算认证通过。</li>\n<li>Authrizer： 授权器，或者访问控制器。决定主体是否有权限进行相应操作。</li>\n<li>Realm： 可以一个或者多个。可以是jdbc，redis，内存等实现。</li>\n<li>SessionManager： 会话管理器。</li>\n<li>SessionDAO： 数据访问对象，用于会话的CRUD。可以自定义，控制session存储的位置，关系数据库，redis等。另外，可以使用缓存，提高性能。</li>\n<li>CacheManager： 缓存管理器。</li>\n<li>Cryptography： 密码模块。提供了一些加解密算法。</li>\n</ul>\n<h4 id=\"3-过滤器\"><a href=\"#3-过滤器\" class=\"headerlink\" title=\"3.过滤器\"></a>3.过滤器</h4><p>应用到web系统中时，Shiro会默认创建一些过滤器对客户端请求进行过滤。常用过滤器有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">过滤器简称</th>\n<th style=\"text-align:left\">对应的 Java 类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">anon</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.AnonymousFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">authc</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">authcBasic</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">perms</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">port</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.PortFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rest</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">roles</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ssl</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.SslFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">user</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.UserFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">logout</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.LogoutFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">noSessionCreation</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.session.NoSessionCreationFilter</td>\n</tr>\n</tbody>\n</table>\n<p>说明：</p>\n<pre><code>/admins/**=anon               # 表示该 uri 可以匿名访问\n/admins/**=auth               # 表示该 uri 需要认证才能访问\n/admins/**=authcBasic         # 表示该 uri 需要 httpBasic 认证\n/admins/**=perms[user:add:*]  # 表示该 uri 需要认证用户拥有 user:add:* 权限才能访问\n/admins/**=port[8081]         # 表示该 uri 需要使用 8081 端口\n/admins/**=rest[user]         # 相当于 /admins/**=perms[user:method]，其中，method 表示  get、post、delete 等\n/admins/**=roles[admin]       # 表示该 uri 需要认证用户拥有 admin 角色才能访问\n/admins/**=ssl                # 表示该 uri 需要使用 https 协议\n/admins/**=user               # 表示该 uri 需要认证或通过记住我认证才能访问\n/logout=logout                # 表示注销,可以当作固定配置\n</code></pre><p> _注意_<br> anon，authcBasic，auchc，user 是认证过滤器。<br> perms，roles，ssl，rest，port 是授权过滤器。   </p>\n<h3 id=\"二-认证\"><a href=\"#二-认证\" class=\"headerlink\" title=\"二.认证\"></a>二.认证</h3><p>1.认证路程图：<br><img src=\"/2018/05/14/shiro-start/shiro-04.png\"> </p>\n<p>2.使用代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthenticationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleAccountRealm simpleAccoutRealm = <span class=\"keyword\">new</span> SimpleAccountRealm();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        simpleAccoutRealm.addAccount(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">testAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(simpleAccoutRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.logout();<span class=\"comment\">//退出登录</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//未认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-授权\"><a href=\"#三-授权\" class=\"headerlink\" title=\"三.授权\"></a>三.授权</h3><p>1.流程图：<br><img src=\"/2018/05/14/shiro-start/shiro-05.png\"></p>\n<p>2。代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthenticationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleAccountRealm simpleAccoutRealm = <span class=\"keyword\">new</span> SimpleAccountRealm();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");</span></span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">        simpleAccoutRealm.addAccount(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>,<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//添加角色</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">testAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(simpleAccoutRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user1\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.logout();//退出登录</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-Shiro自定义Realm\"><a href=\"#四-Shiro自定义Realm\" class=\"headerlink\" title=\"四.Shiro自定义Realm\"></a>四.Shiro自定义Realm</h3><h4 id=\"1-IniRealm讲解\"><a href=\"#1-IniRealm讲解\" class=\"headerlink\" title=\"1.IniRealm讲解\"></a>1.IniRealm讲解</h4><p>代码样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.text.IniRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IniRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IniRealm iniRealm = <span class=\"keyword\">new</span> IniRealm(<span class=\"string\">\"classpath:user.ini\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(iniRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:delete\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//报错，没有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编辑：user.ini</span><br><span class=\"line\"></span><br><span class=\"line\">[users]</span><br><span class=\"line\">zmt=123456,admin,user</span><br><span class=\"line\">[roles]</span><br><span class=\"line\">admin=user:delete,user:update</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-JdbcRealm讲解\"><a href=\"#2-JdbcRealm讲解\" class=\"headerlink\" title=\"2.JdbcRealm讲解\"></a>2.JdbcRealm讲解</h4><p>用户、角色、权限数据都在数据库里面。而不是在配置文件里面。<br>两种方式，一种是使用默认查询语句；另外一种是自己设计表，写sql语句，不必遵守默认的。   </p>\n<h5 id=\"2-1-默认方式\"><a href=\"#2-1-默认方式\" class=\"headerlink\" title=\"2.1.默认方式\"></a>2.1.默认方式</h5><ul>\n<li><p>首先，创建相关默认数据表：   </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Navicat MySQL Data Transfer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Source Server         : localhost</span></span><br><span class=\"line\"><span class=\"comment\">Source Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">Source Host           : localhost:3307</span></span><br><span class=\"line\"><span class=\"comment\">Source Database       : shiro-test</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Target Server Type    : MYSQL</span></span><br><span class=\"line\"><span class=\"comment\">Target Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">File Encoding         : 65001</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Date: 2018-10-15 17:09:45</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for roles_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`roles_permissions`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`roles_permissions`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`permission`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`role_name`</span> (<span class=\"string\">`role_name`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> <span class=\"string\">`roles_permissions_ibfk_1`</span> <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (<span class=\"string\">`role_name`</span>) <span class=\"keyword\">REFERENCES</span> <span class=\"string\">`user_roles`</span> (<span class=\"string\">`role_name`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of roles_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`roles_permissions`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'admin'</span>, <span class=\"string\">'user:select'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for user_roles</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`user_roles`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`user_roles`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`username`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`role_name`</span> (<span class=\"string\">`role_name`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> <span class=\"string\">`user_roles_ibfk_1`</span> <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (<span class=\"string\">`username`</span>) <span class=\"keyword\">REFERENCES</span> <span class=\"string\">`users`</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of user_roles</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`user_roles`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'zmt'</span>, <span class=\"string\">'admin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for users</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`users`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`users`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password_salt`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of users</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`users`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'zmt'</span>, <span class=\"string\">'123456'</span>, <span class=\"string\">'abcd'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3307/shiro-test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 查询默认的数据表做相关操作。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JdbcRealm jdbcRealm = <span class=\"keyword\">new</span> JdbcRealm();</span><br><span class=\"line\">        jdbcRealm.setDataSource(dataSource); <span class=\"comment\">//设置数据源</span></span><br><span class=\"line\">        jdbcRealm.setPermissionsLookupEnabled(<span class=\"keyword\">true</span>); <span class=\"comment\">//是否可以查看权限。默认为false。不打开，则无法查看权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(jdbcRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:update\"); //报错，没有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"2-2-自己设计表写查询语句\"><a href=\"#2-2-自己设计表写查询语句\" class=\"headerlink\" title=\"2.2.自己设计表写查询语句\"></a>2.2.自己设计表写查询语句</h5><ul>\n<li>创建数据表<br>不必遵循默认规范，表名、字段名都可以自定义。  </li>\n</ul>\n<p>脚本：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Navicat MySQL Data Transfer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Source Server         : localhost</span></span><br><span class=\"line\"><span class=\"comment\">Source Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">Source Host           : localhost:3307</span></span><br><span class=\"line\"><span class=\"comment\">Source Database       : shiro-test</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Target Server Type    : MYSQL</span></span><br><span class=\"line\"><span class=\"comment\">Target Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">File Encoding         : 65001</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Date: 2018-10-17 11:42:25</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_role_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_role_permissions`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_role_permissions`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`permission`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_role_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_role_permissions`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'caiwu'</span>, <span class=\"string\">'user:update'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_user</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_user`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_user`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`user_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`user_name`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_user</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_user`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'xr'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_user_role</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_user_role`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_user_role`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`test_user_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_user_role</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_user_role`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'xr'</span>, <span class=\"string\">'caiwu'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>代码样例：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3307/shiro-test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JdbcRealm jdbcRealm = <span class=\"keyword\">new</span> JdbcRealm();</span><br><span class=\"line\">        jdbcRealm.setDataSource(dataSource); <span class=\"comment\">//设置数据源</span></span><br><span class=\"line\">        jdbcRealm.setPermissionsLookupEnabled(<span class=\"keyword\">true</span>); <span class=\"comment\">//是否可以查看权限。默认为false。不打开，则无法查看权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建sql语句，使用自己的表、sql来验证</span></span><br><span class=\"line\">        String sql_auth = <span class=\"string\">\"SELECT `password` FROM test_user WHERE user_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setAuthenticationQuery(sql_auth);</span><br><span class=\"line\">        String sql_role = <span class=\"string\">\"SELECT role_name FROM test_user_role WHERE test_user_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setUserRolesQuery(sql_role);</span><br><span class=\"line\">        String sql_permisstion = <span class=\"string\">\"SELECT permission FROM test_role_permissions WHERE role_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setPermissionsQuery(sql_permisstion);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(jdbcRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"caiwu\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-自定义Realm\"><a href=\"#3-自定义Realm\" class=\"headerlink\" title=\"3.自定义Realm\"></a>3.自定义Realm</h4><ul>\n<li>创建类CustomRealm</li>\n</ul>\n<p>自定义Realm需要继承<code>AuthorizingRealm</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String realmName = <span class=\"keyword\">this</span>.getClass().getSimpleName(); <span class=\"comment\">//自定义realm名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; userMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"654321\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(realmName); <span class=\"comment\">//设置名称</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">        String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"comment\">//从数据库或者缓存中获取角色数据。</span></span><br><span class=\"line\">        Set&lt;String&gt; roles = getRolesByUsername(username);</span><br><span class=\"line\">        Set&lt;String&gt; permissions = getPermissionByUsername(username);</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(permissions); <span class=\"comment\">//设置权限</span></span><br><span class=\"line\">        authorizationInfo.setRoles(roles); <span class=\"comment\">//设置角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟通过用户名获取权限。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getPermissionByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"admin:delete\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:select\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:update\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> permissions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取角色。根据用户名获取角色。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getRolesByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"admin\"</span>);</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从主体传过来认证信息,获得用户名</span></span><br><span class=\"line\">        String username = (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过用户名到数据库中获取凭证</span></span><br><span class=\"line\">        String pwd = getPwdByUsername(username);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pwd == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,pwd,realmName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取数据库数据。根据用户名获取用户密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getPwdByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userMap.get(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CustomRealm customRealm = <span class=\"keyword\">new</span> CustomRealm();<span class=\"comment\">//自定义Realm</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(customRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRole(\"admin\"); //admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"五-Shiro加密\"><a href=\"#五-Shiro加密\" class=\"headerlink\" title=\"五.Shiro加密\"></a>五.Shiro加密</h3><p>前面介绍的密码都是明文的，实际的密码在数据库中是加密的。    </p>\n<p>下面在自定义的Realm中使用加密。  </p>\n<ul>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.util.ByteSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String realmName = <span class=\"keyword\">this</span>.getClass().getSimpleName(); <span class=\"comment\">//自定义realm名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; userMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"><span class=\"comment\">//        userMap.put(\"zmt\",\"123456\");</span></span><br><span class=\"line\"><span class=\"comment\">//        userMap.put(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\"); //数据库的密码是密文，不加盐</span></span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"640a19b710290a9ff4d72e70cdd21913\"</span>); <span class=\"comment\">//md5加盐密码</span></span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"654321\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(realmName); <span class=\"comment\">//设置名称</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">        String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"comment\">//从数据库或者缓存中获取角色数据。</span></span><br><span class=\"line\">        Set&lt;String&gt; roles = getRolesByUsername(username);</span><br><span class=\"line\">        Set&lt;String&gt; permissions = getPermissionByUsername(username);</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(permissions); <span class=\"comment\">//设置权限</span></span><br><span class=\"line\">        authorizationInfo.setRoles(roles); <span class=\"comment\">//设置角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟通过用户名获取权限。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getPermissionByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"admin:delete\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:select\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:update\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> permissions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取角色。根据用户名获取角色。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getRolesByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"admin\"</span>);</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从主体传过来认证信息,获得用户名</span></span><br><span class=\"line\">        String username = (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过用户名到数据库中获取凭证</span></span><br><span class=\"line\">        String pwd = getPwdByUsername(username);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pwd == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,pwd,realmName);</span><br><span class=\"line\">        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(<span class=\"string\">\"aaa\"</span>)); <span class=\"comment\">//密码加盐后，这里要加上这句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取数据库数据。根据用户名获取用户密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getPwdByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userMap.get(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.crypto.hash.Md5Hash;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CustomRealm customRealm = <span class=\"keyword\">new</span> CustomRealm();<span class=\"comment\">//自定义Realm</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(customRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//设置散列加密</span></span><br><span class=\"line\">        HashedCredentialsMatcher matcher = <span class=\"keyword\">new</span> HashedCredentialsMatcher();</span><br><span class=\"line\">        matcher.setHashAlgorithmName(<span class=\"string\">\"md5\"</span>);<span class=\"comment\">//设置加密方式</span></span><br><span class=\"line\">        matcher.setHashIterations(<span class=\"number\">1</span>); <span class=\"comment\">//设置加密次数</span></span><br><span class=\"line\">        customRealm.setCredentialsMatcher(matcher); <span class=\"comment\">//设置加密对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"e10adc3949ba59abbe56e057f20f883e\"</span>);<span class=\"comment\">//用户,密码MD5加密。明文：123456</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRole(\"admin\"); //admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">genPwd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        Md5Hash md5Hash = new Md5Hash(\"123456\"); //md5加密密码，不加盐</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"md5加密：\" + md5Hash);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Md5Hash md5Hash = <span class=\"keyword\">new</span> Md5Hash(<span class=\"string\">\"e10adc3949ba59abbe56e057f20f883e\"</span>,<span class=\"string\">\"aaa\"</span>); <span class=\"comment\">//md5加密密码，加盐，密码更加难以识破，盐一般用随机数，这里写死</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"md5加盐加密：\"</span> + md5Hash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"六-shiro会话\"><a href=\"#六-shiro会话\" class=\"headerlink\" title=\"六.shiro会话\"></a>六.shiro会话</h3>"},{"title":"spring-boot异步调用","date":"2017-11-10T08:22:18.000Z","_content":"\n在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。\n在spring-boot中，通过简单的注解 `@Async` 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：\n\n参考：\n- http://blog.csdn.net/blueheart20/article/details/44648667\n- http://blog.csdn.net/liuchuanhong1/article/details/64132520\n\n## 1. 启用异步操作功能\n很简单，只需要在主类中添加注解`@EnableAsync` 即可。\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.scheduling.annotation.EnableAsync;\n    \n    @EnableAsync\n    @SpringBootApplication\n    public class SpringBootAsyncApplication {\n    \n    \tpublic static void main(String[] args) {\n    \t\tSpringApplication.run(SpringBootAsyncApplication.class, args);\n    \t}\n    }\n\n## 2. 定义处理类，并添加方法\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.scheduling.annotation.Async;\n    import org.springframework.scheduling.annotation.AsyncResult;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.Random;\n    import java.util.concurrent.Future;\n    \n    @Component\n    public class Task {\n    \n        public static Random random =new Random();\n    \n        @Async\n        public void webTest() throws Exception {\n            System.out.println(\"开始测试异步\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成测试异步，耗时：\" + (end - start) + \"毫秒\");\n        }\n    \n        @Async\n        public Future<String> doTaskOne() throws Exception {\n            System.out.println(\"开始做任务一\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务一，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务一完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskTwo() throws Exception {\n            System.out.println(\"开始做任务二\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务二，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务二完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskThree() throws Exception {\n            System.out.println(\"开始做任务三\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务三，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务三完成\");\n        }\n    }\n\n只需要在方法上添加注解`@Async`。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。\n\n## 3. 测试\n\n    package com.ymu.demo.async;\n    \n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import java.util.concurrent.Future;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class SpringBootAsyncApplicationTests {\n    \n        @Autowired\n        private Task task;\n    \n        @Test\n        public void contextLoads() {\n    \n            System.out.println(\"===============load context\");\n        }\n    \n        @Test\n        public void test() throws Exception {\n    \n            long start = System.currentTimeMillis();\n    \n            Future<String> task1 = task.doTaskOne();\n            Future<String> task2 = task.doTaskTwo();\n            Future<String> task3 = task.doTaskThree();\n    \n            while(true) {\n                if(task1.isDone() && task2.isDone() && task3.isDone()) {\n                    // 三个任务都调用完成，退出循环等待\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n    \n            long end = System.currentTimeMillis();\n    \n            System.out.println(\"任务全部完成，总耗时：\" + (end - start) + \"毫秒\");\n    \n        }\n    \n    }\n\n---\n    package com.ymu.demo.async;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    public class IndexController {\n    \n        @Autowired\n        Task task;\n    \n        @GetMapping(\"/index\")\n        public String index() throws Exception {\n            task.webTest();\n            return \"index\";\n        }\n    }\n    \n## 4. 基于@Async调用中的异常处理机制\n   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：\n   \n1. 自定义实现AsyncTaskExecutor的任务执行器。\n2. 配置由自定义的TaskExecutor替代内置的任务执行器。      \n\n自定义的TaskExecutor\n\n    \n","source":"_posts/spring-boot-async.md","raw":"---\ntitle: spring-boot异步调用\ndate: 2017-11-10 16:22:18\ncategories: spring-boot\ntags: spring-boot-async\n---\n\n在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。\n在spring-boot中，通过简单的注解 `@Async` 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：\n\n参考：\n- http://blog.csdn.net/blueheart20/article/details/44648667\n- http://blog.csdn.net/liuchuanhong1/article/details/64132520\n\n## 1. 启用异步操作功能\n很简单，只需要在主类中添加注解`@EnableAsync` 即可。\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.scheduling.annotation.EnableAsync;\n    \n    @EnableAsync\n    @SpringBootApplication\n    public class SpringBootAsyncApplication {\n    \n    \tpublic static void main(String[] args) {\n    \t\tSpringApplication.run(SpringBootAsyncApplication.class, args);\n    \t}\n    }\n\n## 2. 定义处理类，并添加方法\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.scheduling.annotation.Async;\n    import org.springframework.scheduling.annotation.AsyncResult;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.Random;\n    import java.util.concurrent.Future;\n    \n    @Component\n    public class Task {\n    \n        public static Random random =new Random();\n    \n        @Async\n        public void webTest() throws Exception {\n            System.out.println(\"开始测试异步\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成测试异步，耗时：\" + (end - start) + \"毫秒\");\n        }\n    \n        @Async\n        public Future<String> doTaskOne() throws Exception {\n            System.out.println(\"开始做任务一\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务一，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务一完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskTwo() throws Exception {\n            System.out.println(\"开始做任务二\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务二，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务二完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskThree() throws Exception {\n            System.out.println(\"开始做任务三\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务三，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务三完成\");\n        }\n    }\n\n只需要在方法上添加注解`@Async`。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。\n\n## 3. 测试\n\n    package com.ymu.demo.async;\n    \n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import java.util.concurrent.Future;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class SpringBootAsyncApplicationTests {\n    \n        @Autowired\n        private Task task;\n    \n        @Test\n        public void contextLoads() {\n    \n            System.out.println(\"===============load context\");\n        }\n    \n        @Test\n        public void test() throws Exception {\n    \n            long start = System.currentTimeMillis();\n    \n            Future<String> task1 = task.doTaskOne();\n            Future<String> task2 = task.doTaskTwo();\n            Future<String> task3 = task.doTaskThree();\n    \n            while(true) {\n                if(task1.isDone() && task2.isDone() && task3.isDone()) {\n                    // 三个任务都调用完成，退出循环等待\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n    \n            long end = System.currentTimeMillis();\n    \n            System.out.println(\"任务全部完成，总耗时：\" + (end - start) + \"毫秒\");\n    \n        }\n    \n    }\n\n---\n    package com.ymu.demo.async;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    public class IndexController {\n    \n        @Autowired\n        Task task;\n    \n        @GetMapping(\"/index\")\n        public String index() throws Exception {\n            task.webTest();\n            return \"index\";\n        }\n    }\n    \n## 4. 基于@Async调用中的异常处理机制\n   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：\n   \n1. 自定义实现AsyncTaskExecutor的任务执行器。\n2. 配置由自定义的TaskExecutor替代内置的任务执行器。      \n\n自定义的TaskExecutor\n\n    \n","slug":"spring-boot-async","published":1,"updated":"2019-06-16T14:38:33.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfo00b9g4vawmu6cjxd","content":"<p>在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。<br>在spring-boot中，通过简单的注解 <code>@Async</code> 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/blueheart20/article/details/44648667\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/blueheart20/article/details/44648667</a></li>\n<li><a href=\"http://blog.csdn.net/liuchuanhong1/article/details/64132520\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/liuchuanhong1/article/details/64132520</a></li>\n</ul>\n<h2 id=\"1-启用异步操作功能\"><a href=\"#1-启用异步操作功能\" class=\"headerlink\" title=\"1. 启用异步操作功能\"></a>1. 启用异步操作功能</h2><p>很简单，只需要在主类中添加注解<code>@EnableAsync</code> 即可。</p>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n@EnableAsync\n@SpringBootApplication\npublic class SpringBootAsyncApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAsyncApplication.class, args);\n    }\n}\n</code></pre><h2 id=\"2-定义处理类，并添加方法\"><a href=\"#2-定义处理类，并添加方法\" class=\"headerlink\" title=\"2. 定义处理类，并添加方法\"></a>2. 定义处理类，并添加方法</h2><pre><code>package com.ymu.demo.async;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.AsyncResult;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Random;\nimport java.util.concurrent.Future;\n\n@Component\npublic class Task {\n\n    public static Random random =new Random();\n\n    @Async\n    public void webTest() throws Exception {\n        System.out.println(&quot;开始测试异步&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成测试异步，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskOne() throws Exception {\n        System.out.println(&quot;开始做任务一&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务一完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskTwo() throws Exception {\n        System.out.println(&quot;开始做任务二&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务二完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskThree() throws Exception {\n        System.out.println(&quot;开始做任务三&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务三完成&quot;);\n    }\n}\n</code></pre><p>只需要在方法上添加注解<code>@Async</code>。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。</p>\n<h2 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h2><pre><code>package com.ymu.demo.async;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.concurrent.Future;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootAsyncApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void contextLoads() {\n\n        System.out.println(&quot;===============load context&quot;);\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        Future&lt;String&gt; task1 = task.doTaskOne();\n        Future&lt;String&gt; task2 = task.doTaskTwo();\n        Future&lt;String&gt; task3 = task.doTaskThree();\n\n        while(true) {\n            if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) {\n                // 三个任务都调用完成，退出循环等待\n                break;\n            }\n            Thread.sleep(1000);\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n\n    }\n\n}\n</code></pre><hr>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class IndexController {\n\n    @Autowired\n    Task task;\n\n    @GetMapping(&quot;/index&quot;)\n    public String index() throws Exception {\n        task.webTest();\n        return &quot;index&quot;;\n    }\n}\n</code></pre><h2 id=\"4-基于-Async调用中的异常处理机制\"><a href=\"#4-基于-Async调用中的异常处理机制\" class=\"headerlink\" title=\"4. 基于@Async调用中的异常处理机制\"></a>4. 基于@Async调用中的异常处理机制</h2><p>   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：</p>\n<ol>\n<li>自定义实现AsyncTaskExecutor的任务执行器。</li>\n<li>配置由自定义的TaskExecutor替代内置的任务执行器。      </li>\n</ol>\n<p>自定义的TaskExecutor</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。<br>在spring-boot中，通过简单的注解 <code>@Async</code> 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/blueheart20/article/details/44648667\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/blueheart20/article/details/44648667</a></li>\n<li><a href=\"http://blog.csdn.net/liuchuanhong1/article/details/64132520\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/liuchuanhong1/article/details/64132520</a></li>\n</ul>\n<h2 id=\"1-启用异步操作功能\"><a href=\"#1-启用异步操作功能\" class=\"headerlink\" title=\"1. 启用异步操作功能\"></a>1. 启用异步操作功能</h2><p>很简单，只需要在主类中添加注解<code>@EnableAsync</code> 即可。</p>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n@EnableAsync\n@SpringBootApplication\npublic class SpringBootAsyncApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAsyncApplication.class, args);\n    }\n}\n</code></pre><h2 id=\"2-定义处理类，并添加方法\"><a href=\"#2-定义处理类，并添加方法\" class=\"headerlink\" title=\"2. 定义处理类，并添加方法\"></a>2. 定义处理类，并添加方法</h2><pre><code>package com.ymu.demo.async;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.AsyncResult;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Random;\nimport java.util.concurrent.Future;\n\n@Component\npublic class Task {\n\n    public static Random random =new Random();\n\n    @Async\n    public void webTest() throws Exception {\n        System.out.println(&quot;开始测试异步&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成测试异步，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskOne() throws Exception {\n        System.out.println(&quot;开始做任务一&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务一完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskTwo() throws Exception {\n        System.out.println(&quot;开始做任务二&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务二完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskThree() throws Exception {\n        System.out.println(&quot;开始做任务三&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务三完成&quot;);\n    }\n}\n</code></pre><p>只需要在方法上添加注解<code>@Async</code>。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。</p>\n<h2 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h2><pre><code>package com.ymu.demo.async;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.concurrent.Future;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootAsyncApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void contextLoads() {\n\n        System.out.println(&quot;===============load context&quot;);\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        Future&lt;String&gt; task1 = task.doTaskOne();\n        Future&lt;String&gt; task2 = task.doTaskTwo();\n        Future&lt;String&gt; task3 = task.doTaskThree();\n\n        while(true) {\n            if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) {\n                // 三个任务都调用完成，退出循环等待\n                break;\n            }\n            Thread.sleep(1000);\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n\n    }\n\n}\n</code></pre><hr>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class IndexController {\n\n    @Autowired\n    Task task;\n\n    @GetMapping(&quot;/index&quot;)\n    public String index() throws Exception {\n        task.webTest();\n        return &quot;index&quot;;\n    }\n}\n</code></pre><h2 id=\"4-基于-Async调用中的异常处理机制\"><a href=\"#4-基于-Async调用中的异常处理机制\" class=\"headerlink\" title=\"4. 基于@Async调用中的异常处理机制\"></a>4. 基于@Async调用中的异常处理机制</h2><p>   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：</p>\n<ol>\n<li>自定义实现AsyncTaskExecutor的任务执行器。</li>\n<li>配置由自定义的TaskExecutor替代内置的任务执行器。      </li>\n</ol>\n<p>自定义的TaskExecutor</p>\n"},{"title":"springboot跨域请求解决","date":"2017-11-15T01:43:12.000Z","_content":"先推荐三篇文章\n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[同源策略和跨域访问](http://blog.csdn.net/shimiso/article/details/21830313)\n[详解js跨域问题](https://segmentfault.com/a/1190000000718840)\n[springboot前后端分离跨域](https://my.oschina.net/u/3677020/blog/1573162)\n\n## 什么是跨域\n\n要想了解跨域，就先要知道什么是同源策略。\n\n同源策略，它是由Netscape提出的一个著名的安全策略。\n\n同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\n\n域：协议+地址(域名或IP)+端口\n\n## 为什么要有同源策略\n\n可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。\n\n## 为什么要有跨域\n\n最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。\n\n## 如何解决跨域\n\n*JSONP*\n\n只能实现GET请求，但是被一些老浏览器支持。\n\n*代理*\n\n在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。\n\n*CORS*\n\n2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。\n\n出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 http://example.com 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 http://hello-world.example，就需要使用该标准。http://hello-world.example 在HTTP的响应头部中定义 Access-Control-Allow-Origin: http://example.org，通知浏览器允许 http://example.org 跨源从 http://hello-world.example上获取资源。\n\n## springboot跨域\n\n### 设置全局跨域\n- 方法一：\n    \n        @Configuration\n        public class WebConfig extends WebMvcConfigurationSupport {\n            /**\n             * 全局跨域设置\n             *\n             * @param registry\n             */\n            @Override\n            protected void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/**\")\n                        //放行哪些原始域\n                        .allowedOrigins(\"*\")\n                        //是否发送Cookie信息\n                        .allowCredentials(true)\n                        //放行哪些原始域(请求方式)\n                        .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                        //放行哪些原始域(头部信息)\n                        .allowedHeaders(\"*\");\n        //                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n        //                .exposedHeaders(\"Header1\", \"Header2\");\n            }\n        \n        }\n\n### 局部跨域\n","source":"_posts/spring-boot-cors.md","raw":"---\ntitle: springboot跨域请求解决\ndate: 2017-11-15 09:43:12\ncategories: spring-boot\ntags: spring-cors\n---\n先推荐三篇文章\n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[同源策略和跨域访问](http://blog.csdn.net/shimiso/article/details/21830313)\n[详解js跨域问题](https://segmentfault.com/a/1190000000718840)\n[springboot前后端分离跨域](https://my.oschina.net/u/3677020/blog/1573162)\n\n## 什么是跨域\n\n要想了解跨域，就先要知道什么是同源策略。\n\n同源策略，它是由Netscape提出的一个著名的安全策略。\n\n同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\n\n域：协议+地址(域名或IP)+端口\n\n## 为什么要有同源策略\n\n可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。\n\n## 为什么要有跨域\n\n最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。\n\n## 如何解决跨域\n\n*JSONP*\n\n只能实现GET请求，但是被一些老浏览器支持。\n\n*代理*\n\n在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。\n\n*CORS*\n\n2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。\n\n出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 http://example.com 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 http://hello-world.example，就需要使用该标准。http://hello-world.example 在HTTP的响应头部中定义 Access-Control-Allow-Origin: http://example.org，通知浏览器允许 http://example.org 跨源从 http://hello-world.example上获取资源。\n\n## springboot跨域\n\n### 设置全局跨域\n- 方法一：\n    \n        @Configuration\n        public class WebConfig extends WebMvcConfigurationSupport {\n            /**\n             * 全局跨域设置\n             *\n             * @param registry\n             */\n            @Override\n            protected void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/**\")\n                        //放行哪些原始域\n                        .allowedOrigins(\"*\")\n                        //是否发送Cookie信息\n                        .allowCredentials(true)\n                        //放行哪些原始域(请求方式)\n                        .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                        //放行哪些原始域(头部信息)\n                        .allowedHeaders(\"*\");\n        //                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n        //                .exposedHeaders(\"Header1\", \"Header2\");\n            }\n        \n        }\n\n### 局部跨域\n","slug":"spring-boot-cors","published":1,"updated":"2019-06-16T14:38:33.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfp00bdg4va4tqfp15r","content":"<p>先推荐三篇文章<br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a><br><a href=\"http://blog.csdn.net/shimiso/article/details/21830313\" target=\"_blank\" rel=\"noopener\">同源策略和跨域访问</a><br><a href=\"https://segmentfault.com/a/1190000000718840\" target=\"_blank\" rel=\"noopener\">详解js跨域问题</a><br><a href=\"https://my.oschina.net/u/3677020/blog/1573162\" target=\"_blank\" rel=\"noopener\">springboot前后端分离跨域</a></p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>要想了解跨域，就先要知道什么是同源策略。</p>\n<p>同源策略，它是由Netscape提出的一个著名的安全策略。</p>\n<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>\n<p>域：协议+地址(域名或IP)+端口</p>\n<h2 id=\"为什么要有同源策略\"><a href=\"#为什么要有同源策略\" class=\"headerlink\" title=\"为什么要有同源策略\"></a>为什么要有同源策略</h2><p>可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。</p>\n<h2 id=\"为什么要有跨域\"><a href=\"#为什么要有跨域\" class=\"headerlink\" title=\"为什么要有跨域\"></a>为什么要有跨域</h2><p>最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。</p>\n<h2 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h2><p><em>JSONP</em></p>\n<p>只能实现GET请求，但是被一些老浏览器支持。</p>\n<p><em>代理</em></p>\n<p>在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。</p>\n<p><em>CORS</em></p>\n<p>2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。</p>\n<p>出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 <a href=\"http://hello-world.example，就需要使用该标准。http://hello-world.example\" target=\"_blank\" rel=\"noopener\">http://hello-world.example，就需要使用该标准。http://hello-world.example</a> 在HTTP的响应头部中定义 Access-Control-Allow-Origin: <a href=\"http://example.org，通知浏览器允许\" target=\"_blank\" rel=\"noopener\">http://example.org，通知浏览器允许</a> <a href=\"http://example.org\" target=\"_blank\" rel=\"noopener\">http://example.org</a> 跨源从 <a href=\"http://hello-world.example上获取资源。\" target=\"_blank\" rel=\"noopener\">http://hello-world.example上获取资源。</a></p>\n<h2 id=\"springboot跨域\"><a href=\"#springboot跨域\" class=\"headerlink\" title=\"springboot跨域\"></a>springboot跨域</h2><h3 id=\"设置全局跨域\"><a href=\"#设置全局跨域\" class=\"headerlink\" title=\"设置全局跨域\"></a>设置全局跨域</h3><ul>\n<li><p>方法一：</p>\n<pre><code>@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n    /**\n     * 全局跨域设置\n     *\n     * @param registry\n     */\n    @Override\n    protected void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(&quot;/**&quot;)\n                //放行哪些原始域\n                .allowedOrigins(&quot;*&quot;)\n                //是否发送Cookie信息\n                .allowCredentials(true)\n                //放行哪些原始域(请求方式)\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)\n                //放行哪些原始域(头部信息)\n                .allowedHeaders(&quot;*&quot;);\n//                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n//                .exposedHeaders(&quot;Header1&quot;, &quot;Header2&quot;);\n    }\n\n}\n</code></pre></li>\n</ul>\n<h3 id=\"局部跨域\"><a href=\"#局部跨域\" class=\"headerlink\" title=\"局部跨域\"></a>局部跨域</h3>","site":{"data":{}},"excerpt":"","more":"<p>先推荐三篇文章<br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a><br><a href=\"http://blog.csdn.net/shimiso/article/details/21830313\" target=\"_blank\" rel=\"noopener\">同源策略和跨域访问</a><br><a href=\"https://segmentfault.com/a/1190000000718840\" target=\"_blank\" rel=\"noopener\">详解js跨域问题</a><br><a href=\"https://my.oschina.net/u/3677020/blog/1573162\" target=\"_blank\" rel=\"noopener\">springboot前后端分离跨域</a></p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>要想了解跨域，就先要知道什么是同源策略。</p>\n<p>同源策略，它是由Netscape提出的一个著名的安全策略。</p>\n<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>\n<p>域：协议+地址(域名或IP)+端口</p>\n<h2 id=\"为什么要有同源策略\"><a href=\"#为什么要有同源策略\" class=\"headerlink\" title=\"为什么要有同源策略\"></a>为什么要有同源策略</h2><p>可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。</p>\n<h2 id=\"为什么要有跨域\"><a href=\"#为什么要有跨域\" class=\"headerlink\" title=\"为什么要有跨域\"></a>为什么要有跨域</h2><p>最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。</p>\n<h2 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h2><p><em>JSONP</em></p>\n<p>只能实现GET请求，但是被一些老浏览器支持。</p>\n<p><em>代理</em></p>\n<p>在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。</p>\n<p><em>CORS</em></p>\n<p>2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。</p>\n<p>出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 <a href=\"http://hello-world.example，就需要使用该标准。http://hello-world.example\" target=\"_blank\" rel=\"noopener\">http://hello-world.example，就需要使用该标准。http://hello-world.example</a> 在HTTP的响应头部中定义 Access-Control-Allow-Origin: <a href=\"http://example.org，通知浏览器允许\" target=\"_blank\" rel=\"noopener\">http://example.org，通知浏览器允许</a> <a href=\"http://example.org\" target=\"_blank\" rel=\"noopener\">http://example.org</a> 跨源从 <a href=\"http://hello-world.example上获取资源。\" target=\"_blank\" rel=\"noopener\">http://hello-world.example上获取资源。</a></p>\n<h2 id=\"springboot跨域\"><a href=\"#springboot跨域\" class=\"headerlink\" title=\"springboot跨域\"></a>springboot跨域</h2><h3 id=\"设置全局跨域\"><a href=\"#设置全局跨域\" class=\"headerlink\" title=\"设置全局跨域\"></a>设置全局跨域</h3><ul>\n<li><p>方法一：</p>\n<pre><code>@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n    /**\n     * 全局跨域设置\n     *\n     * @param registry\n     */\n    @Override\n    protected void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(&quot;/**&quot;)\n                //放行哪些原始域\n                .allowedOrigins(&quot;*&quot;)\n                //是否发送Cookie信息\n                .allowCredentials(true)\n                //放行哪些原始域(请求方式)\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)\n                //放行哪些原始域(头部信息)\n                .allowedHeaders(&quot;*&quot;);\n//                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n//                .exposedHeaders(&quot;Header1&quot;, &quot;Header2&quot;);\n    }\n\n}\n</code></pre></li>\n</ul>\n<h3 id=\"局部跨域\"><a href=\"#局部跨域\" class=\"headerlink\" title=\"局部跨域\"></a>局部跨域</h3>"},{"title":"Spring-Cache使用","date":"2018-03-23T09:29:57.000Z","_content":"","source":"_posts/spring-boot-cache.md","raw":"---\ntitle: Spring-Cache使用\ndate: 2018-03-23 17:29:57\ncategories: spring-boot\ntags: spring cache\n---\n","slug":"spring-boot-cache","published":1,"updated":"2019-06-16T14:38:33.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfq00bgg4va18ae7zhl","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Spring Boot整合神器-Dataway","date":"2020-05-30T14:17:05.000Z","_content":"\n多年前，当我还是个安卓开发小哥的时候，后台给了我一个神奇的接口对接，参数只需要传表名以及表中你需要的字段名，接口就执行该查询语句，并返回你想要的结果……\n那会，那后台哥哥剩下的就只负责喝茶聊天了，而我，内心有一万个草泥马。  \n\n后来，自己做后台开发了，心中会偶尔想，能不能只需要写一个接口或者一个框架，让前端自己去定义接口，按需去取。但是能力有限，始终无法付诸行动……\n\n然而今天，偶然看到一神器名叫Dataway，简单了解后，突然如获至宝，我去……\n\n赶紧记录下来……\n\n## 介绍\n\n_1.优势_:\n\n按照某种固定模式，自由定义接口，并按照定义的sql语句，即可得到查询结果。       \n简单点来说，即把sql查询结果直接转换成http接口对外提供。 \n\n_2.缺点_：\n\n由于返回结果通过直接的sql查询，因此想要得到复杂的返回值，比如跨越多张表并且要对结果进行各种再处理的情况，则难以达到要求。\n\n_3.适用：_\n\n在一些中小企业，技术团队比较弱小甚至只有几个运维的情况下，当他们想要对外开放erp的数据时候，他们是怎么做的呢？    \n\n我见过方法之一就是，建立erp数据库视图供外部使用。考虑到erp数据的安全，且只提供只读视图。\n\n突然发觉，开放视图的方式，和这里介绍的Dataway有着异曲同工之妙。好像都是一样一样的！偷笑……\n\n很炸裂，有一个运维，够了，只需要写sql就行了，外部系统就能通过http接口拿到结果集。\n\n## 集成Spring Boot\n\n#### 引入相关依赖\n\n新建spring-boot项目后，pom.xml中引入依赖：\n\n```text\n<!-- 引入依赖 -->\n<dependency>\n    <groupId>net.hasor</groupId>\n    <artifactId>hasor-spring</artifactId>\n    <version>4.1.7</version><!-- 查看最新版本：https://mvnrepository.com/artifact/net.hasor/hasor-spring -->\n</dependency>\n<dependency>\n    <groupId>net.hasor</groupId>\n    <artifactId>hasor-dataway</artifactId>\n    <version>4.1.7</version><!-- 查看最新版本：https://mvnrepository.com/artifact/net.hasor/hasor-dataway -->\n</dependency>\n```\n   \n#### 配置文件中启用Dataway\n\n在应用的 application.properties 配置文件中启用 Dataway\n\n```properties\n# 启用 Dataway 功能（默认不启用）\nHASOR_DATAQL_DATAWAY=true\n# 开启 ui 管理功能（注意生产环境必须要设置为 false，否则会造成严重的生产安全事故）\nHASOR_DATAQL_DATAWAY_ADMIN=true\n\n# （可选）API工作路径\nHASOR_DATAQL_DATAWAY_API_URL=/api/\n# （可选）ui 的工作路径，只有开启 ui 管理功能后才有效\nHASOR_DATAQL_DATAWAY_UI_URL=/interface-ui/\n```\n\n\n    \n#### 初始化必要的表(例：MySQL)\n\n```sql\nCREATE TABLE `interface_info` (\n    `api_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT 'ID',\n    `api_method`      varchar(12)  NOT NULL                  COMMENT 'HttpMethod：GET、PUT、POST',\n    `api_path`        varchar(512) NOT NULL                  COMMENT '拦截路径',\n    `api_status`      int(2)       NOT NULL                  COMMENT '状态：0草稿，1发布，2有变更，3禁用',\n    `api_comment`     varchar(255)     NULL                  COMMENT '注释',\n    `api_type`        varchar(24)  NOT NULL                  COMMENT '脚本类型：SQL、DataQL',\n    `api_script`      mediumtext   NOT NULL                  COMMENT '查询脚本：xxxxxxx',\n    `api_schema`      mediumtext       NULL                  COMMENT '接口的请求/响应数据结构',\n    `api_sample`      mediumtext       NULL                  COMMENT '请求/响应/请求头样本数据',\n    `api_option`      mediumtext       NULL                  COMMENT '扩展配置信息',\n    `api_create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    `api_gmt_time`    datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',\n    PRIMARY KEY (`api_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT='Dataway 中的API';\n\nCREATE TABLE `interface_release` (\n    `pub_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT 'Publish ID',\n    `pub_api_id`      int(11)      NOT NULL                  COMMENT '所属API ID',\n    `pub_method`      varchar(12)  NOT NULL                  COMMENT 'HttpMethod：GET、PUT、POST',\n    `pub_path`        varchar(512) NOT NULL                  COMMENT '拦截路径',\n    `pub_status`      int(2)       NOT NULL                  COMMENT '状态：0有效，1无效（可能被下线）',\n    `pub_type`        varchar(24)  NOT NULL                  COMMENT '脚本类型：SQL、DataQL',\n    `pub_script`      mediumtext   NOT NULL                  COMMENT '查询脚本：xxxxxxx',\n    `pub_script_ori`  mediumtext   NOT NULL                  COMMENT '原始查询脚本，仅当类型为SQL时不同',\n    `pub_schema`      mediumtext       NULL                  COMMENT '接口的请求/响应数据结构',\n    `pub_sample`      mediumtext       NULL                  COMMENT '请求/响应/请求头样本数据',\n    `pub_option`      mediumtext       NULL                  COMMENT '扩展配置信息',\n    `pub_release_time`datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '发布时间（下线不更新）',\n    PRIMARY KEY (`pub_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT='Dataway API 发布历史。';\n\ncreate index idx_interface_release on interface_release (pub_api_id);\n```\n\n#### 初始化数据源\n\n如果项目中已经配置了数据源，则直接将 Spring 使用的数据源导入到 Hasor 环境共 Dataway 使用。\n\n```java\n@DimModule\n@Component\npublic class ExampleModule implements SpringModule {\n    @Autowired\n    private DataSource dataSource = null;\n\n    @Override\n    public void loadModule(ApiBinder apiBinder) throws Throwable {\n        // .DataSource form Spring boot into Hasor\n        apiBinder.installModule(new JdbcModule(Level.Full, this.dataSource));\n        // .custom DataQL\n        //apiBinder.tryCast(QueryApiBinder.class).loadUdfSource(apiBinder.findClass(DimUdfSource.class));\n        //apiBinder.tryCast(QueryApiBinder.class).bindFragment(\"sql\", SqlFragment.class);\n    }\n}\n```\n\n如果没有配置数据源，则要配置数据源：\n\n1.引入依赖\n\n```text\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n    <version>1.1.10</version>\n</dependency>\n```\n\n2.添加配置\n\n在application.properties中添加数据源配置：\n\n```properties\n# db\nspring.datasource.url=jdbc:mysql://172.31.31.31:3910/dataway?useUnicode=true&characterEncoding=utf8&useTimezone=true&serverTimezone=Asia/Shanghai\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\n# druid\nspring.datasource.druid.initial-size=3\nspring.datasource.druid.min-idle=3\nspring.datasource.druid.max-active=10\nspring.datasource.druid.max-wait=60000\nspring.datasource.druid.stat-view-servlet.login-username=admin\nspring.datasource.druid.stat-view-servlet.login-password=admin\nspring.datasource.druid.filter.stat.log-slow-sql=true\nspring.datasource.druid.filter.stat.slow-sql-millis=1\n```\n\nHasor 启动的时候会调用 loadModule 方法，在这里再把 DataSource 设置到 Hasor 中。\n\n#### 在SprintBoot 中启用 Hasor\n\n```java\nimport net.hasor.spring.boot.EnableHasor;\nimport net.hasor.spring.boot.EnableHasorWeb;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@EnableHasor\n@EnableHasorWeb\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n    @Controller\n    @ResponseBody\n    @RequestMapping(\"/\")\n    public class HomeController {\n\n        /**\n         * 输入http://localhost:8080直接跳转到http://localhost:8080/interface-ui/\n         * @param request\n         * @param response\n         * @throws IOException\n         */\n        @GetMapping\n        public void index(HttpServletRequest request, HttpServletResponse response) throws IOException {\n           response.sendRedirect(\"/interface-ui/\");\n        }\n    }\n}\n```\n\n这一步非常简单，只需要在 Spring 启动类上增加两个注解即可。\n\n启动后，浏览器打开http://localhost:8080。\n\n具体使用参考：\n\n[https://www.hasor.net/web/dataway/for_boot.html](https://www.hasor.net/web/dataway/for_boot.html)","source":"_posts/spring-boot-dataway.md","raw":"---\ntitle: Spring Boot整合神器-Dataway\ndate: 2020-05-30 22:17:05\ncategories: spring-boot\ntags:\n---\n\n多年前，当我还是个安卓开发小哥的时候，后台给了我一个神奇的接口对接，参数只需要传表名以及表中你需要的字段名，接口就执行该查询语句，并返回你想要的结果……\n那会，那后台哥哥剩下的就只负责喝茶聊天了，而我，内心有一万个草泥马。  \n\n后来，自己做后台开发了，心中会偶尔想，能不能只需要写一个接口或者一个框架，让前端自己去定义接口，按需去取。但是能力有限，始终无法付诸行动……\n\n然而今天，偶然看到一神器名叫Dataway，简单了解后，突然如获至宝，我去……\n\n赶紧记录下来……\n\n## 介绍\n\n_1.优势_:\n\n按照某种固定模式，自由定义接口，并按照定义的sql语句，即可得到查询结果。       \n简单点来说，即把sql查询结果直接转换成http接口对外提供。 \n\n_2.缺点_：\n\n由于返回结果通过直接的sql查询，因此想要得到复杂的返回值，比如跨越多张表并且要对结果进行各种再处理的情况，则难以达到要求。\n\n_3.适用：_\n\n在一些中小企业，技术团队比较弱小甚至只有几个运维的情况下，当他们想要对外开放erp的数据时候，他们是怎么做的呢？    \n\n我见过方法之一就是，建立erp数据库视图供外部使用。考虑到erp数据的安全，且只提供只读视图。\n\n突然发觉，开放视图的方式，和这里介绍的Dataway有着异曲同工之妙。好像都是一样一样的！偷笑……\n\n很炸裂，有一个运维，够了，只需要写sql就行了，外部系统就能通过http接口拿到结果集。\n\n## 集成Spring Boot\n\n#### 引入相关依赖\n\n新建spring-boot项目后，pom.xml中引入依赖：\n\n```text\n<!-- 引入依赖 -->\n<dependency>\n    <groupId>net.hasor</groupId>\n    <artifactId>hasor-spring</artifactId>\n    <version>4.1.7</version><!-- 查看最新版本：https://mvnrepository.com/artifact/net.hasor/hasor-spring -->\n</dependency>\n<dependency>\n    <groupId>net.hasor</groupId>\n    <artifactId>hasor-dataway</artifactId>\n    <version>4.1.7</version><!-- 查看最新版本：https://mvnrepository.com/artifact/net.hasor/hasor-dataway -->\n</dependency>\n```\n   \n#### 配置文件中启用Dataway\n\n在应用的 application.properties 配置文件中启用 Dataway\n\n```properties\n# 启用 Dataway 功能（默认不启用）\nHASOR_DATAQL_DATAWAY=true\n# 开启 ui 管理功能（注意生产环境必须要设置为 false，否则会造成严重的生产安全事故）\nHASOR_DATAQL_DATAWAY_ADMIN=true\n\n# （可选）API工作路径\nHASOR_DATAQL_DATAWAY_API_URL=/api/\n# （可选）ui 的工作路径，只有开启 ui 管理功能后才有效\nHASOR_DATAQL_DATAWAY_UI_URL=/interface-ui/\n```\n\n\n    \n#### 初始化必要的表(例：MySQL)\n\n```sql\nCREATE TABLE `interface_info` (\n    `api_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT 'ID',\n    `api_method`      varchar(12)  NOT NULL                  COMMENT 'HttpMethod：GET、PUT、POST',\n    `api_path`        varchar(512) NOT NULL                  COMMENT '拦截路径',\n    `api_status`      int(2)       NOT NULL                  COMMENT '状态：0草稿，1发布，2有变更，3禁用',\n    `api_comment`     varchar(255)     NULL                  COMMENT '注释',\n    `api_type`        varchar(24)  NOT NULL                  COMMENT '脚本类型：SQL、DataQL',\n    `api_script`      mediumtext   NOT NULL                  COMMENT '查询脚本：xxxxxxx',\n    `api_schema`      mediumtext       NULL                  COMMENT '接口的请求/响应数据结构',\n    `api_sample`      mediumtext       NULL                  COMMENT '请求/响应/请求头样本数据',\n    `api_option`      mediumtext       NULL                  COMMENT '扩展配置信息',\n    `api_create_time` datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',\n    `api_gmt_time`    datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',\n    PRIMARY KEY (`api_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT='Dataway 中的API';\n\nCREATE TABLE `interface_release` (\n    `pub_id`          int(11)      NOT NULL AUTO_INCREMENT   COMMENT 'Publish ID',\n    `pub_api_id`      int(11)      NOT NULL                  COMMENT '所属API ID',\n    `pub_method`      varchar(12)  NOT NULL                  COMMENT 'HttpMethod：GET、PUT、POST',\n    `pub_path`        varchar(512) NOT NULL                  COMMENT '拦截路径',\n    `pub_status`      int(2)       NOT NULL                  COMMENT '状态：0有效，1无效（可能被下线）',\n    `pub_type`        varchar(24)  NOT NULL                  COMMENT '脚本类型：SQL、DataQL',\n    `pub_script`      mediumtext   NOT NULL                  COMMENT '查询脚本：xxxxxxx',\n    `pub_script_ori`  mediumtext   NOT NULL                  COMMENT '原始查询脚本，仅当类型为SQL时不同',\n    `pub_schema`      mediumtext       NULL                  COMMENT '接口的请求/响应数据结构',\n    `pub_sample`      mediumtext       NULL                  COMMENT '请求/响应/请求头样本数据',\n    `pub_option`      mediumtext       NULL                  COMMENT '扩展配置信息',\n    `pub_release_time`datetime     DEFAULT CURRENT_TIMESTAMP COMMENT '发布时间（下线不更新）',\n    PRIMARY KEY (`pub_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COMMENT='Dataway API 发布历史。';\n\ncreate index idx_interface_release on interface_release (pub_api_id);\n```\n\n#### 初始化数据源\n\n如果项目中已经配置了数据源，则直接将 Spring 使用的数据源导入到 Hasor 环境共 Dataway 使用。\n\n```java\n@DimModule\n@Component\npublic class ExampleModule implements SpringModule {\n    @Autowired\n    private DataSource dataSource = null;\n\n    @Override\n    public void loadModule(ApiBinder apiBinder) throws Throwable {\n        // .DataSource form Spring boot into Hasor\n        apiBinder.installModule(new JdbcModule(Level.Full, this.dataSource));\n        // .custom DataQL\n        //apiBinder.tryCast(QueryApiBinder.class).loadUdfSource(apiBinder.findClass(DimUdfSource.class));\n        //apiBinder.tryCast(QueryApiBinder.class).bindFragment(\"sql\", SqlFragment.class);\n    }\n}\n```\n\n如果没有配置数据源，则要配置数据源：\n\n1.引入依赖\n\n```text\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-jdbc</artifactId>\n</dependency>\n<dependency>\n    <groupId>mysql</groupId>\n    <artifactId>mysql-connector-java</artifactId>\n</dependency>\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>druid-spring-boot-starter</artifactId>\n    <version>1.1.10</version>\n</dependency>\n```\n\n2.添加配置\n\n在application.properties中添加数据源配置：\n\n```properties\n# db\nspring.datasource.url=jdbc:mysql://172.31.31.31:3910/dataway?useUnicode=true&characterEncoding=utf8&useTimezone=true&serverTimezone=Asia/Shanghai\nspring.datasource.username=root\nspring.datasource.password=123456\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.type=com.alibaba.druid.pool.DruidDataSource\n# druid\nspring.datasource.druid.initial-size=3\nspring.datasource.druid.min-idle=3\nspring.datasource.druid.max-active=10\nspring.datasource.druid.max-wait=60000\nspring.datasource.druid.stat-view-servlet.login-username=admin\nspring.datasource.druid.stat-view-servlet.login-password=admin\nspring.datasource.druid.filter.stat.log-slow-sql=true\nspring.datasource.druid.filter.stat.slow-sql-millis=1\n```\n\nHasor 启动的时候会调用 loadModule 方法，在这里再把 DataSource 设置到 Hasor 中。\n\n#### 在SprintBoot 中启用 Hasor\n\n```java\nimport net.hasor.spring.boot.EnableHasor;\nimport net.hasor.spring.boot.EnableHasorWeb;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n@EnableHasor\n@EnableHasorWeb\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n    }\n\n    @Controller\n    @ResponseBody\n    @RequestMapping(\"/\")\n    public class HomeController {\n\n        /**\n         * 输入http://localhost:8080直接跳转到http://localhost:8080/interface-ui/\n         * @param request\n         * @param response\n         * @throws IOException\n         */\n        @GetMapping\n        public void index(HttpServletRequest request, HttpServletResponse response) throws IOException {\n           response.sendRedirect(\"/interface-ui/\");\n        }\n    }\n}\n```\n\n这一步非常简单，只需要在 Spring 启动类上增加两个注解即可。\n\n启动后，浏览器打开http://localhost:8080。\n\n具体使用参考：\n\n[https://www.hasor.net/web/dataway/for_boot.html](https://www.hasor.net/web/dataway/for_boot.html)","slug":"spring-boot-dataway","published":1,"updated":"2020-05-30T15:59:57.865Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfr00big4vafshdptfu","content":"<p>多年前，当我还是个安卓开发小哥的时候，后台给了我一个神奇的接口对接，参数只需要传表名以及表中你需要的字段名，接口就执行该查询语句，并返回你想要的结果……<br>那会，那后台哥哥剩下的就只负责喝茶聊天了，而我，内心有一万个草泥马。  </p>\n<p>后来，自己做后台开发了，心中会偶尔想，能不能只需要写一个接口或者一个框架，让前端自己去定义接口，按需去取。但是能力有限，始终无法付诸行动……</p>\n<p>然而今天，偶然看到一神器名叫Dataway，简单了解后，突然如获至宝，我去……</p>\n<p>赶紧记录下来……</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><em>1.优势</em>:</p>\n<p>按照某种固定模式，自由定义接口，并按照定义的sql语句，即可得到查询结果。<br>简单点来说，即把sql查询结果直接转换成http接口对外提供。 </p>\n<p><em>2.缺点</em>：</p>\n<p>由于返回结果通过直接的sql查询，因此想要得到复杂的返回值，比如跨越多张表并且要对结果进行各种再处理的情况，则难以达到要求。</p>\n<p><em>3.适用：</em></p>\n<p>在一些中小企业，技术团队比较弱小甚至只有几个运维的情况下，当他们想要对外开放erp的数据时候，他们是怎么做的呢？    </p>\n<p>我见过方法之一就是，建立erp数据库视图供外部使用。考虑到erp数据的安全，且只提供只读视图。</p>\n<p>突然发觉，开放视图的方式，和这里介绍的Dataway有着异曲同工之妙。好像都是一样一样的！偷笑……</p>\n<p>很炸裂，有一个运维，够了，只需要写sql就行了，外部系统就能通过http接口拿到结果集。</p>\n<h2 id=\"集成Spring-Boot\"><a href=\"#集成Spring-Boot\" class=\"headerlink\" title=\"集成Spring Boot\"></a>集成Spring Boot</h2><h4 id=\"引入相关依赖\"><a href=\"#引入相关依赖\" class=\"headerlink\" title=\"引入相关依赖\"></a>引入相关依赖</h4><p>新建spring-boot项目后，pom.xml中引入依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 引入依赖 --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;net.hasor&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;hasor-spring&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.1.7&lt;/version&gt;&lt;!-- 查看最新版本：https://mvnrepository.com/artifact/net.hasor/hasor-spring --&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;net.hasor&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;hasor-dataway&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.1.7&lt;/version&gt;&lt;!-- 查看最新版本：https://mvnrepository.com/artifact/net.hasor/hasor-dataway --&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置文件中启用Dataway\"><a href=\"#配置文件中启用Dataway\" class=\"headerlink\" title=\"配置文件中启用Dataway\"></a>配置文件中启用Dataway</h4><p>在应用的 application.properties 配置文件中启用 Dataway</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 启用 Dataway 功能（默认不启用）</span><br><span class=\"line\">HASOR_DATAQL_DATAWAY=true</span><br><span class=\"line\"># 开启 ui 管理功能（注意生产环境必须要设置为 false，否则会造成严重的生产安全事故）</span><br><span class=\"line\">HASOR_DATAQL_DATAWAY_ADMIN=true</span><br><span class=\"line\"></span><br><span class=\"line\"># （可选）API工作路径</span><br><span class=\"line\">HASOR_DATAQL_DATAWAY_API_URL=/api/</span><br><span class=\"line\"># （可选）ui 的工作路径，只有开启 ui 管理功能后才有效</span><br><span class=\"line\">HASOR_DATAQL_DATAWAY_UI_URL=/interface-ui/</span><br></pre></td></tr></table></figure>\n<h4 id=\"初始化必要的表-例：MySQL\"><a href=\"#初始化必要的表-例：MySQL\" class=\"headerlink\" title=\"初始化必要的表(例：MySQL)\"></a>初始化必要的表(例：MySQL)</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`interface_info`</span> (</span><br><span class=\"line\">    <span class=\"string\">`api_id`</span>          <span class=\"built_in\">int</span>(<span class=\"number\">11</span>)      <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT   <span class=\"keyword\">COMMENT</span> <span class=\"string\">'ID'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_method`</span>      <span class=\"built_in\">varchar</span>(<span class=\"number\">12</span>)  <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'HttpMethod：GET、PUT、POST'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_path`</span>        <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'拦截路径'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_status`</span>      <span class=\"built_in\">int</span>(<span class=\"number\">2</span>)       <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'状态：0草稿，1发布，2有变更，3禁用'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_comment`</span>     <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>)     <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'注释'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_type`</span>        <span class=\"built_in\">varchar</span>(<span class=\"number\">24</span>)  <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'脚本类型：SQL、DataQL'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_script`</span>      mediumtext   <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'查询脚本：xxxxxxx'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_schema`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'接口的请求/响应数据结构'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_sample`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'请求/响应/请求头样本数据'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_option`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'扩展配置信息'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_create_time`</span> datetime     <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'创建时间'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_gmt_time`</span>    datetime     <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'修改时间'</span>,</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`api_id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4 <span class=\"keyword\">COMMENT</span>=<span class=\"string\">'Dataway 中的API'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`interface_release`</span> (</span><br><span class=\"line\">    <span class=\"string\">`pub_id`</span>          <span class=\"built_in\">int</span>(<span class=\"number\">11</span>)      <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT   <span class=\"keyword\">COMMENT</span> <span class=\"string\">'Publish ID'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_api_id`</span>      <span class=\"built_in\">int</span>(<span class=\"number\">11</span>)      <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'所属API ID'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_method`</span>      <span class=\"built_in\">varchar</span>(<span class=\"number\">12</span>)  <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'HttpMethod：GET、PUT、POST'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_path`</span>        <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'拦截路径'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_status`</span>      <span class=\"built_in\">int</span>(<span class=\"number\">2</span>)       <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'状态：0有效，1无效（可能被下线）'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_type`</span>        <span class=\"built_in\">varchar</span>(<span class=\"number\">24</span>)  <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'脚本类型：SQL、DataQL'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_script`</span>      mediumtext   <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'查询脚本：xxxxxxx'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_script_ori`</span>  mediumtext   <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'原始查询脚本，仅当类型为SQL时不同'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_schema`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'接口的请求/响应数据结构'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_sample`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'请求/响应/请求头样本数据'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_option`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'扩展配置信息'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_release_time`</span>datetime     <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'发布时间（下线不更新）'</span>,</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`pub_id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4 <span class=\"keyword\">COMMENT</span>=<span class=\"string\">'Dataway API 发布历史。'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">index</span> idx_interface_release <span class=\"keyword\">on</span> interface_release (pub_api_id);</span><br></pre></td></tr></table></figure>\n<h4 id=\"初始化数据源\"><a href=\"#初始化数据源\" class=\"headerlink\" title=\"初始化数据源\"></a>初始化数据源</h4><p>如果项目中已经配置了数据源，则直接将 Spring 使用的数据源导入到 Hasor 环境共 Dataway 使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DimModule</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleModule</span> <span class=\"keyword\">implements</span> <span class=\"title\">SpringModule</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DataSource dataSource = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadModule</span><span class=\"params\">(ApiBinder apiBinder)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// .DataSource form Spring boot into Hasor</span></span><br><span class=\"line\">        apiBinder.installModule(<span class=\"keyword\">new</span> JdbcModule(Level.Full, <span class=\"keyword\">this</span>.dataSource));</span><br><span class=\"line\">        <span class=\"comment\">// .custom DataQL</span></span><br><span class=\"line\">        <span class=\"comment\">//apiBinder.tryCast(QueryApiBinder.class).loadUdfSource(apiBinder.findClass(DimUdfSource.class));</span></span><br><span class=\"line\">        <span class=\"comment\">//apiBinder.tryCast(QueryApiBinder.class).bindFragment(\"sql\", SqlFragment.class);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有配置数据源，则要配置数据源：</p>\n<p>1.引入依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>2.添加配置</p>\n<p>在application.properties中添加数据源配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># db</span><br><span class=\"line\">spring.datasource.url=jdbc:mysql://172.31.31.31:3910/dataway?useUnicode=true&amp;characterEncoding=utf8&amp;useTimezone=true&amp;serverTimezone=Asia/Shanghai</span><br><span class=\"line\">spring.datasource.username=root</span><br><span class=\"line\">spring.datasource.password=123456</span><br><span class=\"line\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class=\"line\">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\"># druid</span><br><span class=\"line\">spring.datasource.druid.initial-size=3</span><br><span class=\"line\">spring.datasource.druid.min-idle=3</span><br><span class=\"line\">spring.datasource.druid.max-active=10</span><br><span class=\"line\">spring.datasource.druid.max-wait=60000</span><br><span class=\"line\">spring.datasource.druid.stat-view-servlet.login-username=admin</span><br><span class=\"line\">spring.datasource.druid.stat-view-servlet.login-password=admin</span><br><span class=\"line\">spring.datasource.druid.filter.stat.log-slow-sql=true</span><br><span class=\"line\">spring.datasource.druid.filter.stat.slow-sql-millis=1</span><br></pre></td></tr></table></figure>\n<p>Hasor 启动的时候会调用 loadModule 方法，在这里再把 DataSource 设置到 Hasor 中。</p>\n<h4 id=\"在SprintBoot-中启用-Hasor\"><a href=\"#在SprintBoot-中启用-Hasor\" class=\"headerlink\" title=\"在SprintBoot 中启用 Hasor\"></a>在SprintBoot 中启用 Hasor</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> net.hasor.spring.boot.EnableHasor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.hasor.spring.boot.EnableHasorWeb;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@EnableHasor</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHasorWeb</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(DemoApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Controller</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 输入http://localhost:8080直接跳转到http://localhost:8080/interface-ui/</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">index</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">           response.sendRedirect(<span class=\"string\">\"/interface-ui/\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步非常简单，只需要在 Spring 启动类上增加两个注解即可。</p>\n<p>启动后，浏览器打开<a href=\"http://localhost:8080。\" target=\"_blank\" rel=\"noopener\">http://localhost:8080。</a></p>\n<p>具体使用参考：</p>\n<p><a href=\"https://www.hasor.net/web/dataway/for_boot.html\" target=\"_blank\" rel=\"noopener\">https://www.hasor.net/web/dataway/for_boot.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>多年前，当我还是个安卓开发小哥的时候，后台给了我一个神奇的接口对接，参数只需要传表名以及表中你需要的字段名，接口就执行该查询语句，并返回你想要的结果……<br>那会，那后台哥哥剩下的就只负责喝茶聊天了，而我，内心有一万个草泥马。  </p>\n<p>后来，自己做后台开发了，心中会偶尔想，能不能只需要写一个接口或者一个框架，让前端自己去定义接口，按需去取。但是能力有限，始终无法付诸行动……</p>\n<p>然而今天，偶然看到一神器名叫Dataway，简单了解后，突然如获至宝，我去……</p>\n<p>赶紧记录下来……</p>\n<h2 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h2><p><em>1.优势</em>:</p>\n<p>按照某种固定模式，自由定义接口，并按照定义的sql语句，即可得到查询结果。<br>简单点来说，即把sql查询结果直接转换成http接口对外提供。 </p>\n<p><em>2.缺点</em>：</p>\n<p>由于返回结果通过直接的sql查询，因此想要得到复杂的返回值，比如跨越多张表并且要对结果进行各种再处理的情况，则难以达到要求。</p>\n<p><em>3.适用：</em></p>\n<p>在一些中小企业，技术团队比较弱小甚至只有几个运维的情况下，当他们想要对外开放erp的数据时候，他们是怎么做的呢？    </p>\n<p>我见过方法之一就是，建立erp数据库视图供外部使用。考虑到erp数据的安全，且只提供只读视图。</p>\n<p>突然发觉，开放视图的方式，和这里介绍的Dataway有着异曲同工之妙。好像都是一样一样的！偷笑……</p>\n<p>很炸裂，有一个运维，够了，只需要写sql就行了，外部系统就能通过http接口拿到结果集。</p>\n<h2 id=\"集成Spring-Boot\"><a href=\"#集成Spring-Boot\" class=\"headerlink\" title=\"集成Spring Boot\"></a>集成Spring Boot</h2><h4 id=\"引入相关依赖\"><a href=\"#引入相关依赖\" class=\"headerlink\" title=\"引入相关依赖\"></a>引入相关依赖</h4><p>新建spring-boot项目后，pom.xml中引入依赖：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 引入依赖 --&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;net.hasor&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;hasor-spring&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.1.7&lt;/version&gt;&lt;!-- 查看最新版本：https://mvnrepository.com/artifact/net.hasor/hasor-spring --&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;net.hasor&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;hasor-dataway&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;4.1.7&lt;/version&gt;&lt;!-- 查看最新版本：https://mvnrepository.com/artifact/net.hasor/hasor-dataway --&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<h4 id=\"配置文件中启用Dataway\"><a href=\"#配置文件中启用Dataway\" class=\"headerlink\" title=\"配置文件中启用Dataway\"></a>配置文件中启用Dataway</h4><p>在应用的 application.properties 配置文件中启用 Dataway</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 启用 Dataway 功能（默认不启用）</span><br><span class=\"line\">HASOR_DATAQL_DATAWAY=true</span><br><span class=\"line\"># 开启 ui 管理功能（注意生产环境必须要设置为 false，否则会造成严重的生产安全事故）</span><br><span class=\"line\">HASOR_DATAQL_DATAWAY_ADMIN=true</span><br><span class=\"line\"></span><br><span class=\"line\"># （可选）API工作路径</span><br><span class=\"line\">HASOR_DATAQL_DATAWAY_API_URL=/api/</span><br><span class=\"line\"># （可选）ui 的工作路径，只有开启 ui 管理功能后才有效</span><br><span class=\"line\">HASOR_DATAQL_DATAWAY_UI_URL=/interface-ui/</span><br></pre></td></tr></table></figure>\n<h4 id=\"初始化必要的表-例：MySQL\"><a href=\"#初始化必要的表-例：MySQL\" class=\"headerlink\" title=\"初始化必要的表(例：MySQL)\"></a>初始化必要的表(例：MySQL)</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`interface_info`</span> (</span><br><span class=\"line\">    <span class=\"string\">`api_id`</span>          <span class=\"built_in\">int</span>(<span class=\"number\">11</span>)      <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT   <span class=\"keyword\">COMMENT</span> <span class=\"string\">'ID'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_method`</span>      <span class=\"built_in\">varchar</span>(<span class=\"number\">12</span>)  <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'HttpMethod：GET、PUT、POST'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_path`</span>        <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'拦截路径'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_status`</span>      <span class=\"built_in\">int</span>(<span class=\"number\">2</span>)       <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'状态：0草稿，1发布，2有变更，3禁用'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_comment`</span>     <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>)     <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'注释'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_type`</span>        <span class=\"built_in\">varchar</span>(<span class=\"number\">24</span>)  <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'脚本类型：SQL、DataQL'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_script`</span>      mediumtext   <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'查询脚本：xxxxxxx'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_schema`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'接口的请求/响应数据结构'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_sample`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'请求/响应/请求头样本数据'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_option`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'扩展配置信息'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_create_time`</span> datetime     <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'创建时间'</span>,</span><br><span class=\"line\">    <span class=\"string\">`api_gmt_time`</span>    datetime     <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'修改时间'</span>,</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`api_id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4 <span class=\"keyword\">COMMENT</span>=<span class=\"string\">'Dataway 中的API'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`interface_release`</span> (</span><br><span class=\"line\">    <span class=\"string\">`pub_id`</span>          <span class=\"built_in\">int</span>(<span class=\"number\">11</span>)      <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT   <span class=\"keyword\">COMMENT</span> <span class=\"string\">'Publish ID'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_api_id`</span>      <span class=\"built_in\">int</span>(<span class=\"number\">11</span>)      <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'所属API ID'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_method`</span>      <span class=\"built_in\">varchar</span>(<span class=\"number\">12</span>)  <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'HttpMethod：GET、PUT、POST'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_path`</span>        <span class=\"built_in\">varchar</span>(<span class=\"number\">512</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'拦截路径'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_status`</span>      <span class=\"built_in\">int</span>(<span class=\"number\">2</span>)       <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'状态：0有效，1无效（可能被下线）'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_type`</span>        <span class=\"built_in\">varchar</span>(<span class=\"number\">24</span>)  <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'脚本类型：SQL、DataQL'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_script`</span>      mediumtext   <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'查询脚本：xxxxxxx'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_script_ori`</span>  mediumtext   <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'原始查询脚本，仅当类型为SQL时不同'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_schema`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'接口的请求/响应数据结构'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_sample`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'请求/响应/请求头样本数据'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_option`</span>      mediumtext       <span class=\"literal\">NULL</span>                  <span class=\"keyword\">COMMENT</span> <span class=\"string\">'扩展配置信息'</span>,</span><br><span class=\"line\">    <span class=\"string\">`pub_release_time`</span>datetime     <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CURRENT_TIMESTAMP</span> <span class=\"keyword\">COMMENT</span> <span class=\"string\">'发布时间（下线不更新）'</span>,</span><br><span class=\"line\">    PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`pub_id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">0</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4 <span class=\"keyword\">COMMENT</span>=<span class=\"string\">'Dataway API 发布历史。'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">index</span> idx_interface_release <span class=\"keyword\">on</span> interface_release (pub_api_id);</span><br></pre></td></tr></table></figure>\n<h4 id=\"初始化数据源\"><a href=\"#初始化数据源\" class=\"headerlink\" title=\"初始化数据源\"></a>初始化数据源</h4><p>如果项目中已经配置了数据源，则直接将 Spring 使用的数据源导入到 Hasor 环境共 Dataway 使用。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@DimModule</span></span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ExampleModule</span> <span class=\"keyword\">implements</span> <span class=\"title\">SpringModule</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> DataSource dataSource = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">loadModule</span><span class=\"params\">(ApiBinder apiBinder)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// .DataSource form Spring boot into Hasor</span></span><br><span class=\"line\">        apiBinder.installModule(<span class=\"keyword\">new</span> JdbcModule(Level.Full, <span class=\"keyword\">this</span>.dataSource));</span><br><span class=\"line\">        <span class=\"comment\">// .custom DataQL</span></span><br><span class=\"line\">        <span class=\"comment\">//apiBinder.tryCast(QueryApiBinder.class).loadUdfSource(apiBinder.findClass(DimUdfSource.class));</span></span><br><span class=\"line\">        <span class=\"comment\">//apiBinder.tryCast(QueryApiBinder.class).bindFragment(\"sql\", SqlFragment.class);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果没有配置数据源，则要配置数据源：</p>\n<p>1.引入依赖</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br><span class=\"line\">&lt;dependency&gt;</span><br><span class=\"line\">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class=\"line\">    &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;</span><br><span class=\"line\">    &lt;version&gt;1.1.10&lt;/version&gt;</span><br><span class=\"line\">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>\n<p>2.添加配置</p>\n<p>在application.properties中添加数据源配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># db</span><br><span class=\"line\">spring.datasource.url=jdbc:mysql://172.31.31.31:3910/dataway?useUnicode=true&amp;characterEncoding=utf8&amp;useTimezone=true&amp;serverTimezone=Asia/Shanghai</span><br><span class=\"line\">spring.datasource.username=root</span><br><span class=\"line\">spring.datasource.password=123456</span><br><span class=\"line\">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class=\"line\">spring.datasource.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class=\"line\"># druid</span><br><span class=\"line\">spring.datasource.druid.initial-size=3</span><br><span class=\"line\">spring.datasource.druid.min-idle=3</span><br><span class=\"line\">spring.datasource.druid.max-active=10</span><br><span class=\"line\">spring.datasource.druid.max-wait=60000</span><br><span class=\"line\">spring.datasource.druid.stat-view-servlet.login-username=admin</span><br><span class=\"line\">spring.datasource.druid.stat-view-servlet.login-password=admin</span><br><span class=\"line\">spring.datasource.druid.filter.stat.log-slow-sql=true</span><br><span class=\"line\">spring.datasource.druid.filter.stat.slow-sql-millis=1</span><br></pre></td></tr></table></figure>\n<p>Hasor 启动的时候会调用 loadModule 方法，在这里再把 DataSource 设置到 Hasor 中。</p>\n<h4 id=\"在SprintBoot-中启用-Hasor\"><a href=\"#在SprintBoot-中启用-Hasor\" class=\"headerlink\" title=\"在SprintBoot 中启用 Hasor\"></a>在SprintBoot 中启用 Hasor</h4><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> net.hasor.spring.boot.EnableHasor;</span><br><span class=\"line\"><span class=\"keyword\">import</span> net.hasor.spring.boot.EnableHasorWeb;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.SpringApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.stereotype.Controller;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@EnableHasor</span></span><br><span class=\"line\"><span class=\"meta\">@EnableHasorWeb</span></span><br><span class=\"line\"><span class=\"meta\">@SpringBootApplication</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DemoApplication</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        SpringApplication.run(DemoApplication.class, args);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Controller</span></span><br><span class=\"line\">    <span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HomeController</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 输入http://localhost:8080直接跳转到http://localhost:8080/interface-ui/</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> request</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@param</span> response</span></span><br><span class=\"line\"><span class=\"comment\">         * <span class=\"doctag\">@throws</span> IOException</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        <span class=\"meta\">@GetMapping</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">index</span><span class=\"params\">(HttpServletRequest request, HttpServletResponse response)</span> <span class=\"keyword\">throws</span> IOException </span>&#123;</span><br><span class=\"line\">           response.sendRedirect(<span class=\"string\">\"/interface-ui/\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这一步非常简单，只需要在 Spring 启动类上增加两个注解即可。</p>\n<p>启动后，浏览器打开<a href=\"http://localhost:8080。\" target=\"_blank\" rel=\"noopener\">http://localhost:8080。</a></p>\n<p>具体使用参考：</p>\n<p><a href=\"https://www.hasor.net/web/dataway/for_boot.html\" target=\"_blank\" rel=\"noopener\">https://www.hasor.net/web/dataway/for_boot.html</a></p>\n"},{"title":"spring-boot开发常见异常收录","date":"2017-09-28T16:31:25.000Z","_content":"\n## jpa篇\n\n### 1 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n#### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n#### 1.2 不传递依赖\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n#### 1.3 在@SpringBootApplication中排除其注入\n\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n### 2 自动创建表指定Mysql搜索引擎类型\n\n解决方法，只需要在配置文件添加如下代码:\n    \n    # 指定生成表名的存储引擎为InneoDB\n    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n\n## 启动类配置\n\n1.让一个类型不被ComponentScan扫描\n\n    @ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n            value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\n    public class ServiceFileclientApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(ServiceFileclientApplication.class, args);\n        }\n    }\n    \n    ----\n    \n    package com.ymu.servicefileclient.config;\n    \n    public @interface ExcludeComponent {\n    }\n    \n    -------\n    /**\n     * 该类为Feign的配置类\n     * 注意：该类不应该在主应用程序上下文的@CompantScan中\n     */\n    @ExcludeComponent\n    @Configuration\n    public class FeignConfiguration {\n    \n        /**\n         * 用feign.Contract.Default替换SpringMvcContract契约\n         *\n         * @return\n         */\n        @Bean\n        public Contract feignContract() {\n            return new feign.Contract.Default();\n        }\n    \n    }\n\n## 文件相关\n\n1.在jar包所在目录下创建文件或者文件夹\n\n     //运行jar所在文件目录\n     @Value(\"${user.dir}\")\n     private String userDir;\n     \n     //创建文件夹abc\n      URI uri = URI.create(userDir);\n      File file = new File(uri + \"/abc\");\n      if (!file.exists()) {\n          file.mkdir();\n      }\n\n2.系统用户根目录下创建文件\n\n     // 桌面路径\n    FileSystemView fsv = FileSystemView.getFileSystemView();\n    File com = fsv.getHomeDirectory();\n    // String url = com.getPath().replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\") + \"\\\\\";\n    String filePath = com.getPath();\n    String fileName = \"导出数据.pdf\";\n    String uri = filePath.concat(File.separator).concat(fileName);   \n   \n3.获取类所在资源目录\n\n    this.getClass().getClassLoader().getResource(\"\").getPath(); \n    \n    --------------------------------------x\n    \n    近期在用springboot封装一些对外服务的API接口，在本机测试都很顺利，可是当我打包jar文件放到服务器上测试的时候发现了类似下面的异常信息：\n    \n    java.nio.file.NoSuchFileException: file:/app.jar!/BOOT-INF/classes!/xxx.properties \n     \n    于是网上一番搜索，找到类似的解决方法：\n    Properties prop = new Properties();\n    InputStream is = this.getClass().getResourceAsStream(filePath);     \n    \n## 取消自动配置\n\n### 方式一\n\n去掉pom中相关的依赖包。\n\n### 代码中配置\n\n1.使用了@EnableAutoConfiguration的时候    \n\n    @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n    \n2.使用了@SpringBootApplication的时候\n\n    @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n    1\n3.使用了@SpringCloudApplication的时候\n\n    @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n    @SpringCloudApplication\n    \n4.通过配置文件来设置\n\n    spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n    1\n    \n  \n## spring boot tomcat临时文件夹的问题\n \n###  The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is no \n\n线上的系统中不能上传文件了，出现如下错误：\n\n    org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request;nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is not valid \n    \n原因： \n在linux系统中，springboot应用服务再启动（java -jar 命令启动服务）的时候，会在操作系统的/tmp目录下生成一个tomcat*的文件目录，上传的文件先要转换成临时文件保存在这个文件夹下面。由于临时/tmp目录下的文件，在长时间（10天）没有使用的情况下，就会被系统机制自动删除掉。所以如果系统长时间无人问津的话，就可能导致上面这个问题。\n\n临时解决方法： \n手动在/tmp下创建相应得文件夹或者重启系统\n\n解决办法： \n在 yml配置文件 中添加：\n\n    server.tomcat.basedir: /data/apps/temp  \n    \n手动的将临时文件夹设置为自定义的文件夹，就不会被Linux删除了。    \n    \n \n ## 集成jooq后，添加aop切面，应用启动变慢的问题\n \n- 问题描述：\n \n spring boot2项目中，jpa集成jooq，添加切面，然后启动程序，每次都卡在初始化jpa的地方，要等待一两分钟甚至更久才能启动应用。\n\naop表达式：\n\n    @Before(\"execution(public * com.xrlj.servicesyscommon.service.impl..*.*(..)))\")\n    \n启动会卡在这里：    \n\n    2019-04-15 00:21:42.100  INFO 9072 --- [  restartedMain] log4jdbc.log4j2                          : 2. Connection closed. {executed in 0ms} \n    2019-04-15 00:21:42.100  INFO 9072 --- [  restartedMain] log4jdbc.log4j2                          : 2. Connection.close() returned \n    2019-04-15 00:21:42.122  INFO 9072 --- [  restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'myself_db'\n\n- 问题解决：\n把execution表达式，改成within表达式即可。    \n\n改成：\n\n    @Before(\"within(com.xrlj.servicesyscommon.service.impl..*)\")\n\n即可。\n\n参考：\n网上描述，说是集成了jooq后才会这样的。   \nhttps://github.com/jOOQ/jOOQ/issues/5902\n     \n    \n","source":"_posts/spring-boot-dev-error-show.md","raw":"---\ntitle: spring-boot开发常见异常收录\ndate: 2017-09-29 00:31:25\ncategories: spring-boot\ntags: \n---\n\n## jpa篇\n\n### 1 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n#### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n#### 1.2 不传递依赖\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n#### 1.3 在@SpringBootApplication中排除其注入\n\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n### 2 自动创建表指定Mysql搜索引擎类型\n\n解决方法，只需要在配置文件添加如下代码:\n    \n    # 指定生成表名的存储引擎为InneoDB\n    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n\n## 启动类配置\n\n1.让一个类型不被ComponentScan扫描\n\n    @ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n            value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\n    public class ServiceFileclientApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(ServiceFileclientApplication.class, args);\n        }\n    }\n    \n    ----\n    \n    package com.ymu.servicefileclient.config;\n    \n    public @interface ExcludeComponent {\n    }\n    \n    -------\n    /**\n     * 该类为Feign的配置类\n     * 注意：该类不应该在主应用程序上下文的@CompantScan中\n     */\n    @ExcludeComponent\n    @Configuration\n    public class FeignConfiguration {\n    \n        /**\n         * 用feign.Contract.Default替换SpringMvcContract契约\n         *\n         * @return\n         */\n        @Bean\n        public Contract feignContract() {\n            return new feign.Contract.Default();\n        }\n    \n    }\n\n## 文件相关\n\n1.在jar包所在目录下创建文件或者文件夹\n\n     //运行jar所在文件目录\n     @Value(\"${user.dir}\")\n     private String userDir;\n     \n     //创建文件夹abc\n      URI uri = URI.create(userDir);\n      File file = new File(uri + \"/abc\");\n      if (!file.exists()) {\n          file.mkdir();\n      }\n\n2.系统用户根目录下创建文件\n\n     // 桌面路径\n    FileSystemView fsv = FileSystemView.getFileSystemView();\n    File com = fsv.getHomeDirectory();\n    // String url = com.getPath().replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\") + \"\\\\\";\n    String filePath = com.getPath();\n    String fileName = \"导出数据.pdf\";\n    String uri = filePath.concat(File.separator).concat(fileName);   \n   \n3.获取类所在资源目录\n\n    this.getClass().getClassLoader().getResource(\"\").getPath(); \n    \n    --------------------------------------x\n    \n    近期在用springboot封装一些对外服务的API接口，在本机测试都很顺利，可是当我打包jar文件放到服务器上测试的时候发现了类似下面的异常信息：\n    \n    java.nio.file.NoSuchFileException: file:/app.jar!/BOOT-INF/classes!/xxx.properties \n     \n    于是网上一番搜索，找到类似的解决方法：\n    Properties prop = new Properties();\n    InputStream is = this.getClass().getResourceAsStream(filePath);     \n    \n## 取消自动配置\n\n### 方式一\n\n去掉pom中相关的依赖包。\n\n### 代码中配置\n\n1.使用了@EnableAutoConfiguration的时候    \n\n    @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n    \n2.使用了@SpringBootApplication的时候\n\n    @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n    1\n3.使用了@SpringCloudApplication的时候\n\n    @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n    @SpringCloudApplication\n    \n4.通过配置文件来设置\n\n    spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n    1\n    \n  \n## spring boot tomcat临时文件夹的问题\n \n###  The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is no \n\n线上的系统中不能上传文件了，出现如下错误：\n\n    org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request;nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is not valid \n    \n原因： \n在linux系统中，springboot应用服务再启动（java -jar 命令启动服务）的时候，会在操作系统的/tmp目录下生成一个tomcat*的文件目录，上传的文件先要转换成临时文件保存在这个文件夹下面。由于临时/tmp目录下的文件，在长时间（10天）没有使用的情况下，就会被系统机制自动删除掉。所以如果系统长时间无人问津的话，就可能导致上面这个问题。\n\n临时解决方法： \n手动在/tmp下创建相应得文件夹或者重启系统\n\n解决办法： \n在 yml配置文件 中添加：\n\n    server.tomcat.basedir: /data/apps/temp  \n    \n手动的将临时文件夹设置为自定义的文件夹，就不会被Linux删除了。    \n    \n \n ## 集成jooq后，添加aop切面，应用启动变慢的问题\n \n- 问题描述：\n \n spring boot2项目中，jpa集成jooq，添加切面，然后启动程序，每次都卡在初始化jpa的地方，要等待一两分钟甚至更久才能启动应用。\n\naop表达式：\n\n    @Before(\"execution(public * com.xrlj.servicesyscommon.service.impl..*.*(..)))\")\n    \n启动会卡在这里：    \n\n    2019-04-15 00:21:42.100  INFO 9072 --- [  restartedMain] log4jdbc.log4j2                          : 2. Connection closed. {executed in 0ms} \n    2019-04-15 00:21:42.100  INFO 9072 --- [  restartedMain] log4jdbc.log4j2                          : 2. Connection.close() returned \n    2019-04-15 00:21:42.122  INFO 9072 --- [  restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'myself_db'\n\n- 问题解决：\n把execution表达式，改成within表达式即可。    \n\n改成：\n\n    @Before(\"within(com.xrlj.servicesyscommon.service.impl..*)\")\n\n即可。\n\n参考：\n网上描述，说是集成了jooq后才会这样的。   \nhttps://github.com/jOOQ/jOOQ/issues/5902\n     \n    \n","slug":"spring-boot-dev-error-show","published":1,"updated":"2019-06-16T14:38:33.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqft00bmg4vahjjdbqyr","content":"<h2 id=\"jpa篇\"><a href=\"#jpa篇\" class=\"headerlink\" title=\"jpa篇\"></a>jpa篇</h2><h3 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1 异常一：缺少jpa数据源配置\"></a>1 异常一：缺少jpa数据源配置</h3><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h4 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h4><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2 不传递依赖\"></a>1.2 不传递依赖</h4><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h4 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h4><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre><h3 id=\"2-自动创建表指定Mysql搜索引擎类型\"><a href=\"#2-自动创建表指定Mysql搜索引擎类型\" class=\"headerlink\" title=\"2 自动创建表指定Mysql搜索引擎类型\"></a>2 自动创建表指定Mysql搜索引擎类型</h3><p>解决方法，只需要在配置文件添加如下代码:</p>\n<pre><code># 指定生成表名的存储引擎为InneoDB\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n</code></pre><h2 id=\"启动类配置\"><a href=\"#启动类配置\" class=\"headerlink\" title=\"启动类配置\"></a>启动类配置</h2><p>1.让一个类型不被ComponentScan扫描</p>\n<pre><code>@ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n        value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\npublic class ServiceFileclientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceFileclientApplication.class, args);\n    }\n}\n\n----\n\npackage com.ymu.servicefileclient.config;\n\npublic @interface ExcludeComponent {\n}\n\n-------\n/**\n * 该类为Feign的配置类\n * 注意：该类不应该在主应用程序上下文的@CompantScan中\n */\n@ExcludeComponent\n@Configuration\npublic class FeignConfiguration {\n\n    /**\n     * 用feign.Contract.Default替换SpringMvcContract契约\n     *\n     * @return\n     */\n    @Bean\n    public Contract feignContract() {\n        return new feign.Contract.Default();\n    }\n\n}\n</code></pre><h2 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h2><p>1.在jar包所在目录下创建文件或者文件夹</p>\n<pre><code>//运行jar所在文件目录\n@Value(&quot;${user.dir}&quot;)\nprivate String userDir;\n\n//创建文件夹abc\n URI uri = URI.create(userDir);\n File file = new File(uri + &quot;/abc&quot;);\n if (!file.exists()) {\n     file.mkdir();\n }\n</code></pre><p>2.系统用户根目录下创建文件</p>\n<pre><code> // 桌面路径\nFileSystemView fsv = FileSystemView.getFileSystemView();\nFile com = fsv.getHomeDirectory();\n// String url = com.getPath().replaceAll(&quot;\\\\\\\\&quot;, &quot;\\\\\\\\\\\\\\\\&quot;) + &quot;\\\\&quot;;\nString filePath = com.getPath();\nString fileName = &quot;导出数据.pdf&quot;;\nString uri = filePath.concat(File.separator).concat(fileName);   \n</code></pre><p>3.获取类所在资源目录</p>\n<pre><code>this.getClass().getClassLoader().getResource(&quot;&quot;).getPath(); \n\n--------------------------------------x\n\n近期在用springboot封装一些对外服务的API接口，在本机测试都很顺利，可是当我打包jar文件放到服务器上测试的时候发现了类似下面的异常信息：\n\njava.nio.file.NoSuchFileException: file:/app.jar!/BOOT-INF/classes!/xxx.properties \n\n于是网上一番搜索，找到类似的解决方法：\nProperties prop = new Properties();\nInputStream is = this.getClass().getResourceAsStream(filePath);     \n</code></pre><h2 id=\"取消自动配置\"><a href=\"#取消自动配置\" class=\"headerlink\" title=\"取消自动配置\"></a>取消自动配置</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>去掉pom中相关的依赖包。</p>\n<h3 id=\"代码中配置\"><a href=\"#代码中配置\" class=\"headerlink\" title=\"代码中配置\"></a>代码中配置</h3><p>1.使用了@EnableAutoConfiguration的时候    </p>\n<pre><code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n</code></pre><p>2.使用了@SpringBootApplication的时候</p>\n<pre><code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n1\n</code></pre><p>3.使用了@SpringCloudApplication的时候</p>\n<pre><code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n@SpringCloudApplication\n</code></pre><p>4.通过配置文件来设置</p>\n<pre><code>spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n1\n</code></pre><h2 id=\"spring-boot-tomcat临时文件夹的问题\"><a href=\"#spring-boot-tomcat临时文件夹的问题\" class=\"headerlink\" title=\"spring boot tomcat临时文件夹的问题\"></a>spring boot tomcat临时文件夹的问题</h2><h3 id=\"The-temporary-upload-location-tmp-tomcat-1337767218595042057-80-work-Tomcat-localhost-ROOT-is-no\"><a href=\"#The-temporary-upload-location-tmp-tomcat-1337767218595042057-80-work-Tomcat-localhost-ROOT-is-no\" class=\"headerlink\" title=\"The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is no\"></a>The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is no</h3><p>线上的系统中不能上传文件了，出现如下错误：</p>\n<pre><code>org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request;nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is not valid \n</code></pre><p>原因：<br>在linux系统中，springboot应用服务再启动（java -jar 命令启动服务）的时候，会在操作系统的/tmp目录下生成一个tomcat*的文件目录，上传的文件先要转换成临时文件保存在这个文件夹下面。由于临时/tmp目录下的文件，在长时间（10天）没有使用的情况下，就会被系统机制自动删除掉。所以如果系统长时间无人问津的话，就可能导致上面这个问题。</p>\n<p>临时解决方法：<br>手动在/tmp下创建相应得文件夹或者重启系统</p>\n<p>解决办法：<br>在 yml配置文件 中添加：</p>\n<pre><code>server.tomcat.basedir: /data/apps/temp  \n</code></pre><p>手动的将临时文件夹设置为自定义的文件夹，就不会被Linux删除了。    </p>\n<h2 id=\"集成jooq后，添加aop切面，应用启动变慢的问题\"><a href=\"#集成jooq后，添加aop切面，应用启动变慢的问题\" class=\"headerlink\" title=\"集成jooq后，添加aop切面，应用启动变慢的问题\"></a>集成jooq后，添加aop切面，应用启动变慢的问题</h2><ul>\n<li><p>问题描述：</p>\n<p>spring boot2项目中，jpa集成jooq，添加切面，然后启动程序，每次都卡在初始化jpa的地方，要等待一两分钟甚至更久才能启动应用。</p>\n</li>\n</ul>\n<p>aop表达式：</p>\n<pre><code>@Before(&quot;execution(public * com.xrlj.servicesyscommon.service.impl..*.*(..)))&quot;)\n</code></pre><p>启动会卡在这里：    </p>\n<pre><code>2019-04-15 00:21:42.100  INFO 9072 --- [  restartedMain] log4jdbc.log4j2                          : 2. Connection closed. {executed in 0ms} \n2019-04-15 00:21:42.100  INFO 9072 --- [  restartedMain] log4jdbc.log4j2                          : 2. Connection.close() returned \n2019-04-15 00:21:42.122  INFO 9072 --- [  restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit &apos;myself_db&apos;\n</code></pre><ul>\n<li>问题解决：<br>把execution表达式，改成within表达式即可。    </li>\n</ul>\n<p>改成：</p>\n<pre><code>@Before(&quot;within(com.xrlj.servicesyscommon.service.impl..*)&quot;)\n</code></pre><p>即可。</p>\n<p>参考：<br>网上描述，说是集成了jooq后才会这样的。<br><a href=\"https://github.com/jOOQ/jOOQ/issues/5902\" target=\"_blank\" rel=\"noopener\">https://github.com/jOOQ/jOOQ/issues/5902</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"jpa篇\"><a href=\"#jpa篇\" class=\"headerlink\" title=\"jpa篇\"></a>jpa篇</h2><h3 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1 异常一：缺少jpa数据源配置\"></a>1 异常一：缺少jpa数据源配置</h3><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h4 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h4><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2 不传递依赖\"></a>1.2 不传递依赖</h4><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h4 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h4><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre><h3 id=\"2-自动创建表指定Mysql搜索引擎类型\"><a href=\"#2-自动创建表指定Mysql搜索引擎类型\" class=\"headerlink\" title=\"2 自动创建表指定Mysql搜索引擎类型\"></a>2 自动创建表指定Mysql搜索引擎类型</h3><p>解决方法，只需要在配置文件添加如下代码:</p>\n<pre><code># 指定生成表名的存储引擎为InneoDB\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n</code></pre><h2 id=\"启动类配置\"><a href=\"#启动类配置\" class=\"headerlink\" title=\"启动类配置\"></a>启动类配置</h2><p>1.让一个类型不被ComponentScan扫描</p>\n<pre><code>@ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n        value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\npublic class ServiceFileclientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceFileclientApplication.class, args);\n    }\n}\n\n----\n\npackage com.ymu.servicefileclient.config;\n\npublic @interface ExcludeComponent {\n}\n\n-------\n/**\n * 该类为Feign的配置类\n * 注意：该类不应该在主应用程序上下文的@CompantScan中\n */\n@ExcludeComponent\n@Configuration\npublic class FeignConfiguration {\n\n    /**\n     * 用feign.Contract.Default替换SpringMvcContract契约\n     *\n     * @return\n     */\n    @Bean\n    public Contract feignContract() {\n        return new feign.Contract.Default();\n    }\n\n}\n</code></pre><h2 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h2><p>1.在jar包所在目录下创建文件或者文件夹</p>\n<pre><code>//运行jar所在文件目录\n@Value(&quot;${user.dir}&quot;)\nprivate String userDir;\n\n//创建文件夹abc\n URI uri = URI.create(userDir);\n File file = new File(uri + &quot;/abc&quot;);\n if (!file.exists()) {\n     file.mkdir();\n }\n</code></pre><p>2.系统用户根目录下创建文件</p>\n<pre><code> // 桌面路径\nFileSystemView fsv = FileSystemView.getFileSystemView();\nFile com = fsv.getHomeDirectory();\n// String url = com.getPath().replaceAll(&quot;\\\\\\\\&quot;, &quot;\\\\\\\\\\\\\\\\&quot;) + &quot;\\\\&quot;;\nString filePath = com.getPath();\nString fileName = &quot;导出数据.pdf&quot;;\nString uri = filePath.concat(File.separator).concat(fileName);   \n</code></pre><p>3.获取类所在资源目录</p>\n<pre><code>this.getClass().getClassLoader().getResource(&quot;&quot;).getPath(); \n\n--------------------------------------x\n\n近期在用springboot封装一些对外服务的API接口，在本机测试都很顺利，可是当我打包jar文件放到服务器上测试的时候发现了类似下面的异常信息：\n\njava.nio.file.NoSuchFileException: file:/app.jar!/BOOT-INF/classes!/xxx.properties \n\n于是网上一番搜索，找到类似的解决方法：\nProperties prop = new Properties();\nInputStream is = this.getClass().getResourceAsStream(filePath);     \n</code></pre><h2 id=\"取消自动配置\"><a href=\"#取消自动配置\" class=\"headerlink\" title=\"取消自动配置\"></a>取消自动配置</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>去掉pom中相关的依赖包。</p>\n<h3 id=\"代码中配置\"><a href=\"#代码中配置\" class=\"headerlink\" title=\"代码中配置\"></a>代码中配置</h3><p>1.使用了@EnableAutoConfiguration的时候    </p>\n<pre><code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n</code></pre><p>2.使用了@SpringBootApplication的时候</p>\n<pre><code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n1\n</code></pre><p>3.使用了@SpringCloudApplication的时候</p>\n<pre><code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n@SpringCloudApplication\n</code></pre><p>4.通过配置文件来设置</p>\n<pre><code>spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n1\n</code></pre><h2 id=\"spring-boot-tomcat临时文件夹的问题\"><a href=\"#spring-boot-tomcat临时文件夹的问题\" class=\"headerlink\" title=\"spring boot tomcat临时文件夹的问题\"></a>spring boot tomcat临时文件夹的问题</h2><h3 id=\"The-temporary-upload-location-tmp-tomcat-1337767218595042057-80-work-Tomcat-localhost-ROOT-is-no\"><a href=\"#The-temporary-upload-location-tmp-tomcat-1337767218595042057-80-work-Tomcat-localhost-ROOT-is-no\" class=\"headerlink\" title=\"The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is no\"></a>The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is no</h3><p>线上的系统中不能上传文件了，出现如下错误：</p>\n<pre><code>org.springframework.web.multipart.MultipartException: Could not parse multipart servlet request;nested exception is java.io.IOException: The temporary upload location [/tmp/tomcat.1337767218595042057.80/work/Tomcat/localhost/ROOT] is not valid \n</code></pre><p>原因：<br>在linux系统中，springboot应用服务再启动（java -jar 命令启动服务）的时候，会在操作系统的/tmp目录下生成一个tomcat*的文件目录，上传的文件先要转换成临时文件保存在这个文件夹下面。由于临时/tmp目录下的文件，在长时间（10天）没有使用的情况下，就会被系统机制自动删除掉。所以如果系统长时间无人问津的话，就可能导致上面这个问题。</p>\n<p>临时解决方法：<br>手动在/tmp下创建相应得文件夹或者重启系统</p>\n<p>解决办法：<br>在 yml配置文件 中添加：</p>\n<pre><code>server.tomcat.basedir: /data/apps/temp  \n</code></pre><p>手动的将临时文件夹设置为自定义的文件夹，就不会被Linux删除了。    </p>\n<h2 id=\"集成jooq后，添加aop切面，应用启动变慢的问题\"><a href=\"#集成jooq后，添加aop切面，应用启动变慢的问题\" class=\"headerlink\" title=\"集成jooq后，添加aop切面，应用启动变慢的问题\"></a>集成jooq后，添加aop切面，应用启动变慢的问题</h2><ul>\n<li><p>问题描述：</p>\n<p>spring boot2项目中，jpa集成jooq，添加切面，然后启动程序，每次都卡在初始化jpa的地方，要等待一两分钟甚至更久才能启动应用。</p>\n</li>\n</ul>\n<p>aop表达式：</p>\n<pre><code>@Before(&quot;execution(public * com.xrlj.servicesyscommon.service.impl..*.*(..)))&quot;)\n</code></pre><p>启动会卡在这里：    </p>\n<pre><code>2019-04-15 00:21:42.100  INFO 9072 --- [  restartedMain] log4jdbc.log4j2                          : 2. Connection closed. {executed in 0ms} \n2019-04-15 00:21:42.100  INFO 9072 --- [  restartedMain] log4jdbc.log4j2                          : 2. Connection.close() returned \n2019-04-15 00:21:42.122  INFO 9072 --- [  restartedMain] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit &apos;myself_db&apos;\n</code></pre><ul>\n<li>问题解决：<br>把execution表达式，改成within表达式即可。    </li>\n</ul>\n<p>改成：</p>\n<pre><code>@Before(&quot;within(com.xrlj.servicesyscommon.service.impl..*)&quot;)\n</code></pre><p>即可。</p>\n<p>参考：<br>网上描述，说是集成了jooq后才会这样的。<br><a href=\"https://github.com/jOOQ/jOOQ/issues/5902\" target=\"_blank\" rel=\"noopener\">https://github.com/jOOQ/jOOQ/issues/5902</a></p>\n"},{"title":"spring-boot集成docker部署","date":"2019-01-01T13:13:02.000Z","_content":"\n本章介绍spring-boot项目docker化构件，利用maven插件把spring-boot项目构件成docker镜像，并上传到自己的docker私服nexus3上。\n\n官方参考例子： \nhttps://spring.io/guides/gs/spring-boot-docker/\n\n## 快速在本机构件spring-boot项目镜像\n\n1.新建spring-boot项目。\n通过https://start.spring.io/  \n2.在项目根目录下添加Dockerfile文件，并编辑内容如下：\n\n    FROM openjdk:8-jdk-alpine\n    VOLUME /tmp\n    ARG DEPENDENCY=target/dependency\n    COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib\n    COPY ${DEPENDENCY}/META-INF /app/META-INF\n    COPY ${DEPENDENCY}/BOOT-INF/classes /app\n    ENTRYPOINT [\"java\",\"-cp\",\"app:app/lib/*\",\"hello.Application\"]    \n3.配置maven插件，编辑pom.xml，添加：\n[dockerfile-maven 插件](https://github.com/spotify/dockerfile-maven)\n\n    <properties>\n       <docker.image.prefix>springio</docker.image.prefix>\n    </properties>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>com.spotify</groupId>\n                <artifactId>dockerfile-maven-plugin</artifactId>\n                <version>1.4.9</version>\n                <configuration>\n                    <repository>${docker.image.prefix}/${project.artifactId}</repository>\n                    <tag>${project.version}</tag>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n    \n参数说明：\n- repository：指定镜像名称。\n- tag: 指定镜像标签，如果不指定，则默认是latest。   \n    \n为了确保在构件docker镜像之前，spring-boot jar包是解压的，添加下面插件配置：\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-dependency-plugin</artifactId>\n        <executions>\n            <execution>\n                <id>unpack</id>\n                <phase>package</phase>\n                <goals>\n                    <goal>unpack</goal>\n                </goals>\n                <configuration>\n                    <artifactItems>\n                        <artifactItem>\n                            <groupId>${project.groupId}</groupId>\n                            <artifactId>${project.artifactId}</artifactId>\n                            <version>${project.version}</version>\n                        </artifactItem>\n                    </artifactItems>\n                </configuration>\n            </execution>\n        </executions>\n    </plugin>\n   \n4.执行命令构件docker镜像\n\n    $ ./mvnw install dockerfile:build\n    \n    或者(如果么有mvnw)\n    \n    mvn install dockerfile:build\n    \n        \n## 上传到docker私服\n\n1.配置setting.xml\n\n    <server>\n      <id>ip:8082</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n    \n注意id，必须为私服地址。\n\n\n2.配置pom.xml\n\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n        <!-- tag::plugin[] -->\n        <plugin>\n            <groupId>com.spotify</groupId>\n            <artifactId>dockerfile-maven-plugin</artifactId>\n            <version>1.4.9</version>\n            <configuration>\n                <repository>119.145.41.171:8082/${docker.image.prefix}/${project.artifactId}</repository>\n                <tag>${project.version}</tag>\n                <useMavenSettingsForAuth>true</useMavenSettingsForAuth>\n            </configuration>\n        </plugin>\n        <!-- end::plugin[] -->\n\n        <!-- tag::unpack[] -->\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-dependency-plugin</artifactId>\n            <executions>\n                <execution>\n                    <id>unpack</id>\n                    <phase>package</phase>\n                    <goals>\n                        <goal>unpack</goal>\n                    </goals>\n                    <configuration>\n                        <artifactItems>\n                            <artifactItem>\n                                <groupId>${project.groupId}</groupId>\n                                <artifactId>${project.artifactId}</artifactId>\n                                <version>${project.version}</version>\n                            </artifactItem>\n                        </artifactItems>\n                    </configuration>\n                </execution>\n            </executions>\n        </plugin>\n        <!-- end::unpack[] -->\n    </plugins>\n    \n重点两个参数： \n\n- repository：需要加上私服地址。\n- useMavenSettingsForAuth：设置为true。\n\n3.执行命令构建并上传镜像到私服\n\n    mvn clean install dockerfile:push   \n    \n## 绑定maven执行阶段\n\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n        <!-- tag::plugin[] -->\n        <plugin>\n            <groupId>com.spotify</groupId>\n            <artifactId>dockerfile-maven-plugin</artifactId>\n            <version>1.4.9</version>\n            <executions>\n                <execution>\n                  <id>default</id>\n                  <goals>\n                    <goal>build</goal>\n                    <goal>push</goal>\n                  </goals>\n                </execution>\n             </executions>\n            <configuration>\n                <repository>119.145.41.171:8082/${docker.image.prefix}/${project.artifactId}</repository>\n                <tag>${project.version}</tag>\n                <useMavenSettingsForAuth>true</useMavenSettingsForAuth>\n            </configuration>\n        </plugin>\n        <!-- end::plugin[] -->\n\n        <!-- tag::unpack[] -->\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-dependency-plugin</artifactId>\n            <executions>\n                <execution>\n                    <id>unpack</id>\n                    <phase>package</phase>\n                    <goals>\n                        <goal>unpack</goal>\n                    </goals>\n                    <configuration>\n                        <artifactItems>\n                            <artifactItem>\n                                <groupId>${project.groupId}</groupId>\n                                <artifactId>${project.artifactId}</artifactId>\n                                <version>${project.version}</version>\n                            </artifactItem>\n                        </artifactItems>\n                    </configuration>\n                </execution>\n            </executions>\n        </plugin>\n        <!-- end::unpack[] -->\n    </plugins>\n\n这样子就可以使用`mvn package`,`mvn deploy`命令了。也可以精准使用`mvn dockerfile:build`。          \n    \n## 启动容器\n\n    $ docker run -e \"SPRING_PROFILES_ACTIVE=prod\" -p 8080:8080 -t springio/gs-spring-boot-docker\n   \n或者\n\n    $ docker run -e \"SPRING_PROFILES_ACTIVE=dev\" -p 8080:8080 -t springio/gs-spring-boot-docker\n    \n\n## 调试容器内的应用\n\n                 ","source":"_posts/spring-boot-docker.md","raw":"---\ntitle: spring-boot集成docker部署\ndate: 2019-01-01 21:13:02\ncategories: spring-boot\ntags:\n---\n\n本章介绍spring-boot项目docker化构件，利用maven插件把spring-boot项目构件成docker镜像，并上传到自己的docker私服nexus3上。\n\n官方参考例子： \nhttps://spring.io/guides/gs/spring-boot-docker/\n\n## 快速在本机构件spring-boot项目镜像\n\n1.新建spring-boot项目。\n通过https://start.spring.io/  \n2.在项目根目录下添加Dockerfile文件，并编辑内容如下：\n\n    FROM openjdk:8-jdk-alpine\n    VOLUME /tmp\n    ARG DEPENDENCY=target/dependency\n    COPY ${DEPENDENCY}/BOOT-INF/lib /app/lib\n    COPY ${DEPENDENCY}/META-INF /app/META-INF\n    COPY ${DEPENDENCY}/BOOT-INF/classes /app\n    ENTRYPOINT [\"java\",\"-cp\",\"app:app/lib/*\",\"hello.Application\"]    \n3.配置maven插件，编辑pom.xml，添加：\n[dockerfile-maven 插件](https://github.com/spotify/dockerfile-maven)\n\n    <properties>\n       <docker.image.prefix>springio</docker.image.prefix>\n    </properties>\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>com.spotify</groupId>\n                <artifactId>dockerfile-maven-plugin</artifactId>\n                <version>1.4.9</version>\n                <configuration>\n                    <repository>${docker.image.prefix}/${project.artifactId}</repository>\n                    <tag>${project.version}</tag>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n    \n参数说明：\n- repository：指定镜像名称。\n- tag: 指定镜像标签，如果不指定，则默认是latest。   \n    \n为了确保在构件docker镜像之前，spring-boot jar包是解压的，添加下面插件配置：\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-dependency-plugin</artifactId>\n        <executions>\n            <execution>\n                <id>unpack</id>\n                <phase>package</phase>\n                <goals>\n                    <goal>unpack</goal>\n                </goals>\n                <configuration>\n                    <artifactItems>\n                        <artifactItem>\n                            <groupId>${project.groupId}</groupId>\n                            <artifactId>${project.artifactId}</artifactId>\n                            <version>${project.version}</version>\n                        </artifactItem>\n                    </artifactItems>\n                </configuration>\n            </execution>\n        </executions>\n    </plugin>\n   \n4.执行命令构件docker镜像\n\n    $ ./mvnw install dockerfile:build\n    \n    或者(如果么有mvnw)\n    \n    mvn install dockerfile:build\n    \n        \n## 上传到docker私服\n\n1.配置setting.xml\n\n    <server>\n      <id>ip:8082</id>\n      <username>admin</username>\n      <password>admin123</password>\n    </server>\n    \n注意id，必须为私服地址。\n\n\n2.配置pom.xml\n\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n        <!-- tag::plugin[] -->\n        <plugin>\n            <groupId>com.spotify</groupId>\n            <artifactId>dockerfile-maven-plugin</artifactId>\n            <version>1.4.9</version>\n            <configuration>\n                <repository>119.145.41.171:8082/${docker.image.prefix}/${project.artifactId}</repository>\n                <tag>${project.version}</tag>\n                <useMavenSettingsForAuth>true</useMavenSettingsForAuth>\n            </configuration>\n        </plugin>\n        <!-- end::plugin[] -->\n\n        <!-- tag::unpack[] -->\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-dependency-plugin</artifactId>\n            <executions>\n                <execution>\n                    <id>unpack</id>\n                    <phase>package</phase>\n                    <goals>\n                        <goal>unpack</goal>\n                    </goals>\n                    <configuration>\n                        <artifactItems>\n                            <artifactItem>\n                                <groupId>${project.groupId}</groupId>\n                                <artifactId>${project.artifactId}</artifactId>\n                                <version>${project.version}</version>\n                            </artifactItem>\n                        </artifactItems>\n                    </configuration>\n                </execution>\n            </executions>\n        </plugin>\n        <!-- end::unpack[] -->\n    </plugins>\n    \n重点两个参数： \n\n- repository：需要加上私服地址。\n- useMavenSettingsForAuth：设置为true。\n\n3.执行命令构建并上传镜像到私服\n\n    mvn clean install dockerfile:push   \n    \n## 绑定maven执行阶段\n\n    <plugins>\n        <plugin>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-maven-plugin</artifactId>\n        </plugin>\n        <!-- tag::plugin[] -->\n        <plugin>\n            <groupId>com.spotify</groupId>\n            <artifactId>dockerfile-maven-plugin</artifactId>\n            <version>1.4.9</version>\n            <executions>\n                <execution>\n                  <id>default</id>\n                  <goals>\n                    <goal>build</goal>\n                    <goal>push</goal>\n                  </goals>\n                </execution>\n             </executions>\n            <configuration>\n                <repository>119.145.41.171:8082/${docker.image.prefix}/${project.artifactId}</repository>\n                <tag>${project.version}</tag>\n                <useMavenSettingsForAuth>true</useMavenSettingsForAuth>\n            </configuration>\n        </plugin>\n        <!-- end::plugin[] -->\n\n        <!-- tag::unpack[] -->\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-dependency-plugin</artifactId>\n            <executions>\n                <execution>\n                    <id>unpack</id>\n                    <phase>package</phase>\n                    <goals>\n                        <goal>unpack</goal>\n                    </goals>\n                    <configuration>\n                        <artifactItems>\n                            <artifactItem>\n                                <groupId>${project.groupId}</groupId>\n                                <artifactId>${project.artifactId}</artifactId>\n                                <version>${project.version}</version>\n                            </artifactItem>\n                        </artifactItems>\n                    </configuration>\n                </execution>\n            </executions>\n        </plugin>\n        <!-- end::unpack[] -->\n    </plugins>\n\n这样子就可以使用`mvn package`,`mvn deploy`命令了。也可以精准使用`mvn dockerfile:build`。          \n    \n## 启动容器\n\n    $ docker run -e \"SPRING_PROFILES_ACTIVE=prod\" -p 8080:8080 -t springio/gs-spring-boot-docker\n   \n或者\n\n    $ docker run -e \"SPRING_PROFILES_ACTIVE=dev\" -p 8080:8080 -t springio/gs-spring-boot-docker\n    \n\n## 调试容器内的应用\n\n                 ","slug":"spring-boot-docker","published":1,"updated":"2019-06-16T14:38:33.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqft00bng4vauscik1q8","content":"<p>本章介绍spring-boot项目docker化构件，利用maven插件把spring-boot项目构件成docker镜像，并上传到自己的docker私服nexus3上。</p>\n<p>官方参考例子：<br><a href=\"https://spring.io/guides/gs/spring-boot-docker/\" target=\"_blank\" rel=\"noopener\">https://spring.io/guides/gs/spring-boot-docker/</a></p>\n<h2 id=\"快速在本机构件spring-boot项目镜像\"><a href=\"#快速在本机构件spring-boot项目镜像\" class=\"headerlink\" title=\"快速在本机构件spring-boot项目镜像\"></a>快速在本机构件spring-boot项目镜像</h2><p>1.新建spring-boot项目。<br>通过<a href=\"https://start.spring.io/\" target=\"_blank\" rel=\"noopener\">https://start.spring.io/</a><br>2.在项目根目录下添加Dockerfile文件，并编辑内容如下：</p>\n<pre><code>FROM openjdk:8-jdk-alpine\nVOLUME /tmp\nARG DEPENDENCY=target/dependency\nCOPY ${DEPENDENCY}/BOOT-INF/lib /app/lib\nCOPY ${DEPENDENCY}/META-INF /app/META-INF\nCOPY ${DEPENDENCY}/BOOT-INF/classes /app\nENTRYPOINT [&quot;java&quot;,&quot;-cp&quot;,&quot;app:app/lib/*&quot;,&quot;hello.Application&quot;]    \n</code></pre><p>3.配置maven插件，编辑pom.xml，添加：<br><a href=\"https://github.com/spotify/dockerfile-maven\" target=\"_blank\" rel=\"noopener\">dockerfile-maven 插件</a></p>\n<pre><code>&lt;properties&gt;\n   &lt;docker.image.prefix&gt;springio&lt;/docker.image.prefix&gt;\n&lt;/properties&gt;\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n            &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;\n            &lt;version&gt;1.4.9&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt;\n                &lt;tag&gt;${project.version}&lt;/tag&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre><p>参数说明：</p>\n<ul>\n<li>repository：指定镜像名称。</li>\n<li>tag: 指定镜像标签，如果不指定，则默认是latest。   </li>\n</ul>\n<p>为了确保在构件docker镜像之前，spring-boot jar包是解压的，添加下面插件配置：</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;unpack&lt;/id&gt;\n            &lt;phase&gt;package&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;unpack&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;configuration&gt;\n                &lt;artifactItems&gt;\n                    &lt;artifactItem&gt;\n                        &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n                        &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt;\n                        &lt;version&gt;${project.version}&lt;/version&gt;\n                    &lt;/artifactItem&gt;\n                &lt;/artifactItems&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>4.执行命令构件docker镜像</p>\n<pre><code>$ ./mvnw install dockerfile:build\n\n或者(如果么有mvnw)\n\nmvn install dockerfile:build\n</code></pre><h2 id=\"上传到docker私服\"><a href=\"#上传到docker私服\" class=\"headerlink\" title=\"上传到docker私服\"></a>上传到docker私服</h2><p>1.配置setting.xml</p>\n<pre><code>&lt;server&gt;\n  &lt;id&gt;ip:8082&lt;/id&gt;\n  &lt;username&gt;admin&lt;/username&gt;\n  &lt;password&gt;admin123&lt;/password&gt;\n&lt;/server&gt;\n</code></pre><p>注意id，必须为私服地址。</p>\n<p>2.配置pom.xml</p>\n<pre><code>&lt;plugins&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n    &lt;/plugin&gt;\n    &lt;!-- tag::plugin[] --&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n        &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;1.4.9&lt;/version&gt;\n        &lt;configuration&gt;\n            &lt;repository&gt;119.145.41.171:8082/${docker.image.prefix}/${project.artifactId}&lt;/repository&gt;\n            &lt;tag&gt;${project.version}&lt;/tag&gt;\n            &lt;useMavenSettingsForAuth&gt;true&lt;/useMavenSettingsForAuth&gt;\n        &lt;/configuration&gt;\n    &lt;/plugin&gt;\n    &lt;!-- end::plugin[] --&gt;\n\n    &lt;!-- tag::unpack[] --&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;\n        &lt;executions&gt;\n            &lt;execution&gt;\n                &lt;id&gt;unpack&lt;/id&gt;\n                &lt;phase&gt;package&lt;/phase&gt;\n                &lt;goals&gt;\n                    &lt;goal&gt;unpack&lt;/goal&gt;\n                &lt;/goals&gt;\n                &lt;configuration&gt;\n                    &lt;artifactItems&gt;\n                        &lt;artifactItem&gt;\n                            &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n                            &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt;\n                            &lt;version&gt;${project.version}&lt;/version&gt;\n                        &lt;/artifactItem&gt;\n                    &lt;/artifactItems&gt;\n                &lt;/configuration&gt;\n            &lt;/execution&gt;\n        &lt;/executions&gt;\n    &lt;/plugin&gt;\n    &lt;!-- end::unpack[] --&gt;\n&lt;/plugins&gt;\n</code></pre><p>重点两个参数： </p>\n<ul>\n<li>repository：需要加上私服地址。</li>\n<li>useMavenSettingsForAuth：设置为true。</li>\n</ul>\n<p>3.执行命令构建并上传镜像到私服</p>\n<pre><code>mvn clean install dockerfile:push   \n</code></pre><h2 id=\"绑定maven执行阶段\"><a href=\"#绑定maven执行阶段\" class=\"headerlink\" title=\"绑定maven执行阶段\"></a>绑定maven执行阶段</h2><pre><code>&lt;plugins&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n    &lt;/plugin&gt;\n    &lt;!-- tag::plugin[] --&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n        &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;1.4.9&lt;/version&gt;\n        &lt;executions&gt;\n            &lt;execution&gt;\n              &lt;id&gt;default&lt;/id&gt;\n              &lt;goals&gt;\n                &lt;goal&gt;build&lt;/goal&gt;\n                &lt;goal&gt;push&lt;/goal&gt;\n              &lt;/goals&gt;\n            &lt;/execution&gt;\n         &lt;/executions&gt;\n        &lt;configuration&gt;\n            &lt;repository&gt;119.145.41.171:8082/${docker.image.prefix}/${project.artifactId}&lt;/repository&gt;\n            &lt;tag&gt;${project.version}&lt;/tag&gt;\n            &lt;useMavenSettingsForAuth&gt;true&lt;/useMavenSettingsForAuth&gt;\n        &lt;/configuration&gt;\n    &lt;/plugin&gt;\n    &lt;!-- end::plugin[] --&gt;\n\n    &lt;!-- tag::unpack[] --&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;\n        &lt;executions&gt;\n            &lt;execution&gt;\n                &lt;id&gt;unpack&lt;/id&gt;\n                &lt;phase&gt;package&lt;/phase&gt;\n                &lt;goals&gt;\n                    &lt;goal&gt;unpack&lt;/goal&gt;\n                &lt;/goals&gt;\n                &lt;configuration&gt;\n                    &lt;artifactItems&gt;\n                        &lt;artifactItem&gt;\n                            &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n                            &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt;\n                            &lt;version&gt;${project.version}&lt;/version&gt;\n                        &lt;/artifactItem&gt;\n                    &lt;/artifactItems&gt;\n                &lt;/configuration&gt;\n            &lt;/execution&gt;\n        &lt;/executions&gt;\n    &lt;/plugin&gt;\n    &lt;!-- end::unpack[] --&gt;\n&lt;/plugins&gt;\n</code></pre><p>这样子就可以使用<code>mvn package</code>,<code>mvn deploy</code>命令了。也可以精准使用<code>mvn dockerfile:build</code>。          </p>\n<h2 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h2><pre><code>$ docker run -e &quot;SPRING_PROFILES_ACTIVE=prod&quot; -p 8080:8080 -t springio/gs-spring-boot-docker\n</code></pre><p>或者</p>\n<pre><code>$ docker run -e &quot;SPRING_PROFILES_ACTIVE=dev&quot; -p 8080:8080 -t springio/gs-spring-boot-docker\n</code></pre><h2 id=\"调试容器内的应用\"><a href=\"#调试容器内的应用\" class=\"headerlink\" title=\"调试容器内的应用\"></a>调试容器内的应用</h2>","site":{"data":{}},"excerpt":"","more":"<p>本章介绍spring-boot项目docker化构件，利用maven插件把spring-boot项目构件成docker镜像，并上传到自己的docker私服nexus3上。</p>\n<p>官方参考例子：<br><a href=\"https://spring.io/guides/gs/spring-boot-docker/\" target=\"_blank\" rel=\"noopener\">https://spring.io/guides/gs/spring-boot-docker/</a></p>\n<h2 id=\"快速在本机构件spring-boot项目镜像\"><a href=\"#快速在本机构件spring-boot项目镜像\" class=\"headerlink\" title=\"快速在本机构件spring-boot项目镜像\"></a>快速在本机构件spring-boot项目镜像</h2><p>1.新建spring-boot项目。<br>通过<a href=\"https://start.spring.io/\" target=\"_blank\" rel=\"noopener\">https://start.spring.io/</a><br>2.在项目根目录下添加Dockerfile文件，并编辑内容如下：</p>\n<pre><code>FROM openjdk:8-jdk-alpine\nVOLUME /tmp\nARG DEPENDENCY=target/dependency\nCOPY ${DEPENDENCY}/BOOT-INF/lib /app/lib\nCOPY ${DEPENDENCY}/META-INF /app/META-INF\nCOPY ${DEPENDENCY}/BOOT-INF/classes /app\nENTRYPOINT [&quot;java&quot;,&quot;-cp&quot;,&quot;app:app/lib/*&quot;,&quot;hello.Application&quot;]    \n</code></pre><p>3.配置maven插件，编辑pom.xml，添加：<br><a href=\"https://github.com/spotify/dockerfile-maven\" target=\"_blank\" rel=\"noopener\">dockerfile-maven 插件</a></p>\n<pre><code>&lt;properties&gt;\n   &lt;docker.image.prefix&gt;springio&lt;/docker.image.prefix&gt;\n&lt;/properties&gt;\n&lt;build&gt;\n    &lt;plugins&gt;\n        &lt;plugin&gt;\n            &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n            &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;\n            &lt;version&gt;1.4.9&lt;/version&gt;\n            &lt;configuration&gt;\n                &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt;\n                &lt;tag&gt;${project.version}&lt;/tag&gt;\n            &lt;/configuration&gt;\n        &lt;/plugin&gt;\n    &lt;/plugins&gt;\n&lt;/build&gt;\n</code></pre><p>参数说明：</p>\n<ul>\n<li>repository：指定镜像名称。</li>\n<li>tag: 指定镜像标签，如果不指定，则默认是latest。   </li>\n</ul>\n<p>为了确保在构件docker镜像之前，spring-boot jar包是解压的，添加下面插件配置：</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;id&gt;unpack&lt;/id&gt;\n            &lt;phase&gt;package&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;unpack&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;configuration&gt;\n                &lt;artifactItems&gt;\n                    &lt;artifactItem&gt;\n                        &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n                        &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt;\n                        &lt;version&gt;${project.version}&lt;/version&gt;\n                    &lt;/artifactItem&gt;\n                &lt;/artifactItems&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>4.执行命令构件docker镜像</p>\n<pre><code>$ ./mvnw install dockerfile:build\n\n或者(如果么有mvnw)\n\nmvn install dockerfile:build\n</code></pre><h2 id=\"上传到docker私服\"><a href=\"#上传到docker私服\" class=\"headerlink\" title=\"上传到docker私服\"></a>上传到docker私服</h2><p>1.配置setting.xml</p>\n<pre><code>&lt;server&gt;\n  &lt;id&gt;ip:8082&lt;/id&gt;\n  &lt;username&gt;admin&lt;/username&gt;\n  &lt;password&gt;admin123&lt;/password&gt;\n&lt;/server&gt;\n</code></pre><p>注意id，必须为私服地址。</p>\n<p>2.配置pom.xml</p>\n<pre><code>&lt;plugins&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n    &lt;/plugin&gt;\n    &lt;!-- tag::plugin[] --&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n        &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;1.4.9&lt;/version&gt;\n        &lt;configuration&gt;\n            &lt;repository&gt;119.145.41.171:8082/${docker.image.prefix}/${project.artifactId}&lt;/repository&gt;\n            &lt;tag&gt;${project.version}&lt;/tag&gt;\n            &lt;useMavenSettingsForAuth&gt;true&lt;/useMavenSettingsForAuth&gt;\n        &lt;/configuration&gt;\n    &lt;/plugin&gt;\n    &lt;!-- end::plugin[] --&gt;\n\n    &lt;!-- tag::unpack[] --&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;\n        &lt;executions&gt;\n            &lt;execution&gt;\n                &lt;id&gt;unpack&lt;/id&gt;\n                &lt;phase&gt;package&lt;/phase&gt;\n                &lt;goals&gt;\n                    &lt;goal&gt;unpack&lt;/goal&gt;\n                &lt;/goals&gt;\n                &lt;configuration&gt;\n                    &lt;artifactItems&gt;\n                        &lt;artifactItem&gt;\n                            &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n                            &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt;\n                            &lt;version&gt;${project.version}&lt;/version&gt;\n                        &lt;/artifactItem&gt;\n                    &lt;/artifactItems&gt;\n                &lt;/configuration&gt;\n            &lt;/execution&gt;\n        &lt;/executions&gt;\n    &lt;/plugin&gt;\n    &lt;!-- end::unpack[] --&gt;\n&lt;/plugins&gt;\n</code></pre><p>重点两个参数： </p>\n<ul>\n<li>repository：需要加上私服地址。</li>\n<li>useMavenSettingsForAuth：设置为true。</li>\n</ul>\n<p>3.执行命令构建并上传镜像到私服</p>\n<pre><code>mvn clean install dockerfile:push   \n</code></pre><h2 id=\"绑定maven执行阶段\"><a href=\"#绑定maven执行阶段\" class=\"headerlink\" title=\"绑定maven执行阶段\"></a>绑定maven执行阶段</h2><pre><code>&lt;plugins&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n    &lt;/plugin&gt;\n    &lt;!-- tag::plugin[] --&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;com.spotify&lt;/groupId&gt;\n        &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;1.4.9&lt;/version&gt;\n        &lt;executions&gt;\n            &lt;execution&gt;\n              &lt;id&gt;default&lt;/id&gt;\n              &lt;goals&gt;\n                &lt;goal&gt;build&lt;/goal&gt;\n                &lt;goal&gt;push&lt;/goal&gt;\n              &lt;/goals&gt;\n            &lt;/execution&gt;\n         &lt;/executions&gt;\n        &lt;configuration&gt;\n            &lt;repository&gt;119.145.41.171:8082/${docker.image.prefix}/${project.artifactId}&lt;/repository&gt;\n            &lt;tag&gt;${project.version}&lt;/tag&gt;\n            &lt;useMavenSettingsForAuth&gt;true&lt;/useMavenSettingsForAuth&gt;\n        &lt;/configuration&gt;\n    &lt;/plugin&gt;\n    &lt;!-- end::plugin[] --&gt;\n\n    &lt;!-- tag::unpack[] --&gt;\n    &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt;\n        &lt;executions&gt;\n            &lt;execution&gt;\n                &lt;id&gt;unpack&lt;/id&gt;\n                &lt;phase&gt;package&lt;/phase&gt;\n                &lt;goals&gt;\n                    &lt;goal&gt;unpack&lt;/goal&gt;\n                &lt;/goals&gt;\n                &lt;configuration&gt;\n                    &lt;artifactItems&gt;\n                        &lt;artifactItem&gt;\n                            &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;\n                            &lt;artifactId&gt;${project.artifactId}&lt;/artifactId&gt;\n                            &lt;version&gt;${project.version}&lt;/version&gt;\n                        &lt;/artifactItem&gt;\n                    &lt;/artifactItems&gt;\n                &lt;/configuration&gt;\n            &lt;/execution&gt;\n        &lt;/executions&gt;\n    &lt;/plugin&gt;\n    &lt;!-- end::unpack[] --&gt;\n&lt;/plugins&gt;\n</code></pre><p>这样子就可以使用<code>mvn package</code>,<code>mvn deploy</code>命令了。也可以精准使用<code>mvn dockerfile:build</code>。          </p>\n<h2 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h2><pre><code>$ docker run -e &quot;SPRING_PROFILES_ACTIVE=prod&quot; -p 8080:8080 -t springio/gs-spring-boot-docker\n</code></pre><p>或者</p>\n<pre><code>$ docker run -e &quot;SPRING_PROFILES_ACTIVE=dev&quot; -p 8080:8080 -t springio/gs-spring-boot-docker\n</code></pre><h2 id=\"调试容器内的应用\"><a href=\"#调试容器内的应用\" class=\"headerlink\" title=\"调试容器内的应用\"></a>调试容器内的应用</h2>"},{"title":"spring-boot过滤器篇","date":"2018-04-26T06:40:54.000Z","_content":"\n本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……\n\n## 在spring-boot项目中添加过滤器\n\n### 方式一\n\n1.创建类TestFilter,并实现Filter接口\n\n    package com.ymu.servicecommon.filter;\n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    import javax.servlet.*;\n    import java.io.IOException;\n    \n    /**\n     * 功能简述:<br>\n     *     过滤器配置测试。\n     *\n     * @author zmt\n     * @create 2018-04-26 下午5:15\n     * @updateTime\n     * @since 1.0.0\n     */\n    public class TestFilter implements Filter {\n    \n        protected final Logger logger = LogManager.getLogger(this.getClass());\n    \n        @Override\n        public void init(FilterConfig filterConfig) throws ServletException {\n            logger.debug(\">>>>testFilter init\");\n        }\n    \n        @Override\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n            logger.debug(\">>>>testFilter doFilter\");\n            filterChain.doFilter(servletRequest,servletResponse);\n        }\n    \n        @Override\n        public void destroy() {\n            logger.debug(\">>>>testFilter destroy\");\n        }\n    }\n\n2.注解bean\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean indexFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            return registration;\n        }\n    \n    }\n\n\n### 方式二\n\n1.创建过滤器IndexFilter2\n\n    package com.example.filter;\n    import java.io.IOException;\n    import javax.servlet.Filter;\n    import javax.servlet.FilterChain;\n    import javax.servlet.FilterConfig;\n    import javax.servlet.ServletException;\n    import javax.servlet.ServletRequest;\n    import javax.servlet.ServletResponse;\n    import javax.servlet.annotation.WebFilter;\n    \n    @WebFilter(urlPatterns = \"/*\", filterName = \"indexFilter2\")\n    public class IndexFilter2 implements Filter{\n      @Override\n      public void destroy() {\n        System.out.println(\"filter2 destroy method\");\n      }\n      @Override\n      public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n          throws IOException, ServletException {\n        System.out.println(\"filter2 doFilter method\");\n      }\n      @Override\n      public void init(FilterConfig arg0) throws ServletException {\n        System.out.println(\"filter2 init method\");\n      }\n    }\n\n2.在程序启动入库加入注解`ServletComponentScan`\n\n    @SpringBootApplication\n    @ServletComponentScan\n    public class SpringBootSimpleApplication {\n      public static void main(String[] args) {\n        SpringApplication.run(SpringBootSimpleApplication.class, args);\n      }\n    }\n\n## 多个过滤器调用顺序\n\n在spring-boot中通过注解`@Order`来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。\n\n1.代码设置\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.Test2Filter;\n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean testFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n        @Bean\n        public FilterRegistrationBean test2FilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"test2Filter\");\n            registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n    }\n    \n----------------------------------------------------    \n\n- 启动程序，观察执行顺序。\n\n{% asset_img a.png %} \n\n- 请求接口，观察执行顺序。\n\n{% asset_img b.png %}\n\n\n## 在过滤器中为请求添加http请求头信息\n\n1.定义类ModifyHttpServletRequestWrapper.java\n\n    package com.ymu.framework.web;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import javax.servlet.http.HttpServletRequestWrapper;\n    import java.util.*;\n    \n    public class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n     \n        private Map<String, String> customHeaders;\n     \n        public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n            super(request);\n            this.customHeaders = new HashMap<>();\n        }\n     \n        public void putHeader(String name, String value) {\n            this.customHeaders.put(name, value);\n        }\n     \n        public String getHeader(String name) {\n            String value = this.customHeaders.get(name);\n            if (value != null) {\n                return value;\n            }\n            return ((HttpServletRequest) getRequest()).getHeader(name);\n        }\n     \n        public Enumeration<String> getHeaderNames() {\n            Set<String> set = new HashSet<>(customHeaders.keySet());\n            Enumeration<String> enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n            while (enumeration.hasMoreElements()) {\n                String name = enumeration.nextElement();\n                set.add(name);\n            }\n            return Collections.enumeration(set);\n        }\n     \n    }\n    \n2.定义过滤器，编辑\n    \n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(\">>>>indexFilter doFilter\");\n\n        //添加或者更改header信息\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        String apiVersion = request.getHeader(\"Content-Version\");\n        if (null == apiVersion || \"\".equals(apiVersion)) {\n            ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n            requestWrapper.putHeader(\"Content-Version\",\"-1\");\n            filterChain.doFilter(requestWrapper,servletResponse);\n        } else {\n            filterChain.doFilter(request,servletResponse);\n        }\n    }   \n\n    重点代码：\n    ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n    requestWrapper.putHeader(\"Content-Version\",\"-1\");\n    filterChain.doFilter(requestWrapper,servletResponse);","source":"_posts/spring-boot-filter.md","raw":"---\ntitle: spring-boot过滤器篇\ndate: 2018-04-26 14:40:54\ncategories: spring-boot\ntags: spring-boot-filter\n---\n\n本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……\n\n## 在spring-boot项目中添加过滤器\n\n### 方式一\n\n1.创建类TestFilter,并实现Filter接口\n\n    package com.ymu.servicecommon.filter;\n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    import javax.servlet.*;\n    import java.io.IOException;\n    \n    /**\n     * 功能简述:<br>\n     *     过滤器配置测试。\n     *\n     * @author zmt\n     * @create 2018-04-26 下午5:15\n     * @updateTime\n     * @since 1.0.0\n     */\n    public class TestFilter implements Filter {\n    \n        protected final Logger logger = LogManager.getLogger(this.getClass());\n    \n        @Override\n        public void init(FilterConfig filterConfig) throws ServletException {\n            logger.debug(\">>>>testFilter init\");\n        }\n    \n        @Override\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n            logger.debug(\">>>>testFilter doFilter\");\n            filterChain.doFilter(servletRequest,servletResponse);\n        }\n    \n        @Override\n        public void destroy() {\n            logger.debug(\">>>>testFilter destroy\");\n        }\n    }\n\n2.注解bean\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean indexFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            return registration;\n        }\n    \n    }\n\n\n### 方式二\n\n1.创建过滤器IndexFilter2\n\n    package com.example.filter;\n    import java.io.IOException;\n    import javax.servlet.Filter;\n    import javax.servlet.FilterChain;\n    import javax.servlet.FilterConfig;\n    import javax.servlet.ServletException;\n    import javax.servlet.ServletRequest;\n    import javax.servlet.ServletResponse;\n    import javax.servlet.annotation.WebFilter;\n    \n    @WebFilter(urlPatterns = \"/*\", filterName = \"indexFilter2\")\n    public class IndexFilter2 implements Filter{\n      @Override\n      public void destroy() {\n        System.out.println(\"filter2 destroy method\");\n      }\n      @Override\n      public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n          throws IOException, ServletException {\n        System.out.println(\"filter2 doFilter method\");\n      }\n      @Override\n      public void init(FilterConfig arg0) throws ServletException {\n        System.out.println(\"filter2 init method\");\n      }\n    }\n\n2.在程序启动入库加入注解`ServletComponentScan`\n\n    @SpringBootApplication\n    @ServletComponentScan\n    public class SpringBootSimpleApplication {\n      public static void main(String[] args) {\n        SpringApplication.run(SpringBootSimpleApplication.class, args);\n      }\n    }\n\n## 多个过滤器调用顺序\n\n在spring-boot中通过注解`@Order`来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。\n\n1.代码设置\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.Test2Filter;\n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean testFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n        @Bean\n        public FilterRegistrationBean test2FilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"test2Filter\");\n            registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n    }\n    \n----------------------------------------------------    \n\n- 启动程序，观察执行顺序。\n\n{% asset_img a.png %} \n\n- 请求接口，观察执行顺序。\n\n{% asset_img b.png %}\n\n\n## 在过滤器中为请求添加http请求头信息\n\n1.定义类ModifyHttpServletRequestWrapper.java\n\n    package com.ymu.framework.web;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import javax.servlet.http.HttpServletRequestWrapper;\n    import java.util.*;\n    \n    public class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n     \n        private Map<String, String> customHeaders;\n     \n        public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n            super(request);\n            this.customHeaders = new HashMap<>();\n        }\n     \n        public void putHeader(String name, String value) {\n            this.customHeaders.put(name, value);\n        }\n     \n        public String getHeader(String name) {\n            String value = this.customHeaders.get(name);\n            if (value != null) {\n                return value;\n            }\n            return ((HttpServletRequest) getRequest()).getHeader(name);\n        }\n     \n        public Enumeration<String> getHeaderNames() {\n            Set<String> set = new HashSet<>(customHeaders.keySet());\n            Enumeration<String> enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n            while (enumeration.hasMoreElements()) {\n                String name = enumeration.nextElement();\n                set.add(name);\n            }\n            return Collections.enumeration(set);\n        }\n     \n    }\n    \n2.定义过滤器，编辑\n    \n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(\">>>>indexFilter doFilter\");\n\n        //添加或者更改header信息\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        String apiVersion = request.getHeader(\"Content-Version\");\n        if (null == apiVersion || \"\".equals(apiVersion)) {\n            ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n            requestWrapper.putHeader(\"Content-Version\",\"-1\");\n            filterChain.doFilter(requestWrapper,servletResponse);\n        } else {\n            filterChain.doFilter(request,servletResponse);\n        }\n    }   \n\n    重点代码：\n    ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n    requestWrapper.putHeader(\"Content-Version\",\"-1\");\n    filterChain.doFilter(requestWrapper,servletResponse);","slug":"spring-boot-filter","published":1,"updated":"2019-06-16T14:38:33.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfv00brg4va51p27apg","content":"<p>本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……</p>\n<h2 id=\"在spring-boot项目中添加过滤器\"><a href=\"#在spring-boot项目中添加过滤器\" class=\"headerlink\" title=\"在spring-boot项目中添加过滤器\"></a>在spring-boot项目中添加过滤器</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>1.创建类TestFilter,并实现Filter接口</p>\n<pre><code>package com.ymu.servicecommon.filter;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\n/**\n * 功能简述:&lt;br&gt;\n *     过滤器配置测试。\n *\n * @author zmt\n * @create 2018-04-26 下午5:15\n * @updateTime\n * @since 1.0.0\n */\npublic class TestFilter implements Filter {\n\n    protected final Logger logger = LogManager.getLogger(this.getClass());\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter init&quot;);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter doFilter&quot;);\n        filterChain.doFilter(servletRequest,servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter destroy&quot;);\n    }\n}\n</code></pre><p>2.注解bean</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean indexFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        return registration;\n    }\n\n}\n</code></pre><h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>1.创建过滤器IndexFilter2</p>\n<pre><code>package com.example.filter;\nimport java.io.IOException;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\n\n@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;indexFilter2&quot;)\npublic class IndexFilter2 implements Filter{\n  @Override\n  public void destroy() {\n    System.out.println(&quot;filter2 destroy method&quot;);\n  }\n  @Override\n  public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n      throws IOException, ServletException {\n    System.out.println(&quot;filter2 doFilter method&quot;);\n  }\n  @Override\n  public void init(FilterConfig arg0) throws ServletException {\n    System.out.println(&quot;filter2 init method&quot;);\n  }\n}\n</code></pre><p>2.在程序启动入库加入注解<code>ServletComponentScan</code></p>\n<pre><code>@SpringBootApplication\n@ServletComponentScan\npublic class SpringBootSimpleApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(SpringBootSimpleApplication.class, args);\n  }\n}\n</code></pre><h2 id=\"多个过滤器调用顺序\"><a href=\"#多个过滤器调用顺序\" class=\"headerlink\" title=\"多个过滤器调用顺序\"></a>多个过滤器调用顺序</h2><p>在spring-boot中通过注解<code>@Order</code>来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。</p>\n<p>1.代码设置</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.Test2Filter;\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n    @Bean\n    public FilterRegistrationBean test2FilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;test2Filter&quot;);\n        registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n}\n</code></pre><hr>\n<ul>\n<li>启动程序，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/a.png\"> \n<ul>\n<li>请求接口，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/b.png\">\n<h2 id=\"在过滤器中为请求添加http请求头信息\"><a href=\"#在过滤器中为请求添加http请求头信息\" class=\"headerlink\" title=\"在过滤器中为请求添加http请求头信息\"></a>在过滤器中为请求添加http请求头信息</h2><p>1.定义类ModifyHttpServletRequestWrapper.java</p>\n<pre><code>package com.ymu.framework.web;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.util.*;\n\npublic class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n\n    private Map&lt;String, String&gt; customHeaders;\n\n    public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n        super(request);\n        this.customHeaders = new HashMap&lt;&gt;();\n    }\n\n    public void putHeader(String name, String value) {\n        this.customHeaders.put(name, value);\n    }\n\n    public String getHeader(String name) {\n        String value = this.customHeaders.get(name);\n        if (value != null) {\n            return value;\n        }\n        return ((HttpServletRequest) getRequest()).getHeader(name);\n    }\n\n    public Enumeration&lt;String&gt; getHeaderNames() {\n        Set&lt;String&gt; set = new HashSet&lt;&gt;(customHeaders.keySet());\n        Enumeration&lt;String&gt; enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n        while (enumeration.hasMoreElements()) {\n            String name = enumeration.nextElement();\n            set.add(name);\n        }\n        return Collections.enumeration(set);\n    }\n\n}\n</code></pre><p>2.定义过滤器，编辑</p>\n<pre><code>@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    logger.debug(&quot;&gt;&gt;&gt;&gt;indexFilter doFilter&quot;);\n\n    //添加或者更改header信息\n    HttpServletRequest request = (HttpServletRequest) servletRequest;\n    String apiVersion = request.getHeader(&quot;Content-Version&quot;);\n    if (null == apiVersion || &quot;&quot;.equals(apiVersion)) {\n        ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n        requestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\n        filterChain.doFilter(requestWrapper,servletResponse);\n    } else {\n        filterChain.doFilter(request,servletResponse);\n    }\n}   \n\n重点代码：\nModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\nrequestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\nfilterChain.doFilter(requestWrapper,servletResponse);\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……</p>\n<h2 id=\"在spring-boot项目中添加过滤器\"><a href=\"#在spring-boot项目中添加过滤器\" class=\"headerlink\" title=\"在spring-boot项目中添加过滤器\"></a>在spring-boot项目中添加过滤器</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>1.创建类TestFilter,并实现Filter接口</p>\n<pre><code>package com.ymu.servicecommon.filter;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\n/**\n * 功能简述:&lt;br&gt;\n *     过滤器配置测试。\n *\n * @author zmt\n * @create 2018-04-26 下午5:15\n * @updateTime\n * @since 1.0.0\n */\npublic class TestFilter implements Filter {\n\n    protected final Logger logger = LogManager.getLogger(this.getClass());\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter init&quot;);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter doFilter&quot;);\n        filterChain.doFilter(servletRequest,servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter destroy&quot;);\n    }\n}\n</code></pre><p>2.注解bean</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean indexFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        return registration;\n    }\n\n}\n</code></pre><h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>1.创建过滤器IndexFilter2</p>\n<pre><code>package com.example.filter;\nimport java.io.IOException;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\n\n@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;indexFilter2&quot;)\npublic class IndexFilter2 implements Filter{\n  @Override\n  public void destroy() {\n    System.out.println(&quot;filter2 destroy method&quot;);\n  }\n  @Override\n  public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n      throws IOException, ServletException {\n    System.out.println(&quot;filter2 doFilter method&quot;);\n  }\n  @Override\n  public void init(FilterConfig arg0) throws ServletException {\n    System.out.println(&quot;filter2 init method&quot;);\n  }\n}\n</code></pre><p>2.在程序启动入库加入注解<code>ServletComponentScan</code></p>\n<pre><code>@SpringBootApplication\n@ServletComponentScan\npublic class SpringBootSimpleApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(SpringBootSimpleApplication.class, args);\n  }\n}\n</code></pre><h2 id=\"多个过滤器调用顺序\"><a href=\"#多个过滤器调用顺序\" class=\"headerlink\" title=\"多个过滤器调用顺序\"></a>多个过滤器调用顺序</h2><p>在spring-boot中通过注解<code>@Order</code>来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。</p>\n<p>1.代码设置</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.Test2Filter;\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n    @Bean\n    public FilterRegistrationBean test2FilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;test2Filter&quot;);\n        registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n}\n</code></pre><hr>\n<ul>\n<li>启动程序，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/a.png\"> \n<ul>\n<li>请求接口，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/b.png\">\n<h2 id=\"在过滤器中为请求添加http请求头信息\"><a href=\"#在过滤器中为请求添加http请求头信息\" class=\"headerlink\" title=\"在过滤器中为请求添加http请求头信息\"></a>在过滤器中为请求添加http请求头信息</h2><p>1.定义类ModifyHttpServletRequestWrapper.java</p>\n<pre><code>package com.ymu.framework.web;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.util.*;\n\npublic class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n\n    private Map&lt;String, String&gt; customHeaders;\n\n    public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n        super(request);\n        this.customHeaders = new HashMap&lt;&gt;();\n    }\n\n    public void putHeader(String name, String value) {\n        this.customHeaders.put(name, value);\n    }\n\n    public String getHeader(String name) {\n        String value = this.customHeaders.get(name);\n        if (value != null) {\n            return value;\n        }\n        return ((HttpServletRequest) getRequest()).getHeader(name);\n    }\n\n    public Enumeration&lt;String&gt; getHeaderNames() {\n        Set&lt;String&gt; set = new HashSet&lt;&gt;(customHeaders.keySet());\n        Enumeration&lt;String&gt; enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n        while (enumeration.hasMoreElements()) {\n            String name = enumeration.nextElement();\n            set.add(name);\n        }\n        return Collections.enumeration(set);\n    }\n\n}\n</code></pre><p>2.定义过滤器，编辑</p>\n<pre><code>@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    logger.debug(&quot;&gt;&gt;&gt;&gt;indexFilter doFilter&quot;);\n\n    //添加或者更改header信息\n    HttpServletRequest request = (HttpServletRequest) servletRequest;\n    String apiVersion = request.getHeader(&quot;Content-Version&quot;);\n    if (null == apiVersion || &quot;&quot;.equals(apiVersion)) {\n        ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n        requestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\n        filterChain.doFilter(requestWrapper,servletResponse);\n    } else {\n        filterChain.doFilter(request,servletResponse);\n    }\n}   \n\n重点代码：\nModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\nrequestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\nfilterChain.doFilter(requestWrapper,servletResponse);\n</code></pre>"},{"title":"spring-boot异常统一处理","date":"2017-09-30T01:33:12.000Z","_content":"\n参考： \nhttps://www.infoq.cn/article/x-XFMSsN8IrDO2YR0T82\n\nhttps://my.oschina.net/u/4007037/blog/3049044 ","source":"_posts/spring-boot-exception.md","raw":"---\ntitle: spring-boot异常统一处理\ndate: 2017-09-30 09:33:12\ncategories: spring-boot\ntags:\n---\n\n参考： \nhttps://www.infoq.cn/article/x-XFMSsN8IrDO2YR0T82\n\nhttps://my.oschina.net/u/4007037/blog/3049044 ","slug":"spring-boot-exception","published":1,"updated":"2019-06-16T14:38:33.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfw00btg4va2keva0wb","content":"<p>参考：<br><a href=\"https://www.infoq.cn/article/x-XFMSsN8IrDO2YR0T82\" target=\"_blank\" rel=\"noopener\">https://www.infoq.cn/article/x-XFMSsN8IrDO2YR0T82</a></p>\n<p><a href=\"https://my.oschina.net/u/4007037/blog/3049044\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/4007037/blog/3049044</a> </p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<br><a href=\"https://www.infoq.cn/article/x-XFMSsN8IrDO2YR0T82\" target=\"_blank\" rel=\"noopener\">https://www.infoq.cn/article/x-XFMSsN8IrDO2YR0T82</a></p>\n<p><a href=\"https://my.oschina.net/u/4007037/blog/3049044\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/4007037/blog/3049044</a> </p>\n"},{"title":"spring-boot发布包jar的秘密","date":"2018-10-19T09:27:44.000Z","_content":"\n### 修改spring-boot可执行jar包\n\n本主题介绍的实际是对java可执行jar包的修改问题。 \n\n在生产环境中，有时候我们发现了个小bug，开发迅速修改代码后，很多时候我们不得不重新发布一个新的可执行jar包上去替换掉。   \n但是这样就有个问题了，如果开发人员改动了很多的源码，这样我们就不得不重新测试检查各个功能了。而在生产环境，我们只是想仅仅替换改动的一点点东西。 \n\n在war包运行的情况下，我们可以直接在tomcat对应应用解压文件夹下替换某个文件即可。但是打成jar包就没那么方便了。\n\n所以，这里介绍两种方式达成目的：只换jar包中的某个文件资源：\n\n#### 方法一：用解压工具\n\n1.下载服务器中的jar包。  \n2.用360等相关解压工具直接双击`jar`包，打开。  \n3.拖动改动后的文件进去覆盖`jar`中的。  \n4.关闭解压工具软件。 \n5.重新上传改动后的`jar`包到服务器。   \n6.执行查看改动后效果。\n\n_注意：_ 整个过程不能解压下载下来的`jar`包。\n\n#### 方法二：java命令\n\n1.下载服务器jar包。    \n2.解压jar包\n\n    shell>jar xvf micro-service-core-0608-5-SC-SNAPSHOT.jar\n\n解压后三个目录：\nBOOT-INF、META-INF、org\n\n3.把修改过的文件在BOOT-INF下对应的文件夹中覆盖\n\n4.重新打回jar包\n     \n注意：不能覆盖META-INF下面的MANIFEST.MF文件，不能压缩打包。所以直接用下面命令行打包即可。\n     \n    shell>jar cvf0M core.jar BOOT-INF META-INF org\n\n执行完在当前目录下应该出现core.jar的新jar包。\n\n5.验证新jar包是否可执行（正确打包）\n\n    shell>jar cvf0M core.jar BOOT-INF META-INF org\n\n如果能正常启动，则重新打包成功\n\n","source":"_posts/spring-boot-jar.md","raw":"---\ntitle: spring-boot发布包jar的秘密\ndate: 2018-10-19 17:27:44\ncategories: spring-boot\ntags: spring-boot-jar\n---\n\n### 修改spring-boot可执行jar包\n\n本主题介绍的实际是对java可执行jar包的修改问题。 \n\n在生产环境中，有时候我们发现了个小bug，开发迅速修改代码后，很多时候我们不得不重新发布一个新的可执行jar包上去替换掉。   \n但是这样就有个问题了，如果开发人员改动了很多的源码，这样我们就不得不重新测试检查各个功能了。而在生产环境，我们只是想仅仅替换改动的一点点东西。 \n\n在war包运行的情况下，我们可以直接在tomcat对应应用解压文件夹下替换某个文件即可。但是打成jar包就没那么方便了。\n\n所以，这里介绍两种方式达成目的：只换jar包中的某个文件资源：\n\n#### 方法一：用解压工具\n\n1.下载服务器中的jar包。  \n2.用360等相关解压工具直接双击`jar`包，打开。  \n3.拖动改动后的文件进去覆盖`jar`中的。  \n4.关闭解压工具软件。 \n5.重新上传改动后的`jar`包到服务器。   \n6.执行查看改动后效果。\n\n_注意：_ 整个过程不能解压下载下来的`jar`包。\n\n#### 方法二：java命令\n\n1.下载服务器jar包。    \n2.解压jar包\n\n    shell>jar xvf micro-service-core-0608-5-SC-SNAPSHOT.jar\n\n解压后三个目录：\nBOOT-INF、META-INF、org\n\n3.把修改过的文件在BOOT-INF下对应的文件夹中覆盖\n\n4.重新打回jar包\n     \n注意：不能覆盖META-INF下面的MANIFEST.MF文件，不能压缩打包。所以直接用下面命令行打包即可。\n     \n    shell>jar cvf0M core.jar BOOT-INF META-INF org\n\n执行完在当前目录下应该出现core.jar的新jar包。\n\n5.验证新jar包是否可执行（正确打包）\n\n    shell>jar cvf0M core.jar BOOT-INF META-INF org\n\n如果能正常启动，则重新打包成功\n\n","slug":"spring-boot-jar","published":1,"updated":"2019-06-16T14:38:33.975Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfx00bxg4vadu7tgskw","content":"<h3 id=\"修改spring-boot可执行jar包\"><a href=\"#修改spring-boot可执行jar包\" class=\"headerlink\" title=\"修改spring-boot可执行jar包\"></a>修改spring-boot可执行jar包</h3><p>本主题介绍的实际是对java可执行jar包的修改问题。 </p>\n<p>在生产环境中，有时候我们发现了个小bug，开发迅速修改代码后，很多时候我们不得不重新发布一个新的可执行jar包上去替换掉。<br>但是这样就有个问题了，如果开发人员改动了很多的源码，这样我们就不得不重新测试检查各个功能了。而在生产环境，我们只是想仅仅替换改动的一点点东西。 </p>\n<p>在war包运行的情况下，我们可以直接在tomcat对应应用解压文件夹下替换某个文件即可。但是打成jar包就没那么方便了。</p>\n<p>所以，这里介绍两种方式达成目的：只换jar包中的某个文件资源：</p>\n<h4 id=\"方法一：用解压工具\"><a href=\"#方法一：用解压工具\" class=\"headerlink\" title=\"方法一：用解压工具\"></a>方法一：用解压工具</h4><p>1.下载服务器中的jar包。<br>2.用360等相关解压工具直接双击<code>jar</code>包，打开。<br>3.拖动改动后的文件进去覆盖<code>jar</code>中的。<br>4.关闭解压工具软件。<br>5.重新上传改动后的<code>jar</code>包到服务器。<br>6.执行查看改动后效果。</p>\n<p><em>注意：</em> 整个过程不能解压下载下来的<code>jar</code>包。</p>\n<h4 id=\"方法二：java命令\"><a href=\"#方法二：java命令\" class=\"headerlink\" title=\"方法二：java命令\"></a>方法二：java命令</h4><p>1.下载服务器jar包。<br>2.解压jar包</p>\n<pre><code>shell&gt;jar xvf micro-service-core-0608-5-SC-SNAPSHOT.jar\n</code></pre><p>解压后三个目录：<br>BOOT-INF、META-INF、org</p>\n<p>3.把修改过的文件在BOOT-INF下对应的文件夹中覆盖</p>\n<p>4.重新打回jar包</p>\n<p>注意：不能覆盖META-INF下面的MANIFEST.MF文件，不能压缩打包。所以直接用下面命令行打包即可。</p>\n<pre><code>shell&gt;jar cvf0M core.jar BOOT-INF META-INF org\n</code></pre><p>执行完在当前目录下应该出现core.jar的新jar包。</p>\n<p>5.验证新jar包是否可执行（正确打包）</p>\n<pre><code>shell&gt;jar cvf0M core.jar BOOT-INF META-INF org\n</code></pre><p>如果能正常启动，则重新打包成功</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"修改spring-boot可执行jar包\"><a href=\"#修改spring-boot可执行jar包\" class=\"headerlink\" title=\"修改spring-boot可执行jar包\"></a>修改spring-boot可执行jar包</h3><p>本主题介绍的实际是对java可执行jar包的修改问题。 </p>\n<p>在生产环境中，有时候我们发现了个小bug，开发迅速修改代码后，很多时候我们不得不重新发布一个新的可执行jar包上去替换掉。<br>但是这样就有个问题了，如果开发人员改动了很多的源码，这样我们就不得不重新测试检查各个功能了。而在生产环境，我们只是想仅仅替换改动的一点点东西。 </p>\n<p>在war包运行的情况下，我们可以直接在tomcat对应应用解压文件夹下替换某个文件即可。但是打成jar包就没那么方便了。</p>\n<p>所以，这里介绍两种方式达成目的：只换jar包中的某个文件资源：</p>\n<h4 id=\"方法一：用解压工具\"><a href=\"#方法一：用解压工具\" class=\"headerlink\" title=\"方法一：用解压工具\"></a>方法一：用解压工具</h4><p>1.下载服务器中的jar包。<br>2.用360等相关解压工具直接双击<code>jar</code>包，打开。<br>3.拖动改动后的文件进去覆盖<code>jar</code>中的。<br>4.关闭解压工具软件。<br>5.重新上传改动后的<code>jar</code>包到服务器。<br>6.执行查看改动后效果。</p>\n<p><em>注意：</em> 整个过程不能解压下载下来的<code>jar</code>包。</p>\n<h4 id=\"方法二：java命令\"><a href=\"#方法二：java命令\" class=\"headerlink\" title=\"方法二：java命令\"></a>方法二：java命令</h4><p>1.下载服务器jar包。<br>2.解压jar包</p>\n<pre><code>shell&gt;jar xvf micro-service-core-0608-5-SC-SNAPSHOT.jar\n</code></pre><p>解压后三个目录：<br>BOOT-INF、META-INF、org</p>\n<p>3.把修改过的文件在BOOT-INF下对应的文件夹中覆盖</p>\n<p>4.重新打回jar包</p>\n<p>注意：不能覆盖META-INF下面的MANIFEST.MF文件，不能压缩打包。所以直接用下面命令行打包即可。</p>\n<pre><code>shell&gt;jar cvf0M core.jar BOOT-INF META-INF org\n</code></pre><p>执行完在当前目录下应该出现core.jar的新jar包。</p>\n<p>5.验证新jar包是否可执行（正确打包）</p>\n<pre><code>shell&gt;jar cvf0M core.jar BOOT-INF META-INF org\n</code></pre><p>如果能正常启动，则重新打包成功</p>\n"},{"title":"spring-boot消息国际化","date":"2018-05-18T01:58:40.000Z","_content":"","source":"_posts/spring-boot-messages.md","raw":"---\ntitle: spring-boot消息国际化\ndate: 2018-05-18 09:58:40\ncategories: spring-boot\ntags: spring mvc国际化\n---\n","slug":"spring-boot-messages","published":1,"updated":"2019-06-16T14:38:33.976Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfy00bzg4vaxh2408tu","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"spring-boot使用记录","date":"2019-05-03T17:09:30.000Z","_content":"\n收集spring boot使用过程中的常用点……\n\n## 常见注解\n\n### 注解@ConditionalOnMissingBean\n\n- 作用：标识是否要初始化该Bean。\n\n例子： \n\n    @Bean\n    @ConditionalOnMissingBean\n    public DataSourceConnectionProvider dataSourceConnectionProvider(\n            DataSource dataSource) {\n        return new DataSourceConnectionProvider(\n                new TransactionAwareDataSourceProxy(dataSource));\n    }\n\n上面初始化一个Bean，但是加了注解@ConditionalOnMissingBean。意思是：如果已经有初始化DataSourceConnectionProvider的Bean，该方法将不会执行。如：\n\n    @Bean\n    public DataSourceConnectionProvider connectionProvider() {\n        return new DataSourceConnectionProvider(new TransactionAwareDataSourceProxy(DataSourceSpyUtils.conversion(environment,dynamicDataSource)));\n    }\n\n上面这段代码，初始化了该Bean，所以上面的将不会再执行。\n\n- 用处：常用在spring boot starter中。\n\n### @ConditionalOnxxx相关注解总结\n\n参考：     \nhttps://www.cnblogs.com/yixianyixian/p/7346894.html     \nhttps://blog.csdn.net/xcy1193068639/article/details/81491071\n\n### 自定义Conditional\n\nhttps://blog.csdn.net/zhanglu1236789/article/details/78999496\n\n## 集成hikari数据源\n\n### 错误一，maxLifetime问题\n\n    The last packet successfully received from the server was 1,057,018 milliseconds ago.  The last packet sent successfully to the server was 1,057,026 milliseconds ago.). Possibly consider using a shorter maxLifetime value.\n\n该警告代码在：com.zaxxer.hikari.pool.PoolBase类中，可以debbuger进去看。 \n\n解决：\n\n## Redis使用错误\n\n- 错误描述：\n\n\n    Spring Data Redis - Could not safely identify store assignment for repositor\n    \n- 原因分析：\n\n1.使用了Spring data jpa 作为持久层框架    \n2.使用了Spring Redis 缓存\n\n这是 Spring Boot 的 Autoconfigure 包干的好事，里面有个叫 RedisRepositoriesAutoConfiguration 的类会检查当前的 classpath 里面是不是存在 Jedis 和 @EnableRedisRepositories，如果存在，无论你的代码有没有用，他都会帮你自动启用这个注解（不带参数），于是整个 classpath 的类都会被扫进去。\n\n- 解决：\n\n解决方法也很简单，RedisRepositoriesAutoConfiguration 里面会判断 spring.data.redis.repositories.enable 这个配置项是否存在，不存在、存在和值为 true 都会生效，只要显式设置它为 false 即可；如果不想写配置信息，也不需要用 RedisRepository 的话（不影响 RedisTemplate），可以通过另外一个判断条件——检查 RedisRepositoryFactoryBean 这个 Bean 是否存在来处理，默认是不存在则执行这个 AutoConfiguration，只要自己在代码里造一个 RedisRepositoryFactoryBean 即可，比如这样\n\n    @Bean\n    public RedisRepositoryFactoryBean redisRepositoryFactoryBean() {\n        return null;\n    }\n    \n也可以直接禁用redis的repositories\n\n    spring.data.redis.repositories.enabled = false    \n\n    ","source":"_posts/spring-boot-record.md","raw":"---\ntitle: spring-boot使用记录\ndate: 2019-05-04 01:09:30\ncategories: spring-boot\ntags:\n---\n\n收集spring boot使用过程中的常用点……\n\n## 常见注解\n\n### 注解@ConditionalOnMissingBean\n\n- 作用：标识是否要初始化该Bean。\n\n例子： \n\n    @Bean\n    @ConditionalOnMissingBean\n    public DataSourceConnectionProvider dataSourceConnectionProvider(\n            DataSource dataSource) {\n        return new DataSourceConnectionProvider(\n                new TransactionAwareDataSourceProxy(dataSource));\n    }\n\n上面初始化一个Bean，但是加了注解@ConditionalOnMissingBean。意思是：如果已经有初始化DataSourceConnectionProvider的Bean，该方法将不会执行。如：\n\n    @Bean\n    public DataSourceConnectionProvider connectionProvider() {\n        return new DataSourceConnectionProvider(new TransactionAwareDataSourceProxy(DataSourceSpyUtils.conversion(environment,dynamicDataSource)));\n    }\n\n上面这段代码，初始化了该Bean，所以上面的将不会再执行。\n\n- 用处：常用在spring boot starter中。\n\n### @ConditionalOnxxx相关注解总结\n\n参考：     \nhttps://www.cnblogs.com/yixianyixian/p/7346894.html     \nhttps://blog.csdn.net/xcy1193068639/article/details/81491071\n\n### 自定义Conditional\n\nhttps://blog.csdn.net/zhanglu1236789/article/details/78999496\n\n## 集成hikari数据源\n\n### 错误一，maxLifetime问题\n\n    The last packet successfully received from the server was 1,057,018 milliseconds ago.  The last packet sent successfully to the server was 1,057,026 milliseconds ago.). Possibly consider using a shorter maxLifetime value.\n\n该警告代码在：com.zaxxer.hikari.pool.PoolBase类中，可以debbuger进去看。 \n\n解决：\n\n## Redis使用错误\n\n- 错误描述：\n\n\n    Spring Data Redis - Could not safely identify store assignment for repositor\n    \n- 原因分析：\n\n1.使用了Spring data jpa 作为持久层框架    \n2.使用了Spring Redis 缓存\n\n这是 Spring Boot 的 Autoconfigure 包干的好事，里面有个叫 RedisRepositoriesAutoConfiguration 的类会检查当前的 classpath 里面是不是存在 Jedis 和 @EnableRedisRepositories，如果存在，无论你的代码有没有用，他都会帮你自动启用这个注解（不带参数），于是整个 classpath 的类都会被扫进去。\n\n- 解决：\n\n解决方法也很简单，RedisRepositoriesAutoConfiguration 里面会判断 spring.data.redis.repositories.enable 这个配置项是否存在，不存在、存在和值为 true 都会生效，只要显式设置它为 false 即可；如果不想写配置信息，也不需要用 RedisRepository 的话（不影响 RedisTemplate），可以通过另外一个判断条件——检查 RedisRepositoryFactoryBean 这个 Bean 是否存在来处理，默认是不存在则执行这个 AutoConfiguration，只要自己在代码里造一个 RedisRepositoryFactoryBean 即可，比如这样\n\n    @Bean\n    public RedisRepositoryFactoryBean redisRepositoryFactoryBean() {\n        return null;\n    }\n    \n也可以直接禁用redis的repositories\n\n    spring.data.redis.repositories.enabled = false    \n\n    ","slug":"spring-boot-record","published":1,"updated":"2019-11-10T14:27:50.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqfz00c3g4vaqtw2umun","content":"<p>收集spring boot使用过程中的常用点……</p>\n<h2 id=\"常见注解\"><a href=\"#常见注解\" class=\"headerlink\" title=\"常见注解\"></a>常见注解</h2><h3 id=\"注解-ConditionalOnMissingBean\"><a href=\"#注解-ConditionalOnMissingBean\" class=\"headerlink\" title=\"注解@ConditionalOnMissingBean\"></a>注解@ConditionalOnMissingBean</h3><ul>\n<li>作用：标识是否要初始化该Bean。</li>\n</ul>\n<p>例子： </p>\n<pre><code>@Bean\n@ConditionalOnMissingBean\npublic DataSourceConnectionProvider dataSourceConnectionProvider(\n        DataSource dataSource) {\n    return new DataSourceConnectionProvider(\n            new TransactionAwareDataSourceProxy(dataSource));\n}\n</code></pre><p>上面初始化一个Bean，但是加了注解@ConditionalOnMissingBean。意思是：如果已经有初始化DataSourceConnectionProvider的Bean，该方法将不会执行。如：</p>\n<pre><code>@Bean\npublic DataSourceConnectionProvider connectionProvider() {\n    return new DataSourceConnectionProvider(new TransactionAwareDataSourceProxy(DataSourceSpyUtils.conversion(environment,dynamicDataSource)));\n}\n</code></pre><p>上面这段代码，初始化了该Bean，所以上面的将不会再执行。</p>\n<ul>\n<li>用处：常用在spring boot starter中。</li>\n</ul>\n<h3 id=\"ConditionalOnxxx相关注解总结\"><a href=\"#ConditionalOnxxx相关注解总结\" class=\"headerlink\" title=\"@ConditionalOnxxx相关注解总结\"></a>@ConditionalOnxxx相关注解总结</h3><p>参考：<br><a href=\"https://www.cnblogs.com/yixianyixian/p/7346894.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yixianyixian/p/7346894.html</a><br><a href=\"https://blog.csdn.net/xcy1193068639/article/details/81491071\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xcy1193068639/article/details/81491071</a></p>\n<h3 id=\"自定义Conditional\"><a href=\"#自定义Conditional\" class=\"headerlink\" title=\"自定义Conditional\"></a>自定义Conditional</h3><p><a href=\"https://blog.csdn.net/zhanglu1236789/article/details/78999496\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhanglu1236789/article/details/78999496</a></p>\n<h2 id=\"集成hikari数据源\"><a href=\"#集成hikari数据源\" class=\"headerlink\" title=\"集成hikari数据源\"></a>集成hikari数据源</h2><h3 id=\"错误一，maxLifetime问题\"><a href=\"#错误一，maxLifetime问题\" class=\"headerlink\" title=\"错误一，maxLifetime问题\"></a>错误一，maxLifetime问题</h3><pre><code>The last packet successfully received from the server was 1,057,018 milliseconds ago.  The last packet sent successfully to the server was 1,057,026 milliseconds ago.). Possibly consider using a shorter maxLifetime value.\n</code></pre><p>该警告代码在：com.zaxxer.hikari.pool.PoolBase类中，可以debbuger进去看。 </p>\n<p>解决：</p>\n<h2 id=\"Redis使用错误\"><a href=\"#Redis使用错误\" class=\"headerlink\" title=\"Redis使用错误\"></a>Redis使用错误</h2><ul>\n<li>错误描述：</li>\n</ul>\n<pre><code>Spring Data Redis - Could not safely identify store assignment for repositor\n</code></pre><ul>\n<li>原因分析：</li>\n</ul>\n<p>1.使用了Spring data jpa 作为持久层框架<br>2.使用了Spring Redis 缓存</p>\n<p>这是 Spring Boot 的 Autoconfigure 包干的好事，里面有个叫 RedisRepositoriesAutoConfiguration 的类会检查当前的 classpath 里面是不是存在 Jedis 和 @EnableRedisRepositories，如果存在，无论你的代码有没有用，他都会帮你自动启用这个注解（不带参数），于是整个 classpath 的类都会被扫进去。</p>\n<ul>\n<li>解决：</li>\n</ul>\n<p>解决方法也很简单，RedisRepositoriesAutoConfiguration 里面会判断 spring.data.redis.repositories.enable 这个配置项是否存在，不存在、存在和值为 true 都会生效，只要显式设置它为 false 即可；如果不想写配置信息，也不需要用 RedisRepository 的话（不影响 RedisTemplate），可以通过另外一个判断条件——检查 RedisRepositoryFactoryBean 这个 Bean 是否存在来处理，默认是不存在则执行这个 AutoConfiguration，只要自己在代码里造一个 RedisRepositoryFactoryBean 即可，比如这样</p>\n<pre><code>@Bean\npublic RedisRepositoryFactoryBean redisRepositoryFactoryBean() {\n    return null;\n}\n</code></pre><p>也可以直接禁用redis的repositories</p>\n<pre><code>spring.data.redis.repositories.enabled = false    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>收集spring boot使用过程中的常用点……</p>\n<h2 id=\"常见注解\"><a href=\"#常见注解\" class=\"headerlink\" title=\"常见注解\"></a>常见注解</h2><h3 id=\"注解-ConditionalOnMissingBean\"><a href=\"#注解-ConditionalOnMissingBean\" class=\"headerlink\" title=\"注解@ConditionalOnMissingBean\"></a>注解@ConditionalOnMissingBean</h3><ul>\n<li>作用：标识是否要初始化该Bean。</li>\n</ul>\n<p>例子： </p>\n<pre><code>@Bean\n@ConditionalOnMissingBean\npublic DataSourceConnectionProvider dataSourceConnectionProvider(\n        DataSource dataSource) {\n    return new DataSourceConnectionProvider(\n            new TransactionAwareDataSourceProxy(dataSource));\n}\n</code></pre><p>上面初始化一个Bean，但是加了注解@ConditionalOnMissingBean。意思是：如果已经有初始化DataSourceConnectionProvider的Bean，该方法将不会执行。如：</p>\n<pre><code>@Bean\npublic DataSourceConnectionProvider connectionProvider() {\n    return new DataSourceConnectionProvider(new TransactionAwareDataSourceProxy(DataSourceSpyUtils.conversion(environment,dynamicDataSource)));\n}\n</code></pre><p>上面这段代码，初始化了该Bean，所以上面的将不会再执行。</p>\n<ul>\n<li>用处：常用在spring boot starter中。</li>\n</ul>\n<h3 id=\"ConditionalOnxxx相关注解总结\"><a href=\"#ConditionalOnxxx相关注解总结\" class=\"headerlink\" title=\"@ConditionalOnxxx相关注解总结\"></a>@ConditionalOnxxx相关注解总结</h3><p>参考：<br><a href=\"https://www.cnblogs.com/yixianyixian/p/7346894.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/yixianyixian/p/7346894.html</a><br><a href=\"https://blog.csdn.net/xcy1193068639/article/details/81491071\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xcy1193068639/article/details/81491071</a></p>\n<h3 id=\"自定义Conditional\"><a href=\"#自定义Conditional\" class=\"headerlink\" title=\"自定义Conditional\"></a>自定义Conditional</h3><p><a href=\"https://blog.csdn.net/zhanglu1236789/article/details/78999496\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zhanglu1236789/article/details/78999496</a></p>\n<h2 id=\"集成hikari数据源\"><a href=\"#集成hikari数据源\" class=\"headerlink\" title=\"集成hikari数据源\"></a>集成hikari数据源</h2><h3 id=\"错误一，maxLifetime问题\"><a href=\"#错误一，maxLifetime问题\" class=\"headerlink\" title=\"错误一，maxLifetime问题\"></a>错误一，maxLifetime问题</h3><pre><code>The last packet successfully received from the server was 1,057,018 milliseconds ago.  The last packet sent successfully to the server was 1,057,026 milliseconds ago.). Possibly consider using a shorter maxLifetime value.\n</code></pre><p>该警告代码在：com.zaxxer.hikari.pool.PoolBase类中，可以debbuger进去看。 </p>\n<p>解决：</p>\n<h2 id=\"Redis使用错误\"><a href=\"#Redis使用错误\" class=\"headerlink\" title=\"Redis使用错误\"></a>Redis使用错误</h2><ul>\n<li>错误描述：</li>\n</ul>\n<pre><code>Spring Data Redis - Could not safely identify store assignment for repositor\n</code></pre><ul>\n<li>原因分析：</li>\n</ul>\n<p>1.使用了Spring data jpa 作为持久层框架<br>2.使用了Spring Redis 缓存</p>\n<p>这是 Spring Boot 的 Autoconfigure 包干的好事，里面有个叫 RedisRepositoriesAutoConfiguration 的类会检查当前的 classpath 里面是不是存在 Jedis 和 @EnableRedisRepositories，如果存在，无论你的代码有没有用，他都会帮你自动启用这个注解（不带参数），于是整个 classpath 的类都会被扫进去。</p>\n<ul>\n<li>解决：</li>\n</ul>\n<p>解决方法也很简单，RedisRepositoriesAutoConfiguration 里面会判断 spring.data.redis.repositories.enable 这个配置项是否存在，不存在、存在和值为 true 都会生效，只要显式设置它为 false 即可；如果不想写配置信息，也不需要用 RedisRepository 的话（不影响 RedisTemplate），可以通过另外一个判断条件——检查 RedisRepositoryFactoryBean 这个 Bean 是否存在来处理，默认是不存在则执行这个 AutoConfiguration，只要自己在代码里造一个 RedisRepositoryFactoryBean 即可，比如这样</p>\n<pre><code>@Bean\npublic RedisRepositoryFactoryBean redisRepositoryFactoryBean() {\n    return null;\n}\n</code></pre><p>也可以直接禁用redis的repositories</p>\n<pre><code>spring.data.redis.repositories.enabled = false    \n</code></pre>"},{"title":"spring-data-jpa动态数据源读写分离","date":"2017-11-08T15:02:49.000Z","_content":"\n在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。\n\n## 1. 配置数据源\n\n采用阿里druid数据源配置连接池。\n\n具体配置如下：\n\n    package service.basic.user.config.ds;\n    \n    import com.alibaba.druid.filter.Filter;\n    import com.alibaba.druid.filter.logging.Log4j2Filter;\n    import com.alibaba.druid.filter.stat.StatFilter;\n    import com.alibaba.druid.pool.DruidDataSource;\n    import com.alibaba.druid.wall.WallConfig;\n    import com.alibaba.druid.wall.WallFilter;\n    import com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.context.annotation.*;\n    import org.springframework.core.env.Environment;\n    \n    import javax.sql.DataSource;\n    import java.sql.SQLException;\n    import java.util.ArrayList;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    \n    \n    /**\n     * 配置数据源\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        /**\n         * druid监控filter配置。\n         * @return\n         */\n        @Bean\n        public StatFilter statFilter() {\n            StatFilter statFilter = new StatFilter();\n            statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n            statFilter.setLogSlowSql(true); //日志记录慢sql\n            statFilter.setMergeSql(true); //相同sql合并\n            return statFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 start ---------//\n    \n        @Bean\n        public WallConfig wallConfig() {\n            WallConfig wallConfig = new WallConfig();\n            wallConfig.setDir(\"classpath:druid/wall/mysql\"); //sql过滤规则装载位置。\n            return wallConfig;\n        }\n    \n        @Bean\n        public WallFilter wallFilter() {\n            WallFilter wallFilter = new WallFilter();\n            wallFilter.setDbType(\"mysql\"); //指定数据库类型。\n            wallFilter.setConfig(wallConfig());\n            return wallFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 end ---------//\n    \n    \n        /**\n         * 打印sql语句。\n         * @return\n         */\n        @Bean(name = \"log4j2Filter\")\n        public Log4j2Filter log4j2Filter() {\n            Log4j2Filter log4j2Filter = new Log4j2Filter();\n            log4j2Filter.setConnectionLogEnabled(false);\n            log4j2Filter.setResultSetLogEnabled(true); //显示sql\n            log4j2Filter.setDataSourceLogEnabled(false);\n            log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n            log4j2Filter.setStatementLogEnabled(false);\n            return log4j2Filter;\n        }\n    \n    \n    \n        //-------------- 数据源配置 start ---------------//\n    \n        /**\n         * 会员主库（spcs_user）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceWrite\")\n        @Qualifier(\"spcsUserDataSourceWrite\")\n        public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n        /**\n         * 会员从库（spcs_user_slave）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceRead_0\")\n        @Qualifier(\"spcsUserDataSourceRead_0\")\n        public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"spcsUserDataSourceWrite\",\"spcsUserDataSourceRead_0\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"spcsUserDataSourceWrite\") DataSource spcsUserDataSource,\n                                              @Qualifier(\"spcsUserDataSourceRead_0\") DataSource spcsUserSlaveDataSource) {\n            // 配置多数据源\n            Map<Object, Object> dsMap = new HashMap<>(5);\n            dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n            dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n    \n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            // 默认数据源\n            dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n            dynamicDataSource.setTargetDataSources(dsMap);\n            return dynamicDataSource;\n        }\n    \n    }\n\n> *注意*：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。\n\n## 2. 实现自己的数据源路由（关键）\n\n相当于多数据源的路由功能。\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n    \n    public class DynamicDataSource extends AbstractRoutingDataSource {\n    \n        private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n    \n        @Override\n        protected Object determineCurrentLookupKey() {\n            log.debug(\"数据源为{}\", DataSourceContextHolder.getDS());\n            //可以做一个简单的负载均衡策略\n            return DataSourceContextHolder.getDS();\n        }\n    \n    }\n    \n## 3. 持有数据源\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    public class DataSourceContextHolder {\n    \n        private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n    \n        private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();\n    \n        /**\n         * 设置数据源名。\n         * @param dbType\n         */\n        public static void setDS(String dbType) {\n            if (dbType == null) {\n                throw new NullPointerException(\"数据源不能null\");\n            }\n            LOGGER.debug(\"切换到{}数据源\", dbType);\n            contextHolder.set(dbType);\n        }\n    \n        /**\n         * 获取数据源名。\n         * @return\n         */\n        public static String getDS() {\n            return (contextHolder.get());\n        }\n    \n        /**\n         * 清除数据源名。\n         */\n        public static void clearDS() {\n            contextHolder.remove();\n        }\n    }\n    \n## 4. 通过aop，注解方式持有数据源\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.ds.DSInject;\n    import com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\n    import org.aspectj.lang.JoinPoint;\n    import org.aspectj.lang.annotation.After;\n    import org.aspectj.lang.annotation.Aspect;\n    import org.aspectj.lang.annotation.Before;\n    import org.aspectj.lang.reflect.MethodSignature;\n    import org.springframework.stereotype.Component;\n    \n    import java.lang.reflect.Method;\n    \n    /**\n     *  解析注入的数据源。\n     */\n    @Aspect\n    @Component\n    public class DynamicDataSourceAspect {\n    \n    \t@Before(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void beforeSwitchDS(JoinPoint point) {\n    \n    \t\t// 获得当前访问的class\n    \t\tClass<?> className = point.getTarget().getClass();\n    \n    \t\t// 获得访问的方法名\n    \t\tString methodName = point.getSignature().getName();\n    \t\t// 得到方法的参数的类型\n    \t\tClass[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n    \t\tString dataSource = DSType.SPCS_USER.name(); //默认主库\n    \t\ttry {\n    \t\t\t// 得到访问的方法对象\n    \t\t\tMethod method = className.getMethod(methodName, argClass);\n    \n    \t\t\t// 判断是否存在@DBInject注解\n    \t\t\tif (method.isAnnotationPresent(DSInject.class)) {\n    \t\t\t\tDSInject annotation = method.getAnnotation(DSInject.class);\n    \t\t\t\t// 取出注解中的数据源名\n    \t\t\t\tdataSource = annotation.value();\n    \t\t\t}\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t}\n    \n    \t\t// 切换数据源\n    \t\tDataSourceContextHolder.setDS(dataSource);\n    \n    \t}\n    \n    \t@After(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void afterSwitchDS(JoinPoint point) {\n    \t\tDataSourceContextHolder.clearDS();\n    \t}\n    }\n\n---\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import java.lang.annotation.Documented;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Target({ ElementType.PARAMETER, ElementType.METHOD })\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface DSInject {\n    \tString value() default \"\";\n    }\n\n## 5. 配置jpa\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\n    import net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\n    import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.core.env.Environment;\n    import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n    import org.springframework.orm.jpa.JpaTransactionManager;\n    import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\n    import org.springframework.transaction.PlatformTransactionManager;\n    import org.springframework.transaction.annotation.EnableTransactionManagement;\n    import service.basic.user.common.Constants;\n    \n    import javax.persistence.EntityManager;\n    import javax.sql.DataSource;\n    import java.util.Map;\n    \n    @Configuration\n    @EnableTransactionManagement\n    @EnableJpaRepositories(entityManagerFactoryRef = \"entityManagerFactorySpcsUserDB\", transactionManagerRef = \"transactionManagerSpcsUserDB\", basePackages = {\n            Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\n    public class SpcsUserDBConfig {\n    \n        @Autowired\n        Environment ev;\n    \n        @Autowired\n        @Qualifier(\"dataSource\")\n        private DataSource dataSource; // 数据源\n    \n        @Primary\n        @Bean(name = \"entityManagerSpcsUser\")\n        public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n            return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n        }\n    \n        @Primary\n        @Bean(name = \"entityManagerFactorySpcsUserDB\")\n        public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n            if (ev.acceptsProfiles(\"dev\") || ev.acceptsProfiles(\"test\")\n                    || ev.acceptsProfiles(\"update\")) {\n                dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n            }\n            return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                    .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                    .persistenceUnit(\"spcsUserUnit\").build(); //实体管理器别名,多数据元要设置。\n        }\n    \n        private Map<String, String> getVendorProperties(DataSource dataSource) {\n            JpaProperties jpaProperties = new JpaProperties();\n            return jpaProperties.getHibernateProperties(dataSource);\n        }\n    \n        /**\n         * 开启事务。\n         *\n         * @param builder\n         * @return\n         */\n        @Primary\n        @Bean(name = \"transactionManagerSpcsUserDB\")\n        public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n            return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n        }\n    \n    }\n    \n> *注意*: 注入的数据源为上面配置的动态数据源。\n@Autowired\n@Qualifier(\"dataSource\")\nprivate DataSource dataSource; // 数据源    \n\n\n## 6. 配置spring jdbcTemplate\n\n    package service.basic.user.config.ds;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.jdbc.core.JdbcTemplate;\n    \n    import javax.sql.DataSource;\n    \n    @Configuration\n    @AutoConfigureAfter(DataSourceConfig.class)\n    public class JdbcTemplateConfig {\n    \n        @Autowired\n        @Qualifier(value = \"dataSource\")\n        private DataSource dataSource;\n    \n        /**\n         * spring jdbc。\n         *\n         * @return\n         */\n        @Bean(name = \"jdbcTemplate\")\n        @Qualifier(\"jdbcTemplate\")\n        public JdbcTemplate jdbcTemplate() {\n            return new JdbcTemplate(dataSource);\n        }\n    }\n\n\n## 7. 使用\n\n- 方式一：\n可在service层，也可在dao层做。\n在开始操作数据库前调用：\n\n\n    DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n    \n    //查询数据\n    \n    DataSourceContextHolder.clearDS();\n    \n- 方式二：\n通过注解，可在service层，也可在dao层做。\n\n\n    @DSInject(value = Constants.SPCS_USER_SLAVE)\n    @Override\n    public User getUserByMobile(String mobile) {\n        return userDao.findUserByMobile(mobile);\n    }    ","source":"_posts/spring-jpa-multiple-datasource.md","raw":"---\ntitle: spring-data-jpa动态数据源读写分离\ndate: 2017-11-08 23:02:49\ncategories: spring-boot\ntags: jpa读写分离配置\n---\n\n在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。\n\n## 1. 配置数据源\n\n采用阿里druid数据源配置连接池。\n\n具体配置如下：\n\n    package service.basic.user.config.ds;\n    \n    import com.alibaba.druid.filter.Filter;\n    import com.alibaba.druid.filter.logging.Log4j2Filter;\n    import com.alibaba.druid.filter.stat.StatFilter;\n    import com.alibaba.druid.pool.DruidDataSource;\n    import com.alibaba.druid.wall.WallConfig;\n    import com.alibaba.druid.wall.WallFilter;\n    import com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.context.annotation.*;\n    import org.springframework.core.env.Environment;\n    \n    import javax.sql.DataSource;\n    import java.sql.SQLException;\n    import java.util.ArrayList;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    \n    \n    /**\n     * 配置数据源\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        /**\n         * druid监控filter配置。\n         * @return\n         */\n        @Bean\n        public StatFilter statFilter() {\n            StatFilter statFilter = new StatFilter();\n            statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n            statFilter.setLogSlowSql(true); //日志记录慢sql\n            statFilter.setMergeSql(true); //相同sql合并\n            return statFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 start ---------//\n    \n        @Bean\n        public WallConfig wallConfig() {\n            WallConfig wallConfig = new WallConfig();\n            wallConfig.setDir(\"classpath:druid/wall/mysql\"); //sql过滤规则装载位置。\n            return wallConfig;\n        }\n    \n        @Bean\n        public WallFilter wallFilter() {\n            WallFilter wallFilter = new WallFilter();\n            wallFilter.setDbType(\"mysql\"); //指定数据库类型。\n            wallFilter.setConfig(wallConfig());\n            return wallFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 end ---------//\n    \n    \n        /**\n         * 打印sql语句。\n         * @return\n         */\n        @Bean(name = \"log4j2Filter\")\n        public Log4j2Filter log4j2Filter() {\n            Log4j2Filter log4j2Filter = new Log4j2Filter();\n            log4j2Filter.setConnectionLogEnabled(false);\n            log4j2Filter.setResultSetLogEnabled(true); //显示sql\n            log4j2Filter.setDataSourceLogEnabled(false);\n            log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n            log4j2Filter.setStatementLogEnabled(false);\n            return log4j2Filter;\n        }\n    \n    \n    \n        //-------------- 数据源配置 start ---------------//\n    \n        /**\n         * 会员主库（spcs_user）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceWrite\")\n        @Qualifier(\"spcsUserDataSourceWrite\")\n        public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n        /**\n         * 会员从库（spcs_user_slave）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceRead_0\")\n        @Qualifier(\"spcsUserDataSourceRead_0\")\n        public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"spcsUserDataSourceWrite\",\"spcsUserDataSourceRead_0\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"spcsUserDataSourceWrite\") DataSource spcsUserDataSource,\n                                              @Qualifier(\"spcsUserDataSourceRead_0\") DataSource spcsUserSlaveDataSource) {\n            // 配置多数据源\n            Map<Object, Object> dsMap = new HashMap<>(5);\n            dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n            dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n    \n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            // 默认数据源\n            dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n            dynamicDataSource.setTargetDataSources(dsMap);\n            return dynamicDataSource;\n        }\n    \n    }\n\n> *注意*：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。\n\n## 2. 实现自己的数据源路由（关键）\n\n相当于多数据源的路由功能。\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n    \n    public class DynamicDataSource extends AbstractRoutingDataSource {\n    \n        private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n    \n        @Override\n        protected Object determineCurrentLookupKey() {\n            log.debug(\"数据源为{}\", DataSourceContextHolder.getDS());\n            //可以做一个简单的负载均衡策略\n            return DataSourceContextHolder.getDS();\n        }\n    \n    }\n    \n## 3. 持有数据源\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    public class DataSourceContextHolder {\n    \n        private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n    \n        private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();\n    \n        /**\n         * 设置数据源名。\n         * @param dbType\n         */\n        public static void setDS(String dbType) {\n            if (dbType == null) {\n                throw new NullPointerException(\"数据源不能null\");\n            }\n            LOGGER.debug(\"切换到{}数据源\", dbType);\n            contextHolder.set(dbType);\n        }\n    \n        /**\n         * 获取数据源名。\n         * @return\n         */\n        public static String getDS() {\n            return (contextHolder.get());\n        }\n    \n        /**\n         * 清除数据源名。\n         */\n        public static void clearDS() {\n            contextHolder.remove();\n        }\n    }\n    \n## 4. 通过aop，注解方式持有数据源\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.ds.DSInject;\n    import com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\n    import org.aspectj.lang.JoinPoint;\n    import org.aspectj.lang.annotation.After;\n    import org.aspectj.lang.annotation.Aspect;\n    import org.aspectj.lang.annotation.Before;\n    import org.aspectj.lang.reflect.MethodSignature;\n    import org.springframework.stereotype.Component;\n    \n    import java.lang.reflect.Method;\n    \n    /**\n     *  解析注入的数据源。\n     */\n    @Aspect\n    @Component\n    public class DynamicDataSourceAspect {\n    \n    \t@Before(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void beforeSwitchDS(JoinPoint point) {\n    \n    \t\t// 获得当前访问的class\n    \t\tClass<?> className = point.getTarget().getClass();\n    \n    \t\t// 获得访问的方法名\n    \t\tString methodName = point.getSignature().getName();\n    \t\t// 得到方法的参数的类型\n    \t\tClass[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n    \t\tString dataSource = DSType.SPCS_USER.name(); //默认主库\n    \t\ttry {\n    \t\t\t// 得到访问的方法对象\n    \t\t\tMethod method = className.getMethod(methodName, argClass);\n    \n    \t\t\t// 判断是否存在@DBInject注解\n    \t\t\tif (method.isAnnotationPresent(DSInject.class)) {\n    \t\t\t\tDSInject annotation = method.getAnnotation(DSInject.class);\n    \t\t\t\t// 取出注解中的数据源名\n    \t\t\t\tdataSource = annotation.value();\n    \t\t\t}\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t}\n    \n    \t\t// 切换数据源\n    \t\tDataSourceContextHolder.setDS(dataSource);\n    \n    \t}\n    \n    \t@After(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void afterSwitchDS(JoinPoint point) {\n    \t\tDataSourceContextHolder.clearDS();\n    \t}\n    }\n\n---\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import java.lang.annotation.Documented;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Target({ ElementType.PARAMETER, ElementType.METHOD })\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface DSInject {\n    \tString value() default \"\";\n    }\n\n## 5. 配置jpa\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\n    import net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\n    import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.core.env.Environment;\n    import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n    import org.springframework.orm.jpa.JpaTransactionManager;\n    import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\n    import org.springframework.transaction.PlatformTransactionManager;\n    import org.springframework.transaction.annotation.EnableTransactionManagement;\n    import service.basic.user.common.Constants;\n    \n    import javax.persistence.EntityManager;\n    import javax.sql.DataSource;\n    import java.util.Map;\n    \n    @Configuration\n    @EnableTransactionManagement\n    @EnableJpaRepositories(entityManagerFactoryRef = \"entityManagerFactorySpcsUserDB\", transactionManagerRef = \"transactionManagerSpcsUserDB\", basePackages = {\n            Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\n    public class SpcsUserDBConfig {\n    \n        @Autowired\n        Environment ev;\n    \n        @Autowired\n        @Qualifier(\"dataSource\")\n        private DataSource dataSource; // 数据源\n    \n        @Primary\n        @Bean(name = \"entityManagerSpcsUser\")\n        public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n            return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n        }\n    \n        @Primary\n        @Bean(name = \"entityManagerFactorySpcsUserDB\")\n        public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n            if (ev.acceptsProfiles(\"dev\") || ev.acceptsProfiles(\"test\")\n                    || ev.acceptsProfiles(\"update\")) {\n                dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n            }\n            return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                    .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                    .persistenceUnit(\"spcsUserUnit\").build(); //实体管理器别名,多数据元要设置。\n        }\n    \n        private Map<String, String> getVendorProperties(DataSource dataSource) {\n            JpaProperties jpaProperties = new JpaProperties();\n            return jpaProperties.getHibernateProperties(dataSource);\n        }\n    \n        /**\n         * 开启事务。\n         *\n         * @param builder\n         * @return\n         */\n        @Primary\n        @Bean(name = \"transactionManagerSpcsUserDB\")\n        public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n            return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n        }\n    \n    }\n    \n> *注意*: 注入的数据源为上面配置的动态数据源。\n@Autowired\n@Qualifier(\"dataSource\")\nprivate DataSource dataSource; // 数据源    \n\n\n## 6. 配置spring jdbcTemplate\n\n    package service.basic.user.config.ds;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.jdbc.core.JdbcTemplate;\n    \n    import javax.sql.DataSource;\n    \n    @Configuration\n    @AutoConfigureAfter(DataSourceConfig.class)\n    public class JdbcTemplateConfig {\n    \n        @Autowired\n        @Qualifier(value = \"dataSource\")\n        private DataSource dataSource;\n    \n        /**\n         * spring jdbc。\n         *\n         * @return\n         */\n        @Bean(name = \"jdbcTemplate\")\n        @Qualifier(\"jdbcTemplate\")\n        public JdbcTemplate jdbcTemplate() {\n            return new JdbcTemplate(dataSource);\n        }\n    }\n\n\n## 7. 使用\n\n- 方式一：\n可在service层，也可在dao层做。\n在开始操作数据库前调用：\n\n\n    DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n    \n    //查询数据\n    \n    DataSourceContextHolder.clearDS();\n    \n- 方式二：\n通过注解，可在service层，也可在dao层做。\n\n\n    @DSInject(value = Constants.SPCS_USER_SLAVE)\n    @Override\n    public User getUserByMobile(String mobile) {\n        return userDao.findUserByMobile(mobile);\n    }    ","slug":"spring-jpa-multiple-datasource","published":1,"updated":"2019-06-16T14:38:33.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqg000c5g4vagjuzlbq6","content":"<p>在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。</p>\n<h2 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h2><p>采用阿里druid数据源配置连接池。</p>\n<p>具体配置如下：</p>\n<pre><code>package service.basic.user.config.ds;\n\nimport com.alibaba.druid.filter.Filter;\nimport com.alibaba.druid.filter.logging.Log4j2Filter;\nimport com.alibaba.druid.filter.stat.StatFilter;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.wall.WallConfig;\nimport com.alibaba.druid.wall.WallFilter;\nimport com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.*;\nimport org.springframework.core.env.Environment;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * 配置数据源\n */\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * druid监控filter配置。\n     * @return\n     */\n    @Bean\n    public StatFilter statFilter() {\n        StatFilter statFilter = new StatFilter();\n        statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n        statFilter.setLogSlowSql(true); //日志记录慢sql\n        statFilter.setMergeSql(true); //相同sql合并\n        return statFilter;\n    }\n\n    //----------- sql注入攻击防御配置 start ---------//\n\n    @Bean\n    public WallConfig wallConfig() {\n        WallConfig wallConfig = new WallConfig();\n        wallConfig.setDir(&quot;classpath:druid/wall/mysql&quot;); //sql过滤规则装载位置。\n        return wallConfig;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n        WallFilter wallFilter = new WallFilter();\n        wallFilter.setDbType(&quot;mysql&quot;); //指定数据库类型。\n        wallFilter.setConfig(wallConfig());\n        return wallFilter;\n    }\n\n    //----------- sql注入攻击防御配置 end ---------//\n\n\n    /**\n     * 打印sql语句。\n     * @return\n     */\n    @Bean(name = &quot;log4j2Filter&quot;)\n    public Log4j2Filter log4j2Filter() {\n        Log4j2Filter log4j2Filter = new Log4j2Filter();\n        log4j2Filter.setConnectionLogEnabled(false);\n        log4j2Filter.setResultSetLogEnabled(true); //显示sql\n        log4j2Filter.setDataSourceLogEnabled(false);\n        log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n        log4j2Filter.setStatementLogEnabled(false);\n        return log4j2Filter;\n    }\n\n\n\n    //-------------- 数据源配置 start ---------------//\n\n    /**\n     * 会员主库（spcs_user）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceWrite&quot;)\n    @Qualifier(&quot;spcsUserDataSourceWrite&quot;)\n    public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n    /**\n     * 会员从库（spcs_user_slave）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceRead_0&quot;)\n    @Qualifier(&quot;spcsUserDataSourceRead_0&quot;)\n    public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;spcsUserDataSourceWrite&quot;,&quot;spcsUserDataSourceRead_0&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;spcsUserDataSourceWrite&quot;) DataSource spcsUserDataSource,\n                                          @Qualifier(&quot;spcsUserDataSourceRead_0&quot;) DataSource spcsUserSlaveDataSource) {\n        // 配置多数据源\n        Map&lt;Object, Object&gt; dsMap = new HashMap&lt;&gt;(5);\n        dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n        dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        // 默认数据源\n        dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n        dynamicDataSource.setTargetDataSources(dsMap);\n        return dynamicDataSource;\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。</p>\n</blockquote>\n<h2 id=\"2-实现自己的数据源路由（关键）\"><a href=\"#2-实现自己的数据源路由（关键）\" class=\"headerlink\" title=\"2. 实现自己的数据源路由（关键）\"></a>2. 实现自己的数据源路由（关键）</h2><p>相当于多数据源的路由功能。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        log.debug(&quot;数据源为{}&quot;, DataSourceContextHolder.getDS());\n        //可以做一个简单的负载均衡策略\n        return DataSourceContextHolder.getDS();\n    }\n\n}\n</code></pre><h2 id=\"3-持有数据源\"><a href=\"#3-持有数据源\" class=\"headerlink\" title=\"3. 持有数据源\"></a>3. 持有数据源</h2><pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class DataSourceContextHolder {\n\n    private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n\n    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();\n\n    /**\n     * 设置数据源名。\n     * @param dbType\n     */\n    public static void setDS(String dbType) {\n        if (dbType == null) {\n            throw new NullPointerException(&quot;数据源不能null&quot;);\n        }\n        LOGGER.debug(&quot;切换到{}数据源&quot;, dbType);\n        contextHolder.set(dbType);\n    }\n\n    /**\n     * 获取数据源名。\n     * @return\n     */\n    public static String getDS() {\n        return (contextHolder.get());\n    }\n\n    /**\n     * 清除数据源名。\n     */\n    public static void clearDS() {\n        contextHolder.remove();\n    }\n}\n</code></pre><h2 id=\"4-通过aop，注解方式持有数据源\"><a href=\"#4-通过aop，注解方式持有数据源\" class=\"headerlink\" title=\"4. 通过aop，注解方式持有数据源\"></a>4. 通过aop，注解方式持有数据源</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.ds.DSInject;\nimport com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n/**\n *  解析注入的数据源。\n */\n@Aspect\n@Component\npublic class DynamicDataSourceAspect {\n\n    @Before(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void beforeSwitchDS(JoinPoint point) {\n\n        // 获得当前访问的class\n        Class&lt;?&gt; className = point.getTarget().getClass();\n\n        // 获得访问的方法名\n        String methodName = point.getSignature().getName();\n        // 得到方法的参数的类型\n        Class[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n        String dataSource = DSType.SPCS_USER.name(); //默认主库\n        try {\n            // 得到访问的方法对象\n            Method method = className.getMethod(methodName, argClass);\n\n            // 判断是否存在@DBInject注解\n            if (method.isAnnotationPresent(DSInject.class)) {\n                DSInject annotation = method.getAnnotation(DSInject.class);\n                // 取出注解中的数据源名\n                dataSource = annotation.value();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // 切换数据源\n        DataSourceContextHolder.setDS(dataSource);\n\n    }\n\n    @After(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void afterSwitchDS(JoinPoint point) {\n        DataSourceContextHolder.clearDS();\n    }\n}\n</code></pre><hr>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface DSInject {\n    String value() default &quot;&quot;;\n}\n</code></pre><h2 id=\"5-配置jpa\"><a href=\"#5-配置jpa\" class=\"headerlink\" title=\"5. 配置jpa\"></a>5. 配置jpa</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\nimport net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.core.env.Environment;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport service.basic.user.common.Constants;\n\nimport javax.persistence.EntityManager;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(entityManagerFactoryRef = &quot;entityManagerFactorySpcsUserDB&quot;, transactionManagerRef = &quot;transactionManagerSpcsUserDB&quot;, basePackages = {\n        Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\npublic class SpcsUserDBConfig {\n\n    @Autowired\n    Environment ev;\n\n    @Autowired\n    @Qualifier(&quot;dataSource&quot;)\n    private DataSource dataSource; // 数据源\n\n    @Primary\n    @Bean(name = &quot;entityManagerSpcsUser&quot;)\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n    }\n\n    @Primary\n    @Bean(name = &quot;entityManagerFactorySpcsUserDB&quot;)\n    public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n        if (ev.acceptsProfiles(&quot;dev&quot;) || ev.acceptsProfiles(&quot;test&quot;)\n                || ev.acceptsProfiles(&quot;update&quot;)) {\n            dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n        }\n        return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                .persistenceUnit(&quot;spcsUserUnit&quot;).build(); //实体管理器别名,多数据元要设置。\n    }\n\n    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {\n        JpaProperties jpaProperties = new JpaProperties();\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    /**\n     * 开启事务。\n     *\n     * @param builder\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;transactionManagerSpcsUserDB&quot;)\n    public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>: 注入的数据源为上面配置的动态数据源。<br>@Autowired<br>@Qualifier(“dataSource”)<br>private DataSource dataSource; // 数据源    </p>\n</blockquote>\n<h2 id=\"6-配置spring-jdbcTemplate\"><a href=\"#6-配置spring-jdbcTemplate\" class=\"headerlink\" title=\"6. 配置spring jdbcTemplate\"></a>6. 配置spring jdbcTemplate</h2><pre><code>package service.basic.user.config.ds;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@AutoConfigureAfter(DataSourceConfig.class)\npublic class JdbcTemplateConfig {\n\n    @Autowired\n    @Qualifier(value = &quot;dataSource&quot;)\n    private DataSource dataSource;\n\n    /**\n     * spring jdbc。\n     *\n     * @return\n     */\n    @Bean(name = &quot;jdbcTemplate&quot;)\n    @Qualifier(&quot;jdbcTemplate&quot;)\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(dataSource);\n    }\n}\n</code></pre><h2 id=\"7-使用\"><a href=\"#7-使用\" class=\"headerlink\" title=\"7. 使用\"></a>7. 使用</h2><ul>\n<li>方式一：<br>可在service层，也可在dao层做。<br>在开始操作数据库前调用：</li>\n</ul>\n<pre><code>DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n\n//查询数据\n\nDataSourceContextHolder.clearDS();\n</code></pre><ul>\n<li>方式二：<br>通过注解，可在service层，也可在dao层做。</li>\n</ul>\n<pre><code>@DSInject(value = Constants.SPCS_USER_SLAVE)\n@Override\npublic User getUserByMobile(String mobile) {\n    return userDao.findUserByMobile(mobile);\n}    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。</p>\n<h2 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h2><p>采用阿里druid数据源配置连接池。</p>\n<p>具体配置如下：</p>\n<pre><code>package service.basic.user.config.ds;\n\nimport com.alibaba.druid.filter.Filter;\nimport com.alibaba.druid.filter.logging.Log4j2Filter;\nimport com.alibaba.druid.filter.stat.StatFilter;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.wall.WallConfig;\nimport com.alibaba.druid.wall.WallFilter;\nimport com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.*;\nimport org.springframework.core.env.Environment;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * 配置数据源\n */\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * druid监控filter配置。\n     * @return\n     */\n    @Bean\n    public StatFilter statFilter() {\n        StatFilter statFilter = new StatFilter();\n        statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n        statFilter.setLogSlowSql(true); //日志记录慢sql\n        statFilter.setMergeSql(true); //相同sql合并\n        return statFilter;\n    }\n\n    //----------- sql注入攻击防御配置 start ---------//\n\n    @Bean\n    public WallConfig wallConfig() {\n        WallConfig wallConfig = new WallConfig();\n        wallConfig.setDir(&quot;classpath:druid/wall/mysql&quot;); //sql过滤规则装载位置。\n        return wallConfig;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n        WallFilter wallFilter = new WallFilter();\n        wallFilter.setDbType(&quot;mysql&quot;); //指定数据库类型。\n        wallFilter.setConfig(wallConfig());\n        return wallFilter;\n    }\n\n    //----------- sql注入攻击防御配置 end ---------//\n\n\n    /**\n     * 打印sql语句。\n     * @return\n     */\n    @Bean(name = &quot;log4j2Filter&quot;)\n    public Log4j2Filter log4j2Filter() {\n        Log4j2Filter log4j2Filter = new Log4j2Filter();\n        log4j2Filter.setConnectionLogEnabled(false);\n        log4j2Filter.setResultSetLogEnabled(true); //显示sql\n        log4j2Filter.setDataSourceLogEnabled(false);\n        log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n        log4j2Filter.setStatementLogEnabled(false);\n        return log4j2Filter;\n    }\n\n\n\n    //-------------- 数据源配置 start ---------------//\n\n    /**\n     * 会员主库（spcs_user）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceWrite&quot;)\n    @Qualifier(&quot;spcsUserDataSourceWrite&quot;)\n    public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n    /**\n     * 会员从库（spcs_user_slave）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceRead_0&quot;)\n    @Qualifier(&quot;spcsUserDataSourceRead_0&quot;)\n    public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;spcsUserDataSourceWrite&quot;,&quot;spcsUserDataSourceRead_0&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;spcsUserDataSourceWrite&quot;) DataSource spcsUserDataSource,\n                                          @Qualifier(&quot;spcsUserDataSourceRead_0&quot;) DataSource spcsUserSlaveDataSource) {\n        // 配置多数据源\n        Map&lt;Object, Object&gt; dsMap = new HashMap&lt;&gt;(5);\n        dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n        dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        // 默认数据源\n        dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n        dynamicDataSource.setTargetDataSources(dsMap);\n        return dynamicDataSource;\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。</p>\n</blockquote>\n<h2 id=\"2-实现自己的数据源路由（关键）\"><a href=\"#2-实现自己的数据源路由（关键）\" class=\"headerlink\" title=\"2. 实现自己的数据源路由（关键）\"></a>2. 实现自己的数据源路由（关键）</h2><p>相当于多数据源的路由功能。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        log.debug(&quot;数据源为{}&quot;, DataSourceContextHolder.getDS());\n        //可以做一个简单的负载均衡策略\n        return DataSourceContextHolder.getDS();\n    }\n\n}\n</code></pre><h2 id=\"3-持有数据源\"><a href=\"#3-持有数据源\" class=\"headerlink\" title=\"3. 持有数据源\"></a>3. 持有数据源</h2><pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class DataSourceContextHolder {\n\n    private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n\n    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();\n\n    /**\n     * 设置数据源名。\n     * @param dbType\n     */\n    public static void setDS(String dbType) {\n        if (dbType == null) {\n            throw new NullPointerException(&quot;数据源不能null&quot;);\n        }\n        LOGGER.debug(&quot;切换到{}数据源&quot;, dbType);\n        contextHolder.set(dbType);\n    }\n\n    /**\n     * 获取数据源名。\n     * @return\n     */\n    public static String getDS() {\n        return (contextHolder.get());\n    }\n\n    /**\n     * 清除数据源名。\n     */\n    public static void clearDS() {\n        contextHolder.remove();\n    }\n}\n</code></pre><h2 id=\"4-通过aop，注解方式持有数据源\"><a href=\"#4-通过aop，注解方式持有数据源\" class=\"headerlink\" title=\"4. 通过aop，注解方式持有数据源\"></a>4. 通过aop，注解方式持有数据源</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.ds.DSInject;\nimport com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n/**\n *  解析注入的数据源。\n */\n@Aspect\n@Component\npublic class DynamicDataSourceAspect {\n\n    @Before(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void beforeSwitchDS(JoinPoint point) {\n\n        // 获得当前访问的class\n        Class&lt;?&gt; className = point.getTarget().getClass();\n\n        // 获得访问的方法名\n        String methodName = point.getSignature().getName();\n        // 得到方法的参数的类型\n        Class[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n        String dataSource = DSType.SPCS_USER.name(); //默认主库\n        try {\n            // 得到访问的方法对象\n            Method method = className.getMethod(methodName, argClass);\n\n            // 判断是否存在@DBInject注解\n            if (method.isAnnotationPresent(DSInject.class)) {\n                DSInject annotation = method.getAnnotation(DSInject.class);\n                // 取出注解中的数据源名\n                dataSource = annotation.value();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // 切换数据源\n        DataSourceContextHolder.setDS(dataSource);\n\n    }\n\n    @After(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void afterSwitchDS(JoinPoint point) {\n        DataSourceContextHolder.clearDS();\n    }\n}\n</code></pre><hr>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface DSInject {\n    String value() default &quot;&quot;;\n}\n</code></pre><h2 id=\"5-配置jpa\"><a href=\"#5-配置jpa\" class=\"headerlink\" title=\"5. 配置jpa\"></a>5. 配置jpa</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\nimport net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.core.env.Environment;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport service.basic.user.common.Constants;\n\nimport javax.persistence.EntityManager;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(entityManagerFactoryRef = &quot;entityManagerFactorySpcsUserDB&quot;, transactionManagerRef = &quot;transactionManagerSpcsUserDB&quot;, basePackages = {\n        Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\npublic class SpcsUserDBConfig {\n\n    @Autowired\n    Environment ev;\n\n    @Autowired\n    @Qualifier(&quot;dataSource&quot;)\n    private DataSource dataSource; // 数据源\n\n    @Primary\n    @Bean(name = &quot;entityManagerSpcsUser&quot;)\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n    }\n\n    @Primary\n    @Bean(name = &quot;entityManagerFactorySpcsUserDB&quot;)\n    public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n        if (ev.acceptsProfiles(&quot;dev&quot;) || ev.acceptsProfiles(&quot;test&quot;)\n                || ev.acceptsProfiles(&quot;update&quot;)) {\n            dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n        }\n        return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                .persistenceUnit(&quot;spcsUserUnit&quot;).build(); //实体管理器别名,多数据元要设置。\n    }\n\n    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {\n        JpaProperties jpaProperties = new JpaProperties();\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    /**\n     * 开启事务。\n     *\n     * @param builder\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;transactionManagerSpcsUserDB&quot;)\n    public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>: 注入的数据源为上面配置的动态数据源。<br>@Autowired<br>@Qualifier(“dataSource”)<br>private DataSource dataSource; // 数据源    </p>\n</blockquote>\n<h2 id=\"6-配置spring-jdbcTemplate\"><a href=\"#6-配置spring-jdbcTemplate\" class=\"headerlink\" title=\"6. 配置spring jdbcTemplate\"></a>6. 配置spring jdbcTemplate</h2><pre><code>package service.basic.user.config.ds;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@AutoConfigureAfter(DataSourceConfig.class)\npublic class JdbcTemplateConfig {\n\n    @Autowired\n    @Qualifier(value = &quot;dataSource&quot;)\n    private DataSource dataSource;\n\n    /**\n     * spring jdbc。\n     *\n     * @return\n     */\n    @Bean(name = &quot;jdbcTemplate&quot;)\n    @Qualifier(&quot;jdbcTemplate&quot;)\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(dataSource);\n    }\n}\n</code></pre><h2 id=\"7-使用\"><a href=\"#7-使用\" class=\"headerlink\" title=\"7. 使用\"></a>7. 使用</h2><ul>\n<li>方式一：<br>可在service层，也可在dao层做。<br>在开始操作数据库前调用：</li>\n</ul>\n<pre><code>DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n\n//查询数据\n\nDataSourceContextHolder.clearDS();\n</code></pre><ul>\n<li>方式二：<br>通过注解，可在service层，也可在dao层做。</li>\n</ul>\n<pre><code>@DSInject(value = Constants.SPCS_USER_SLAVE)\n@Override\npublic User getUserByMobile(String mobile) {\n    return userDao.findUserByMobile(mobile);\n}    \n</code></pre>"},{"title":"teamcity持续集成使用","date":"2017-10-30T01:18:57.000Z","_content":"","source":"_posts/teamcity-use-start.md","raw":"---\ntitle: teamcity持续集成使用\ndate: 2017-10-30 09:18:57\ncategories: teamcity\ntags: teamcity-start\n---\n","slug":"teamcity-use-start","published":1,"updated":"2019-06-16T14:38:33.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqg100c8g4vasdisi81i","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"TypeScript学习(一)","date":"2017-10-13T15:33:23.000Z","_content":"","source":"_posts/tslang-study-one.md","raw":"---\ntitle: TypeScript学习(一)\ndate: 2017-10-13 23:33:23\ncategories: TypeScript\ntags: \n---\n","slug":"tslang-study-one","published":1,"updated":"2019-06-16T14:38:33.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqg300cbg4va2jmqcnai","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"vagrant常用命令","date":"2018-11-15T09:52:14.000Z","_content":"\nhttps://www.vagrantup.com/docs/cli/","source":"_posts/vagrant-cli.md","raw":"---\ntitle: vagrant常用命令\ndate: 2018-11-15 17:52:14\ncategories: vagrant\ntags:\n---\n\nhttps://www.vagrantup.com/docs/cli/","slug":"vagrant-cli","published":1,"updated":"2019-06-16T14:38:33.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqg300cdg4vapvx204c2","content":"<p><a href=\"https://www.vagrantup.com/docs/cli/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/cli/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.vagrantup.com/docs/cli/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/cli/</a></p>\n"},{"title":"通过Xshell登录vagrant虚拟机","date":"2018-11-15T07:00:40.000Z","_content":"\n在windows系统环境中，可以在命令行窗口中通过`vagrant ssh`登录`vagrant`虚拟机，但是操作有诸多不便，比如复制粘贴…… \n于是，我们想到了`Xshell`。下面介绍通过`Xshell`来登录`vagrant`虚拟机。 \n\n## 使用`vagrant`账号登录\n\nVagrant虚拟机默认登录账号为`vagrant`,且通过私钥登录。 \n\n在虚拟机 vagrantfile 的目录位置下进行。\n\n1.启动虚拟机\n\n    Xshell 6 (Build 0101)\n    Copyright (c) 2002 NetSarang Computer, Inc. All rights reserved.\n    \n    Type `help' to learn how to use Xshell prompt.\n    [d:\\~]$ cd G:\\xr-server\\xr-server\n    [G:\\xr-server\\xr-server]$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Machine already provisioned. Run `vagrant provision` or use the `--provision`\n    ==> default: flag to force provisioning. Provisioners marked to run always will still run.\n    \n    [G:\\xr-server\\xr-server]$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Importing base box 'centos/7'...\n    ==> default: Matching MAC address for NAT networking...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Setting the name of the VM: centos7_xr-server\n    ==> default: Clearing any previously set network interfaces...\n    ==> default: Preparing network interfaces based on configuration...\n        default: Adapter 1: nat\n    ==> default: Forwarding ports...\n        default: 22 (guest) => 2222 (host) (adapter 1)\n    ==> default: Running 'pre-boot' VM customizations...\n    ==> default: Booting VM...\n    ==> default: Waiting for machine to boot. This may take a few minutes...\n        default: SSH address: 127.0.0.1:2222\n        default: SSH username: vagrant\n        default: SSH auth method: private key\n        default: \n        default: Vagrant insecure key detected. Vagrant will automatically replace\n        default: this with a newly generated keypair for better security.\n        default: \n        default: Inserting generated public key within guest...\n        default: Removing insecure key from the guest if it's present...\n        default: Key inserted! Disconnecting and reconnecting using new SSH key...\n    ==> default: Machine booted and ready!\n    ==> default: Checking for guest additions in VM...\n        default: No guest additions were detected on the base box for this VM! Guest\n        default: additions are required for forwarded ports, shared folders, host only\n        default: networking, and more. If SSH fails on this machine, please install\n        default: the guest additions and repackage the box to continue.\n        default: \n        default: This is not an error message; everything may continue to work properly,\n        default: in which case you may ignore this message.\n    ==> default: Setting hostname...\n    ==> default: Rsyncing folder: /cygdrive/g/xr-server/xr-server/ => /vagrant\n\n2.查看虚拟机ssh信息\n\n    [G:\\xr-server\\xr-server]$ vagrant ssh-config\n    Host default\n      HostName 127.0.0.1\n      User vagrant\n      Port 2222\n      UserKnownHostsFile /dev/null\n      StrictHostKeyChecking no\n      PasswordAuthentication no\n      IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key\n      IdentitiesOnly yes\n      LogLevel FATAL\n\n查看 hostname ，port，IdentityFile 这三个位置。知道登录主机，端口，登录私钥。\n\n3.在Xshell下新建会话，登录\n\n{%asset_img a-1.png%}\n\n点击连接，如下图：\n\n{%asset_img a-2.png%}\n\n点击确定，如下图：\n\n{%asset_img a-3.png%}\n\n选定私钥。位置在`IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key`\n\n登录成功：\n\n    Connecting to 127.0.0.1:2222...\n    Connection established.\n    To escape to local shell, press 'Ctrl+Alt+]'.\n    \n    WARNING! The remote SSH server rejected X11 forwarding request.\n    Last login: Thu Nov 15 07:31:28 2018 from 10.0.2.2\n    [vagrant@xr-server ~]$ ll\n    total 0\n    [vagrant@xr-server ~]$ cd /\n    [vagrant@xr-server /]$ \n\n\n## root账号登录\n\n1.vagrant登陆后，切换到root账号，vagrant虚拟机的root账号密码默认为`vagrant`  \n如果root没有初始化，则可以设置root的密码：   \n\n    [vagrant@xr-server ~]$ su root\n    Password: \n    [root@xr-server vagrant]# \n\n2.修改 /etc/ssh/sshd_config 文件，（注意，vagrant用户下这个文件是只读的，可能什么也看不见）   \n\n- 修改 ssd_config 里 PermitRootLogin属性 改为yes ，并把前面的# 去掉\n\n`[root@xr-server vagrant]# vim /etc/ssh/sshd_config`\n\n{%asset_img b-1.png%}\n\n保存退出。\n\n- PasswordAuthentication 改为yes 并且去掉 #\n\n{%asset_img b-2.png%}\n\n保存退出。\n\n3.保存退出，重启sshd服务     \n`$ systemctl restart sshd`\n或者\n`systemctl restart sshd.service`\n\n_问题_：虽然xshell里都是用127.0.0.1:2222或者2200 这种登录的，但是也可以使用自己设置的ip 例如192.16.25.11:22 去登录，这里用自己设置的ip时端口则是22。\n设置完成以后就和自己开的虚拟机没什么两样了。\n\n\n","source":"_posts/vagrant-Xshell.md","raw":"---\ntitle: 通过Xshell登录vagrant虚拟机\ndate: 2018-11-15 15:00:40\ncategories: vagrant\ntags:\n---\n\n在windows系统环境中，可以在命令行窗口中通过`vagrant ssh`登录`vagrant`虚拟机，但是操作有诸多不便，比如复制粘贴…… \n于是，我们想到了`Xshell`。下面介绍通过`Xshell`来登录`vagrant`虚拟机。 \n\n## 使用`vagrant`账号登录\n\nVagrant虚拟机默认登录账号为`vagrant`,且通过私钥登录。 \n\n在虚拟机 vagrantfile 的目录位置下进行。\n\n1.启动虚拟机\n\n    Xshell 6 (Build 0101)\n    Copyright (c) 2002 NetSarang Computer, Inc. All rights reserved.\n    \n    Type `help' to learn how to use Xshell prompt.\n    [d:\\~]$ cd G:\\xr-server\\xr-server\n    [G:\\xr-server\\xr-server]$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Machine already provisioned. Run `vagrant provision` or use the `--provision`\n    ==> default: flag to force provisioning. Provisioners marked to run always will still run.\n    \n    [G:\\xr-server\\xr-server]$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Importing base box 'centos/7'...\n    ==> default: Matching MAC address for NAT networking...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Setting the name of the VM: centos7_xr-server\n    ==> default: Clearing any previously set network interfaces...\n    ==> default: Preparing network interfaces based on configuration...\n        default: Adapter 1: nat\n    ==> default: Forwarding ports...\n        default: 22 (guest) => 2222 (host) (adapter 1)\n    ==> default: Running 'pre-boot' VM customizations...\n    ==> default: Booting VM...\n    ==> default: Waiting for machine to boot. This may take a few minutes...\n        default: SSH address: 127.0.0.1:2222\n        default: SSH username: vagrant\n        default: SSH auth method: private key\n        default: \n        default: Vagrant insecure key detected. Vagrant will automatically replace\n        default: this with a newly generated keypair for better security.\n        default: \n        default: Inserting generated public key within guest...\n        default: Removing insecure key from the guest if it's present...\n        default: Key inserted! Disconnecting and reconnecting using new SSH key...\n    ==> default: Machine booted and ready!\n    ==> default: Checking for guest additions in VM...\n        default: No guest additions were detected on the base box for this VM! Guest\n        default: additions are required for forwarded ports, shared folders, host only\n        default: networking, and more. If SSH fails on this machine, please install\n        default: the guest additions and repackage the box to continue.\n        default: \n        default: This is not an error message; everything may continue to work properly,\n        default: in which case you may ignore this message.\n    ==> default: Setting hostname...\n    ==> default: Rsyncing folder: /cygdrive/g/xr-server/xr-server/ => /vagrant\n\n2.查看虚拟机ssh信息\n\n    [G:\\xr-server\\xr-server]$ vagrant ssh-config\n    Host default\n      HostName 127.0.0.1\n      User vagrant\n      Port 2222\n      UserKnownHostsFile /dev/null\n      StrictHostKeyChecking no\n      PasswordAuthentication no\n      IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key\n      IdentitiesOnly yes\n      LogLevel FATAL\n\n查看 hostname ，port，IdentityFile 这三个位置。知道登录主机，端口，登录私钥。\n\n3.在Xshell下新建会话，登录\n\n{%asset_img a-1.png%}\n\n点击连接，如下图：\n\n{%asset_img a-2.png%}\n\n点击确定，如下图：\n\n{%asset_img a-3.png%}\n\n选定私钥。位置在`IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key`\n\n登录成功：\n\n    Connecting to 127.0.0.1:2222...\n    Connection established.\n    To escape to local shell, press 'Ctrl+Alt+]'.\n    \n    WARNING! The remote SSH server rejected X11 forwarding request.\n    Last login: Thu Nov 15 07:31:28 2018 from 10.0.2.2\n    [vagrant@xr-server ~]$ ll\n    total 0\n    [vagrant@xr-server ~]$ cd /\n    [vagrant@xr-server /]$ \n\n\n## root账号登录\n\n1.vagrant登陆后，切换到root账号，vagrant虚拟机的root账号密码默认为`vagrant`  \n如果root没有初始化，则可以设置root的密码：   \n\n    [vagrant@xr-server ~]$ su root\n    Password: \n    [root@xr-server vagrant]# \n\n2.修改 /etc/ssh/sshd_config 文件，（注意，vagrant用户下这个文件是只读的，可能什么也看不见）   \n\n- 修改 ssd_config 里 PermitRootLogin属性 改为yes ，并把前面的# 去掉\n\n`[root@xr-server vagrant]# vim /etc/ssh/sshd_config`\n\n{%asset_img b-1.png%}\n\n保存退出。\n\n- PasswordAuthentication 改为yes 并且去掉 #\n\n{%asset_img b-2.png%}\n\n保存退出。\n\n3.保存退出，重启sshd服务     \n`$ systemctl restart sshd`\n或者\n`systemctl restart sshd.service`\n\n_问题_：虽然xshell里都是用127.0.0.1:2222或者2200 这种登录的，但是也可以使用自己设置的ip 例如192.16.25.11:22 去登录，这里用自己设置的ip时端口则是22。\n设置完成以后就和自己开的虚拟机没什么两样了。\n\n\n","slug":"vagrant-Xshell","published":1,"updated":"2019-06-16T14:38:33.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqg500cgg4vasjgog9pp","content":"<p>在windows系统环境中，可以在命令行窗口中通过<code>vagrant ssh</code>登录<code>vagrant</code>虚拟机，但是操作有诸多不便，比如复制粘贴……<br>于是，我们想到了<code>Xshell</code>。下面介绍通过<code>Xshell</code>来登录<code>vagrant</code>虚拟机。 </p>\n<h2 id=\"使用vagrant账号登录\"><a href=\"#使用vagrant账号登录\" class=\"headerlink\" title=\"使用vagrant账号登录\"></a>使用<code>vagrant</code>账号登录</h2><p>Vagrant虚拟机默认登录账号为<code>vagrant</code>,且通过私钥登录。 </p>\n<p>在虚拟机 vagrantfile 的目录位置下进行。</p>\n<p>1.启动虚拟机</p>\n<pre><code>Xshell 6 (Build 0101)\nCopyright (c) 2002 NetSarang Computer, Inc. All rights reserved.\n\nType `help&apos; to learn how to use Xshell prompt.\n[d:\\~]$ cd G:\\xr-server\\xr-server\n[G:\\xr-server\\xr-server]$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Machine already provisioned. Run `vagrant provision` or use the `--provision`\n==&gt; default: flag to force provisioning. Provisioners marked to run always will still run.\n\n[G:\\xr-server\\xr-server]$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Importing base box &apos;centos/7&apos;...\n==&gt; default: Matching MAC address for NAT networking...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Setting the name of the VM: centos7_xr-server\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Running &apos;pre-boot&apos; VM customizations...\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n    default: \n    default: Vagrant insecure key detected. Vagrant will automatically replace\n    default: this with a newly generated keypair for better security.\n    default: \n    default: Inserting generated public key within guest...\n    default: Removing insecure key from the guest if it&apos;s present...\n    default: Key inserted! Disconnecting and reconnecting using new SSH key...\n==&gt; default: Machine booted and ready!\n==&gt; default: Checking for guest additions in VM...\n    default: No guest additions were detected on the base box for this VM! Guest\n    default: additions are required for forwarded ports, shared folders, host only\n    default: networking, and more. If SSH fails on this machine, please install\n    default: the guest additions and repackage the box to continue.\n    default: \n    default: This is not an error message; everything may continue to work properly,\n    default: in which case you may ignore this message.\n==&gt; default: Setting hostname...\n==&gt; default: Rsyncing folder: /cygdrive/g/xr-server/xr-server/ =&gt; /vagrant\n</code></pre><p>2.查看虚拟机ssh信息</p>\n<pre><code>[G:\\xr-server\\xr-server]$ vagrant ssh-config\nHost default\n  HostName 127.0.0.1\n  User vagrant\n  Port 2222\n  UserKnownHostsFile /dev/null\n  StrictHostKeyChecking no\n  PasswordAuthentication no\n  IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key\n  IdentitiesOnly yes\n  LogLevel FATAL\n</code></pre><p>查看 hostname ，port，IdentityFile 这三个位置。知道登录主机，端口，登录私钥。</p>\n<p>3.在Xshell下新建会话，登录</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-1.png\">\n<p>点击连接，如下图：</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-2.png\">\n<p>点击确定，如下图：</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-3.png\">\n<p>选定私钥。位置在<code>IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key</code></p>\n<p>登录成功：</p>\n<pre><code>Connecting to 127.0.0.1:2222...\nConnection established.\nTo escape to local shell, press &apos;Ctrl+Alt+]&apos;.\n\nWARNING! The remote SSH server rejected X11 forwarding request.\nLast login: Thu Nov 15 07:31:28 2018 from 10.0.2.2\n[vagrant@xr-server ~]$ ll\ntotal 0\n[vagrant@xr-server ~]$ cd /\n[vagrant@xr-server /]$ \n</code></pre><h2 id=\"root账号登录\"><a href=\"#root账号登录\" class=\"headerlink\" title=\"root账号登录\"></a>root账号登录</h2><p>1.vagrant登陆后，切换到root账号，vagrant虚拟机的root账号密码默认为<code>vagrant</code><br>如果root没有初始化，则可以设置root的密码：   </p>\n<pre><code>[vagrant@xr-server ~]$ su root\nPassword: \n[root@xr-server vagrant]# \n</code></pre><p>2.修改 /etc/ssh/sshd_config 文件，（注意，vagrant用户下这个文件是只读的，可能什么也看不见）   </p>\n<ul>\n<li>修改 ssd_config 里 PermitRootLogin属性 改为yes ，并把前面的# 去掉</li>\n</ul>\n<p><code>[root@xr-server vagrant]# vim /etc/ssh/sshd_config</code></p>\n<img src=\"/2018/11/15/vagrant-Xshell/b-1.png\">\n<p>保存退出。</p>\n<ul>\n<li>PasswordAuthentication 改为yes 并且去掉 #</li>\n</ul>\n<img src=\"/2018/11/15/vagrant-Xshell/b-2.png\">\n<p>保存退出。</p>\n<p>3.保存退出，重启sshd服务<br><code>$ systemctl restart sshd</code><br>或者<br><code>systemctl restart sshd.service</code></p>\n<p>_问题_：虽然xshell里都是用127.0.0.1:2222或者2200 这种登录的，但是也可以使用自己设置的ip 例如192.16.25.11:22 去登录，这里用自己设置的ip时端口则是22。<br>设置完成以后就和自己开的虚拟机没什么两样了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在windows系统环境中，可以在命令行窗口中通过<code>vagrant ssh</code>登录<code>vagrant</code>虚拟机，但是操作有诸多不便，比如复制粘贴……<br>于是，我们想到了<code>Xshell</code>。下面介绍通过<code>Xshell</code>来登录<code>vagrant</code>虚拟机。 </p>\n<h2 id=\"使用vagrant账号登录\"><a href=\"#使用vagrant账号登录\" class=\"headerlink\" title=\"使用vagrant账号登录\"></a>使用<code>vagrant</code>账号登录</h2><p>Vagrant虚拟机默认登录账号为<code>vagrant</code>,且通过私钥登录。 </p>\n<p>在虚拟机 vagrantfile 的目录位置下进行。</p>\n<p>1.启动虚拟机</p>\n<pre><code>Xshell 6 (Build 0101)\nCopyright (c) 2002 NetSarang Computer, Inc. All rights reserved.\n\nType `help&apos; to learn how to use Xshell prompt.\n[d:\\~]$ cd G:\\xr-server\\xr-server\n[G:\\xr-server\\xr-server]$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Machine already provisioned. Run `vagrant provision` or use the `--provision`\n==&gt; default: flag to force provisioning. Provisioners marked to run always will still run.\n\n[G:\\xr-server\\xr-server]$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Importing base box &apos;centos/7&apos;...\n==&gt; default: Matching MAC address for NAT networking...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Setting the name of the VM: centos7_xr-server\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Running &apos;pre-boot&apos; VM customizations...\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n    default: \n    default: Vagrant insecure key detected. Vagrant will automatically replace\n    default: this with a newly generated keypair for better security.\n    default: \n    default: Inserting generated public key within guest...\n    default: Removing insecure key from the guest if it&apos;s present...\n    default: Key inserted! Disconnecting and reconnecting using new SSH key...\n==&gt; default: Machine booted and ready!\n==&gt; default: Checking for guest additions in VM...\n    default: No guest additions were detected on the base box for this VM! Guest\n    default: additions are required for forwarded ports, shared folders, host only\n    default: networking, and more. If SSH fails on this machine, please install\n    default: the guest additions and repackage the box to continue.\n    default: \n    default: This is not an error message; everything may continue to work properly,\n    default: in which case you may ignore this message.\n==&gt; default: Setting hostname...\n==&gt; default: Rsyncing folder: /cygdrive/g/xr-server/xr-server/ =&gt; /vagrant\n</code></pre><p>2.查看虚拟机ssh信息</p>\n<pre><code>[G:\\xr-server\\xr-server]$ vagrant ssh-config\nHost default\n  HostName 127.0.0.1\n  User vagrant\n  Port 2222\n  UserKnownHostsFile /dev/null\n  StrictHostKeyChecking no\n  PasswordAuthentication no\n  IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key\n  IdentitiesOnly yes\n  LogLevel FATAL\n</code></pre><p>查看 hostname ，port，IdentityFile 这三个位置。知道登录主机，端口，登录私钥。</p>\n<p>3.在Xshell下新建会话，登录</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-1.png\">\n<p>点击连接，如下图：</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-2.png\">\n<p>点击确定，如下图：</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-3.png\">\n<p>选定私钥。位置在<code>IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key</code></p>\n<p>登录成功：</p>\n<pre><code>Connecting to 127.0.0.1:2222...\nConnection established.\nTo escape to local shell, press &apos;Ctrl+Alt+]&apos;.\n\nWARNING! The remote SSH server rejected X11 forwarding request.\nLast login: Thu Nov 15 07:31:28 2018 from 10.0.2.2\n[vagrant@xr-server ~]$ ll\ntotal 0\n[vagrant@xr-server ~]$ cd /\n[vagrant@xr-server /]$ \n</code></pre><h2 id=\"root账号登录\"><a href=\"#root账号登录\" class=\"headerlink\" title=\"root账号登录\"></a>root账号登录</h2><p>1.vagrant登陆后，切换到root账号，vagrant虚拟机的root账号密码默认为<code>vagrant</code><br>如果root没有初始化，则可以设置root的密码：   </p>\n<pre><code>[vagrant@xr-server ~]$ su root\nPassword: \n[root@xr-server vagrant]# \n</code></pre><p>2.修改 /etc/ssh/sshd_config 文件，（注意，vagrant用户下这个文件是只读的，可能什么也看不见）   </p>\n<ul>\n<li>修改 ssd_config 里 PermitRootLogin属性 改为yes ，并把前面的# 去掉</li>\n</ul>\n<p><code>[root@xr-server vagrant]# vim /etc/ssh/sshd_config</code></p>\n<img src=\"/2018/11/15/vagrant-Xshell/b-1.png\">\n<p>保存退出。</p>\n<ul>\n<li>PasswordAuthentication 改为yes 并且去掉 #</li>\n</ul>\n<img src=\"/2018/11/15/vagrant-Xshell/b-2.png\">\n<p>保存退出。</p>\n<p>3.保存退出，重启sshd服务<br><code>$ systemctl restart sshd</code><br>或者<br><code>systemctl restart sshd.service</code></p>\n<p>_问题_：虽然xshell里都是用127.0.0.1:2222或者2200 这种登录的，但是也可以使用自己设置的ip 例如192.16.25.11:22 去登录，这里用自己设置的ip时端口则是22。<br>设置完成以后就和自己开的虚拟机没什么两样了。</p>\n"},{"title":"虚拟开发环境-Vagrant","date":"2018-01-23T02:04:27.000Z","_content":"\n介绍vagrant，为公司搭建统一的开发环境。最终会输出一个统一的虚拟开发环境，然后就可以分发给团队中所有的开发人员，大家在一致的开发环境中编辑，验证代码……\n\n从此,告别“在我的机子上运行没问题的……”这个看似很有道理的扯皮了。\n\n官网网址：https://www.vagrantup.com/\n\n## vagrant安装\n\n### 安装开源虚拟机VirtualBox\n\n注意安装版本和vagrant版本要对应，否则后面会出现各种问题。这里安装最新版本。  \n \n下载地址：https://www.virtualbox.org/wiki/Downloads \n\n选择自己电脑系统对应版本。\n\n{% asset_img a.png %}\n\n    axel -n 10 https://download.virtualbox.org/virtualbox/5.2.14/virtualbox-5.2_5.2.14-123301~Ubuntu~xenial_amd64.deb\n\n然后，执行安装命令`sudo dpkg -i *.deb`进行安装即可。\n\n安装过程中可能会缺少依赖包，把依赖包安装即可：\n\n{% asset_img b.png %}\n\n安装依赖包：`mutian@mutian-ThinkPad-T440p:~/Downloads$ sudo apt install libsdl1.2debian`\n\n重新执行安装命令：\n\n{% asset_img c.png %}\n\n安装没有任何错误。 已安装到系统。\n\n{% asset_img d.png %}\n\n_windows下安装问题_：     \n安装Virtualbox的时候回滚，并提示发生一个严重的错误。\n\n    解决方法如下：\n    \n    打开服务选项  ：win + R  然后在跳出来的编辑框 键入  services.msc   然后回车\n    \n    1.Device Install Service\n    \n    2.Device Setup Manager\n    \n    开启这两个服务，然后右键安装程序，以管理员身份运行，然后就能安装啦~\n\n### 安装vagrant\n\n安装最新版本。\n\n下载地址：https://www.vagrantup.com/downloads.html \n\n下载自己电脑系统对应版本。\n\n    axel -n 10 https://releases.hashicorp.com/vagrant/2.1.2/vagrant_2.1.2_x86_64.deb\n\n然后，执行安装命令`sudo dpkg -i vagrant_2.1.2_x86_64.deb`进行安装即可。\n\n查看安装是否成功：\n\n    mutian@mutian-ThinkPad-T440p:~/Downloads$ vagrant -v\n    Vagrant 2.1.2\n\n表明安装已经成功，版本`2.1.2`。\n\n## 添加Box\n\n官方box源：https://app.vagrantup.com/boxes/search \n\n网络不好，需要翻墙。或者通过其它途径下载想要的box。\n\n- 查看所有已下载box\n\n`vagrant box list`\n\n- 添加box\n\n`vagrant box add centos/7`\n\n执行上面命令会添加相应box到vagrant系统，如果没有，会先从box官源下载。   \n\n- 再次执行`vagrant box list`便可以看到。 \n\n离线方式：   \nhttps://cloud.centos.org/centos/7/vagrant/x86_64/images/\n\n下载相应box镜像，然后执行命令添加box：\n\n    vagrant box add centos/7 aa.box\n\n## 创造自己box\n\n- 创建目录\n\n` mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ mkdir xcsqjr-dev/` \n\n- 初始化，创建配置文件\n\n\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ cd xcsqjr-dev/\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/xcsqjr-dev$ vagrant init centos/7\n    A `Vagrantfile` has been placed in this directory. You are now\n    ready to `vagrant up` your first virtual environment! Please read\n    the comments in the Vagrantfile as well as documentation on\n    `vagrantup.com` for more information on using Vagrant. \n\n会在当前目录下创建文件`Vagrantfile`。然后就可以编辑该文件，做一些配置：\n\n    # -*- mode: ruby -*-\n    # vi: set ft=ruby :\n    \n    # All Vagrant configuration is done below. The \"2\" in Vagrant.configure\n    # configures the configuration version (we support older styles for\n    # backwards compatibility). Please don't change it unless you know what\n    # you're doing.\n    Vagrant.configure(\"2\") do |config|\n      # The most common configuration options are documented and commented below.\n      # For a complete reference, please see the online documentation at\n      # https://docs.vagrantup.com.\n    \n      # Every Vagrant development environment requires a box. You can search for\n      # boxes at https://vagrantcloud.com/search.\n      \n      # ----------- 一些相关配置 start ----------------#\n      config.vm.box = \"centos/7\" #和已经下载的box名字一致\n      config.vm.hostname = \"ymu\"  \n      #config.vm.box_version = \"1.1.0\"\t\n      config.vm.box_url = \"http://ymu.box\"\n    \n      # 对虚拟机的一些配置 \t\n      config.vm.provider \"virtualbox\" do |vb|\n      #   # Display the VirtualBox GUI when booting the machine\n      #   vb.gui = true\n      #\n      #   # Customize the amount of memory on the VM:\n          vb.memory = \"1024\" #为虚拟机分配内存\n          vb.cpus = 2 #为虚拟机分配cup，分2核心\n          vb.name = \"centos7_ymu\" #虚拟机名称\n      end\n      \n      # ----------- 一些相关配置 end ----------------#\n    \n      # Disable automatic box update checking. If you disable this, then\n      # boxes will only be checked for updates when the user runs\n      # `vagrant box outdated`. This is not recommended.\n      # config.vm.box_check_update = false\n    \n      # Create a forwarded port mapping which allows access to a specific port\n      # within the machine from a port on the host machine. In the example below,\n      # accessing \"localhost:8080\" will access port 80 on the guest machine.\n      # NOTE: This will enable public access to the opened port\n      # config.vm.network \"forwarded_port\", guest: 80, host: 8080\n    \n      # Create a forwarded port mapping which allows access to a specific port\n      # within the machine from a port on the host machine and only allow access\n      # via 127.0.0.1 to disable public access\n      # config.vm.network \"forwarded_port\", guest: 80, host: 8080, host_ip: \"127.0.0.1\"\n    \n      # Create a private network, which allows host-only access to the machine\n      # using a specific IP.\n      # config.vm.network \"private_network\", ip: \"192.168.33.10\"\n    \n      # Create a public network, which generally matched to bridged network.\n      # Bridged networks make the machine appear as another physical device on\n      # your network.\n      # config.vm.network \"public_network\"\n    \n      # Share an additional folder to the guest VM. The first argument is\n      # the path on the host to the actual folder. The second argument is\n      # the path on the guest to mount the folder. And the optional third\n      # argument is a set of non-required options.\n      # config.vm.synced_folder \"../data\", \"/vagrant_data\"\n    \n      # Provider-specific configuration so you can fine-tune various\n      # backing providers for Vagrant. These expose provider-specific options.\n      # Example for VirtualBox:\n      #\n      # config.vm.provider \"virtualbox\" do |vb|\n      #   # Display the VirtualBox GUI when booting the machine\n      #   vb.gui = true\n      #\n      #   # Customize the amount of memory on the VM:\n      #   vb.memory = \"1024\"\n      # end\n      #\n      # View the documentation for the provider you are using for more\n      # information on available options.\n    \n      # Enable provisioning with a shell script. Additional provisioners such as\n      # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the\n      # documentation for more information about their specific syntax and use.\n      # config.vm.provision \"shell\", inline: <<-SHELL\n      #   apt-get update\n      #   apt-get install -y apache2\n      # SHELL\n    end\n\n- 启动虚拟机\n\n\n    mutian@mutian-ThinkPad-T440p:~$ cd dev/vagrant/ymu-dev/\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Clearing any previously set forwarded ports...\n    ==> default: Clearing any previously set network interfaces...\n    ==> default: Preparing network interfaces based on configuration...\n        default: Adapter 1: nat\n    ==> default: Forwarding ports...\n        default: 22 (guest) => 2222 (host) (adapter 1)\n    ==> default: Running 'pre-boot' VM customizations...\n    ==> default: Booting VM...\n    ==> default: Waiting for machine to boot. This may take a few minutes...\n        default: SSH address: 127.0.0.1:2222\n        default: SSH username: vagrant\n        default: SSH auth method: private key\n \n 打开virtualbox,可以看到centos7_ymu的虚拟机已经启动。\n        \n {%asset_img e.png%}  \n \n - 进入该虚拟机\n \n ` vagrant ssh`\n \n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant ssh\n    Last login: Mon Jul  9 07:40:01 2018 from 10.0.2.2\n    [vagrant@ymu ~]$ \n\n下面就可以在里面，类似在真实的服务器操作系统里面一样，安装各种开发软件，配置各种开发环境了。 \n\n- 登出虚拟机\n\n        [vagrant@ymu ~]$ logout\n        Connection to 127.0.0.1 closed.\n        mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ \n        \n- 停止运行虚拟机\n\n        mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant halt\n        ==> default: Attempting graceful shutdown of VM...\n\n- 挂起虚拟机\n\n`vagrant shutdown`\n\n- 重新加载配置启动\n\n`vagrant reload`\n\n### 配置\n\n    config.vm.box = \"centos/7\" #和已经下载的box名字一致\n    config.vm.hostname = \"ymu\"  \n    #config.vm.box_version = \"1.1.0\"\t\n    config.vm.box_url = \"http://ymu.box\"\n    config.vm.synced_folder \"/home/mutian/dev/java/github/ymu-micro-service\", \"/vagrant\", :ext4 => true #共享文件夹\n  \n#### 配置共享文件\n\n注：如果不配置共享目录，默认会把`Vagrantfile`文件所在的目录同步到虚拟机中的`、vagrant`目录下。\n\n`config.vm.synced_folder \"/home/mutian/dev/java/github/ymu-micro-service\", \"/vagrant\", :ext4 => true #共享文件夹`\n\n第一个路径为宿主电脑文件夹，第二个为同步的虚拟机文件夹。宿主机文件夹中所有内容将实时同步到虚拟机中文件夹下。\n\n注意文件类型。在`ubuntu`下查询自己系统文件类型执行命令`df -lhT`。\n\n登录虚拟机，进入`/vagrant`,将看到：\n\n    [vagrant@ymu vagrant]$ ls\n    logs    ymu-config-repo    ymu-hystrix-dashboard  ymu-server-eureka\n    target  ymu-config-server  ymu-hystrix-turbine    ymu-service-basic\n\n看到宿舍机相关目录下的内容同步过来了。\n\n所以，这个时候，你就可以只在宿主机编辑代码，在虚拟机里面编译执行了。\n\n#### 配置网络\n\n## 为自己的box安装各种应用环境\n\n### docker安装\n\n设置自启动：`systemctl enable docker.service`\n\n参考之前blog。\n\n### 安装`nginx`\n\n- docker运行方式\n- 传统按照方式。\n\n### 安装`redis`\n\n- docker运行方式\n\nhttps://hub.docker.com/_/redis/\n\n- 传统按照方式。\n\n## 打包分发\n\n1.打包，把上面自己定制的box打包。     \n命令： \n- `vagrant package --output xxx.box`\n-  `vagrant package --output xxx.box --base 虚拟机名称`  \n\n2.分发，把打好的包通过优盘等，给其它人用。\n\n3.更新软件\n\n- 老用户\n\n- 新用户   \n用最新的打包即可。\n\n## 实时共享文件的问题\n\n通常，默认的，启动虚拟机后或者重新启动虚拟机，会同步Vagrantfile所在目录到虚拟机的目录`/vagrant`下，但是修改了宿主机的文件，不能实时同步到虚拟机。\n\n下面介绍宿主机通过安装rsync来实时同步宿主机子的文件到虚拟机。    \n\nhttps://www.vagrantup.com/docs/synced-folders/rsync.html\n\n### window下安装rsync\n\n通过安装来cygwin安装rsync。     \ncygwin的网址：https://cygwin.com/install.html。下载安装即可。\n\n安装好后，配置`Vagrantfile`文件。 \n具体配置查看:https://www.vagrantup.com/docs/synced-folders/rsync.html\n\n    config.vm.synced_folder \".\", \"/vagrant\",type:\"rsync\"\n    或\n    config.vm.synced_folder \".\", \"/vagrant\",type:\"rsync\",rsync__auto:\"true\"\n\n启动或者重启`vagrant reload`,然后执行`vagrant rsync-auto`.    \n\n试试改变宿主机的文件，就实时同步到虚拟机了。只能单向把宿主机的文件同步到虚拟机。\n\n_命令说明_:   \n\n- type：rsync，关键，指定类型。\n- rsync__auto：默认是true，如果不配置。如果设置了false，则不实时同步该宿主机目录。\n\n\n### linux系统安装rsync\n\n    yun install rsync\n\n\n## win7启动powershell版本过低问题\n\n    F:\\xrlj.github.com\\xrlj-vagrant-dev>vagrant up\n    The version of powershell currently installed on this host is less than\n    the required minimum version. Please upgrade the installed version of\n    powershell to the minimum required version and run the command again.\n    \n      Installed version: 2\n    \n      Minimum required version: 3\n\n要求powershell版本3以上，所以要升级powershell。  \n\n下面是升级powershell到4.0的方法： \n\nhttps://social.technet.microsoft.com/wiki/contents/articles/21016.how-to-install-windows-powershell-4-0.aspx    \n\n下载对应版本。 \nwin7 sp1下载这个：Windows6.1-KB2819745-x64-MultiPkg.msu\n\n## 学习资源\n\n- http://www.imooc.com/learn/805\n- https://github.com/apanly/mooc\n","source":"_posts/vagrant-start.md","raw":"---\ntitle: 虚拟开发环境-Vagrant\ndate: 2018-01-23 10:04:27\ncategories: vagrant\ntags: vagrant-start\n---\n\n介绍vagrant，为公司搭建统一的开发环境。最终会输出一个统一的虚拟开发环境，然后就可以分发给团队中所有的开发人员，大家在一致的开发环境中编辑，验证代码……\n\n从此,告别“在我的机子上运行没问题的……”这个看似很有道理的扯皮了。\n\n官网网址：https://www.vagrantup.com/\n\n## vagrant安装\n\n### 安装开源虚拟机VirtualBox\n\n注意安装版本和vagrant版本要对应，否则后面会出现各种问题。这里安装最新版本。  \n \n下载地址：https://www.virtualbox.org/wiki/Downloads \n\n选择自己电脑系统对应版本。\n\n{% asset_img a.png %}\n\n    axel -n 10 https://download.virtualbox.org/virtualbox/5.2.14/virtualbox-5.2_5.2.14-123301~Ubuntu~xenial_amd64.deb\n\n然后，执行安装命令`sudo dpkg -i *.deb`进行安装即可。\n\n安装过程中可能会缺少依赖包，把依赖包安装即可：\n\n{% asset_img b.png %}\n\n安装依赖包：`mutian@mutian-ThinkPad-T440p:~/Downloads$ sudo apt install libsdl1.2debian`\n\n重新执行安装命令：\n\n{% asset_img c.png %}\n\n安装没有任何错误。 已安装到系统。\n\n{% asset_img d.png %}\n\n_windows下安装问题_：     \n安装Virtualbox的时候回滚，并提示发生一个严重的错误。\n\n    解决方法如下：\n    \n    打开服务选项  ：win + R  然后在跳出来的编辑框 键入  services.msc   然后回车\n    \n    1.Device Install Service\n    \n    2.Device Setup Manager\n    \n    开启这两个服务，然后右键安装程序，以管理员身份运行，然后就能安装啦~\n\n### 安装vagrant\n\n安装最新版本。\n\n下载地址：https://www.vagrantup.com/downloads.html \n\n下载自己电脑系统对应版本。\n\n    axel -n 10 https://releases.hashicorp.com/vagrant/2.1.2/vagrant_2.1.2_x86_64.deb\n\n然后，执行安装命令`sudo dpkg -i vagrant_2.1.2_x86_64.deb`进行安装即可。\n\n查看安装是否成功：\n\n    mutian@mutian-ThinkPad-T440p:~/Downloads$ vagrant -v\n    Vagrant 2.1.2\n\n表明安装已经成功，版本`2.1.2`。\n\n## 添加Box\n\n官方box源：https://app.vagrantup.com/boxes/search \n\n网络不好，需要翻墙。或者通过其它途径下载想要的box。\n\n- 查看所有已下载box\n\n`vagrant box list`\n\n- 添加box\n\n`vagrant box add centos/7`\n\n执行上面命令会添加相应box到vagrant系统，如果没有，会先从box官源下载。   \n\n- 再次执行`vagrant box list`便可以看到。 \n\n离线方式：   \nhttps://cloud.centos.org/centos/7/vagrant/x86_64/images/\n\n下载相应box镜像，然后执行命令添加box：\n\n    vagrant box add centos/7 aa.box\n\n## 创造自己box\n\n- 创建目录\n\n` mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ mkdir xcsqjr-dev/` \n\n- 初始化，创建配置文件\n\n\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ cd xcsqjr-dev/\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/xcsqjr-dev$ vagrant init centos/7\n    A `Vagrantfile` has been placed in this directory. You are now\n    ready to `vagrant up` your first virtual environment! Please read\n    the comments in the Vagrantfile as well as documentation on\n    `vagrantup.com` for more information on using Vagrant. \n\n会在当前目录下创建文件`Vagrantfile`。然后就可以编辑该文件，做一些配置：\n\n    # -*- mode: ruby -*-\n    # vi: set ft=ruby :\n    \n    # All Vagrant configuration is done below. The \"2\" in Vagrant.configure\n    # configures the configuration version (we support older styles for\n    # backwards compatibility). Please don't change it unless you know what\n    # you're doing.\n    Vagrant.configure(\"2\") do |config|\n      # The most common configuration options are documented and commented below.\n      # For a complete reference, please see the online documentation at\n      # https://docs.vagrantup.com.\n    \n      # Every Vagrant development environment requires a box. You can search for\n      # boxes at https://vagrantcloud.com/search.\n      \n      # ----------- 一些相关配置 start ----------------#\n      config.vm.box = \"centos/7\" #和已经下载的box名字一致\n      config.vm.hostname = \"ymu\"  \n      #config.vm.box_version = \"1.1.0\"\t\n      config.vm.box_url = \"http://ymu.box\"\n    \n      # 对虚拟机的一些配置 \t\n      config.vm.provider \"virtualbox\" do |vb|\n      #   # Display the VirtualBox GUI when booting the machine\n      #   vb.gui = true\n      #\n      #   # Customize the amount of memory on the VM:\n          vb.memory = \"1024\" #为虚拟机分配内存\n          vb.cpus = 2 #为虚拟机分配cup，分2核心\n          vb.name = \"centos7_ymu\" #虚拟机名称\n      end\n      \n      # ----------- 一些相关配置 end ----------------#\n    \n      # Disable automatic box update checking. If you disable this, then\n      # boxes will only be checked for updates when the user runs\n      # `vagrant box outdated`. This is not recommended.\n      # config.vm.box_check_update = false\n    \n      # Create a forwarded port mapping which allows access to a specific port\n      # within the machine from a port on the host machine. In the example below,\n      # accessing \"localhost:8080\" will access port 80 on the guest machine.\n      # NOTE: This will enable public access to the opened port\n      # config.vm.network \"forwarded_port\", guest: 80, host: 8080\n    \n      # Create a forwarded port mapping which allows access to a specific port\n      # within the machine from a port on the host machine and only allow access\n      # via 127.0.0.1 to disable public access\n      # config.vm.network \"forwarded_port\", guest: 80, host: 8080, host_ip: \"127.0.0.1\"\n    \n      # Create a private network, which allows host-only access to the machine\n      # using a specific IP.\n      # config.vm.network \"private_network\", ip: \"192.168.33.10\"\n    \n      # Create a public network, which generally matched to bridged network.\n      # Bridged networks make the machine appear as another physical device on\n      # your network.\n      # config.vm.network \"public_network\"\n    \n      # Share an additional folder to the guest VM. The first argument is\n      # the path on the host to the actual folder. The second argument is\n      # the path on the guest to mount the folder. And the optional third\n      # argument is a set of non-required options.\n      # config.vm.synced_folder \"../data\", \"/vagrant_data\"\n    \n      # Provider-specific configuration so you can fine-tune various\n      # backing providers for Vagrant. These expose provider-specific options.\n      # Example for VirtualBox:\n      #\n      # config.vm.provider \"virtualbox\" do |vb|\n      #   # Display the VirtualBox GUI when booting the machine\n      #   vb.gui = true\n      #\n      #   # Customize the amount of memory on the VM:\n      #   vb.memory = \"1024\"\n      # end\n      #\n      # View the documentation for the provider you are using for more\n      # information on available options.\n    \n      # Enable provisioning with a shell script. Additional provisioners such as\n      # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the\n      # documentation for more information about their specific syntax and use.\n      # config.vm.provision \"shell\", inline: <<-SHELL\n      #   apt-get update\n      #   apt-get install -y apache2\n      # SHELL\n    end\n\n- 启动虚拟机\n\n\n    mutian@mutian-ThinkPad-T440p:~$ cd dev/vagrant/ymu-dev/\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Clearing any previously set forwarded ports...\n    ==> default: Clearing any previously set network interfaces...\n    ==> default: Preparing network interfaces based on configuration...\n        default: Adapter 1: nat\n    ==> default: Forwarding ports...\n        default: 22 (guest) => 2222 (host) (adapter 1)\n    ==> default: Running 'pre-boot' VM customizations...\n    ==> default: Booting VM...\n    ==> default: Waiting for machine to boot. This may take a few minutes...\n        default: SSH address: 127.0.0.1:2222\n        default: SSH username: vagrant\n        default: SSH auth method: private key\n \n 打开virtualbox,可以看到centos7_ymu的虚拟机已经启动。\n        \n {%asset_img e.png%}  \n \n - 进入该虚拟机\n \n ` vagrant ssh`\n \n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant ssh\n    Last login: Mon Jul  9 07:40:01 2018 from 10.0.2.2\n    [vagrant@ymu ~]$ \n\n下面就可以在里面，类似在真实的服务器操作系统里面一样，安装各种开发软件，配置各种开发环境了。 \n\n- 登出虚拟机\n\n        [vagrant@ymu ~]$ logout\n        Connection to 127.0.0.1 closed.\n        mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ \n        \n- 停止运行虚拟机\n\n        mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant halt\n        ==> default: Attempting graceful shutdown of VM...\n\n- 挂起虚拟机\n\n`vagrant shutdown`\n\n- 重新加载配置启动\n\n`vagrant reload`\n\n### 配置\n\n    config.vm.box = \"centos/7\" #和已经下载的box名字一致\n    config.vm.hostname = \"ymu\"  \n    #config.vm.box_version = \"1.1.0\"\t\n    config.vm.box_url = \"http://ymu.box\"\n    config.vm.synced_folder \"/home/mutian/dev/java/github/ymu-micro-service\", \"/vagrant\", :ext4 => true #共享文件夹\n  \n#### 配置共享文件\n\n注：如果不配置共享目录，默认会把`Vagrantfile`文件所在的目录同步到虚拟机中的`、vagrant`目录下。\n\n`config.vm.synced_folder \"/home/mutian/dev/java/github/ymu-micro-service\", \"/vagrant\", :ext4 => true #共享文件夹`\n\n第一个路径为宿主电脑文件夹，第二个为同步的虚拟机文件夹。宿主机文件夹中所有内容将实时同步到虚拟机中文件夹下。\n\n注意文件类型。在`ubuntu`下查询自己系统文件类型执行命令`df -lhT`。\n\n登录虚拟机，进入`/vagrant`,将看到：\n\n    [vagrant@ymu vagrant]$ ls\n    logs    ymu-config-repo    ymu-hystrix-dashboard  ymu-server-eureka\n    target  ymu-config-server  ymu-hystrix-turbine    ymu-service-basic\n\n看到宿舍机相关目录下的内容同步过来了。\n\n所以，这个时候，你就可以只在宿主机编辑代码，在虚拟机里面编译执行了。\n\n#### 配置网络\n\n## 为自己的box安装各种应用环境\n\n### docker安装\n\n设置自启动：`systemctl enable docker.service`\n\n参考之前blog。\n\n### 安装`nginx`\n\n- docker运行方式\n- 传统按照方式。\n\n### 安装`redis`\n\n- docker运行方式\n\nhttps://hub.docker.com/_/redis/\n\n- 传统按照方式。\n\n## 打包分发\n\n1.打包，把上面自己定制的box打包。     \n命令： \n- `vagrant package --output xxx.box`\n-  `vagrant package --output xxx.box --base 虚拟机名称`  \n\n2.分发，把打好的包通过优盘等，给其它人用。\n\n3.更新软件\n\n- 老用户\n\n- 新用户   \n用最新的打包即可。\n\n## 实时共享文件的问题\n\n通常，默认的，启动虚拟机后或者重新启动虚拟机，会同步Vagrantfile所在目录到虚拟机的目录`/vagrant`下，但是修改了宿主机的文件，不能实时同步到虚拟机。\n\n下面介绍宿主机通过安装rsync来实时同步宿主机子的文件到虚拟机。    \n\nhttps://www.vagrantup.com/docs/synced-folders/rsync.html\n\n### window下安装rsync\n\n通过安装来cygwin安装rsync。     \ncygwin的网址：https://cygwin.com/install.html。下载安装即可。\n\n安装好后，配置`Vagrantfile`文件。 \n具体配置查看:https://www.vagrantup.com/docs/synced-folders/rsync.html\n\n    config.vm.synced_folder \".\", \"/vagrant\",type:\"rsync\"\n    或\n    config.vm.synced_folder \".\", \"/vagrant\",type:\"rsync\",rsync__auto:\"true\"\n\n启动或者重启`vagrant reload`,然后执行`vagrant rsync-auto`.    \n\n试试改变宿主机的文件，就实时同步到虚拟机了。只能单向把宿主机的文件同步到虚拟机。\n\n_命令说明_:   \n\n- type：rsync，关键，指定类型。\n- rsync__auto：默认是true，如果不配置。如果设置了false，则不实时同步该宿主机目录。\n\n\n### linux系统安装rsync\n\n    yun install rsync\n\n\n## win7启动powershell版本过低问题\n\n    F:\\xrlj.github.com\\xrlj-vagrant-dev>vagrant up\n    The version of powershell currently installed on this host is less than\n    the required minimum version. Please upgrade the installed version of\n    powershell to the minimum required version and run the command again.\n    \n      Installed version: 2\n    \n      Minimum required version: 3\n\n要求powershell版本3以上，所以要升级powershell。  \n\n下面是升级powershell到4.0的方法： \n\nhttps://social.technet.microsoft.com/wiki/contents/articles/21016.how-to-install-windows-powershell-4-0.aspx    \n\n下载对应版本。 \nwin7 sp1下载这个：Windows6.1-KB2819745-x64-MultiPkg.msu\n\n## 学习资源\n\n- http://www.imooc.com/learn/805\n- https://github.com/apanly/mooc\n","slug":"vagrant-start","published":1,"updated":"2019-06-17T16:06:28.279Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqg600cig4vaw386n5qt","content":"<p>介绍vagrant，为公司搭建统一的开发环境。最终会输出一个统一的虚拟开发环境，然后就可以分发给团队中所有的开发人员，大家在一致的开发环境中编辑，验证代码……</p>\n<p>从此,告别“在我的机子上运行没问题的……”这个看似很有道理的扯皮了。</p>\n<p>官网网址：<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a></p>\n<h2 id=\"vagrant安装\"><a href=\"#vagrant安装\" class=\"headerlink\" title=\"vagrant安装\"></a>vagrant安装</h2><h3 id=\"安装开源虚拟机VirtualBox\"><a href=\"#安装开源虚拟机VirtualBox\" class=\"headerlink\" title=\"安装开源虚拟机VirtualBox\"></a>安装开源虚拟机VirtualBox</h3><p>注意安装版本和vagrant版本要对应，否则后面会出现各种问题。这里安装最新版本。  </p>\n<p>下载地址：<a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/wiki/Downloads</a> </p>\n<p>选择自己电脑系统对应版本。</p>\n<img src=\"/2018/01/23/vagrant-start/a.png\">\n<pre><code>axel -n 10 https://download.virtualbox.org/virtualbox/5.2.14/virtualbox-5.2_5.2.14-123301~Ubuntu~xenial_amd64.deb\n</code></pre><p>然后，执行安装命令<code>sudo dpkg -i *.deb</code>进行安装即可。</p>\n<p>安装过程中可能会缺少依赖包，把依赖包安装即可：</p>\n<img src=\"/2018/01/23/vagrant-start/b.png\">\n<p>安装依赖包：<code>mutian@mutian-ThinkPad-T440p:~/Downloads$ sudo apt install libsdl1.2debian</code></p>\n<p>重新执行安装命令：</p>\n<img src=\"/2018/01/23/vagrant-start/c.png\">\n<p>安装没有任何错误。 已安装到系统。</p>\n<img src=\"/2018/01/23/vagrant-start/d.png\">\n<p><em>windows下安装问题</em>：<br>安装Virtualbox的时候回滚，并提示发生一个严重的错误。</p>\n<pre><code>解决方法如下：\n\n打开服务选项  ：win + R  然后在跳出来的编辑框 键入  services.msc   然后回车\n\n1.Device Install Service\n\n2.Device Setup Manager\n\n开启这两个服务，然后右键安装程序，以管理员身份运行，然后就能安装啦~\n</code></pre><h3 id=\"安装vagrant\"><a href=\"#安装vagrant\" class=\"headerlink\" title=\"安装vagrant\"></a>安装vagrant</h3><p>安装最新版本。</p>\n<p>下载地址：<a href=\"https://www.vagrantup.com/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/downloads.html</a> </p>\n<p>下载自己电脑系统对应版本。</p>\n<pre><code>axel -n 10 https://releases.hashicorp.com/vagrant/2.1.2/vagrant_2.1.2_x86_64.deb\n</code></pre><p>然后，执行安装命令<code>sudo dpkg -i vagrant_2.1.2_x86_64.deb</code>进行安装即可。</p>\n<p>查看安装是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/Downloads$ vagrant -v\nVagrant 2.1.2\n</code></pre><p>表明安装已经成功，版本<code>2.1.2</code>。</p>\n<h2 id=\"添加Box\"><a href=\"#添加Box\" class=\"headerlink\" title=\"添加Box\"></a>添加Box</h2><p>官方box源：<a href=\"https://app.vagrantup.com/boxes/search\" target=\"_blank\" rel=\"noopener\">https://app.vagrantup.com/boxes/search</a> </p>\n<p>网络不好，需要翻墙。或者通过其它途径下载想要的box。</p>\n<ul>\n<li>查看所有已下载box</li>\n</ul>\n<p><code>vagrant box list</code></p>\n<ul>\n<li>添加box</li>\n</ul>\n<p><code>vagrant box add centos/7</code></p>\n<p>执行上面命令会添加相应box到vagrant系统，如果没有，会先从box官源下载。   </p>\n<ul>\n<li>再次执行<code>vagrant box list</code>便可以看到。 </li>\n</ul>\n<p>离线方式：<br><a href=\"https://cloud.centos.org/centos/7/vagrant/x86_64/images/\" target=\"_blank\" rel=\"noopener\">https://cloud.centos.org/centos/7/vagrant/x86_64/images/</a></p>\n<p>下载相应box镜像，然后执行命令添加box：</p>\n<pre><code>vagrant box add centos/7 aa.box\n</code></pre><h2 id=\"创造自己box\"><a href=\"#创造自己box\" class=\"headerlink\" title=\"创造自己box\"></a>创造自己box</h2><ul>\n<li>创建目录</li>\n</ul>\n<p><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ mkdir xcsqjr-dev/</code> </p>\n<ul>\n<li>初始化，创建配置文件</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ cd xcsqjr-dev/\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/xcsqjr-dev$ vagrant init centos/7\nA `Vagrantfile` has been placed in this directory. You are now\nready to `vagrant up` your first virtual environment! Please read\nthe comments in the Vagrantfile as well as documentation on\n`vagrantup.com` for more information on using Vagrant. \n</code></pre><p>会在当前目录下创建文件<code>Vagrantfile</code>。然后就可以编辑该文件，做一些配置：</p>\n<pre><code># -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n# All Vagrant configuration is done below. The &quot;2&quot; in Vagrant.configure\n# configures the configuration version (we support older styles for\n# backwards compatibility). Please don&apos;t change it unless you know what\n# you&apos;re doing.\nVagrant.configure(&quot;2&quot;) do |config|\n  # The most common configuration options are documented and commented below.\n  # For a complete reference, please see the online documentation at\n  # https://docs.vagrantup.com.\n\n  # Every Vagrant development environment requires a box. You can search for\n  # boxes at https://vagrantcloud.com/search.\n\n  # ----------- 一些相关配置 start ----------------#\n  config.vm.box = &quot;centos/7&quot; #和已经下载的box名字一致\n  config.vm.hostname = &quot;ymu&quot;  \n  #config.vm.box_version = &quot;1.1.0&quot;    \n  config.vm.box_url = &quot;http://ymu.box&quot;\n\n  # 对虚拟机的一些配置     \n  config.vm.provider &quot;virtualbox&quot; do |vb|\n  #   # Display the VirtualBox GUI when booting the machine\n  #   vb.gui = true\n  #\n  #   # Customize the amount of memory on the VM:\n      vb.memory = &quot;1024&quot; #为虚拟机分配内存\n      vb.cpus = 2 #为虚拟机分配cup，分2核心\n      vb.name = &quot;centos7_ymu&quot; #虚拟机名称\n  end\n\n  # ----------- 一些相关配置 end ----------------#\n\n  # Disable automatic box update checking. If you disable this, then\n  # boxes will only be checked for updates when the user runs\n  # `vagrant box outdated`. This is not recommended.\n  # config.vm.box_check_update = false\n\n  # Create a forwarded port mapping which allows access to a specific port\n  # within the machine from a port on the host machine. In the example below,\n  # accessing &quot;localhost:8080&quot; will access port 80 on the guest machine.\n  # NOTE: This will enable public access to the opened port\n  # config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080\n\n  # Create a forwarded port mapping which allows access to a specific port\n  # within the machine from a port on the host machine and only allow access\n  # via 127.0.0.1 to disable public access\n  # config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080, host_ip: &quot;127.0.0.1&quot;\n\n  # Create a private network, which allows host-only access to the machine\n  # using a specific IP.\n  # config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot;\n\n  # Create a public network, which generally matched to bridged network.\n  # Bridged networks make the machine appear as another physical device on\n  # your network.\n  # config.vm.network &quot;public_network&quot;\n\n  # Share an additional folder to the guest VM. The first argument is\n  # the path on the host to the actual folder. The second argument is\n  # the path on the guest to mount the folder. And the optional third\n  # argument is a set of non-required options.\n  # config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;\n\n  # Provider-specific configuration so you can fine-tune various\n  # backing providers for Vagrant. These expose provider-specific options.\n  # Example for VirtualBox:\n  #\n  # config.vm.provider &quot;virtualbox&quot; do |vb|\n  #   # Display the VirtualBox GUI when booting the machine\n  #   vb.gui = true\n  #\n  #   # Customize the amount of memory on the VM:\n  #   vb.memory = &quot;1024&quot;\n  # end\n  #\n  # View the documentation for the provider you are using for more\n  # information on available options.\n\n  # Enable provisioning with a shell script. Additional provisioners such as\n  # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the\n  # documentation for more information about their specific syntax and use.\n  # config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL\n  #   apt-get update\n  #   apt-get install -y apache2\n  # SHELL\nend\n</code></pre><ul>\n<li>启动虚拟机</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd dev/vagrant/ymu-dev/\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Clearing any previously set forwarded ports...\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Running &apos;pre-boot&apos; VM customizations...\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n</code></pre><p> 打开virtualbox,可以看到centos7_ymu的虚拟机已经启动。</p>\n <img src=\"/2018/01/23/vagrant-start/e.png\">  \n<ul>\n<li><p>进入该虚拟机</p>\n<p><code>vagrant ssh</code></p>\n<p> mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant ssh<br> Last login: Mon Jul  9 07:40:01 2018 from 10.0.2.2<br> [vagrant@ymu ~]$ </p>\n</li>\n</ul>\n<p>下面就可以在里面，类似在真实的服务器操作系统里面一样，安装各种开发软件，配置各种开发环境了。 </p>\n<ul>\n<li><p>登出虚拟机</p>\n<pre><code>[vagrant@ymu ~]$ logout\nConnection to 127.0.0.1 closed.\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ \n</code></pre></li>\n<li><p>停止运行虚拟机</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant halt\n==&gt; default: Attempting graceful shutdown of VM...\n</code></pre></li>\n<li><p>挂起虚拟机</p>\n</li>\n</ul>\n<p><code>vagrant shutdown</code></p>\n<ul>\n<li>重新加载配置启动</li>\n</ul>\n<p><code>vagrant reload</code></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><pre><code>config.vm.box = &quot;centos/7&quot; #和已经下载的box名字一致\nconfig.vm.hostname = &quot;ymu&quot;  \n#config.vm.box_version = &quot;1.1.0&quot;    \nconfig.vm.box_url = &quot;http://ymu.box&quot;\nconfig.vm.synced_folder &quot;/home/mutian/dev/java/github/ymu-micro-service&quot;, &quot;/vagrant&quot;, :ext4 =&gt; true #共享文件夹\n</code></pre><h4 id=\"配置共享文件\"><a href=\"#配置共享文件\" class=\"headerlink\" title=\"配置共享文件\"></a>配置共享文件</h4><p>注：如果不配置共享目录，默认会把<code>Vagrantfile</code>文件所在的目录同步到虚拟机中的<code>、vagrant</code>目录下。</p>\n<p><code>config.vm.synced_folder &quot;/home/mutian/dev/java/github/ymu-micro-service&quot;, &quot;/vagrant&quot;, :ext4 =&gt; true #共享文件夹</code></p>\n<p>第一个路径为宿主电脑文件夹，第二个为同步的虚拟机文件夹。宿主机文件夹中所有内容将实时同步到虚拟机中文件夹下。</p>\n<p>注意文件类型。在<code>ubuntu</code>下查询自己系统文件类型执行命令<code>df -lhT</code>。</p>\n<p>登录虚拟机，进入<code>/vagrant</code>,将看到：</p>\n<pre><code>[vagrant@ymu vagrant]$ ls\nlogs    ymu-config-repo    ymu-hystrix-dashboard  ymu-server-eureka\ntarget  ymu-config-server  ymu-hystrix-turbine    ymu-service-basic\n</code></pre><p>看到宿舍机相关目录下的内容同步过来了。</p>\n<p>所以，这个时候，你就可以只在宿主机编辑代码，在虚拟机里面编译执行了。</p>\n<h4 id=\"配置网络\"><a href=\"#配置网络\" class=\"headerlink\" title=\"配置网络\"></a>配置网络</h4><h2 id=\"为自己的box安装各种应用环境\"><a href=\"#为自己的box安装各种应用环境\" class=\"headerlink\" title=\"为自己的box安装各种应用环境\"></a>为自己的box安装各种应用环境</h2><h3 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h3><p>设置自启动：<code>systemctl enable docker.service</code></p>\n<p>参考之前blog。</p>\n<h3 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装<code>nginx</code></h3><ul>\n<li>docker运行方式</li>\n<li>传统按照方式。</li>\n</ul>\n<h3 id=\"安装redis\"><a href=\"#安装redis\" class=\"headerlink\" title=\"安装redis\"></a>安装<code>redis</code></h3><ul>\n<li>docker运行方式</li>\n</ul>\n<p><a href=\"https://hub.docker.com/_/redis/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/redis/</a></p>\n<ul>\n<li>传统按照方式。</li>\n</ul>\n<h2 id=\"打包分发\"><a href=\"#打包分发\" class=\"headerlink\" title=\"打包分发\"></a>打包分发</h2><p>1.打包，把上面自己定制的box打包。<br>命令： </p>\n<ul>\n<li><code>vagrant package --output xxx.box</code></li>\n<li><code>vagrant package --output xxx.box --base 虚拟机名称</code>  </li>\n</ul>\n<p>2.分发，把打好的包通过优盘等，给其它人用。</p>\n<p>3.更新软件</p>\n<ul>\n<li><p>老用户</p>\n</li>\n<li><p>新用户<br>用最新的打包即可。</p>\n</li>\n</ul>\n<h2 id=\"实时共享文件的问题\"><a href=\"#实时共享文件的问题\" class=\"headerlink\" title=\"实时共享文件的问题\"></a>实时共享文件的问题</h2><p>通常，默认的，启动虚拟机后或者重新启动虚拟机，会同步Vagrantfile所在目录到虚拟机的目录<code>/vagrant</code>下，但是修改了宿主机的文件，不能实时同步到虚拟机。</p>\n<p>下面介绍宿主机通过安装rsync来实时同步宿主机子的文件到虚拟机。    </p>\n<p><a href=\"https://www.vagrantup.com/docs/synced-folders/rsync.html\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/synced-folders/rsync.html</a></p>\n<h3 id=\"window下安装rsync\"><a href=\"#window下安装rsync\" class=\"headerlink\" title=\"window下安装rsync\"></a>window下安装rsync</h3><p>通过安装来cygwin安装rsync。<br>cygwin的网址：<a href=\"https://cygwin.com/install.html。下载安装即可。\" target=\"_blank\" rel=\"noopener\">https://cygwin.com/install.html。下载安装即可。</a></p>\n<p>安装好后，配置<code>Vagrantfile</code>文件。<br>具体配置查看:<a href=\"https://www.vagrantup.com/docs/synced-folders/rsync.html\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/synced-folders/rsync.html</a></p>\n<pre><code>config.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;,type:&quot;rsync&quot;\n或\nconfig.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;,type:&quot;rsync&quot;,rsync__auto:&quot;true&quot;\n</code></pre><p>启动或者重启<code>vagrant reload</code>,然后执行<code>vagrant rsync-auto</code>.    </p>\n<p>试试改变宿主机的文件，就实时同步到虚拟机了。只能单向把宿主机的文件同步到虚拟机。</p>\n<p><em>命令说明</em>:   </p>\n<ul>\n<li>type：rsync，关键，指定类型。</li>\n<li>rsync__auto：默认是true，如果不配置。如果设置了false，则不实时同步该宿主机目录。</li>\n</ul>\n<h3 id=\"linux系统安装rsync\"><a href=\"#linux系统安装rsync\" class=\"headerlink\" title=\"linux系统安装rsync\"></a>linux系统安装rsync</h3><pre><code>yun install rsync\n</code></pre><h2 id=\"win7启动powershell版本过低问题\"><a href=\"#win7启动powershell版本过低问题\" class=\"headerlink\" title=\"win7启动powershell版本过低问题\"></a>win7启动powershell版本过低问题</h2><pre><code>F:\\xrlj.github.com\\xrlj-vagrant-dev&gt;vagrant up\nThe version of powershell currently installed on this host is less than\nthe required minimum version. Please upgrade the installed version of\npowershell to the minimum required version and run the command again.\n\n  Installed version: 2\n\n  Minimum required version: 3\n</code></pre><p>要求powershell版本3以上，所以要升级powershell。  </p>\n<p>下面是升级powershell到4.0的方法： </p>\n<p><a href=\"https://social.technet.microsoft.com/wiki/contents/articles/21016.how-to-install-windows-powershell-4-0.aspx\" target=\"_blank\" rel=\"noopener\">https://social.technet.microsoft.com/wiki/contents/articles/21016.how-to-install-windows-powershell-4-0.aspx</a>    </p>\n<p>下载对应版本。<br>win7 sp1下载这个：Windows6.1-KB2819745-x64-MultiPkg.msu</p>\n<h2 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h2><ul>\n<li><a href=\"http://www.imooc.com/learn/805\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/learn/805</a></li>\n<li><a href=\"https://github.com/apanly/mooc\" target=\"_blank\" rel=\"noopener\">https://github.com/apanly/mooc</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍vagrant，为公司搭建统一的开发环境。最终会输出一个统一的虚拟开发环境，然后就可以分发给团队中所有的开发人员，大家在一致的开发环境中编辑，验证代码……</p>\n<p>从此,告别“在我的机子上运行没问题的……”这个看似很有道理的扯皮了。</p>\n<p>官网网址：<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a></p>\n<h2 id=\"vagrant安装\"><a href=\"#vagrant安装\" class=\"headerlink\" title=\"vagrant安装\"></a>vagrant安装</h2><h3 id=\"安装开源虚拟机VirtualBox\"><a href=\"#安装开源虚拟机VirtualBox\" class=\"headerlink\" title=\"安装开源虚拟机VirtualBox\"></a>安装开源虚拟机VirtualBox</h3><p>注意安装版本和vagrant版本要对应，否则后面会出现各种问题。这里安装最新版本。  </p>\n<p>下载地址：<a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/wiki/Downloads</a> </p>\n<p>选择自己电脑系统对应版本。</p>\n<img src=\"/2018/01/23/vagrant-start/a.png\">\n<pre><code>axel -n 10 https://download.virtualbox.org/virtualbox/5.2.14/virtualbox-5.2_5.2.14-123301~Ubuntu~xenial_amd64.deb\n</code></pre><p>然后，执行安装命令<code>sudo dpkg -i *.deb</code>进行安装即可。</p>\n<p>安装过程中可能会缺少依赖包，把依赖包安装即可：</p>\n<img src=\"/2018/01/23/vagrant-start/b.png\">\n<p>安装依赖包：<code>mutian@mutian-ThinkPad-T440p:~/Downloads$ sudo apt install libsdl1.2debian</code></p>\n<p>重新执行安装命令：</p>\n<img src=\"/2018/01/23/vagrant-start/c.png\">\n<p>安装没有任何错误。 已安装到系统。</p>\n<img src=\"/2018/01/23/vagrant-start/d.png\">\n<p><em>windows下安装问题</em>：<br>安装Virtualbox的时候回滚，并提示发生一个严重的错误。</p>\n<pre><code>解决方法如下：\n\n打开服务选项  ：win + R  然后在跳出来的编辑框 键入  services.msc   然后回车\n\n1.Device Install Service\n\n2.Device Setup Manager\n\n开启这两个服务，然后右键安装程序，以管理员身份运行，然后就能安装啦~\n</code></pre><h3 id=\"安装vagrant\"><a href=\"#安装vagrant\" class=\"headerlink\" title=\"安装vagrant\"></a>安装vagrant</h3><p>安装最新版本。</p>\n<p>下载地址：<a href=\"https://www.vagrantup.com/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/downloads.html</a> </p>\n<p>下载自己电脑系统对应版本。</p>\n<pre><code>axel -n 10 https://releases.hashicorp.com/vagrant/2.1.2/vagrant_2.1.2_x86_64.deb\n</code></pre><p>然后，执行安装命令<code>sudo dpkg -i vagrant_2.1.2_x86_64.deb</code>进行安装即可。</p>\n<p>查看安装是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/Downloads$ vagrant -v\nVagrant 2.1.2\n</code></pre><p>表明安装已经成功，版本<code>2.1.2</code>。</p>\n<h2 id=\"添加Box\"><a href=\"#添加Box\" class=\"headerlink\" title=\"添加Box\"></a>添加Box</h2><p>官方box源：<a href=\"https://app.vagrantup.com/boxes/search\" target=\"_blank\" rel=\"noopener\">https://app.vagrantup.com/boxes/search</a> </p>\n<p>网络不好，需要翻墙。或者通过其它途径下载想要的box。</p>\n<ul>\n<li>查看所有已下载box</li>\n</ul>\n<p><code>vagrant box list</code></p>\n<ul>\n<li>添加box</li>\n</ul>\n<p><code>vagrant box add centos/7</code></p>\n<p>执行上面命令会添加相应box到vagrant系统，如果没有，会先从box官源下载。   </p>\n<ul>\n<li>再次执行<code>vagrant box list</code>便可以看到。 </li>\n</ul>\n<p>离线方式：<br><a href=\"https://cloud.centos.org/centos/7/vagrant/x86_64/images/\" target=\"_blank\" rel=\"noopener\">https://cloud.centos.org/centos/7/vagrant/x86_64/images/</a></p>\n<p>下载相应box镜像，然后执行命令添加box：</p>\n<pre><code>vagrant box add centos/7 aa.box\n</code></pre><h2 id=\"创造自己box\"><a href=\"#创造自己box\" class=\"headerlink\" title=\"创造自己box\"></a>创造自己box</h2><ul>\n<li>创建目录</li>\n</ul>\n<p><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ mkdir xcsqjr-dev/</code> </p>\n<ul>\n<li>初始化，创建配置文件</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ cd xcsqjr-dev/\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/xcsqjr-dev$ vagrant init centos/7\nA `Vagrantfile` has been placed in this directory. You are now\nready to `vagrant up` your first virtual environment! Please read\nthe comments in the Vagrantfile as well as documentation on\n`vagrantup.com` for more information on using Vagrant. \n</code></pre><p>会在当前目录下创建文件<code>Vagrantfile</code>。然后就可以编辑该文件，做一些配置：</p>\n<pre><code># -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n# All Vagrant configuration is done below. The &quot;2&quot; in Vagrant.configure\n# configures the configuration version (we support older styles for\n# backwards compatibility). Please don&apos;t change it unless you know what\n# you&apos;re doing.\nVagrant.configure(&quot;2&quot;) do |config|\n  # The most common configuration options are documented and commented below.\n  # For a complete reference, please see the online documentation at\n  # https://docs.vagrantup.com.\n\n  # Every Vagrant development environment requires a box. You can search for\n  # boxes at https://vagrantcloud.com/search.\n\n  # ----------- 一些相关配置 start ----------------#\n  config.vm.box = &quot;centos/7&quot; #和已经下载的box名字一致\n  config.vm.hostname = &quot;ymu&quot;  \n  #config.vm.box_version = &quot;1.1.0&quot;    \n  config.vm.box_url = &quot;http://ymu.box&quot;\n\n  # 对虚拟机的一些配置     \n  config.vm.provider &quot;virtualbox&quot; do |vb|\n  #   # Display the VirtualBox GUI when booting the machine\n  #   vb.gui = true\n  #\n  #   # Customize the amount of memory on the VM:\n      vb.memory = &quot;1024&quot; #为虚拟机分配内存\n      vb.cpus = 2 #为虚拟机分配cup，分2核心\n      vb.name = &quot;centos7_ymu&quot; #虚拟机名称\n  end\n\n  # ----------- 一些相关配置 end ----------------#\n\n  # Disable automatic box update checking. If you disable this, then\n  # boxes will only be checked for updates when the user runs\n  # `vagrant box outdated`. This is not recommended.\n  # config.vm.box_check_update = false\n\n  # Create a forwarded port mapping which allows access to a specific port\n  # within the machine from a port on the host machine. In the example below,\n  # accessing &quot;localhost:8080&quot; will access port 80 on the guest machine.\n  # NOTE: This will enable public access to the opened port\n  # config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080\n\n  # Create a forwarded port mapping which allows access to a specific port\n  # within the machine from a port on the host machine and only allow access\n  # via 127.0.0.1 to disable public access\n  # config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080, host_ip: &quot;127.0.0.1&quot;\n\n  # Create a private network, which allows host-only access to the machine\n  # using a specific IP.\n  # config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot;\n\n  # Create a public network, which generally matched to bridged network.\n  # Bridged networks make the machine appear as another physical device on\n  # your network.\n  # config.vm.network &quot;public_network&quot;\n\n  # Share an additional folder to the guest VM. The first argument is\n  # the path on the host to the actual folder. The second argument is\n  # the path on the guest to mount the folder. And the optional third\n  # argument is a set of non-required options.\n  # config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;\n\n  # Provider-specific configuration so you can fine-tune various\n  # backing providers for Vagrant. These expose provider-specific options.\n  # Example for VirtualBox:\n  #\n  # config.vm.provider &quot;virtualbox&quot; do |vb|\n  #   # Display the VirtualBox GUI when booting the machine\n  #   vb.gui = true\n  #\n  #   # Customize the amount of memory on the VM:\n  #   vb.memory = &quot;1024&quot;\n  # end\n  #\n  # View the documentation for the provider you are using for more\n  # information on available options.\n\n  # Enable provisioning with a shell script. Additional provisioners such as\n  # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the\n  # documentation for more information about their specific syntax and use.\n  # config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL\n  #   apt-get update\n  #   apt-get install -y apache2\n  # SHELL\nend\n</code></pre><ul>\n<li>启动虚拟机</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd dev/vagrant/ymu-dev/\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Clearing any previously set forwarded ports...\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Running &apos;pre-boot&apos; VM customizations...\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n</code></pre><p> 打开virtualbox,可以看到centos7_ymu的虚拟机已经启动。</p>\n <img src=\"/2018/01/23/vagrant-start/e.png\">  \n<ul>\n<li><p>进入该虚拟机</p>\n<p><code>vagrant ssh</code></p>\n<p> mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant ssh<br> Last login: Mon Jul  9 07:40:01 2018 from 10.0.2.2<br> [vagrant@ymu ~]$ </p>\n</li>\n</ul>\n<p>下面就可以在里面，类似在真实的服务器操作系统里面一样，安装各种开发软件，配置各种开发环境了。 </p>\n<ul>\n<li><p>登出虚拟机</p>\n<pre><code>[vagrant@ymu ~]$ logout\nConnection to 127.0.0.1 closed.\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ \n</code></pre></li>\n<li><p>停止运行虚拟机</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant halt\n==&gt; default: Attempting graceful shutdown of VM...\n</code></pre></li>\n<li><p>挂起虚拟机</p>\n</li>\n</ul>\n<p><code>vagrant shutdown</code></p>\n<ul>\n<li>重新加载配置启动</li>\n</ul>\n<p><code>vagrant reload</code></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><pre><code>config.vm.box = &quot;centos/7&quot; #和已经下载的box名字一致\nconfig.vm.hostname = &quot;ymu&quot;  \n#config.vm.box_version = &quot;1.1.0&quot;    \nconfig.vm.box_url = &quot;http://ymu.box&quot;\nconfig.vm.synced_folder &quot;/home/mutian/dev/java/github/ymu-micro-service&quot;, &quot;/vagrant&quot;, :ext4 =&gt; true #共享文件夹\n</code></pre><h4 id=\"配置共享文件\"><a href=\"#配置共享文件\" class=\"headerlink\" title=\"配置共享文件\"></a>配置共享文件</h4><p>注：如果不配置共享目录，默认会把<code>Vagrantfile</code>文件所在的目录同步到虚拟机中的<code>、vagrant</code>目录下。</p>\n<p><code>config.vm.synced_folder &quot;/home/mutian/dev/java/github/ymu-micro-service&quot;, &quot;/vagrant&quot;, :ext4 =&gt; true #共享文件夹</code></p>\n<p>第一个路径为宿主电脑文件夹，第二个为同步的虚拟机文件夹。宿主机文件夹中所有内容将实时同步到虚拟机中文件夹下。</p>\n<p>注意文件类型。在<code>ubuntu</code>下查询自己系统文件类型执行命令<code>df -lhT</code>。</p>\n<p>登录虚拟机，进入<code>/vagrant</code>,将看到：</p>\n<pre><code>[vagrant@ymu vagrant]$ ls\nlogs    ymu-config-repo    ymu-hystrix-dashboard  ymu-server-eureka\ntarget  ymu-config-server  ymu-hystrix-turbine    ymu-service-basic\n</code></pre><p>看到宿舍机相关目录下的内容同步过来了。</p>\n<p>所以，这个时候，你就可以只在宿主机编辑代码，在虚拟机里面编译执行了。</p>\n<h4 id=\"配置网络\"><a href=\"#配置网络\" class=\"headerlink\" title=\"配置网络\"></a>配置网络</h4><h2 id=\"为自己的box安装各种应用环境\"><a href=\"#为自己的box安装各种应用环境\" class=\"headerlink\" title=\"为自己的box安装各种应用环境\"></a>为自己的box安装各种应用环境</h2><h3 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h3><p>设置自启动：<code>systemctl enable docker.service</code></p>\n<p>参考之前blog。</p>\n<h3 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装<code>nginx</code></h3><ul>\n<li>docker运行方式</li>\n<li>传统按照方式。</li>\n</ul>\n<h3 id=\"安装redis\"><a href=\"#安装redis\" class=\"headerlink\" title=\"安装redis\"></a>安装<code>redis</code></h3><ul>\n<li>docker运行方式</li>\n</ul>\n<p><a href=\"https://hub.docker.com/_/redis/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/redis/</a></p>\n<ul>\n<li>传统按照方式。</li>\n</ul>\n<h2 id=\"打包分发\"><a href=\"#打包分发\" class=\"headerlink\" title=\"打包分发\"></a>打包分发</h2><p>1.打包，把上面自己定制的box打包。<br>命令： </p>\n<ul>\n<li><code>vagrant package --output xxx.box</code></li>\n<li><code>vagrant package --output xxx.box --base 虚拟机名称</code>  </li>\n</ul>\n<p>2.分发，把打好的包通过优盘等，给其它人用。</p>\n<p>3.更新软件</p>\n<ul>\n<li><p>老用户</p>\n</li>\n<li><p>新用户<br>用最新的打包即可。</p>\n</li>\n</ul>\n<h2 id=\"实时共享文件的问题\"><a href=\"#实时共享文件的问题\" class=\"headerlink\" title=\"实时共享文件的问题\"></a>实时共享文件的问题</h2><p>通常，默认的，启动虚拟机后或者重新启动虚拟机，会同步Vagrantfile所在目录到虚拟机的目录<code>/vagrant</code>下，但是修改了宿主机的文件，不能实时同步到虚拟机。</p>\n<p>下面介绍宿主机通过安装rsync来实时同步宿主机子的文件到虚拟机。    </p>\n<p><a href=\"https://www.vagrantup.com/docs/synced-folders/rsync.html\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/synced-folders/rsync.html</a></p>\n<h3 id=\"window下安装rsync\"><a href=\"#window下安装rsync\" class=\"headerlink\" title=\"window下安装rsync\"></a>window下安装rsync</h3><p>通过安装来cygwin安装rsync。<br>cygwin的网址：<a href=\"https://cygwin.com/install.html。下载安装即可。\" target=\"_blank\" rel=\"noopener\">https://cygwin.com/install.html。下载安装即可。</a></p>\n<p>安装好后，配置<code>Vagrantfile</code>文件。<br>具体配置查看:<a href=\"https://www.vagrantup.com/docs/synced-folders/rsync.html\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/synced-folders/rsync.html</a></p>\n<pre><code>config.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;,type:&quot;rsync&quot;\n或\nconfig.vm.synced_folder &quot;.&quot;, &quot;/vagrant&quot;,type:&quot;rsync&quot;,rsync__auto:&quot;true&quot;\n</code></pre><p>启动或者重启<code>vagrant reload</code>,然后执行<code>vagrant rsync-auto</code>.    </p>\n<p>试试改变宿主机的文件，就实时同步到虚拟机了。只能单向把宿主机的文件同步到虚拟机。</p>\n<p><em>命令说明</em>:   </p>\n<ul>\n<li>type：rsync，关键，指定类型。</li>\n<li>rsync__auto：默认是true，如果不配置。如果设置了false，则不实时同步该宿主机目录。</li>\n</ul>\n<h3 id=\"linux系统安装rsync\"><a href=\"#linux系统安装rsync\" class=\"headerlink\" title=\"linux系统安装rsync\"></a>linux系统安装rsync</h3><pre><code>yun install rsync\n</code></pre><h2 id=\"win7启动powershell版本过低问题\"><a href=\"#win7启动powershell版本过低问题\" class=\"headerlink\" title=\"win7启动powershell版本过低问题\"></a>win7启动powershell版本过低问题</h2><pre><code>F:\\xrlj.github.com\\xrlj-vagrant-dev&gt;vagrant up\nThe version of powershell currently installed on this host is less than\nthe required minimum version. Please upgrade the installed version of\npowershell to the minimum required version and run the command again.\n\n  Installed version: 2\n\n  Minimum required version: 3\n</code></pre><p>要求powershell版本3以上，所以要升级powershell。  </p>\n<p>下面是升级powershell到4.0的方法： </p>\n<p><a href=\"https://social.technet.microsoft.com/wiki/contents/articles/21016.how-to-install-windows-powershell-4-0.aspx\" target=\"_blank\" rel=\"noopener\">https://social.technet.microsoft.com/wiki/contents/articles/21016.how-to-install-windows-powershell-4-0.aspx</a>    </p>\n<p>下载对应版本。<br>win7 sp1下载这个：Windows6.1-KB2819745-x64-MultiPkg.msu</p>\n<h2 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h2><ul>\n<li><a href=\"http://www.imooc.com/learn/805\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/learn/805</a></li>\n<li><a href=\"https://github.com/apanly/mooc\" target=\"_blank\" rel=\"noopener\">https://github.com/apanly/mooc</a></li>\n</ul>\n"},{"title":"vagrant常用配置介绍","date":"2018-11-15T09:55:52.000Z","_content":"\nhttps://www.vagrantup.com/docs/vagrantfile/\n\n## 基础配置\n\n    config.vm.box = \"centos/7\" \n基础镜像，本机没有，会从网络拉取    \n\n     config.vm.hostname = \"xr-server\" \n很重要，多来虚拟机，用来区别。可以通过vagrant up centos1来指定只启动哪一台。\n\n## 虚拟机网络设置\n\n    config.vm.network \"private_network\", ip: \"192.168.10.11\"\n    //Host-only模式\n     \n    config.vm.network \"public_network\", ip: \"10.1.2.61\"\n    //Bridge模式\n\nVagrant的网络连接方式有三种：  \n\n- NAT : 缺省创建，用于让vm可以通过host转发访问局域网甚至互联网。\n- host-only : 只有主机可以访问vm，其他机器无法访问它。\n- bridge : 此模式下vm就像局域网中的一台独立的机器，可以被其他机器访问。\n\n\n    config.vm.network :private_network, ip: \"192.168.33.10\"\n    #配置当前vm的host-only网络的IP地址为192.168.33.10\n\nhost-only 模式的IP可以不指定，而是采用dhcp自动生成的方式，如 :    \n\n    config.vm.network \"private_network\", type: \"dhcp”\n\n```text\n#config.vm.network \"public_network\", ip: \"192.168.0.17\"\n#创建一个bridge桥接网络，指定IP\n#config.vm.network \"public_network\", bridge: \"en1: Wi-Fi (AirPort)\"\n#创建一个bridge桥接网络，指定桥接适配器\nconfig.vm.network \"public_network\"\n#创建一个bridge桥接网络，不指定桥接适配器\n\n```\n\n## 同步目录设置\n\n网址：https://www.vagrantup.com/docs/synced-folders/\n\n默认是：宿主机子`vagrantfile`所在目录，虚拟机的`/vagrant`目录 。\n\n     config.vm.synced_folder \"D:/xxx/code\", \"/home/www/\" \n\n第一个地址为宿主机目录，第二个为虚拟机的目录。\n\n## 端口转发\n\n","source":"_posts/vagrant-vagrantfile.md","raw":"---\ntitle: vagrant常用配置介绍\ndate: 2018-11-15 17:55:52\ncategories: vagrant\ntags:\n---\n\nhttps://www.vagrantup.com/docs/vagrantfile/\n\n## 基础配置\n\n    config.vm.box = \"centos/7\" \n基础镜像，本机没有，会从网络拉取    \n\n     config.vm.hostname = \"xr-server\" \n很重要，多来虚拟机，用来区别。可以通过vagrant up centos1来指定只启动哪一台。\n\n## 虚拟机网络设置\n\n    config.vm.network \"private_network\", ip: \"192.168.10.11\"\n    //Host-only模式\n     \n    config.vm.network \"public_network\", ip: \"10.1.2.61\"\n    //Bridge模式\n\nVagrant的网络连接方式有三种：  \n\n- NAT : 缺省创建，用于让vm可以通过host转发访问局域网甚至互联网。\n- host-only : 只有主机可以访问vm，其他机器无法访问它。\n- bridge : 此模式下vm就像局域网中的一台独立的机器，可以被其他机器访问。\n\n\n    config.vm.network :private_network, ip: \"192.168.33.10\"\n    #配置当前vm的host-only网络的IP地址为192.168.33.10\n\nhost-only 模式的IP可以不指定，而是采用dhcp自动生成的方式，如 :    \n\n    config.vm.network \"private_network\", type: \"dhcp”\n\n```text\n#config.vm.network \"public_network\", ip: \"192.168.0.17\"\n#创建一个bridge桥接网络，指定IP\n#config.vm.network \"public_network\", bridge: \"en1: Wi-Fi (AirPort)\"\n#创建一个bridge桥接网络，指定桥接适配器\nconfig.vm.network \"public_network\"\n#创建一个bridge桥接网络，不指定桥接适配器\n\n```\n\n## 同步目录设置\n\n网址：https://www.vagrantup.com/docs/synced-folders/\n\n默认是：宿主机子`vagrantfile`所在目录，虚拟机的`/vagrant`目录 。\n\n     config.vm.synced_folder \"D:/xxx/code\", \"/home/www/\" \n\n第一个地址为宿主机目录，第二个为虚拟机的目录。\n\n## 端口转发\n\n","slug":"vagrant-vagrantfile","published":1,"updated":"2019-06-16T14:38:33.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqg700cmg4vas3tar4sg","content":"<p><a href=\"https://www.vagrantup.com/docs/vagrantfile/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/vagrantfile/</a></p>\n<h2 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h2><pre><code>config.vm.box = &quot;centos/7&quot; \n</code></pre><p>基础镜像，本机没有，会从网络拉取    </p>\n<pre><code>config.vm.hostname = &quot;xr-server&quot; \n</code></pre><p>很重要，多来虚拟机，用来区别。可以通过vagrant up centos1来指定只启动哪一台。</p>\n<h2 id=\"虚拟机网络设置\"><a href=\"#虚拟机网络设置\" class=\"headerlink\" title=\"虚拟机网络设置\"></a>虚拟机网络设置</h2><pre><code>config.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.11&quot;\n//Host-only模式\n\nconfig.vm.network &quot;public_network&quot;, ip: &quot;10.1.2.61&quot;\n//Bridge模式\n</code></pre><p>Vagrant的网络连接方式有三种：  </p>\n<ul>\n<li>NAT : 缺省创建，用于让vm可以通过host转发访问局域网甚至互联网。</li>\n<li>host-only : 只有主机可以访问vm，其他机器无法访问它。</li>\n<li>bridge : 此模式下vm就像局域网中的一台独立的机器，可以被其他机器访问。</li>\n</ul>\n<pre><code>config.vm.network :private_network, ip: &quot;192.168.33.10&quot;\n#配置当前vm的host-only网络的IP地址为192.168.33.10\n</code></pre><p>host-only 模式的IP可以不指定，而是采用dhcp自动生成的方式，如 :    </p>\n<pre><code>config.vm.network &quot;private_network&quot;, type: &quot;dhcp”\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#config.vm.network &quot;public_network&quot;, ip: &quot;192.168.0.17&quot;</span><br><span class=\"line\">#创建一个bridge桥接网络，指定IP</span><br><span class=\"line\">#config.vm.network &quot;public_network&quot;, bridge: &quot;en1: Wi-Fi (AirPort)&quot;</span><br><span class=\"line\">#创建一个bridge桥接网络，指定桥接适配器</span><br><span class=\"line\">config.vm.network &quot;public_network&quot;</span><br><span class=\"line\">#创建一个bridge桥接网络，不指定桥接适配器</span><br></pre></td></tr></table></figure>\n<h2 id=\"同步目录设置\"><a href=\"#同步目录设置\" class=\"headerlink\" title=\"同步目录设置\"></a>同步目录设置</h2><p>网址：<a href=\"https://www.vagrantup.com/docs/synced-folders/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/synced-folders/</a></p>\n<p>默认是：宿主机子<code>vagrantfile</code>所在目录，虚拟机的<code>/vagrant</code>目录 。</p>\n<pre><code>config.vm.synced_folder &quot;D:/xxx/code&quot;, &quot;/home/www/&quot; \n</code></pre><p>第一个地址为宿主机目录，第二个为虚拟机的目录。</p>\n<h2 id=\"端口转发\"><a href=\"#端口转发\" class=\"headerlink\" title=\"端口转发\"></a>端口转发</h2>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.vagrantup.com/docs/vagrantfile/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/vagrantfile/</a></p>\n<h2 id=\"基础配置\"><a href=\"#基础配置\" class=\"headerlink\" title=\"基础配置\"></a>基础配置</h2><pre><code>config.vm.box = &quot;centos/7&quot; \n</code></pre><p>基础镜像，本机没有，会从网络拉取    </p>\n<pre><code>config.vm.hostname = &quot;xr-server&quot; \n</code></pre><p>很重要，多来虚拟机，用来区别。可以通过vagrant up centos1来指定只启动哪一台。</p>\n<h2 id=\"虚拟机网络设置\"><a href=\"#虚拟机网络设置\" class=\"headerlink\" title=\"虚拟机网络设置\"></a>虚拟机网络设置</h2><pre><code>config.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.11&quot;\n//Host-only模式\n\nconfig.vm.network &quot;public_network&quot;, ip: &quot;10.1.2.61&quot;\n//Bridge模式\n</code></pre><p>Vagrant的网络连接方式有三种：  </p>\n<ul>\n<li>NAT : 缺省创建，用于让vm可以通过host转发访问局域网甚至互联网。</li>\n<li>host-only : 只有主机可以访问vm，其他机器无法访问它。</li>\n<li>bridge : 此模式下vm就像局域网中的一台独立的机器，可以被其他机器访问。</li>\n</ul>\n<pre><code>config.vm.network :private_network, ip: &quot;192.168.33.10&quot;\n#配置当前vm的host-only网络的IP地址为192.168.33.10\n</code></pre><p>host-only 模式的IP可以不指定，而是采用dhcp自动生成的方式，如 :    </p>\n<pre><code>config.vm.network &quot;private_network&quot;, type: &quot;dhcp”\n</code></pre><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#config.vm.network &quot;public_network&quot;, ip: &quot;192.168.0.17&quot;</span><br><span class=\"line\">#创建一个bridge桥接网络，指定IP</span><br><span class=\"line\">#config.vm.network &quot;public_network&quot;, bridge: &quot;en1: Wi-Fi (AirPort)&quot;</span><br><span class=\"line\">#创建一个bridge桥接网络，指定桥接适配器</span><br><span class=\"line\">config.vm.network &quot;public_network&quot;</span><br><span class=\"line\">#创建一个bridge桥接网络，不指定桥接适配器</span><br></pre></td></tr></table></figure>\n<h2 id=\"同步目录设置\"><a href=\"#同步目录设置\" class=\"headerlink\" title=\"同步目录设置\"></a>同步目录设置</h2><p>网址：<a href=\"https://www.vagrantup.com/docs/synced-folders/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/synced-folders/</a></p>\n<p>默认是：宿主机子<code>vagrantfile</code>所在目录，虚拟机的<code>/vagrant</code>目录 。</p>\n<pre><code>config.vm.synced_folder &quot;D:/xxx/code&quot;, &quot;/home/www/&quot; \n</code></pre><p>第一个地址为宿主机目录，第二个为虚拟机的目录。</p>\n<h2 id=\"端口转发\"><a href=\"#端口转发\" class=\"headerlink\" title=\"端口转发\"></a>端口转发</h2>"},{"title":"Vault学习","date":"2018-03-09T02:11:17.000Z","_content":"\nValut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……\n\n特性：\n\n1.安全的私密信息存储 \n\n2.动态的私密信息支持\n\n3.提供对于私密信息的更新，延长有效时间的功能\n\n4.灵活的权限控制\n\n5.多种客户端登录验证方式\n\n参考：\nhttps://www.vaultproject.io/intro/index.html\n\n## 安装Valut\n\n1.下载地址：https://www.vaultproject.io/downloads.html\n\n2.解压\n解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。\n\n配置环境变量，把vault可执行文件所在目录添加到环境变量：\n\n`export PATH=$PATH:/home/mutian/dev/bin`\n\n检验是否成功：\n    \n    mutian@mutian-ThinkPad-T440p:~$ vault \n    Usage: vault <command> [args]\n    \n    Common commands:\n        read        Read data and retrieves secrets\n        write       Write data, configuration, and secrets\n        delete      Delete secrets and configuration\n        list        List data or secrets\n        login       Authenticate locally\n        server      Start a Vault server\n        status      Print seal and HA status\n        unwrap      Unwrap a wrapped secret\n    \n    Other commands:\n        audit          Interact with audit devices\n        auth           Interact with auth methods\n        lease          Interact with leases\n        operator       Perform operator-specific tasks\n        path-help      Retrieve API help for paths\n        policy         Interact with policies\n        secrets        Interact with secrets engines\n        ssh            Initiate an SSH session\n        token          Interact with tokens\n\n表示环境变量添加准确，已经安装成功。\n\n\n3.install completions\n\n    $ vault -autocomplete-install\n    \n然后重新启动shell窗口，输入命令`vault`，然后按Tab键，将出现命令参数提示。如下：    \n\n    mutian@mutian-ThinkPad-T440p:~$ vault \n    audit      lease      operator   read       ssh        unwrap     \n    auth       list       path-help  secrets    status     write      \n    delete     login      policy     server     token      \n    mutian@mutian-ThinkPad-T440p:~$ vault \n\n##　启动服务\n\n#### 启动开发环境\n\n开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n    ==> Vault server configuration:\n    \n                         Cgo: disabled\n             Cluster Address: https://127.0.0.1:8201\n                  Listener 1: tcp (addr: \"127.0.0.1:8200\", cluster address: \"127.0.0.1:8201\", tls: \"disabled\")\n                   Log Level: info\n                       Mlock: supported: true, enabled: false\n            Redirect Address: http://127.0.0.1:8200\n                     Storage: inmem\n                     Version: Vault v0.9.5\n                 Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n    \n    WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\n    and starts unsealed with a single unseal key. The root token is already\n    authenticated to the CLI, so you can immediately begin using Vault.\n    \n    You may need to set the following environment variable:\n    \n        $ export VAULT_ADDR='http://127.0.0.1:8200'\n    \n    The unseal key and root token are displayed below in case you want to\n    seal/unseal the Vault or re-authenticate.\n    \n    Unseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\n    Root Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n    \n    Development mode should NOT be used in production installations!\n    \n    ==> Vault server started! Log data will stream in below:\n\n看到上面内容说明已经启动成功，在前台运行的。\n\n验证服务是否在成功运行：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status \n    Error checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\n    mutian@mutian-ThinkPad-T440p:~$ \n\n看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：\n\n     export VAULT_ADDR=http://127.0.0.1:8200\n     \n再次查看vault服务运行状态:\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status\n    Key             Value\n    ---             -----\n    Seal Type       shamir\n    Sealed          false\n    Total Shares    1\n    Threshold       1\n    Version         0.9.5\n    Cluster Name    vault-cluster-bcf3f2f8\n    Cluster ID      c2649684-fe35-3820-983b-f324a51b115c\n    HA Enabled      false\n         \n看到了上面的内容，则证明服务启动成功。\n\n为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效， \n命令：\n\n| 功能      | 命令    |  说明  |\n| --------   | -----   | :---- |\n| 设置vault访问地址       | export VAULT_ADDR=http://127.0.0.1:8200     |   vault命令作用的vault服务的地址    |\n| 设置Vault PATH        | export PATH=$PATH:< vault install path >      |   vault install path：vault安装路径    |\n| 设置访问token        | \texport VAULT_TOKEN=< token >      |   token：登录vault时的token，首次登录可使用root token    |\n| 设置是否跳过核查        | \texport VAULT_SKIP_VERIFY=false      |    使用TSL访问时需要设置，未使用证书忽略此项    |\n| 设置访问证书        | \texport VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem      |   使用TSL访问时需要设置，未使用证书忽略此项    |\n\n     \n- 保存私密信息\n\n下面是简单的写入信息命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\n    Success! Data written to: secret/hello\n\n这会把键值对信息写入到路劲`secret/hello`中。　键为value,值为world。\n\n也可以一次性写入多个键值保存：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n\n- 读取私密信息\n    \n显示该路径下所有保存键值对：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \n    Key                 Value\n    ---                 -----\n    refresh_interval    768h\n    excited             yes\n    value               world    \n\n获取单个的值：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\n    world\n\n- 删除路径下键值\n\n删除所有：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \n    Success! Data deleted (if it existed) at: secret/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\n    No value found at secret/hello\n\n看上面命令，说明已经把保存到路径`secret/hello`下的键值信息全部删除。\n\n## 秘密引擎\n\n上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径`secret/hello`下面，这个是默认的。当你试图保存到其他路径下时候，将报错。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\n    Error writing data to home/mutian/dev: Error making API request.\n    \n    URL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\n    Code: 404. Errors:\n    \n    * no handler for route 'home/mutian/dev'\n\n默认下，在路劲`secret/.`Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    \n\n- 开启一个新的kv私密引擎\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv\n    Success! Enabled the kv secrets engine at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    abs/          kv           n/a\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n\n通过命令`vault secrets list`可以看到，第一个就是就是我们刚才开启的新私密引擎。\n\n往该新建私密引擎保存私密信息：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\n    Success! Data written to: abs/my-secret\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\n    Success! Data written to: abs/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\n    Success! Data written to: abs/airplane\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n查看该私密引擎下所有key\n\n    mutian@mutian-ThinkPad-T440p:~$ vault list abs\n    Keys\n    ----\n    airplane\n    hello\n    my-secret\n\n- 关闭私密引擎\n\n当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　\n当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\n    Success! Disabled the secrets engine (if it existed) at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n    \n上面结果中，已经再看不到私密引擎`abs/`\n\n- 什么是私密引擎（Secrets Engine）\n\n上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？\n\n实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　\n这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　\n\n\n## 动态私密信息保存\n\n\n\n    \n","source":"_posts/vault-study.md","raw":"---\ntitle: Vault学习\ndate: 2018-03-09 10:11:17\ncategories: 密码\ntags: vault\n---\n\nValut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……\n\n特性：\n\n1.安全的私密信息存储 \n\n2.动态的私密信息支持\n\n3.提供对于私密信息的更新，延长有效时间的功能\n\n4.灵活的权限控制\n\n5.多种客户端登录验证方式\n\n参考：\nhttps://www.vaultproject.io/intro/index.html\n\n## 安装Valut\n\n1.下载地址：https://www.vaultproject.io/downloads.html\n\n2.解压\n解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。\n\n配置环境变量，把vault可执行文件所在目录添加到环境变量：\n\n`export PATH=$PATH:/home/mutian/dev/bin`\n\n检验是否成功：\n    \n    mutian@mutian-ThinkPad-T440p:~$ vault \n    Usage: vault <command> [args]\n    \n    Common commands:\n        read        Read data and retrieves secrets\n        write       Write data, configuration, and secrets\n        delete      Delete secrets and configuration\n        list        List data or secrets\n        login       Authenticate locally\n        server      Start a Vault server\n        status      Print seal and HA status\n        unwrap      Unwrap a wrapped secret\n    \n    Other commands:\n        audit          Interact with audit devices\n        auth           Interact with auth methods\n        lease          Interact with leases\n        operator       Perform operator-specific tasks\n        path-help      Retrieve API help for paths\n        policy         Interact with policies\n        secrets        Interact with secrets engines\n        ssh            Initiate an SSH session\n        token          Interact with tokens\n\n表示环境变量添加准确，已经安装成功。\n\n\n3.install completions\n\n    $ vault -autocomplete-install\n    \n然后重新启动shell窗口，输入命令`vault`，然后按Tab键，将出现命令参数提示。如下：    \n\n    mutian@mutian-ThinkPad-T440p:~$ vault \n    audit      lease      operator   read       ssh        unwrap     \n    auth       list       path-help  secrets    status     write      \n    delete     login      policy     server     token      \n    mutian@mutian-ThinkPad-T440p:~$ vault \n\n##　启动服务\n\n#### 启动开发环境\n\n开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n    ==> Vault server configuration:\n    \n                         Cgo: disabled\n             Cluster Address: https://127.0.0.1:8201\n                  Listener 1: tcp (addr: \"127.0.0.1:8200\", cluster address: \"127.0.0.1:8201\", tls: \"disabled\")\n                   Log Level: info\n                       Mlock: supported: true, enabled: false\n            Redirect Address: http://127.0.0.1:8200\n                     Storage: inmem\n                     Version: Vault v0.9.5\n                 Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n    \n    WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\n    and starts unsealed with a single unseal key. The root token is already\n    authenticated to the CLI, so you can immediately begin using Vault.\n    \n    You may need to set the following environment variable:\n    \n        $ export VAULT_ADDR='http://127.0.0.1:8200'\n    \n    The unseal key and root token are displayed below in case you want to\n    seal/unseal the Vault or re-authenticate.\n    \n    Unseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\n    Root Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n    \n    Development mode should NOT be used in production installations!\n    \n    ==> Vault server started! Log data will stream in below:\n\n看到上面内容说明已经启动成功，在前台运行的。\n\n验证服务是否在成功运行：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status \n    Error checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\n    mutian@mutian-ThinkPad-T440p:~$ \n\n看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：\n\n     export VAULT_ADDR=http://127.0.0.1:8200\n     \n再次查看vault服务运行状态:\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status\n    Key             Value\n    ---             -----\n    Seal Type       shamir\n    Sealed          false\n    Total Shares    1\n    Threshold       1\n    Version         0.9.5\n    Cluster Name    vault-cluster-bcf3f2f8\n    Cluster ID      c2649684-fe35-3820-983b-f324a51b115c\n    HA Enabled      false\n         \n看到了上面的内容，则证明服务启动成功。\n\n为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效， \n命令：\n\n| 功能      | 命令    |  说明  |\n| --------   | -----   | :---- |\n| 设置vault访问地址       | export VAULT_ADDR=http://127.0.0.1:8200     |   vault命令作用的vault服务的地址    |\n| 设置Vault PATH        | export PATH=$PATH:< vault install path >      |   vault install path：vault安装路径    |\n| 设置访问token        | \texport VAULT_TOKEN=< token >      |   token：登录vault时的token，首次登录可使用root token    |\n| 设置是否跳过核查        | \texport VAULT_SKIP_VERIFY=false      |    使用TSL访问时需要设置，未使用证书忽略此项    |\n| 设置访问证书        | \texport VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem      |   使用TSL访问时需要设置，未使用证书忽略此项    |\n\n     \n- 保存私密信息\n\n下面是简单的写入信息命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\n    Success! Data written to: secret/hello\n\n这会把键值对信息写入到路劲`secret/hello`中。　键为value,值为world。\n\n也可以一次性写入多个键值保存：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n\n- 读取私密信息\n    \n显示该路径下所有保存键值对：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \n    Key                 Value\n    ---                 -----\n    refresh_interval    768h\n    excited             yes\n    value               world    \n\n获取单个的值：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\n    world\n\n- 删除路径下键值\n\n删除所有：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \n    Success! Data deleted (if it existed) at: secret/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\n    No value found at secret/hello\n\n看上面命令，说明已经把保存到路径`secret/hello`下的键值信息全部删除。\n\n## 秘密引擎\n\n上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径`secret/hello`下面，这个是默认的。当你试图保存到其他路径下时候，将报错。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\n    Error writing data to home/mutian/dev: Error making API request.\n    \n    URL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\n    Code: 404. Errors:\n    \n    * no handler for route 'home/mutian/dev'\n\n默认下，在路劲`secret/.`Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    \n\n- 开启一个新的kv私密引擎\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv\n    Success! Enabled the kv secrets engine at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    abs/          kv           n/a\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n\n通过命令`vault secrets list`可以看到，第一个就是就是我们刚才开启的新私密引擎。\n\n往该新建私密引擎保存私密信息：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\n    Success! Data written to: abs/my-secret\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\n    Success! Data written to: abs/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\n    Success! Data written to: abs/airplane\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n查看该私密引擎下所有key\n\n    mutian@mutian-ThinkPad-T440p:~$ vault list abs\n    Keys\n    ----\n    airplane\n    hello\n    my-secret\n\n- 关闭私密引擎\n\n当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　\n当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\n    Success! Disabled the secrets engine (if it existed) at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n    \n上面结果中，已经再看不到私密引擎`abs/`\n\n- 什么是私密引擎（Secrets Engine）\n\n上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？\n\n实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　\n这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　\n\n\n## 动态私密信息保存\n\n\n\n    \n","slug":"vault-study","published":1,"updated":"2019-06-16T14:38:33.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqg800cog4vamjrjaxl5","content":"<p>Valut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……</p>\n<p>特性：</p>\n<p>1.安全的私密信息存储 </p>\n<p>2.动态的私密信息支持</p>\n<p>3.提供对于私密信息的更新，延长有效时间的功能</p>\n<p>4.灵活的权限控制</p>\n<p>5.多种客户端登录验证方式</p>\n<p>参考：<br><a href=\"https://www.vaultproject.io/intro/index.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/intro/index.html</a></p>\n<h2 id=\"安装Valut\"><a href=\"#安装Valut\" class=\"headerlink\" title=\"安装Valut\"></a>安装Valut</h2><p>1.下载地址：<a href=\"https://www.vaultproject.io/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/downloads.html</a></p>\n<p>2.解压<br>解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。</p>\n<p>配置环境变量，把vault可执行文件所在目录添加到环境变量：</p>\n<p><code>export PATH=$PATH:/home/mutian/dev/bin</code></p>\n<p>检验是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \nUsage: vault &lt;command&gt; [args]\n\nCommon commands:\n    read        Read data and retrieves secrets\n    write       Write data, configuration, and secrets\n    delete      Delete secrets and configuration\n    list        List data or secrets\n    login       Authenticate locally\n    server      Start a Vault server\n    status      Print seal and HA status\n    unwrap      Unwrap a wrapped secret\n\nOther commands:\n    audit          Interact with audit devices\n    auth           Interact with auth methods\n    lease          Interact with leases\n    operator       Perform operator-specific tasks\n    path-help      Retrieve API help for paths\n    policy         Interact with policies\n    secrets        Interact with secrets engines\n    ssh            Initiate an SSH session\n    token          Interact with tokens\n</code></pre><p>表示环境变量添加准确，已经安装成功。</p>\n<p>3.install completions</p>\n<pre><code>$ vault -autocomplete-install\n</code></pre><p>然后重新启动shell窗口，输入命令<code>vault</code>，然后按Tab键，将出现命令参数提示。如下：    </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \naudit      lease      operator   read       ssh        unwrap     \nauth       list       path-help  secrets    status     write      \ndelete     login      policy     server     token      \nmutian@mutian-ThinkPad-T440p:~$ vault \n</code></pre><p>##　启动服务</p>\n<h4 id=\"启动开发环境\"><a href=\"#启动开发环境\" class=\"headerlink\" title=\"启动开发环境\"></a>启动开发环境</h4><p>开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n==&gt; Vault server configuration:\n\n                     Cgo: disabled\n         Cluster Address: https://127.0.0.1:8201\n              Listener 1: tcp (addr: &quot;127.0.0.1:8200&quot;, cluster address: &quot;127.0.0.1:8201&quot;, tls: &quot;disabled&quot;)\n               Log Level: info\n                   Mlock: supported: true, enabled: false\n        Redirect Address: http://127.0.0.1:8200\n                 Storage: inmem\n                 Version: Vault v0.9.5\n             Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n\nWARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\nand starts unsealed with a single unseal key. The root token is already\nauthenticated to the CLI, so you can immediately begin using Vault.\n\nYou may need to set the following environment variable:\n\n    $ export VAULT_ADDR=&apos;http://127.0.0.1:8200&apos;\n\nThe unseal key and root token are displayed below in case you want to\nseal/unseal the Vault or re-authenticate.\n\nUnseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\nRoot Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n\nDevelopment mode should NOT be used in production installations!\n\n==&gt; Vault server started! Log data will stream in below:\n</code></pre><p>看到上面内容说明已经启动成功，在前台运行的。</p>\n<p>验证服务是否在成功运行：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status \nError checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：</p>\n<pre><code>export VAULT_ADDR=http://127.0.0.1:8200\n</code></pre><p>再次查看vault服务运行状态:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status\nKey             Value\n---             -----\nSeal Type       shamir\nSealed          false\nTotal Shares    1\nThreshold       1\nVersion         0.9.5\nCluster Name    vault-cluster-bcf3f2f8\nCluster ID      c2649684-fe35-3820-983b-f324a51b115c\nHA Enabled      false\n</code></pre><p>看到了上面的内容，则证明服务启动成功。</p>\n<p>为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效，<br>命令：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置vault访问地址</td>\n<td>export VAULT_ADDR=<a href=\"http://127.0.0.1:8200\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8200</a></td>\n<td style=\"text-align:left\">vault命令作用的vault服务的地址</td>\n</tr>\n<tr>\n<td>设置Vault PATH</td>\n<td>export PATH=$PATH:&lt; vault install path &gt;</td>\n<td style=\"text-align:left\">vault install path：vault安装路径</td>\n</tr>\n<tr>\n<td>设置访问token</td>\n<td>export VAULT_TOKEN=&lt; token &gt;</td>\n<td style=\"text-align:left\">token：登录vault时的token，首次登录可使用root token</td>\n</tr>\n<tr>\n<td>设置是否跳过核查</td>\n<td>export VAULT_SKIP_VERIFY=false</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n<tr>\n<td>设置访问证书</td>\n<td>export VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>保存私密信息</li>\n</ul>\n<p>下面是简单的写入信息命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\nSuccess! Data written to: secret/hello\n</code></pre><p>这会把键值对信息写入到路劲<code>secret/hello</code>中。　键为value,值为world。</p>\n<p>也可以一次性写入多个键值保存：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n</code></pre><ul>\n<li>读取私密信息</li>\n</ul>\n<p>显示该路径下所有保存键值对：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \nKey                 Value\n---                 -----\nrefresh_interval    768h\nexcited             yes\nvalue               world    \n</code></pre><p>获取单个的值：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\nworld\n</code></pre><ul>\n<li>删除路径下键值</li>\n</ul>\n<p>删除所有：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \nSuccess! Data deleted (if it existed) at: secret/hello\nmutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\nNo value found at secret/hello\n</code></pre><p>看上面命令，说明已经把保存到路径<code>secret/hello</code>下的键值信息全部删除。</p>\n<h2 id=\"秘密引擎\"><a href=\"#秘密引擎\" class=\"headerlink\" title=\"秘密引擎\"></a>秘密引擎</h2><p>上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径<code>secret/hello</code>下面，这个是默认的。当你试图保存到其他路径下时候，将报错。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\nError writing data to home/mutian/dev: Error making API request.\n\nURL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\nCode: 404. Errors:\n\n* no handler for route &apos;home/mutian/dev&apos;\n</code></pre><p>默认下，在路劲<code>secret/.</code>Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    </p>\n<ul>\n<li><p>开启一个新的kv私密引擎</p>\n<p>  mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv<br>  Success! Enabled the kv secrets engine at: abs/<br>  mutian@mutian-ThinkPad-T440p:~$ vault secrets list<br>  Path          Type         Description</p>\n<hr>\n<p>  abs/          kv           n/a<br>  cubbyhole/    cubbyhole    per-token private secret storage<br>  identity/     identity     identity store<br>  secret/       kv           key/value secret storage<br>  sys/          system       system endpoints used for control, policy and debugging</p>\n</li>\n</ul>\n<p>通过命令<code>vault secrets list</code>可以看到，第一个就是就是我们刚才开启的新私密引擎。</p>\n<p>往该新建私密引擎保存私密信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\nSuccess! Data written to: abs/my-secret\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\nSuccess! Data written to: abs/hello\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\nSuccess! Data written to: abs/airplane\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>查看该私密引擎下所有key</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault list abs\nKeys\n----\nairplane\nhello\nmy-secret\n</code></pre><ul>\n<li>关闭私密引擎</li>\n</ul>\n<p>当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　<br>当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\nSuccess! Disabled the secrets engine (if it existed) at: abs/\nmutian@mutian-ThinkPad-T440p:~$ vault secrets list\nPath          Type         Description\n----          ----         -----------\ncubbyhole/    cubbyhole    per-token private secret storage\nidentity/     identity     identity store\nsecret/       kv           key/value secret storage\nsys/          system       system endpoints used for control, policy and debugging\n</code></pre><p>上面结果中，已经再看不到私密引擎<code>abs/</code></p>\n<ul>\n<li>什么是私密引擎（Secrets Engine）</li>\n</ul>\n<p>上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？</p>\n<p>实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　<br>这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　</p>\n<h2 id=\"动态私密信息保存\"><a href=\"#动态私密信息保存\" class=\"headerlink\" title=\"动态私密信息保存\"></a>动态私密信息保存</h2>","site":{"data":{}},"excerpt":"","more":"<p>Valut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……</p>\n<p>特性：</p>\n<p>1.安全的私密信息存储 </p>\n<p>2.动态的私密信息支持</p>\n<p>3.提供对于私密信息的更新，延长有效时间的功能</p>\n<p>4.灵活的权限控制</p>\n<p>5.多种客户端登录验证方式</p>\n<p>参考：<br><a href=\"https://www.vaultproject.io/intro/index.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/intro/index.html</a></p>\n<h2 id=\"安装Valut\"><a href=\"#安装Valut\" class=\"headerlink\" title=\"安装Valut\"></a>安装Valut</h2><p>1.下载地址：<a href=\"https://www.vaultproject.io/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/downloads.html</a></p>\n<p>2.解压<br>解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。</p>\n<p>配置环境变量，把vault可执行文件所在目录添加到环境变量：</p>\n<p><code>export PATH=$PATH:/home/mutian/dev/bin</code></p>\n<p>检验是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \nUsage: vault &lt;command&gt; [args]\n\nCommon commands:\n    read        Read data and retrieves secrets\n    write       Write data, configuration, and secrets\n    delete      Delete secrets and configuration\n    list        List data or secrets\n    login       Authenticate locally\n    server      Start a Vault server\n    status      Print seal and HA status\n    unwrap      Unwrap a wrapped secret\n\nOther commands:\n    audit          Interact with audit devices\n    auth           Interact with auth methods\n    lease          Interact with leases\n    operator       Perform operator-specific tasks\n    path-help      Retrieve API help for paths\n    policy         Interact with policies\n    secrets        Interact with secrets engines\n    ssh            Initiate an SSH session\n    token          Interact with tokens\n</code></pre><p>表示环境变量添加准确，已经安装成功。</p>\n<p>3.install completions</p>\n<pre><code>$ vault -autocomplete-install\n</code></pre><p>然后重新启动shell窗口，输入命令<code>vault</code>，然后按Tab键，将出现命令参数提示。如下：    </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \naudit      lease      operator   read       ssh        unwrap     \nauth       list       path-help  secrets    status     write      \ndelete     login      policy     server     token      \nmutian@mutian-ThinkPad-T440p:~$ vault \n</code></pre><p>##　启动服务</p>\n<h4 id=\"启动开发环境\"><a href=\"#启动开发环境\" class=\"headerlink\" title=\"启动开发环境\"></a>启动开发环境</h4><p>开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n==&gt; Vault server configuration:\n\n                     Cgo: disabled\n         Cluster Address: https://127.0.0.1:8201\n              Listener 1: tcp (addr: &quot;127.0.0.1:8200&quot;, cluster address: &quot;127.0.0.1:8201&quot;, tls: &quot;disabled&quot;)\n               Log Level: info\n                   Mlock: supported: true, enabled: false\n        Redirect Address: http://127.0.0.1:8200\n                 Storage: inmem\n                 Version: Vault v0.9.5\n             Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n\nWARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\nand starts unsealed with a single unseal key. The root token is already\nauthenticated to the CLI, so you can immediately begin using Vault.\n\nYou may need to set the following environment variable:\n\n    $ export VAULT_ADDR=&apos;http://127.0.0.1:8200&apos;\n\nThe unseal key and root token are displayed below in case you want to\nseal/unseal the Vault or re-authenticate.\n\nUnseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\nRoot Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n\nDevelopment mode should NOT be used in production installations!\n\n==&gt; Vault server started! Log data will stream in below:\n</code></pre><p>看到上面内容说明已经启动成功，在前台运行的。</p>\n<p>验证服务是否在成功运行：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status \nError checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：</p>\n<pre><code>export VAULT_ADDR=http://127.0.0.1:8200\n</code></pre><p>再次查看vault服务运行状态:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status\nKey             Value\n---             -----\nSeal Type       shamir\nSealed          false\nTotal Shares    1\nThreshold       1\nVersion         0.9.5\nCluster Name    vault-cluster-bcf3f2f8\nCluster ID      c2649684-fe35-3820-983b-f324a51b115c\nHA Enabled      false\n</code></pre><p>看到了上面的内容，则证明服务启动成功。</p>\n<p>为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效，<br>命令：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置vault访问地址</td>\n<td>export VAULT_ADDR=<a href=\"http://127.0.0.1:8200\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8200</a></td>\n<td style=\"text-align:left\">vault命令作用的vault服务的地址</td>\n</tr>\n<tr>\n<td>设置Vault PATH</td>\n<td>export PATH=$PATH:&lt; vault install path &gt;</td>\n<td style=\"text-align:left\">vault install path：vault安装路径</td>\n</tr>\n<tr>\n<td>设置访问token</td>\n<td>export VAULT_TOKEN=&lt; token &gt;</td>\n<td style=\"text-align:left\">token：登录vault时的token，首次登录可使用root token</td>\n</tr>\n<tr>\n<td>设置是否跳过核查</td>\n<td>export VAULT_SKIP_VERIFY=false</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n<tr>\n<td>设置访问证书</td>\n<td>export VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>保存私密信息</li>\n</ul>\n<p>下面是简单的写入信息命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\nSuccess! Data written to: secret/hello\n</code></pre><p>这会把键值对信息写入到路劲<code>secret/hello</code>中。　键为value,值为world。</p>\n<p>也可以一次性写入多个键值保存：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n</code></pre><ul>\n<li>读取私密信息</li>\n</ul>\n<p>显示该路径下所有保存键值对：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \nKey                 Value\n---                 -----\nrefresh_interval    768h\nexcited             yes\nvalue               world    \n</code></pre><p>获取单个的值：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\nworld\n</code></pre><ul>\n<li>删除路径下键值</li>\n</ul>\n<p>删除所有：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \nSuccess! Data deleted (if it existed) at: secret/hello\nmutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\nNo value found at secret/hello\n</code></pre><p>看上面命令，说明已经把保存到路径<code>secret/hello</code>下的键值信息全部删除。</p>\n<h2 id=\"秘密引擎\"><a href=\"#秘密引擎\" class=\"headerlink\" title=\"秘密引擎\"></a>秘密引擎</h2><p>上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径<code>secret/hello</code>下面，这个是默认的。当你试图保存到其他路径下时候，将报错。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\nError writing data to home/mutian/dev: Error making API request.\n\nURL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\nCode: 404. Errors:\n\n* no handler for route &apos;home/mutian/dev&apos;\n</code></pre><p>默认下，在路劲<code>secret/.</code>Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    </p>\n<ul>\n<li><p>开启一个新的kv私密引擎</p>\n<p>  mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv<br>  Success! Enabled the kv secrets engine at: abs/<br>  mutian@mutian-ThinkPad-T440p:~$ vault secrets list<br>  Path          Type         Description</p>\n<hr>\n<p>  abs/          kv           n/a<br>  cubbyhole/    cubbyhole    per-token private secret storage<br>  identity/     identity     identity store<br>  secret/       kv           key/value secret storage<br>  sys/          system       system endpoints used for control, policy and debugging</p>\n</li>\n</ul>\n<p>通过命令<code>vault secrets list</code>可以看到，第一个就是就是我们刚才开启的新私密引擎。</p>\n<p>往该新建私密引擎保存私密信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\nSuccess! Data written to: abs/my-secret\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\nSuccess! Data written to: abs/hello\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\nSuccess! Data written to: abs/airplane\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>查看该私密引擎下所有key</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault list abs\nKeys\n----\nairplane\nhello\nmy-secret\n</code></pre><ul>\n<li>关闭私密引擎</li>\n</ul>\n<p>当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　<br>当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\nSuccess! Disabled the secrets engine (if it existed) at: abs/\nmutian@mutian-ThinkPad-T440p:~$ vault secrets list\nPath          Type         Description\n----          ----         -----------\ncubbyhole/    cubbyhole    per-token private secret storage\nidentity/     identity     identity store\nsecret/       kv           key/value secret storage\nsys/          system       system endpoints used for control, policy and debugging\n</code></pre><p>上面结果中，已经再看不到私密引擎<code>abs/</code></p>\n<ul>\n<li>什么是私密引擎（Secrets Engine）</li>\n</ul>\n<p>上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？</p>\n<p>实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　<br>这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　</p>\n<h2 id=\"动态私密信息保存\"><a href=\"#动态私密信息保存\" class=\"headerlink\" title=\"动态私密信息保存\"></a>动态私密信息保存</h2>"},{"title":"网站的高性能","date":"2017-10-13T02:33:45.000Z","_content":"_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","source":"_posts/website-high-performance.md","raw":"---\ntitle: 网站的高性能\ndate: 2017-10-13 10:33:45\ncategories: 架构\ntags: website-high-performance\n---\n_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","slug":"website-high-performance","published":1,"updated":"2019-06-16T14:38:33.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqg900csg4va9hhw7y8y","content":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n</blockquote>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol start=\"2\">\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol start=\"3\">\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol start=\"4\">\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol start=\"5\">\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>","site":{"data":{}},"excerpt":"","more":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n</blockquote>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol start=\"2\">\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol start=\"3\">\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol start=\"4\">\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol start=\"5\">\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>"},{"title":"wkhtmltopdf使用记录","date":"2018-06-19T10:32:21.000Z","_content":"\nhtml转pdf工具wkhtmltopdf的使用记录……\n\n官网：https://wkhtmltopdf.org/\n\n使用文档：   \nhttps://wkhtmltopdf.org/usage/wkhtmltopdf.txt\nhttps://www.cnblogs.com/colder/p/5819197.html\n\n## centos下安装环境\n\n1.依赖包安装： `yum install zlib fontconfig freetype libX11 libXext libXrender`   \n2.下载执行包解压，放在固定目录下。  \n3.赋予执行包可执行权限：`chmod a+x wkhtmltopdf`。     \n4.把相关字体放到`usr/share/fonts`。 \n5.直接调用下面命令执行就可以了。\n\n## 使用问题收集\n\n1.中文字体乱码的问题。\n\nlinux：把字体{%asset_link simsun.ttc simsun.ttc%}添加到系统`usr/share/fonts`下。\n\n2.设定纸张大小，内容随纸张大小。\n\n3.Arial字体\n\n直接把{%asset_link Arial.zip Arial%}中相关字体文件添加到系统`usr/share/fonts`。\n\n参考：https://blog.csdn.net/churujianghu/article/details/75076255\n\n示例：   \n  \n    ./wkhtmltopdf --page-height 5cm --page-width 7cm --margin-bottom 0cm --margin-top 0.1cm --margin-left 0.1cm --margin-right 0cm --disable-smart-shrinking   label.html label.html label.html label.pdf\n\n## 页眉处理\n    \n样例1：\n    \n    wkhtmltopdf.exe --footer-left \"cxmr(500)        制表日期：[date] [time]\"  --footer-right \"制表者： XC-TEST001        页次： [page]/[topage]\"  --footer-line  orders-atn.html a.pdf\n\n样例2：\n\n    wkhtmltopdf.exe --footer-left \"cxmr(500)        制表日期：[date] [time]\"  --footer-right \"制表者： XC-TEST001        页次： [page]/[topage]\"  --footer-line --footer-font-size 8  --footer-spacing 5 orders-atn.html b.pdf\n    \n样例3：\n    \n    wkhtmltopdf.exe --footer-left \"cxmr(500)        制表日期：[date] [time]\"  --footer-right \"制表者： XC-TEST001        页次： [page]/[topage]\"  --footer-line --footer-font-size 8  --footer-spacing 5 orders-atn.html orders-atn.html orders-atn.html b.pdf  \n    \n## 精准打印出现中文不清晰，缺少笔画\n\n--disable-smart-shrinking   这个参数一定要加上，加上页面就不缩小了；    \n--dpi 这个参数不要用默认值，要设置大一点；letter-spacinng : 0  不然字间距太密；     \n\n特别加上dpi参数。","source":"_posts/wkhtmltopdf.md","raw":"---\ntitle: wkhtmltopdf使用记录\ndate: 2018-06-19 18:32:21\ncategories: pdf\ntags: wkhtmltopdf\n---\n\nhtml转pdf工具wkhtmltopdf的使用记录……\n\n官网：https://wkhtmltopdf.org/\n\n使用文档：   \nhttps://wkhtmltopdf.org/usage/wkhtmltopdf.txt\nhttps://www.cnblogs.com/colder/p/5819197.html\n\n## centos下安装环境\n\n1.依赖包安装： `yum install zlib fontconfig freetype libX11 libXext libXrender`   \n2.下载执行包解压，放在固定目录下。  \n3.赋予执行包可执行权限：`chmod a+x wkhtmltopdf`。     \n4.把相关字体放到`usr/share/fonts`。 \n5.直接调用下面命令执行就可以了。\n\n## 使用问题收集\n\n1.中文字体乱码的问题。\n\nlinux：把字体{%asset_link simsun.ttc simsun.ttc%}添加到系统`usr/share/fonts`下。\n\n2.设定纸张大小，内容随纸张大小。\n\n3.Arial字体\n\n直接把{%asset_link Arial.zip Arial%}中相关字体文件添加到系统`usr/share/fonts`。\n\n参考：https://blog.csdn.net/churujianghu/article/details/75076255\n\n示例：   \n  \n    ./wkhtmltopdf --page-height 5cm --page-width 7cm --margin-bottom 0cm --margin-top 0.1cm --margin-left 0.1cm --margin-right 0cm --disable-smart-shrinking   label.html label.html label.html label.pdf\n\n## 页眉处理\n    \n样例1：\n    \n    wkhtmltopdf.exe --footer-left \"cxmr(500)        制表日期：[date] [time]\"  --footer-right \"制表者： XC-TEST001        页次： [page]/[topage]\"  --footer-line  orders-atn.html a.pdf\n\n样例2：\n\n    wkhtmltopdf.exe --footer-left \"cxmr(500)        制表日期：[date] [time]\"  --footer-right \"制表者： XC-TEST001        页次： [page]/[topage]\"  --footer-line --footer-font-size 8  --footer-spacing 5 orders-atn.html b.pdf\n    \n样例3：\n    \n    wkhtmltopdf.exe --footer-left \"cxmr(500)        制表日期：[date] [time]\"  --footer-right \"制表者： XC-TEST001        页次： [page]/[topage]\"  --footer-line --footer-font-size 8  --footer-spacing 5 orders-atn.html orders-atn.html orders-atn.html b.pdf  \n    \n## 精准打印出现中文不清晰，缺少笔画\n\n--disable-smart-shrinking   这个参数一定要加上，加上页面就不缩小了；    \n--dpi 这个参数不要用默认值，要设置大一点；letter-spacinng : 0  不然字间距太密；     \n\n特别加上dpi参数。","slug":"wkhtmltopdf","published":1,"updated":"2019-06-16T14:38:33.991Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqga00cug4vaaquniemf","content":"<p>html转pdf工具wkhtmltopdf的使用记录……</p>\n<p>官网：<a href=\"https://wkhtmltopdf.org/\" target=\"_blank\" rel=\"noopener\">https://wkhtmltopdf.org/</a></p>\n<p>使用文档：<br><a href=\"https://wkhtmltopdf.org/usage/wkhtmltopdf.txt\" target=\"_blank\" rel=\"noopener\">https://wkhtmltopdf.org/usage/wkhtmltopdf.txt</a><br><a href=\"https://www.cnblogs.com/colder/p/5819197.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/colder/p/5819197.html</a></p>\n<h2 id=\"centos下安装环境\"><a href=\"#centos下安装环境\" class=\"headerlink\" title=\"centos下安装环境\"></a>centos下安装环境</h2><p>1.依赖包安装： <code>yum install zlib fontconfig freetype libX11 libXext libXrender</code><br>2.下载执行包解压，放在固定目录下。<br>3.赋予执行包可执行权限：<code>chmod a+x wkhtmltopdf</code>。<br>4.把相关字体放到<code>usr/share/fonts</code>。<br>5.直接调用下面命令执行就可以了。</p>\n<h2 id=\"使用问题收集\"><a href=\"#使用问题收集\" class=\"headerlink\" title=\"使用问题收集\"></a>使用问题收集</h2><p>1.中文字体乱码的问题。</p>\n<p>linux：把字体<a href=\"/2018/06/19/wkhtmltopdf/simsun.ttc\" title=\"simsun.ttc\">simsun.ttc</a>添加到系统<code>usr/share/fonts</code>下。</p>\n<p>2.设定纸张大小，内容随纸张大小。</p>\n<p>3.Arial字体</p>\n<p>直接把<a href=\"/2018/06/19/wkhtmltopdf/Arial.zip\" title=\"Arial\">Arial</a>中相关字体文件添加到系统<code>usr/share/fonts</code>。</p>\n<p>参考：<a href=\"https://blog.csdn.net/churujianghu/article/details/75076255\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/churujianghu/article/details/75076255</a></p>\n<p>示例：   </p>\n<pre><code>./wkhtmltopdf --page-height 5cm --page-width 7cm --margin-bottom 0cm --margin-top 0.1cm --margin-left 0.1cm --margin-right 0cm --disable-smart-shrinking   label.html label.html label.html label.pdf\n</code></pre><h2 id=\"页眉处理\"><a href=\"#页眉处理\" class=\"headerlink\" title=\"页眉处理\"></a>页眉处理</h2><p>样例1：</p>\n<pre><code>wkhtmltopdf.exe --footer-left &quot;cxmr(500)        制表日期：[date] [time]&quot;  --footer-right &quot;制表者： XC-TEST001        页次： [page]/[topage]&quot;  --footer-line  orders-atn.html a.pdf\n</code></pre><p>样例2：</p>\n<pre><code>wkhtmltopdf.exe --footer-left &quot;cxmr(500)        制表日期：[date] [time]&quot;  --footer-right &quot;制表者： XC-TEST001        页次： [page]/[topage]&quot;  --footer-line --footer-font-size 8  --footer-spacing 5 orders-atn.html b.pdf\n</code></pre><p>样例3：</p>\n<pre><code>wkhtmltopdf.exe --footer-left &quot;cxmr(500)        制表日期：[date] [time]&quot;  --footer-right &quot;制表者： XC-TEST001        页次： [page]/[topage]&quot;  --footer-line --footer-font-size 8  --footer-spacing 5 orders-atn.html orders-atn.html orders-atn.html b.pdf  \n</code></pre><h2 id=\"精准打印出现中文不清晰，缺少笔画\"><a href=\"#精准打印出现中文不清晰，缺少笔画\" class=\"headerlink\" title=\"精准打印出现中文不清晰，缺少笔画\"></a>精准打印出现中文不清晰，缺少笔画</h2><p>–disable-smart-shrinking   这个参数一定要加上，加上页面就不缩小了；<br>–dpi 这个参数不要用默认值，要设置大一点；letter-spacinng : 0  不然字间距太密；     </p>\n<p>特别加上dpi参数。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>html转pdf工具wkhtmltopdf的使用记录……</p>\n<p>官网：<a href=\"https://wkhtmltopdf.org/\" target=\"_blank\" rel=\"noopener\">https://wkhtmltopdf.org/</a></p>\n<p>使用文档：<br><a href=\"https://wkhtmltopdf.org/usage/wkhtmltopdf.txt\" target=\"_blank\" rel=\"noopener\">https://wkhtmltopdf.org/usage/wkhtmltopdf.txt</a><br><a href=\"https://www.cnblogs.com/colder/p/5819197.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/colder/p/5819197.html</a></p>\n<h2 id=\"centos下安装环境\"><a href=\"#centos下安装环境\" class=\"headerlink\" title=\"centos下安装环境\"></a>centos下安装环境</h2><p>1.依赖包安装： <code>yum install zlib fontconfig freetype libX11 libXext libXrender</code><br>2.下载执行包解压，放在固定目录下。<br>3.赋予执行包可执行权限：<code>chmod a+x wkhtmltopdf</code>。<br>4.把相关字体放到<code>usr/share/fonts</code>。<br>5.直接调用下面命令执行就可以了。</p>\n<h2 id=\"使用问题收集\"><a href=\"#使用问题收集\" class=\"headerlink\" title=\"使用问题收集\"></a>使用问题收集</h2><p>1.中文字体乱码的问题。</p>\n<p>linux：把字体<a href=\"/2018/06/19/wkhtmltopdf/simsun.ttc\" title=\"simsun.ttc\">simsun.ttc</a>添加到系统<code>usr/share/fonts</code>下。</p>\n<p>2.设定纸张大小，内容随纸张大小。</p>\n<p>3.Arial字体</p>\n<p>直接把<a href=\"/2018/06/19/wkhtmltopdf/Arial.zip\" title=\"Arial\">Arial</a>中相关字体文件添加到系统<code>usr/share/fonts</code>。</p>\n<p>参考：<a href=\"https://blog.csdn.net/churujianghu/article/details/75076255\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/churujianghu/article/details/75076255</a></p>\n<p>示例：   </p>\n<pre><code>./wkhtmltopdf --page-height 5cm --page-width 7cm --margin-bottom 0cm --margin-top 0.1cm --margin-left 0.1cm --margin-right 0cm --disable-smart-shrinking   label.html label.html label.html label.pdf\n</code></pre><h2 id=\"页眉处理\"><a href=\"#页眉处理\" class=\"headerlink\" title=\"页眉处理\"></a>页眉处理</h2><p>样例1：</p>\n<pre><code>wkhtmltopdf.exe --footer-left &quot;cxmr(500)        制表日期：[date] [time]&quot;  --footer-right &quot;制表者： XC-TEST001        页次： [page]/[topage]&quot;  --footer-line  orders-atn.html a.pdf\n</code></pre><p>样例2：</p>\n<pre><code>wkhtmltopdf.exe --footer-left &quot;cxmr(500)        制表日期：[date] [time]&quot;  --footer-right &quot;制表者： XC-TEST001        页次： [page]/[topage]&quot;  --footer-line --footer-font-size 8  --footer-spacing 5 orders-atn.html b.pdf\n</code></pre><p>样例3：</p>\n<pre><code>wkhtmltopdf.exe --footer-left &quot;cxmr(500)        制表日期：[date] [time]&quot;  --footer-right &quot;制表者： XC-TEST001        页次： [page]/[topage]&quot;  --footer-line --footer-font-size 8  --footer-spacing 5 orders-atn.html orders-atn.html orders-atn.html b.pdf  \n</code></pre><h2 id=\"精准打印出现中文不清晰，缺少笔画\"><a href=\"#精准打印出现中文不清晰，缺少笔画\" class=\"headerlink\" title=\"精准打印出现中文不清晰，缺少笔画\"></a>精准打印出现中文不清晰，缺少笔画</h2><p>–disable-smart-shrinking   这个参数一定要加上，加上页面就不缩小了；<br>–dpi 这个参数不要用默认值，要设置大一点；letter-spacinng : 0  不然字间距太密；     </p>\n<p>特别加上dpi参数。</p>\n"},{"title":"zookeeper-curator","date":"2018-06-28T02:01:04.000Z","_content":"","source":"_posts/zookeeper-curator.md","raw":"---\ntitle: zookeeper-curator\ndate: 2018-06-28 10:01:04\ncategories: zookeeper\ntags: apache curator\n---\n","slug":"zookeeper-curator","published":1,"updated":"2019-06-16T14:38:34.096Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqgc00cxg4valx75jhi9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"zookeeper入门","date":"2018-06-28T02:00:46.000Z","_content":"\n## docker安装zookeeper（推荐）\n\n参考:https://hub.docker.com/_/zookeeper\n\n### 1.拉取最新镜像\n\n    docker pull zookeeper\n    \n### 2.创建配置文件zoo.cfg\n \n 首先启动一个zk的一个临时容器，用来从容器中拷贝原始配置文件zoo.cfg。拷贝完后，强制删除容器。\n \n    docker run --name temp-zookeeper  -d zookeeper\n    docker cp temp-zookeeper:/conf/zoo.cfg /server/data/zookeeper/\n    docker rm -f temp-zookeeper\n    \n### 3.按配置文件启动新的可用zk服务\n \n    docker run --name zk-server1 --restart always -p 2181:2181 -p 2888:2888 -p 3888:3888 -d -v /server/data/zookeeper/zoo.cfg:/conf/zoo.cfg zookeeper\n    \n查看启动日志：\n\n    docker logs zk-server1\n    \n### 4.测试是否成功\n \n- 通zkCli连接zk server\n \n \n    docker run -it --rm --link zk-server1:zookeeper zookeeper zkCli.sh -server zookeeper \n    \n    -----------------------------\n    [root@sqjr-client-demo-server1-hn zookeeper]# docker run -it --rm --link zk-server1:zookeeper zookeeper zkCli.sh -server zookeeper\n    Connecting to zookeeper\n    2019-01-03 06:37:36,491 [myid:] - INFO  [main:Environment@100] - Client environment:zookeeper.version=3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMT\n    2019-01-03 06:37:36,494 [myid:] - INFO  [main:Environment@100] - Client environment:host.name=c2f781bcaf31\n    2019-01-03 06:37:36,495 [myid:] - INFO  [main:Environment@100] - Client environment:java.version=1.8.0_181\n    2019-01-03 06:37:36,497 [myid:] - INFO  [main:Environment@100] - Client environment:java.vendor=Oracle Corporation\n    2019-01-03 06:37:36,497 [myid:] - INFO  [main:Environment@100] - Client environment:java.home=/usr/lib/jvm/java-1.8-openjdk/jre\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.class.path=/zookeeper-3.4.13/bin/../build/classes:/zookeeper-3.4.13/bin/../build/lib/*.jar:/zookeeper-3.4.13/bin/../lib/slf4j-log4j12-1.7.25.jar:/zookeeper-3.4.13/bin/../lib/slf4j-api-1.7.25.jar:/zookeeper-3.4.13/bin/../lib/netty-3.10.6.Final.jar:/zookeeper-3.4.13/bin/../lib/log4j-1.2.17.jar:/zookeeper-3.4.13/bin/../lib/jline-0.9.94.jar:/zookeeper-3.4.13/bin/../lib/audience-annotations-0.5.0.jar:/zookeeper-3.4.13/bin/../zookeeper-3.4.13.jar:/zookeeper-3.4.13/bin/../src/java/lib/*.jar:/conf:\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.library.path=/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64/server:/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64:/usr/lib/jvm/java-1.8-openjdk/jre/../lib/amd64:/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.io.tmpdir=/tmp\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.compiler=<NA>\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.name=Linux\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.arch=amd64\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.version=3.10.0-693.2.2.el7.x86_64\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:user.name=root\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:user.home=/root\n    2019-01-03 06:37:36,499 [myid:] - INFO  [main:Environment@100] - Client environment:user.dir=/zookeeper-3.4.13\n    2019-01-03 06:37:36,499 [myid:] - INFO  [main:ZooKeeper@442] - Initiating client connection, connectString=zookeeper sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain$MyWatcher@4b85612c\n    Welcome to ZooKeeper!\n    2019-01-03 06:37:36,523 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@1029] - Opening socket connection to server zookeeper/172.17.0.5:2181. Will not attempt to authenticate using SASL (unknown error)\n    JLine support is enabled\n    2019-01-03 06:37:36,595 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@879] - Socket connection established to zookeeper/172.17.0.5:2181, initiating session\n    [zk: zookeeper(CONNECTING) 0] 2019-01-03 06:37:36,623 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@1303] - Session establishment complete on server zookeeper/172.17.0.5:2181, sessionid = 0x1003451023c0000, negotiated timeout = 30000\n    \n    WATCHER::\n    \n    WatchedEvent state:SyncConnected type:None path:null\n    \n    [zk: zookeeper(CONNECTED) 0]\n    \n- 创建节点\n \n \n    [zk: zookeeper(CONNECTED) 6] create /zk myData\n    Created /zk \n    \n-   获取节点信息\n\n    \n    [zk: zookeeper(CONNECTED) 7] get /zk\n    myData\n    cZxid = 0x2\n    ctime = Thu Jan 03 06:48:26 GMT 2019\n    mZxid = 0x2\n    mtime = Thu Jan 03 06:48:26 GMT 2019\n    pZxid = 0x2\n    cversion = 0\n    dataVersion = 0\n    aclVersion = 0\n    ephemeralOwner = 0x0\n    dataLength = 6\n    numChildren = 0\n\n- 删除节点信息\n\n\n    [zk: zookeeper(CONNECTED) 8] delete /zk\n    [zk: zookeeper(CONNECTED) 9] get /zk\n    Node does not exist: /zk  \n    \n## 直接安装\n\n……               ","source":"_posts/zookeeper-start.md","raw":"---\ntitle: zookeeper入门\ndate: 2018-06-28 10:00:46\ncategories: zookeeper\ntags: \n---\n\n## docker安装zookeeper（推荐）\n\n参考:https://hub.docker.com/_/zookeeper\n\n### 1.拉取最新镜像\n\n    docker pull zookeeper\n    \n### 2.创建配置文件zoo.cfg\n \n 首先启动一个zk的一个临时容器，用来从容器中拷贝原始配置文件zoo.cfg。拷贝完后，强制删除容器。\n \n    docker run --name temp-zookeeper  -d zookeeper\n    docker cp temp-zookeeper:/conf/zoo.cfg /server/data/zookeeper/\n    docker rm -f temp-zookeeper\n    \n### 3.按配置文件启动新的可用zk服务\n \n    docker run --name zk-server1 --restart always -p 2181:2181 -p 2888:2888 -p 3888:3888 -d -v /server/data/zookeeper/zoo.cfg:/conf/zoo.cfg zookeeper\n    \n查看启动日志：\n\n    docker logs zk-server1\n    \n### 4.测试是否成功\n \n- 通zkCli连接zk server\n \n \n    docker run -it --rm --link zk-server1:zookeeper zookeeper zkCli.sh -server zookeeper \n    \n    -----------------------------\n    [root@sqjr-client-demo-server1-hn zookeeper]# docker run -it --rm --link zk-server1:zookeeper zookeeper zkCli.sh -server zookeeper\n    Connecting to zookeeper\n    2019-01-03 06:37:36,491 [myid:] - INFO  [main:Environment@100] - Client environment:zookeeper.version=3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMT\n    2019-01-03 06:37:36,494 [myid:] - INFO  [main:Environment@100] - Client environment:host.name=c2f781bcaf31\n    2019-01-03 06:37:36,495 [myid:] - INFO  [main:Environment@100] - Client environment:java.version=1.8.0_181\n    2019-01-03 06:37:36,497 [myid:] - INFO  [main:Environment@100] - Client environment:java.vendor=Oracle Corporation\n    2019-01-03 06:37:36,497 [myid:] - INFO  [main:Environment@100] - Client environment:java.home=/usr/lib/jvm/java-1.8-openjdk/jre\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.class.path=/zookeeper-3.4.13/bin/../build/classes:/zookeeper-3.4.13/bin/../build/lib/*.jar:/zookeeper-3.4.13/bin/../lib/slf4j-log4j12-1.7.25.jar:/zookeeper-3.4.13/bin/../lib/slf4j-api-1.7.25.jar:/zookeeper-3.4.13/bin/../lib/netty-3.10.6.Final.jar:/zookeeper-3.4.13/bin/../lib/log4j-1.2.17.jar:/zookeeper-3.4.13/bin/../lib/jline-0.9.94.jar:/zookeeper-3.4.13/bin/../lib/audience-annotations-0.5.0.jar:/zookeeper-3.4.13/bin/../zookeeper-3.4.13.jar:/zookeeper-3.4.13/bin/../src/java/lib/*.jar:/conf:\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.library.path=/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64/server:/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64:/usr/lib/jvm/java-1.8-openjdk/jre/../lib/amd64:/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.io.tmpdir=/tmp\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.compiler=<NA>\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.name=Linux\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.arch=amd64\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.version=3.10.0-693.2.2.el7.x86_64\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:user.name=root\n    2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:user.home=/root\n    2019-01-03 06:37:36,499 [myid:] - INFO  [main:Environment@100] - Client environment:user.dir=/zookeeper-3.4.13\n    2019-01-03 06:37:36,499 [myid:] - INFO  [main:ZooKeeper@442] - Initiating client connection, connectString=zookeeper sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain$MyWatcher@4b85612c\n    Welcome to ZooKeeper!\n    2019-01-03 06:37:36,523 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@1029] - Opening socket connection to server zookeeper/172.17.0.5:2181. Will not attempt to authenticate using SASL (unknown error)\n    JLine support is enabled\n    2019-01-03 06:37:36,595 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@879] - Socket connection established to zookeeper/172.17.0.5:2181, initiating session\n    [zk: zookeeper(CONNECTING) 0] 2019-01-03 06:37:36,623 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@1303] - Session establishment complete on server zookeeper/172.17.0.5:2181, sessionid = 0x1003451023c0000, negotiated timeout = 30000\n    \n    WATCHER::\n    \n    WatchedEvent state:SyncConnected type:None path:null\n    \n    [zk: zookeeper(CONNECTED) 0]\n    \n- 创建节点\n \n \n    [zk: zookeeper(CONNECTED) 6] create /zk myData\n    Created /zk \n    \n-   获取节点信息\n\n    \n    [zk: zookeeper(CONNECTED) 7] get /zk\n    myData\n    cZxid = 0x2\n    ctime = Thu Jan 03 06:48:26 GMT 2019\n    mZxid = 0x2\n    mtime = Thu Jan 03 06:48:26 GMT 2019\n    pZxid = 0x2\n    cversion = 0\n    dataVersion = 0\n    aclVersion = 0\n    ephemeralOwner = 0x0\n    dataLength = 6\n    numChildren = 0\n\n- 删除节点信息\n\n\n    [zk: zookeeper(CONNECTED) 8] delete /zk\n    [zk: zookeeper(CONNECTED) 9] get /zk\n    Node does not exist: /zk  \n    \n## 直接安装\n\n……               ","slug":"zookeeper-start","published":1,"updated":"2019-06-16T14:38:34.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqge00d0g4vadfdf737w","content":"<h2 id=\"docker安装zookeeper（推荐）\"><a href=\"#docker安装zookeeper（推荐）\" class=\"headerlink\" title=\"docker安装zookeeper（推荐）\"></a>docker安装zookeeper（推荐）</h2><p>参考:<a href=\"https://hub.docker.com/_/zookeeper\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/zookeeper</a></p>\n<h3 id=\"1-拉取最新镜像\"><a href=\"#1-拉取最新镜像\" class=\"headerlink\" title=\"1.拉取最新镜像\"></a>1.拉取最新镜像</h3><pre><code>docker pull zookeeper\n</code></pre><h3 id=\"2-创建配置文件zoo-cfg\"><a href=\"#2-创建配置文件zoo-cfg\" class=\"headerlink\" title=\"2.创建配置文件zoo.cfg\"></a>2.创建配置文件zoo.cfg</h3><p> 首先启动一个zk的一个临时容器，用来从容器中拷贝原始配置文件zoo.cfg。拷贝完后，强制删除容器。</p>\n<pre><code>docker run --name temp-zookeeper  -d zookeeper\ndocker cp temp-zookeeper:/conf/zoo.cfg /server/data/zookeeper/\ndocker rm -f temp-zookeeper\n</code></pre><h3 id=\"3-按配置文件启动新的可用zk服务\"><a href=\"#3-按配置文件启动新的可用zk服务\" class=\"headerlink\" title=\"3.按配置文件启动新的可用zk服务\"></a>3.按配置文件启动新的可用zk服务</h3><pre><code>docker run --name zk-server1 --restart always -p 2181:2181 -p 2888:2888 -p 3888:3888 -d -v /server/data/zookeeper/zoo.cfg:/conf/zoo.cfg zookeeper\n</code></pre><p>查看启动日志：</p>\n<pre><code>docker logs zk-server1\n</code></pre><h3 id=\"4-测试是否成功\"><a href=\"#4-测试是否成功\" class=\"headerlink\" title=\"4.测试是否成功\"></a>4.测试是否成功</h3><ul>\n<li>通zkCli连接zk server</li>\n</ul>\n<pre><code>docker run -it --rm --link zk-server1:zookeeper zookeeper zkCli.sh -server zookeeper \n\n-----------------------------\n[root@sqjr-client-demo-server1-hn zookeeper]# docker run -it --rm --link zk-server1:zookeeper zookeeper zkCli.sh -server zookeeper\nConnecting to zookeeper\n2019-01-03 06:37:36,491 [myid:] - INFO  [main:Environment@100] - Client environment:zookeeper.version=3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMT\n2019-01-03 06:37:36,494 [myid:] - INFO  [main:Environment@100] - Client environment:host.name=c2f781bcaf31\n2019-01-03 06:37:36,495 [myid:] - INFO  [main:Environment@100] - Client environment:java.version=1.8.0_181\n2019-01-03 06:37:36,497 [myid:] - INFO  [main:Environment@100] - Client environment:java.vendor=Oracle Corporation\n2019-01-03 06:37:36,497 [myid:] - INFO  [main:Environment@100] - Client environment:java.home=/usr/lib/jvm/java-1.8-openjdk/jre\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.class.path=/zookeeper-3.4.13/bin/../build/classes:/zookeeper-3.4.13/bin/../build/lib/*.jar:/zookeeper-3.4.13/bin/../lib/slf4j-log4j12-1.7.25.jar:/zookeeper-3.4.13/bin/../lib/slf4j-api-1.7.25.jar:/zookeeper-3.4.13/bin/../lib/netty-3.10.6.Final.jar:/zookeeper-3.4.13/bin/../lib/log4j-1.2.17.jar:/zookeeper-3.4.13/bin/../lib/jline-0.9.94.jar:/zookeeper-3.4.13/bin/../lib/audience-annotations-0.5.0.jar:/zookeeper-3.4.13/bin/../zookeeper-3.4.13.jar:/zookeeper-3.4.13/bin/../src/java/lib/*.jar:/conf:\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.library.path=/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64/server:/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64:/usr/lib/jvm/java-1.8-openjdk/jre/../lib/amd64:/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.io.tmpdir=/tmp\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.compiler=&lt;NA&gt;\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.name=Linux\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.arch=amd64\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.version=3.10.0-693.2.2.el7.x86_64\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:user.name=root\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:user.home=/root\n2019-01-03 06:37:36,499 [myid:] - INFO  [main:Environment@100] - Client environment:user.dir=/zookeeper-3.4.13\n2019-01-03 06:37:36,499 [myid:] - INFO  [main:ZooKeeper@442] - Initiating client connection, connectString=zookeeper sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain$MyWatcher@4b85612c\nWelcome to ZooKeeper!\n2019-01-03 06:37:36,523 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@1029] - Opening socket connection to server zookeeper/172.17.0.5:2181. Will not attempt to authenticate using SASL (unknown error)\nJLine support is enabled\n2019-01-03 06:37:36,595 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@879] - Socket connection established to zookeeper/172.17.0.5:2181, initiating session\n[zk: zookeeper(CONNECTING) 0] 2019-01-03 06:37:36,623 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@1303] - Session establishment complete on server zookeeper/172.17.0.5:2181, sessionid = 0x1003451023c0000, negotiated timeout = 30000\n\nWATCHER::\n\nWatchedEvent state:SyncConnected type:None path:null\n\n[zk: zookeeper(CONNECTED) 0]\n</code></pre><ul>\n<li>创建节点</li>\n</ul>\n<pre><code>[zk: zookeeper(CONNECTED) 6] create /zk myData\nCreated /zk \n</code></pre><ul>\n<li>获取节点信息</li>\n</ul>\n<pre><code>[zk: zookeeper(CONNECTED) 7] get /zk\nmyData\ncZxid = 0x2\nctime = Thu Jan 03 06:48:26 GMT 2019\nmZxid = 0x2\nmtime = Thu Jan 03 06:48:26 GMT 2019\npZxid = 0x2\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 6\nnumChildren = 0\n</code></pre><ul>\n<li>删除节点信息</li>\n</ul>\n<pre><code>[zk: zookeeper(CONNECTED) 8] delete /zk\n[zk: zookeeper(CONNECTED) 9] get /zk\nNode does not exist: /zk  \n</code></pre><h2 id=\"直接安装\"><a href=\"#直接安装\" class=\"headerlink\" title=\"直接安装\"></a>直接安装</h2><p>……               </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"docker安装zookeeper（推荐）\"><a href=\"#docker安装zookeeper（推荐）\" class=\"headerlink\" title=\"docker安装zookeeper（推荐）\"></a>docker安装zookeeper（推荐）</h2><p>参考:<a href=\"https://hub.docker.com/_/zookeeper\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/zookeeper</a></p>\n<h3 id=\"1-拉取最新镜像\"><a href=\"#1-拉取最新镜像\" class=\"headerlink\" title=\"1.拉取最新镜像\"></a>1.拉取最新镜像</h3><pre><code>docker pull zookeeper\n</code></pre><h3 id=\"2-创建配置文件zoo-cfg\"><a href=\"#2-创建配置文件zoo-cfg\" class=\"headerlink\" title=\"2.创建配置文件zoo.cfg\"></a>2.创建配置文件zoo.cfg</h3><p> 首先启动一个zk的一个临时容器，用来从容器中拷贝原始配置文件zoo.cfg。拷贝完后，强制删除容器。</p>\n<pre><code>docker run --name temp-zookeeper  -d zookeeper\ndocker cp temp-zookeeper:/conf/zoo.cfg /server/data/zookeeper/\ndocker rm -f temp-zookeeper\n</code></pre><h3 id=\"3-按配置文件启动新的可用zk服务\"><a href=\"#3-按配置文件启动新的可用zk服务\" class=\"headerlink\" title=\"3.按配置文件启动新的可用zk服务\"></a>3.按配置文件启动新的可用zk服务</h3><pre><code>docker run --name zk-server1 --restart always -p 2181:2181 -p 2888:2888 -p 3888:3888 -d -v /server/data/zookeeper/zoo.cfg:/conf/zoo.cfg zookeeper\n</code></pre><p>查看启动日志：</p>\n<pre><code>docker logs zk-server1\n</code></pre><h3 id=\"4-测试是否成功\"><a href=\"#4-测试是否成功\" class=\"headerlink\" title=\"4.测试是否成功\"></a>4.测试是否成功</h3><ul>\n<li>通zkCli连接zk server</li>\n</ul>\n<pre><code>docker run -it --rm --link zk-server1:zookeeper zookeeper zkCli.sh -server zookeeper \n\n-----------------------------\n[root@sqjr-client-demo-server1-hn zookeeper]# docker run -it --rm --link zk-server1:zookeeper zookeeper zkCli.sh -server zookeeper\nConnecting to zookeeper\n2019-01-03 06:37:36,491 [myid:] - INFO  [main:Environment@100] - Client environment:zookeeper.version=3.4.13-2d71af4dbe22557fda74f9a9b4309b15a7487f03, built on 06/29/2018 04:05 GMT\n2019-01-03 06:37:36,494 [myid:] - INFO  [main:Environment@100] - Client environment:host.name=c2f781bcaf31\n2019-01-03 06:37:36,495 [myid:] - INFO  [main:Environment@100] - Client environment:java.version=1.8.0_181\n2019-01-03 06:37:36,497 [myid:] - INFO  [main:Environment@100] - Client environment:java.vendor=Oracle Corporation\n2019-01-03 06:37:36,497 [myid:] - INFO  [main:Environment@100] - Client environment:java.home=/usr/lib/jvm/java-1.8-openjdk/jre\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.class.path=/zookeeper-3.4.13/bin/../build/classes:/zookeeper-3.4.13/bin/../build/lib/*.jar:/zookeeper-3.4.13/bin/../lib/slf4j-log4j12-1.7.25.jar:/zookeeper-3.4.13/bin/../lib/slf4j-api-1.7.25.jar:/zookeeper-3.4.13/bin/../lib/netty-3.10.6.Final.jar:/zookeeper-3.4.13/bin/../lib/log4j-1.2.17.jar:/zookeeper-3.4.13/bin/../lib/jline-0.9.94.jar:/zookeeper-3.4.13/bin/../lib/audience-annotations-0.5.0.jar:/zookeeper-3.4.13/bin/../zookeeper-3.4.13.jar:/zookeeper-3.4.13/bin/../src/java/lib/*.jar:/conf:\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.library.path=/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64/server:/usr/lib/jvm/java-1.8-openjdk/jre/lib/amd64:/usr/lib/jvm/java-1.8-openjdk/jre/../lib/amd64:/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.io.tmpdir=/tmp\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:java.compiler=&lt;NA&gt;\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.name=Linux\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.arch=amd64\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:os.version=3.10.0-693.2.2.el7.x86_64\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:user.name=root\n2019-01-03 06:37:36,498 [myid:] - INFO  [main:Environment@100] - Client environment:user.home=/root\n2019-01-03 06:37:36,499 [myid:] - INFO  [main:Environment@100] - Client environment:user.dir=/zookeeper-3.4.13\n2019-01-03 06:37:36,499 [myid:] - INFO  [main:ZooKeeper@442] - Initiating client connection, connectString=zookeeper sessionTimeout=30000 watcher=org.apache.zookeeper.ZooKeeperMain$MyWatcher@4b85612c\nWelcome to ZooKeeper!\n2019-01-03 06:37:36,523 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@1029] - Opening socket connection to server zookeeper/172.17.0.5:2181. Will not attempt to authenticate using SASL (unknown error)\nJLine support is enabled\n2019-01-03 06:37:36,595 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@879] - Socket connection established to zookeeper/172.17.0.5:2181, initiating session\n[zk: zookeeper(CONNECTING) 0] 2019-01-03 06:37:36,623 [myid:] - INFO  [main-SendThread(zookeeper:2181):ClientCnxn$SendThread@1303] - Session establishment complete on server zookeeper/172.17.0.5:2181, sessionid = 0x1003451023c0000, negotiated timeout = 30000\n\nWATCHER::\n\nWatchedEvent state:SyncConnected type:None path:null\n\n[zk: zookeeper(CONNECTED) 0]\n</code></pre><ul>\n<li>创建节点</li>\n</ul>\n<pre><code>[zk: zookeeper(CONNECTED) 6] create /zk myData\nCreated /zk \n</code></pre><ul>\n<li>获取节点信息</li>\n</ul>\n<pre><code>[zk: zookeeper(CONNECTED) 7] get /zk\nmyData\ncZxid = 0x2\nctime = Thu Jan 03 06:48:26 GMT 2019\nmZxid = 0x2\nmtime = Thu Jan 03 06:48:26 GMT 2019\npZxid = 0x2\ncversion = 0\ndataVersion = 0\naclVersion = 0\nephemeralOwner = 0x0\ndataLength = 6\nnumChildren = 0\n</code></pre><ul>\n<li>删除节点信息</li>\n</ul>\n<pre><code>[zk: zookeeper(CONNECTED) 8] delete /zk\n[zk: zookeeper(CONNECTED) 9] get /zk\nNode does not exist: /zk  \n</code></pre><h2 id=\"直接安装\"><a href=\"#直接安装\" class=\"headerlink\" title=\"直接安装\"></a>直接安装</h2><p>……               </p>\n"},{"title":"后端架构师技术图谱","date":"2018-06-19T00:51:42.000Z","_content":"\n列出了后端架构师要掌握的基本知识。少壮不努力，老大徒伤悲……\n\n本文拷贝自https://github.com/xingshaocheng/architect-awesome\n\n\n<h1>《后端架构师技术图谱》</h1>\n\n**更新于20180513**\n* [数据结构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据结构)\n\t* [队列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#队列)\n\t* [集合](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合)\n\t* [链表、数组](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#链表数组)\n\t* [字典、关联数组](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典关联数组)\n\t* [栈](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#栈)\n\t* [树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#树)\n\t\t* [二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉树)\n\t\t* [完全二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#完全二叉树)\n\t\t* [平衡二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平衡二叉树)\n\t\t* [二叉查找树（BST）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉查找树bst)\n\t\t* [红黑树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#红黑树)\n\t\t* [B-，B+，B*树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#b-bb树)\n\t\t* [LSM 树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lsm-树)\n\t* [BitSet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#bitset)\n* [常用算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用算法)\n\t* [排序、查找算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#排序查找算法)\n\t\t* [选择排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#选择排序)\n\t\t* [冒泡排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#冒泡排序)\n\t\t* [插入排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#插入排序)\n\t\t* [快速排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快速排序)\n\t\t* [归并排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#归并排序)\n\t\t* [希尔排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#希尔排序)\n\t\t* [堆排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#堆排序)\n\t\t* [计数排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计数排序)\n\t\t* [桶排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#桶排序)\n\t\t* [基数排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基数排序)\n\t\t* [二分查找](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二分查找)\n\t\t* [Java 中的排序工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-中的排序工具)\n\t* [布隆过滤器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#布隆过滤器)\n\t* [字符串比较](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字符串比较)\n\t\t* [KMP 算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kmp-算法)\n\t* [深度优先、广度优先](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#深度优先广度优先)\n\t* [贪心算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贪心算法)\n\t* [回溯算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回溯算法)\n\t* [剪枝算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#剪枝算法)\n\t* [动态规划](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#动态规划)\n\t* [朴素贝叶斯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#朴素贝叶斯)\n\t* [推荐算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐算法)\n\t* [最小生成树算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最小生成树算法)\n\t* [最短路径算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最短路径算法)\n* [并发](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#并发)\n\t* [多线程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多线程)\n\t* [线程安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程安全)\n\t* [一致性、事务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性事务)\n\t\t* [事务 ACID 特性](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务-acid-特性)\n\t\t* [事务的隔离级别](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务的隔离级别)\n\t\t* [MVCC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvcc)\n\t* [锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#锁)\n\t\t* [Java中的锁和同步类](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java中的锁和同步类)\n\t\t* [公平锁 &amp; 非公平锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公平锁--非公平锁)\n\t\t* [悲观锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#悲观锁)\n\t\t* [乐观锁 &amp; CAS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#乐观锁--cas)\n\t\t* [ABA 问题](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aba-问题)\n\t\t* [CopyOnWrite容器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#copyonwrite容器)\n\t\t* [RingBuffer](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ringbuffer)\n\t\t* [可重入锁 &amp; 不可重入锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#可重入锁--不可重入锁)\n\t\t* [互斥锁 &amp; 共享锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#互斥锁--共享锁)\n\t\t* [死锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#死锁)\n* [操作系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#操作系统)\n\t* [计算机原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计算机原理)\n\t* [CPU](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cpu)\n\t\t* [多级缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多级缓存)\n\t* [进程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#进程)\n\t* [线程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程)\n\t* [协程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协程)\n\t* [Linux](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#linux)\n* [设计模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式)\n\t* [设计模式的六大原则](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式的六大原则)\n\t* [23种常见设计模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#23种常见设计模式)\n\t* [应用场景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景)\n\t* [单例模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单例模式)\n\t* [责任链模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#责任链模式)\n\t* [MVC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvc)\n\t* [IOC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ioc)\n\t* [AOP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aop)\n\t* [UML](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#uml)\n\t* [微服务思想](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#微服务思想)\n\t\t* [康威定律](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#康威定律)\n* [运维 &amp; 统计 &amp; 技术支持](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#运维--统计--技术支持)\n\t* [常规监控](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常规监控)\n\t* [APM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apm)\n\t* [统计分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#统计分析)\n\t* [持续集成(CI/CD)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#持续集成cicd)\n\t\t* [Jenkins](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jenkins)\n\t\t* [环境分离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#环境分离)\n\t* [自动化运维](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自动化运维)\n\t\t* [Ansible](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ansible)\n\t\t* [puppet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#puppet)\n\t\t* [chef](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#chef)\n\t* [测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#测试)\n\t\t* [TDD 理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tdd-理论)\n\t\t* [单元测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单元测试)\n\t\t* [压力测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#压力测试)\n\t\t* [全链路压测](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全链路压测)\n\t\t* [A/B 、灰度、蓝绿测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ab-灰度蓝绿测试)\n\t* [虚拟化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#虚拟化)\n\t\t* [KVM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kvm)\n\t\t* [Xen](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xen)\n\t\t* [OpenVZ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openvz)\n\t* [容器技术](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容器技术)\n\t\t* [Docker](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#docker)\n\t* [云技术](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#云技术)\n\t\t* [OpenStack](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openstack)\n\t* [DevOps](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#devops)\n\t* [文档管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文档管理)\n* [中间件](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#中间件)\n\t* [Web Server](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-server)\n\t\t* [Nginx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx)\n\t\t* [OpenResty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openresty)\n\t\t* [Apache Httpd](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apache-httpd)\n\t\t* [Tomcat](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tomcat)\n\t\t\t* [架构原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构原理)\n\t\t\t* [调优方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#调优方案)\n\t\t* [Jetty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jetty)\n\t* [缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#缓存)\n\t\t* [本地缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#本地缓存)\n\t* [客户端缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#客户端缓存)\n\t* [服务端缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务端缓存)\n\t\t* [Web缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web缓存)\n\t\t* [Memcached](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#memcached)\n\t\t* [Redis](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis)\n\t\t\t* [架构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构)\n\t\t\t* [回收策略](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回收策略)\n\t\t* [Tair](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tair)\n\t* [消息队列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息队列)\n\t\t* [消息总线](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息总线)\n\t\t* [消息的顺序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息的顺序)\n\t\t* [RabbitMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rabbitmq)\n\t\t* [RocketMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rocketmq)\n\t\t* [ActiveMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#activemq)\n\t\t* [Kafka](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka)\n\t\t* [Redis 消息推送](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis-消息推送)\n\t\t* [ZeroMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zeromq)\n\t* [定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#定时调度)\n\t\t* [单机定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单机定时调度)\n\t\t* [分布式定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式定时调度)\n\t* [RPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rpc)\n\t\t* [Dubbo](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dubbo)\n\t\t* [Thrift](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#thrift)\n\t\t* [gRPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#grpc)\n\t* [数据库中间件](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库中间件)\n\t\t* [Sharding Jdbc](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sharding-jdbc)\n\t* [日志系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志系统)\n\t\t* [日志搜集](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志搜集)\n\t* [配置中心](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#配置中心)\n\t* [API 网关](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#api-网关)\n* [网络](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络)\n\t* [协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协议)\n\t\t* [OSI 七层协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#osi-七层协议)\n\t\t* [TCP/IP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcpip)\n\t\t* [HTTP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http)\n\t\t* [HTTP2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http20)\n\t\t* [HTTPS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#https)\n\t* [网络模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络模型)\n\t\t* [Epoll](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#epoll)\n\t\t* [Java NIO](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-nio)\n\t\t* [kqueue](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kqueue)\n\t* [连接和短连接](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接和短连接)\n\t* [框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#框架)\n\t* [零拷贝（Zero-copy）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#零拷贝zero-copy)\n\t* [序列化(二进制协议)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化二进制协议)\n\t\t* [Hessian](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hessian)\n\t\t* [Protobuf](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#protobuf)\n* [数据库](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库)\n\t* [基础理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论)\n\t\t* [数据库设计的三大范式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库设计的三大范式)\n\t* [MySQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mysql)\n\t\t* [原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#原理)\n\t\t* [InnoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#innodb)\n\t\t* [优化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#优化)\n\t\t* [索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#索引)\n\t\t\t* [聚集索引, 非聚集索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#聚集索引-非聚集索引)\n\t\t\t* [复合索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#复合索引)\n\t\t\t* [自适应哈希索引(AHI)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自适应哈希索引ahi)\n\t\t* [explain](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#explain)\n\t* [NoSQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nosql)\n\t\t* [MongoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mongodb)\n\t\t* [Hbase](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hbase)\n* [搜索引擎](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎)\n\t* [搜索引擎原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎原理)\n\t* [Lucene](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lucene)\n\t* [Elasticsearch](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#elasticsearch)\n\t* [Solr](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#solr)\n\t* [sphinx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sphinx)\n* [性能](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能)\n\t* [性能优化方法论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能优化方法论)\n\t* [容量评估](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容量评估)\n\t* [CDN 网络](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cdn-网络)\n\t* [连接池](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接池)\n\t* [性能调优](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能调优)\n* [大数据](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据)\n\t* [流式计算](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#流式计算)\n\t\t* [Storm](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#storm)\n\t\t* [Flink](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#flink)\n\t\t* [Kafka Stream](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka-stream)\n\t\t* [应用场景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景-1)\n\t* [Hadoop](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hadoop)\n\t\t* [HDFS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hdfs)\n\t\t* [MapReduce](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mapreduce)\n\t\t* [Yarn](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#yarn)\n\t* [Spark](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spark)\n* [安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#安全)\n\t* [web 安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-安全)\n\t\t* [XSS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xss)\n\t\t* [CSRF](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#csrf)\n\t\t* [SQL 注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sql-注入)\n\t\t* [Hash Dos](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hash-dos)\n\t\t* [脚本注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#脚本注入)\n\t\t* [漏洞扫描工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#漏洞扫描工具)\n\t\t* [验证码](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#验证码)\n\t* [DDoS 防范](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddos-防范)\n\t* [用户隐私信息保护](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#用户隐私信息保护)\n\t* [序列化漏洞](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化漏洞)\n\t* [加密解密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#加密解密)\n\t\t* [对称加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#对称加密)\n\t\t* [哈希算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#哈希算法)\n\t\t* [非对称加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#非对称加密)\n\t* [服务器安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务器安全)\n\t* [数据安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据安全)\n\t\t* [数据备份](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据备份)\n\t* [网络隔离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络隔离)\n\t\t* [内外网分离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#内外网分离)\n\t\t* [登录跳板机](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#登录跳板机)\n\t* [授权、认证](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#授权认证)\n\t\t* [RBAC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rbac)\n\t\t* [OAuth2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#oauth20)\n\t\t* [双因素认证（2FA）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#双因素认证2fa)\n\t\t* [单点登录(SSO)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单点登录sso)\n* [常用开源框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用开源框架)\n\t* [开源协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源协议)\n\t* [日志框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志框架)\n\t\t* [Log4j、Log4j2](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#log4jlog4j2)\n\t\t* [Logback](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#logback)\n\t* [ORM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#orm)\n\t* [网络框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络框架)\n\t* [Web 框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-框架)\n\t\t* [Spring 家族](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spring-家族)\n\t* [工具框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具框架)\n* [分布式设计](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式设计)\n\t* [扩展性设计](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#扩展性设计)\n\t* [稳定性 &amp; 高可用](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#稳定性--高可用)\n\t\t* [硬件负载均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#硬件负载均衡)\n\t\t* [软件负载均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#软件负载均衡)\n\t\t* [限流](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#限流)\n\t\t* [应用层容灾](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用层容灾)\n\t\t* [跨机房容灾](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#跨机房容灾)\n\t\t* [容灾演练流程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容灾演练流程)\n\t\t* [平滑启动](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平滑启动)\n\t* [数据库扩展](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库扩展)\n\t\t* [读写分离模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#读写分离模式)\n\t\t* [分片模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分片模式)\n\t* [服务治理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务治理)\n\t\t* [服务注册与发现](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务注册与发现)\n\t\t* [服务路由控制](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务路由控制)\n\t* [分布式一致](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致)\n\t\t* [CAP 与 BASE 理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cap-与-base-理论)\n\t\t* [分布式锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式锁)\n\t\t* [分布式一致性算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致性算法)\n\t\t\t* [PAXOS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#paxos)\n\t\t\t* [Zab](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zab)\n\t\t\t* [Raft](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#raft)\n\t\t\t* [Gossip](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#gossip)\n\t\t\t* [两阶段提交、多阶段提交](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#两阶段提交多阶段提交)\n\t\t* [幂等](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#幂等)\n\t\t* [分布式一致方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致方案)\n\t\t* [分布式 Leader 节点选举](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式-leader-节点选举)\n\t\t* [TCC(Try/Confirm/Cancel) 柔性事务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcctryconfirmcancel-柔性事务)\n\t* [分布式文件系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式文件系统)\n\t* [唯一ID 生成](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#唯一id-生成)\n\t\t* [全局唯一ID](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全局唯一id)\n\t* [一致性Hash算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性hash算法)\n* [设计思想 &amp; 开发模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计思想--开发模式)\n\t* [DDD(Domain-driven Design - 领域驱动设计)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddddomain-driven-design---领域驱动设计)\n\t\t* [命令查询职责分离(CQRS)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#命令查询职责分离cqrs)\n\t\t* [贫血，充血模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贫血充血模型)\n\t* [Actor 模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#actor-模式)\n\t* [响应式编程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#响应式编程)\n\t\t* [Reactor](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#reactor)\n\t\t* [RxJava](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rxjava)\n\t\t* [Vert.x](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vertx)\n\t* [DODAF2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dodaf20)\n\t* [Serverless](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#serverless)\n\t* [Service Mesh](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#service-mesh)\n* [项目管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#项目管理)\n\t* [架构评审](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构评审)\n\t* [重构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#重构)\n\t* [代码规范](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码规范)\n\t* [代码 Review](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码-review)\n\t* [RUP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rup)\n\t* [看板管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#看板管理)\n\t* [SCRUM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#scrum)\n\t* [敏捷开发](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#敏捷开发)\n\t* [极限编程（XP）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#极限编程xp)\n\t* [结对编程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#结对编程)\n\t* [FMEA管理模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#fmea管理模式)\n* [通用业务术语](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#通用业务术语)\n* [技术趋势](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术趋势)\n* [政策、法规](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#政策法规)\n\t* [法律](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#法律)\n\t\t* [严格遵守刑法253法条](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#严格遵守刑法253法条)\n* [架构师素质](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构师素质)\n* [团队管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队管理)\n\t* [招聘](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#招聘)\n* [资讯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#资讯)\n\t* [行业资讯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业资讯)\n\t* [公众号列表](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公众号列表)\n\t* [博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#博客)\n\t\t* [团队博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队博客)\n\t\t* [个人博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#个人博客)\n\t* [综合门户、社区](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合门户社区)\n\t* [问答、讨论类社区](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#问答讨论类社区)\n\t* [行业数据分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业数据分析)\n\t* [专项网站](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#专项网站)\n\t* [其他类](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#其他类)\n\t* [推荐参考书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐参考书)\n\t\t* [在线电子书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线电子书)\n\t\t* [纸质书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#纸质书)\n\t\t\t* [开发方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开发方面)\n\t\t\t* [架构方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构方面)\n\t\t\t* [技术管理方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术管理方面)\n\t\t\t* [基础理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论-1)\n\t\t\t* [工具方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具方面)\n\t\t\t* [大数据方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据方面)\n* [技术资源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术资源)\n\t* [开源资源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源资源)\n\t* [手册、文档、教程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#手册文档教程)\n\t* [在线课堂](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线课堂)\n\t* [会议、活动](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#会议活动)\n\t* [常用APP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用app)\n\t* [找工作](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#找工作)\n\t* [工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具)\n\t* [代码托管](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码托管)\n\t* [文件服务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文件服务)\n\t* [综合云服务商](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合云服务商)\n\t\t* [VPS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vps)\n\t\n\n**（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）**\n\n# 数据结构\n\n## 队列\n* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)\n\t* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。\n\t* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。\n\n* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)\n\n## 集合\n* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)\n\n## 链表、数组\n* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)\n\n## 字典、关联数组\n* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)\n\n## 栈\n* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)\n* [《Java Stack 类》](http://www.runoob.com/java/java-stack-class.html)\n* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)\n\t* Stack 是线程安全的。\n\t* 内部使用数组保存数据，不够时翻倍。\n\n## 树\n\n### 二叉树\n\n每个节点最多有两个叶子节点。\n*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)\n\n### 完全二叉树\n* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)\n\t* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。\n\n### 平衡二叉树\n左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n* [《浅谈数据结构-平衡二叉树》](http://www.cnblogs.com/polly333/p/4798944.html)\n* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)\n\n### 二叉查找树（BST）\n二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。\n\n* [《浅谈算法和数据结构: 七 二叉查找树》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)\n\n\n### 红黑树\n* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)\n\t* 添加阶段后，左旋或者右旋从而再次达到平衡。 \n* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)\n\n### B-，B+，B*树\nMySQL是基于B+树聚集索引组织表\n\n* [《B-树，B+树，B\\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)\n* [《B-树，B+树与B\\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)\n\t* B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。\n### LSM 树\n\nLSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。\n\n* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)\n\t* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。\n\t* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n\t\n* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)\n\t* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。\n\t* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。\n\t* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。\n\n## BitSet\n\n经常用于大规模数据的排重检查。\n\n* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)\n* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)\n\n# 常用算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n## 排序、查找算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n### 选择排序\n* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)\n\t* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\n\n### 冒泡排序\n* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)\n\t* 相邻元素前后交换、把最大的排到最后。\n\t* 时间复杂度 O(n²) \n\n### 插入排序\n* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)\n\n### 快速排序\n* [《坐在马桶上看算法：快速排序》](http://developer.51cto.com/art/201403/430986.htm)\n\t* 一侧比另外一次都大或小。 \n### 归并排序\n* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)\n\t* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 \n\n### 希尔排序\nTODO\n\n### 堆排序\n* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)\n\t* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\n\n### 计数排序\n* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)\n\t* 和桶排序过程比较像，差别在于桶的数量。\n\n### 桶排序\n* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)\n* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)\n\t* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。\n\t* 每个桶单独进行排序，然后再遍历每个桶。\n\n### 基数排序\n\n按照个位、十位、百位、...依次来排。\n\n* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)\n* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)\n\n\n### 二分查找\n* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)\n\t* 要求待查找的序列有序。\n\t* 时间复杂度 O(logN)。\n\n* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)\n\t* while + 递归。\n### Java 中的排序工具\n* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)\n\t* Collections.sort算法调用的是合并排序。\n\t* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。\n\n## 布隆过滤器\n\n常用于大数据的排重，比如email，url 等。\n核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。\n优点：空间和时间效率都很高。\n缺点：随着存入的元素数量增加，误算率随之增加。\n\n* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)\n* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)\n* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)\n\t* 基于 Redis 的 Bitmap 数据结构。\n* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)\n\t* 使用Java中的 BitSet 类 和 加权和hash算法。\n\n## 字符串比较\n\n### KMP 算法\nKMP：Knuth-Morris-Pratt算法（简称KMP）\n核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。\n* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n## 深度优先、广度优先\n* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)\n\n## 贪心算法\n* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)\n* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)\n\n## 回溯算法\n* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)\n\n## 剪枝算法\n* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)\n\n## 动态规划\n* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)\n* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)\n\n## 朴素贝叶斯\n\n* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)\n\t* P(B|A)=P(A|B)P(B)/P(A)\n\n* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)\n* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)\n\n\n## 推荐算法\n* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)\n* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)\n\n## 最小生成树算法\n* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)\n\n## 最短路径算法\n\n* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)\n\n# 并发\n\n## Java 并发\n\n* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)\n* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)\n\n## 多线程\n\n* [《40个Java多线程问题总结》](http://www.importnew.com/18459.html)\n\n## 线程安全\n\n* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)\n\n## 一致性、事务\n\n### 事务 ACID 特性\n* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)\n\n### 事务的隔离级别\n\n* 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。\n* 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。\n* 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。\n* 序列化：所有事物串行处理（牺牲了效率）\n\n* [《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)\n* [数据库事务的四大特性及事务隔离级别](https://www.cnblogs.com/z-sm/p/7245981.html)\n\n* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)\n\t* 幻读的例子非常清楚。\n\t* 通过 SELECT ... FOR UPDATE 解决。\n\t\n* [《一篇文章带你读懂MySQL和InnoDB》](http://database.51cto.com/art/201804/570101.htm)\n\t* 图解脏读、不可重复读、幻读问题。\n\n\n### MVCC\n\n\n* [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)\n\t* innodb 中 MVCC 用在 Repeatable-Read 隔离级别。\n\t* MVCC 会产生幻读问题（更新时异常。）\n\n* [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)\n\n\t* 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间\n\t* 每次只操作比当前版本小（或等于）的 行。\n\t\n\n\n## 锁\n\n### Java中的锁和同步类\n\n* [《Java中的锁分类》](https://www.cnblogs.com/qifengshi/p/6831055.html)\n\t* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 \n\n* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)\n\n* [《Java中信号量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)\n\t* 有数量控制\n\t* 申请用 acquire，申请不要则阻塞；释放用 release。\n\n* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)\n\t* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。\t \n\n### 公平锁 & 非公平锁\n\n公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。\n\n* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)\n\t* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。\n\n### 悲观锁 \n\n悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。\n\n* [《【MySQL】悲观锁&乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)\n\t* 乐观锁的方式：版本号+重试方式\n\t* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。\n\n* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)\n\t* mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。\n\t* 锁相同数据的不同索引条件可能会引起死锁。\n\t\n* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)\n\n### 乐观锁 & CAS\n\n* [《乐观锁的一种实现方式——CAS》](http://www.importnew.com/20472.html)\n\t* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。\t \n\n### ABA 问题\n\n由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。\n\n* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)\n* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)\n\t* AtomicStampedReference 和 AtomicStampedReference。 \n\n### CopyOnWrite容器\n\n可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。\n\n* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)\n\t* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  \n\t* 不用加锁，通过最终一致实现一致性。\n\t\n* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)\n\n### RingBuffer \n* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)\n\n### 可重入锁 & 不可重入锁\n\n* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)\n\t* 通过简单代码举例说明可重入锁和不可重入锁。\n\t* 可重入锁指同一个线程可以再次获得之前已经获得的锁。\n\t* 可重入锁可以用户避免死锁。\n\t* Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock\n\n* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)\n\t* synchronized 使用方便，编译器来加锁，是非公平锁。\n\t* ReenTrantLock 使用灵活，锁的公平性可以定制。\n\t* 相同加锁场景下，推荐使用 synchronized。\n\n### 互斥锁 & 共享锁\n\n互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。\n共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。\n\n* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)\n\n### 死锁\n* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)\n\t* 互斥、持有、不可剥夺、环形等待。\n* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)\n\t* JConsole 可以识别死锁。\n\t\n* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)\n\t* jstack 可以显示死锁。\n\t\n# 操作系统\n\n## 计算机原理\n\n* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)\n\n## CPU\n\n### 多级缓存\n典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。\n\n* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)\n\n## 进程\n\nTODO\n\n## 线程\n\n* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)\n\n## 协程\n\n* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)\n\t* 线程的调度是由操作系统负责，协程调度是程序自行负责\n\t* 与线程相比，协程减少了无谓的操作系统切换.\n\t* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.\n\t\n## Linux\n\n* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)\n\n# 设计模式\n\n## 设计模式的六大原则\n* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)\n\t* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。\n\t* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。\n\t* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。\n\t* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。\n\t* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。\n\t* 合成复用原则：尽量使用合成/聚合,而不是使用继承。\n\n## 23种常见设计模式\n* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)\n\n## 应用场景\n* [《细数JDK里的设计模式》](http://blog.jobbole.com/62314/)\n\t* 结构型模式：\n\t\t* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。\n\t\t* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；\n\t\t* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。\n\t\t* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。\n\t\t* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。\n\t\t* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy\n\t\t\n\t* 创建模式:\n\t\t* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。\n\t\t* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。\n\t\t* 工厂方法：就是 **一个返*** 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。\n\t\t* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。\n\t\t* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。\n\t* 行为模式：\n\t\t* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。\n\t\t* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。\n\t\t* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。\n\t\t* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。\n\t\t* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。\n\t\t* 空对象模式：如 java.util.Collections#emptyList()。\n\t\t* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。\n\t\t* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。\n\n* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)\n* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)\n\n## 单例模式\n* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)\n* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)\n\t* 使用枚举类型。\n\n## 责任链模式\nTODO\n\n## MVC\n* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)\n\t* 模型(model)－视图(view)－控制器(controller) \n\n## IOC\n* [《理解 IOC》](https://www.zhihu.com/question/23277575)\n* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)\n\t* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。\n\t* 作用：用于模块解耦。\n\t* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。\n\n## AOP\n\n* [《轻松理解AOP(面向切面编程)》](https://my.oschina.net/yanquan345/blog/203415)\n* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)\n* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)\n\t* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。\n* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)\n\t* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 \n\n\n## UML\n\n* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)\n\n## 微服务思想\n* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)\n* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)\n\n### 康威定律\n* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)\n\t* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。\n\t* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。\n\t* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。\n\t* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。\n\n* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)\n\n# 运维 & 统计 & 技术支持 \n\n## 常规监控\n\n* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)\n\t* 监控的方式：主动、被动、旁路(比如舆情监控)\n\t* 监控类型： 基础监控、服务端监控、客户端监控、\n\t监控、用户端监控\n\t* 监控的目标：全、块、准\n\t* 核心指标：请求量、成功率、耗时\n\n* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)\n\t* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。\n\n* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)\n\n**命令行监控工具**\n\n* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)\n\t* top、sar、tsar、nload\n\n* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)\n\n* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)\n\n## APM\n\nAPM —  Application Performance Management\n\n* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)\n\n* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)\n\n* 主要开源软件，按字母排序\n  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)\n  * [CAT](https://github.com/dianping/cat)\n  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)\n  * [Pinpoint](https://github.com/naver/pinpoint)\n  * [Zipkin](https://github.com/openzipkin/zipkin)\n\n* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)\n\t* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。\n\t\n\n\n## 统计分析\n\n* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)\n\t* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度\n\n* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)\n\t* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。\n\n* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt-mobile-analytics-practice.html)\n\t* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 \n\n\n## 持续集成(CI/CD)\n\n* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n* [《8个流行的持续集成工具》](https://www.testwo.com/article/1170)\n\n### Jenkins\n\n* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)\n\n### 环境分离\n\n开发、测试、生成环境分离。\n\n* [《开发环境、生产环境、测试环境的基本理解和区》](https://my.oschina.net/sancuo/blog/214904)\n\n## 自动化运维\n\n### Ansible\n* [《Ansible中文权威指南》](http://www.ansible.com.cn/)\n* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)\n\n### puppet\n* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)\n\n### chef\n* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)\n\n## 测试\n\n### TDD 理论\n\n* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)\n\t* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.\n\t* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； \n\n### 单元测试\n\n* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)\n* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)\n\t* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 \n* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)\n\t* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 \n\n### 压力测试\n\n* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)\n* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)\n* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)\n* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)\n* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)\n\n\n### 全链路压测\n* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)\n* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)\n* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)\n* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)\n\n\n### A/B 、灰度、蓝绿测试\n\n* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)\n* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)\n\n* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)\n\n## 虚拟化\n\n* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)\n\n### KVM\n* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)\n* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)\n\n### Xen\n* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)\n\n### OpenVZ\n* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)\n\n## 容器技术\n\n### Docker\n* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)\n* [《Docker 核心技术与实现原理》](https://draveness.me/docker)\n* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)\n\n## 云技术\n\n### OpenStack\n* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)\n\n## DevOps\n* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)\n* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)\n\n## 文档管理\n\n* [Confluence-收费文档管理系统](http://www.confluence.cn/)\n* GitLab?\n* Wiki\n\n# 中间件\n\n## Web Server\n\n### Nginx\n* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)\n\t* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。\n\t* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  \n\n* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)\n\t* nginx只适合静态和反向代理，不适合处理动态请求。\n\n### OpenResty\n* [官方网站](http://openresty.org/cn/)\n* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)\n\t* 通过 Lua 模块可以在Nginx上进行开发。 \n\n### Apache Httpd\n* [官方网站](http://httpd.apache.org/)\n\n### Tomcat\n\n#### 架构原理\n* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)\n* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)\n* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)\n\n* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)\n\n* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)\n\t* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。\n\t* Jboss 实现全部了JEE特性，软件开源免费、文档收费。\n\n#### 调优方案\n\n* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)\n\t* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； \n\n* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)\n* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)\n\t* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。\n\t* 并发高时，AJP协议优于HTTP协议。\n\n### Jetty\n* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)\n* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)\n\t* 架构比较:Jetty的架构比Tomcat的更为简单。\n\t* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。\n\t* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 \n\n\n\n## 缓存\n\n* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)\n\n### 本地缓存\n\n* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)\n\n* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)\n\t* 堆内、堆外、磁盘三级缓存。\n\t* 可按照缓存空间容量进行设置。\n\t* 按照时间、次数等过期策略。\n\n* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)\n\t* 简单轻量、无堆外、磁盘缓存。\n\n\n* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)\n\n* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)\n\n## 客户端缓存\n\n* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)\n\t* 主要是利用 Cache-Control 参数。\n\n* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)\n\n## 服务端缓存\n\n### Web缓存\n\n* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache\n* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache\n* [squid](https://github.com/squid-cache/squid) - squid cache\n\n### Memcached\n* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)\n* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)\n\t* 采用多路复用技术提高并发性。\n\t* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。\n* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)\n* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)\n\n* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)\n\t* 区别在于当key存在还是不存在时，返回值是true和false的。\n\n* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)\n\n### Redis\n\n* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)\n* [《redis底层原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)\n\t* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。\n\t* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。\n* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)\n\t* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。\n\t* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。\n\t* 也可以两者结合使用。\n\n* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)\n\n#### 架构\n* [《Redis单线程架构》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)\n\n#### 回收策略\n* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)\n\n### Tair\n\n* [官方网站](https://github.com/alibaba/tair)\n* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)\n* 特点：可以配置备份节点数目，通过异步同步到备份节点\n* 一致性Hash算法。\n* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。\n\n\n几种存储引擎:\n* MDB，完全内存性，可以用来存储Session等数据。\n* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作\n* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。\n* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。\n\n## 消息队列\n\n* [《消息队列-推/拉模式学习 & ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)\n\t* RabbitMQ 消费者默认是推模式（也支持拉模式）。\n\t* Kafka 默认是拉模式。\n\t* Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。\n\t* Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。\n\n* [《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》](https://blog.csdn.net/yunfeng482/article/details/72856762)\n\n### 消息总线\n\n消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。\n\n* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)\n\n### 消息的顺序\n* [《如何保证消费者接收消息的顺序》](https://www.cnblogs.com/cjsblog/p/8267892.html)\n\n### RabbitMQ\n\n支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。\n\n* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)\n* [《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57) \n* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)\n\n### RocketMQ\nJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。\n* [《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)\n* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome)\n\n### ActiveMQ\n纯Java实现，兼容JMS，可以内嵌于Java应用中。\n* [《ActiveMQ消息队列介绍》](https://www.cnblogs.com/wintersun/p/3962302.html)\n\n### Kafka\n高吞吐量、采用拉模式。适合高IO场景，比如日志同步。\n\n* [官方网站](http://kafka.apache.org/)\n* [《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)\n* [《Kafka分区机制介绍与示例》](http://lxw1234.com/archives/2015/10/538.htm)\n\n### Redis 消息推送\n\n生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。\n\n* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)\n\n### ZeroMQ\n TODO\n\n\n## 定时调度\n\n### 单机定时调度\n\n* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)\n\n* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)\n\t* fork 进程 + sleep 轮询\n\n* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)\n* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)\n* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)\n\t* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。\n\n\n### 分布式定时调度\n\n* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)\n\t* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares\n\n* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)\n\t* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 \n* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome)\n* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome)\n\n\n## RPC\n\n* [《从零开始实现RPC框架 - RPC原理及实现》](https://blog.csdn.net/top_code/article/details/54615853)\n\t* 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。\n\n* [《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》](https://blog.csdn.net/testcs_dn/article/details/78050590)\n\n### Dubbo\n* [官方网站](http://dubbo.apache.org/)\n* [dubbo实现原理简单介绍](https://www.cnblogs.com/steven520213/p/7606598.html)\n\n** SPI **\nTODO\n\n### Thrift\n* [官方网站](http://thrift.apache.org/)\n* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)\n\t* 支持多语言，通过中间语言定义接口。\n\n### gRPC\n\n服务端可以认证加密，在外网环境下，可以保证数据安全。\n\n* [官方网站](https://grpc.io/)\n* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)\n\n\n## 数据库中间件\n\n### Sharding Jdbc\n\n* [官网](http://shardingjdbc.io/)\n\n## 日志系统\n\n### 日志搜集\n\n* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)\n* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)\n* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)\n\n## 配置中心\n\n* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)\n\t* Spring Boot 和 Spring Cloud\n\t* 支持推、拉模式更新配置\n\t* 支持多种语言 \n\n* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)\n\n* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)\n\nservlet 3.0 异步特性可用于配置中心的客户端\n* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)\n\n## API 网关\n\n主要职责：请求转发、安全认证、协议转换、容灾。\n\n* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)\n* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)\n\n* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)\n* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome)\n* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)\n\n# 网络\n\n\n## 协议\n\n### OSI 七层协议\n\n* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)\n\n### TCP/IP\n* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)\n* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)\n\n### HTTP\n* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)\n\n### HTTP2.0\n* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)\n* [《HTTP2.0的基本单位为二进制帧》](https://blog.csdn.net/u012657197/article/details/77877840)\n\t* 利用二进制帧负责传输。\n\t* 多路复用。\n\n### HTTPS\n* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)\n\t* 使用非对称加密协商加密算法\n\t* 使用对称加密方式传输数据\n\t* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。\n\n* [《八大免费SSL证书-给你的网站免费添加Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)\n\n## 网络模型\n\n* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)\n\t* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。\n\t* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。\n\n* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)\n\t* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\t* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。\n\t* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。\n\t* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。\n\t\n* [《select，poll，epoll比较  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)\n\t* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。\n\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n\t* NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务\n\n* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)\n\n* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)\n\n### Epoll\n\n* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)\n\n### Java NIO\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)\n\n### kqueue\n* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)\n\n## 连接和短连接\n\n* [《TCP/IP系列——长连接与短连接的区别》](https://www.cnblogs.com/pangguoping/p/5571422.html)\n\n## 框架\n\n* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)\n\t* Reactor 模式介绍。\n\t* Netty 是 Reactor 模式的一种实现。\n\n## 零拷贝（Zero-copy）\n* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)\n\t* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。\n\n## 序列化(二进制协议)\n\n### Hessian\n* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)\nBinary-RPC;不仅仅是序列化\n\n### Protobuf\n* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)\nGoolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。\n* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)\n  \t* 关于协议的解释；缺点：可读性差;\n\n* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)\n\t* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。\n\n# 数据库\n## 基础理论\n### 数据库设计的三大范式\n* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)\n\t* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；\n\t* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；\n\t* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；\n\n## MySQL\n\n### 原理\n* [《MySQL的InnoDB索引原理详解》](http://www.admin10000.com/document/5372.html)\n\n* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)\n\t* 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁\n\n* [《myisam和innodb索引实现的不同》](https://www.2cto.com/database/201211/172380.html)\n\n### InnoDB\n\n* [《一篇文章带你读懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)\n\n### 优化\n\n* [《MySQL36条军规》](http://vdisk.weibo.com/s/muWOT)\n\n* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)\n* [《SQL优化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)\n* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)\n* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)\n* [《 MYSQL分页limit速度太慢优化方法》](https://blog.csdn.net/zy_281870667/article/details/51604540)\n\t* 原则上就是缩小扫描范围。\n\n\n### 索引\n\n#### 聚集索引, 非聚集索引\n\n* [《MySQL 聚集索引/非聚集索引简述》](https://blog.csdn.net/no_endless/article/details/77073549)\n* [《MyISAM和InnoDB的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)\n\nMyISAM 是非聚集，InnoDB 是聚集\n\n#### 复合索引\n\n* [《复合索引的优点和注意事项》](https://www.cnblogs.com/summer0space/p/7247778.html)\n\n#### 自适应哈希索引(AHI)\n\n* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)\n\n\n### explain\n* [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)\n\n## NoSQL\n\n### MongoDB\n\n* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n* [《Mongodb相对于关系型数据库的优缺点》](http://mxdxm.iteye.com/blog/2093603)\n\t* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；\n\t* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；\n\n### Hbase\n\n* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)\n* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)\n* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)\n\n\n* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)\n\t* 空数据不存储，节省空间，且适用于并发。\n\n* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)\n\t* rowkey 按照字典顺序排列，便于批量扫描。\n\t* 通过散列可以避免热点。\n\n# 搜索引擎\n\n## 搜索引擎原理\n\n* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)\n\n## Lucene\n* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)\n\n## Elasticsearch\n\n* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)\n* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)\n\n## Solr\n* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)\n* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)\n\n## sphinx \n* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)\n\n# 性能\n\n## 性能优化方法论\n\n* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)\n\t* 代码层面、业务层面、数据库层面、服务器层面、前端优化。\n\n* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)\n\n## 容量评估\n* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)\n* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect)\n\t* 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS\n\n## CDN 网络\n\n* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)\n* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)\n\n## 连接池\n\n* [《主流Java数据库连接池比较与开发配置实战》](https://blog.csdn.net/fysuccess/article/details/66972554)\n\n## 性能调优\n\n* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)\n\n\n# 大数据\n\n## 流式计算\n\n### Storm\n* [官方网站](http://storm.apache.org/)\n* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)\n\n### Flink\n* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)\n\n### Kafka Stream\n* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)\n\n### 应用场景\n\n例如：\n\n* 广告相关实时统计；\n* 推荐系统用户画像标签实时更新；\n* 线上服务健康状况实时监测；\n* 实时榜单；\n* 实时数据统计。\n\n## Hadoop\n\n* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)\n* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)\n\n### HDFS\n* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)\n\n### MapReduce\n* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)\n* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)\n\n### Yarn\n* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)\n\n## Spark\n* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)\n\n\n# 安全\n\n## web 安全\n\n### XSS\n* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)\n### CSRF\n* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)\n\n### SQL 注入\n\n* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)\n\n### Hash Dos\n\n\n* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)\n\t* 利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。\n* [《一种高级的DoS攻击-Hash碰撞攻击》](https://yq.aliyun.com/articles/92194?t=t1)\n* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)\n\n### 脚本注入\n\n* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)\n\n### 漏洞扫描工具\n* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)\n* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)\n* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)\n\n### 验证码\n\n* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)\n\n* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)\n\t* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。\n\n* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)\n\n## DDoS 防范\n* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)\n* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)\n\n## 用户隐私信息保护\n\n1. 用户密码非明文保存，加动态salt。\n2. 身份证号，手机号如果要显示，用 “\\*” 替代部分字符。\n3. 联系方式在的显示与否由用户自己控制。\n4. TODO\n\n* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)\n* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)\n\n* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)\n\n## 序列化漏洞\n* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)\n\n## 加密解密\n\n### 对称加密\n\n* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)\n\t* DES、3DES、Blowfish、AES\n\t* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。\n\t* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。\n\t\n### 哈希算法\n* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)\n\t* MD5 和 SHA-1 已经不再安全，已被弃用。\n\t* 目前 SHA-256 是比较安全的。\n\t\n* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)\n\n### 非对称加密\n* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)\n\t* RSA、DSA、ECDSA(螺旋曲线加密算法)\n\t* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。\n\t* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。\n\n\t\t[《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)\t\n\n\n## 服务器安全\n* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)\n\n## 数据安全\n\n### 数据备份\n\nTODO\n\n## 网络隔离\n\n### 内外网分离\n\nTODO\n\n### 登录跳板机\n在内外环境中通过跳板机登录到线上主机。\n* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)\n\n## 授权、认证\n### RBAC \n* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)\n* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)\n\n### OAuth2.0\n* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)\n\n### 双因素认证（2FA）\n\n2FA - Two-factor authentication，用于加强登录验证\n\n常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）\n\n* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)\n\n### 单点登录(SSO)\n\n* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)\n\n* [CAS单点登录框架](https://github.com/apereo/cas)\n\n# 常用开源框架\n\n## 开源协议\n\n* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)\n\n* [如何选择一个开源软件协议](http://choosealicense.online/)\n\n## 日志框架\n\n### Log4j、Log4j2\n* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)\n* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)\n* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)\n\t* Log4J 异步日志性能优异。 \n\n### Logback\n* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)\n\n## ORM\n\n* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)\n\t* 主要目的是为了提高开发效率。 \n\n**MyBatis：**\n\n* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)\n\t* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效\n\t* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  \n\n* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)\n\n## 网络框架\n\nTODO\n\n## Web 框架\n\n### Spring 家族\n**Spring**\n* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)\n\n**Spring Boot**\n* [官方网站](http://projects.spring.io/spring-boot/)\n* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n**Spring Cloud**\n\n* [Spring Boot 中文索引站](http://springboot.fun/)\n* [Spring Cloud 中文文档](https://springcloud.cc/)\n* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n## 工具框架\n\n* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)\n* [《Google guava 中文教程》](http://ifeve.com/google-guava/)\n\n\n# 分布式设计\n\n## 扩展性设计\n\n* [《架构师不可不知的十大可扩展架构》](https://blog.csdn.net/hemin1003/article/details/53633926)\n\t* 总结下来，通用的套路就是分布、缓存及异步处理。 \n\n* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)\n\t* 水平切分+垂直切分\n\t* 利用中间件进行分片如，MySQL Proxy。\n\t* 利用分片策略进行切分，如按照ID取模。 \n* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)\n\t* 分布式服务+消息队列。\n\n* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)\n\n## 稳定性 & 高可用\n\n* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)\n\t* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。\n\t* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。\n\t* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。\n\t* 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。\n\t* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。\n\t* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。\n\t* 自动化测试：通过完善的测试，减少发布引起的故障。\n\t* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。\n\n\n* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)\n\t* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。\t \n\n### 硬件负载均衡\n\n* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)\n\t* 主要是和F5对比。\n\n* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)\n\n### 软件负载均衡\n\n* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)\n\t轮寻、权重、负载、最少连接、QoS\n* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)\n\t* 配置简单，更新速度慢。 \n* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)\n\t* 简单轻量、学习成本低；主要适用于web应用。\n\n*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)\n\t* 配置比较负载、只支持到4层，性能较高。\n\n* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)\n\t* 支持到七层（比如HTTP）、功能比较全面，性能也不错。\n\n* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)\n\t* 主要是用户读请求的负载均衡。\n\n* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)\n\n### 限流\n\n* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)\n\t* 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。\n\t* 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。\n\t* 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。\n\t* Nginx 限流：通过 `limit_req` 等模块限制并发连接数。\n\n### 应用层容灾\n\n* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)\n\t* 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 \n\t* 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。\n\t* Hystrix设计原则：\n\t\t* 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。\n\t\t* 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。\n\t\t* 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 \n\n* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)\n* [《缓存击穿、失效以及热点key问题》](https://blog.csdn.net/zeb_perfect/article/details/54135506) \n\t* 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；\n\t* 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；\n\n### 跨机房容灾\n\n* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)\n\t* 通过自研中间件进行数据同步。 \n\n* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)\n\t* 注意延迟问题，多次跨机房调用会将延时放大数倍。\n\t* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。\n\t* 不能依赖于程序端数据双写，要有自动同步方案。 \n\t* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。\n\t* 核心业务和次要业务分而治之，甚至只考虑核心业务。\n\t* 异地多活监控部署、测试也要跟上。\n\t* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。\n\t* 控制跨机房消息体大小，越小越好。\n\t* 考虑使用docker容器虚拟化技术，提高动态调度能力。\n\n* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)\n\n\n### 容灾演练流程\n\n* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)\n\t* 常见故障画像\n\t* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。\n\n### 平滑启动\n\n* 平滑重启应用思路\n1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用\n\n* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)\n推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。\n* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)\nJava、Srping、Dubbo 优雅关闭方式。\n\n## 数据库扩展\n\n### 读写分离模式\n\n* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)\n* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)\n* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)\n\n* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)\n\t* DRDB 进行磁盘复制，避免单点问题。\n\n* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)\n\n### 分片模式\n* [《分库分表需要考虑的问题及方案》](https://www.jianshu.com/p/32b3e91aa22c)\n\t* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。\n\t* 问题：事务、Join、迁移、扩容、ID、分页等。\n\t* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。\n\t* 分库策略：数值范围；取模；日期等。\n\t* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 \n\n* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)\n\t* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。\n\t* 分表：物理上创建不同的表、客户端需要管理分表路由。\n\n## 服务治理\n###  服务注册与发现\n\n* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)\n  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。\n  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。\n* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)\n  * CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）\n  * 作者认为目前 Consul 对 Spring cloud 的支持比较好。\n\n* [《基于Zookeeper的服务注册与发现》](http://mobile.51cto.com/news-502394.htm)\n\t* 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 \n\n### 服务路由控制\n* [《分布式服务框架学习笔记4 服务路由》](https://blog.csdn.net/xundh/article/details/59492750)\n\t* 原则：透明化路由\n\t* 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接\n\t* 本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。\n\t* 配置方式：统一注册表；本地配置；动态下发。\n\n## 分布式一致\n\n### CAP 与 BASE 理论\n\n* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)\n\t* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)\n\t* CAP：一致性、可用性、分区容错性(网络故障引起)\n\t* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）\n\t* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n### 分布式锁\n\n* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)\n\t* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；\n\t* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。\n\t* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。\n* [《基于Zookeeper的分布式锁》](https://www.tuicool.com/articles/VZJr6fY)\n\t* 清楚的原理描述 + Java 代码示例。 \n\n* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)\n\t* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。\n\n* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)\n\t* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。\n\n### 分布式一致性算法\n\n#### PAXOS\n* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)\n* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)\n* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)\n\n#### Zab\n* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)\n\n#### Raft\n* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)\n\t* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）\n\t* 通过随机等待的方式发出投票，得票多的获胜。\n\n#### Gossip\n* [《Gossip算法》](http://blog.51cto.com/tianya23/530743)\n\n#### 两阶段提交、多阶段提交\n\n* [《关于分布式事务、两阶段提交协议、三阶提交协议》](http://blog.jobbole.com/95632/)\n\n### 幂等\n\n* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)\n\t* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。\n\t* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 \n\n### 分布式一致方案\n* [《分布式系统事务一致性解决方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)\n* [《保证分布式系统数据一致性的6种方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)\n\n### 分布式 Leader 节点选举\n* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)\n\n### TCC(Try/Confirm/Cancel) 柔性事务\n* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)\n\t* 基于BASE理论：基本可用、柔性状态、最终一致。\n\t* 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。\n\n## 分布式文件系统\n\n* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？\n* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？\n  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。\n  * FastDFS：轻量级、适合小文件。\n\n## 唯一ID 生成\n\n### 全局唯一ID\n* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)\n\t* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)\n\t* Flicker 方案：MySQL自增ID + \"REPLACE INTO XXX:SELECT LAST_INSERT_ID();\" \n\t* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。\n\t* MongoDB 方案：利用 ObjectId。缺点：不能自增。\n\n* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)\n\t* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。\n\t* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。\n\t* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。\n\n## 一致性Hash算法\n\n* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)\n\n# 设计思想 & 开发模式\n\n## DDD(Domain-driven Design - 领域驱动设计)\n\n* [《浅谈我对DDD领域驱动设计的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)\n  * 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。\n  * 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。\n  * 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。\n  \n* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)\n  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。\n  * 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。\n  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；\n  * 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。\n  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。\n  * 使用的模式：\n    * 关联尽量少，尽量单项，尽量降低整体复杂度。\n    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。\n    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。\n    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。\n    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；\n    * 工厂（Factory）：类似于设计模式中的工厂模式。\n    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。\n\n* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)\n\t* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。\n\n* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](http://www.hollischuang.com/archives/553)\n\n\n### 命令查询职责分离(CQRS)\n\nCQRS — Command Query Responsibility Seperation\n\n* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)\n\t* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。\n\n* [《DDD CQRS架构和传统架构的优缺点比较》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)\n\t* 最终一致的设计理念；依赖于高可用消息中间件。\n\t\n* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)\n\t* 一个实现 CQRS 的抽象案例。\n\n* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)\n\t* CQRS 模式分析 + 12306 抢票案例\n\n### 贫血，充血模型\n\n* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)\n\t* 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。\n\t* 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；\n\t* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。\n\t* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。\n\t* 作者主张使用贫血模式。\n\t\n## Actor 模式\n\nTODO\n\n## 响应式编程\n\n### Reactor\nTODO\n### RxJava\nTODO\n### Vert.x\nTODO\n\n## DODAF2.0\n\n* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)\n* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)\n\n## Serverless\n\n无需过多关系服务器的服务架构理念。\n\n* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)\n\t* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。\n\t* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。\n\t* Serverless 不代表某个具体的框架。\n\n* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)\n\t* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）\n\n\n\n## Service Mesh\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n\n# 项目管理\n\n## 架构评审\n* [《架构设计之如何评审架构设计说明书》](http://developer.51cto.com/art/201506/478486.htm)\n* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)\n\n## 重构\n\n* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)\n\n## 代码规范\n\n* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)\n\n## 代码 Review\n\n\n制度还是制度!\n另外，每个公司需要根据自己的需求和目标制定自己的 check list\n\n* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)\n\t* 代码 review 做的好，在于制度建设。\n\n* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)\n\n* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)\n* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)\n\n* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)\n\n## RUP\n* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)\n\n## 看板管理\n* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)\n\n## SCRUM\n\nSCRUM - 争球\n\n* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。\n* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；\n* 五个价值观：专注、勇气、公开、承诺、尊重。\n\n\n* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)\n\n* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)\n\n## 敏捷开发\n\nTODO\n\n## 极限编程（XP）\n\nXP - eXtreme Programming\n\n* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)\n\t* 是一种指导开发人员的方法论。\n\t* 4大价值：\n\t\t* 沟通：鼓励口头沟通，提高效率。\n\t\t* 简单：够用就好。\n\t\t* 反馈：及时反馈、通知相关人。\n\t\t* 勇气：提倡拥抱变化，敢于重构。\n\t\t\n\t* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。\n\t* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。\n\n## 结对编程\n\n边写码，边review。能够增强代码质量、减少bug。\n\n* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)\n\n## PDCA 循环质量管理\n\nP——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进\n\n* [《PDCA》](http://www.baike.com/wiki/PDCA)\n\n## FMEA管理模式\n\nTODO\n\n# 通用业务术语\n\nTODO\n\n# 技术趋势\n\nTODO\n\n# 政策、法规\n\nTODO\n## 法律\n\n### 严格遵守刑法253法条\n\n我国刑法第253条之一规定：\n\n> * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。\n> * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 \n> * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。\n\n最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”\n\n* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)\n\n\n# 架构师素质\n\n* [《架构师画像》](http://hellojava.info/?p=430)\n\t* 业务理解和抽象能力\n\t* NB的代码能力\n\t* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； \n\t* 全局：是否考虑到了对上下游的系统的影响。\n\t* 权衡：权衡投入产出比；优先级和节奏控制；\n\n* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)\n\t* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。\n\t* 基础设施、配置、测试、开发、运维综合考虑。\n\t* 考虑人、团队、和组织的影响。 \n\n* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) \n\n* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)\n\t* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。\n\t* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 \n\n* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)\n\t* 第一层的架构师看到的只是产品本身\n\t* 第二层的架构师不仅看到自己的产品，还看到了整体的方案\n\t* 第三层的架构师看到的是商业价值 \n\n# 团队管理\n\nTODO\n\n## 招聘\n\n# 资讯\n\n## 行业资讯\n\n* [36kr](http://36kr.com/)\n* [Techweb](http://www.techweb.com.cn/)\n\n## 公众号列表\n\nTODO\n\n## 博客\n\n### 团队博客\n* [阿里中间件博客](http://jm.taobao.org/)\n* [美团点评技术团队博客](https://tech.meituan.com)\n\n### 个人博客\n\n* [阮一峰的网络日志](http://www.ruanyifeng.com/)\n* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)\n* [hellojava-阿里毕玄](http://hellojava.info/)\n* [Cm's Blog](http://cmsblogs.com/)\n* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)\n\n## 综合门户、社区\n\n**国内：**\n\n* [CSDN](http://csdn.net)\n\t 老牌技术社区、不必解释。\n* [51cto.com](http://www.51cto.com/)\n* [ITeye](http://www.iteye.com/)\n\t* 偏 Java 方向 \n* [博客园](https://www.cnblogs.com)\n* [ChinaUnix](http://www.tom.net/)\n\t* 偏 Linux 方向 \n* [开源中国社区](https://www.oschina.net/)\n* [深度开源](http://www.open-open.com/)\n* [伯乐在线](http://www.jobbole.com/)\n\t* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。\n\n* [ITPUB](http://www.itpub.net/)\n* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)\n* [阿里云— 云栖社区](https://yq.aliyun.com/)\n* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)\n* [开发者头条](https://toutiao.io/)\n* [LinkedKeeper](http://www.linkedkeeper.com)\n\n**国外：**\n\n* [DZone](https://dzone.com)\n* [Reddit](https://www.reddit.com)\n\n## 问答、讨论类社区\n\n* [segmentfault](https://segmentfault.com)\n\t* 问答+专栏 \n* [知乎](https://www.zhihu.com/)\n* [stackoverflow](https://stackoverflow.com/)\n\n## 行业数据分析\n\n* [艾瑞网](http://report.iresearch.cn/)\n* [QUEST MOBILE](https://www.questmobile.com.cn)\n\n* [国家数据](http://data.stats.gov.cn/)\n\n* [TalkingData](http://www.talkingdata.com/)\n\n## 专项网站\n\n* 测试:\n\t* [领测国际](http://www.ltesting.net/) \n\t* [测试窝](https://www.testwo.com/)\n\t* [TesterHome](https://testerhome.com)\n\n* 运维:\n  \t* [运维派](http://www.yunweipai.com/) \n  \t* [Abcdocker](https://www.abcdocker.com/)\n  \n* Java:\n\t* [ImportNew](http://www.importnew.com/)\n\t\t* 专注于 Java 技术分享\n\t* [HowToDoInJava](https://howtodoinjava.com/)\n\t\t* 英文博客\n\t\n* 安全\n\t* [红黑联盟](https://www.2cto.com/) \n\t* [FreeBuf](http://www.freebuf.com/)\n\n* 大数据\n\t* [中国大数据](http://www.thebigdata.cn/) \n\n* 其他专题网站：\n\t* [DockerInfo](http://www.dockerinfo.net/)\n\t\t* 专注于 Docker 应用及咨询、教程的网站。\n\t* [Linux公社](https://www.linuxidc.com/)\n\t\t* Linux 主题社区\n\n## 其他类\n\n* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)\n\n## 推荐参考书\n\n\n### 在线电子书\n\n* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)\n\n\n* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)\n* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)\n\n* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)\n\n* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)\n\n* [《架构师之路》](https://www.w3cschool.cn/architectroad/)\n\n### 纸质书\n\n#### 开发方面\n\n* 《阿里巴巴Java开发手册》[京东](https://union-click.jd.com/jdc?d=bVKwZQ) [淘宝](https://s.taobao.com/search?q=阿里巴巴Java开发手册)\n\n#### 架构方面\n* 《软件架构师的12项修炼：技术技能篇》[京东](https://union-click.jd.com/jdc?d=gXvRd8) [淘宝](https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇)\n* 《架构之美》[京东](https://union-click.jd.com/jdc?d=xJit5I) [淘宝](https://s.taobao.com/search?q=架构之美)\n* 《分布式服务架构》[京东](https://union-click.jd.com/jdc?d=JS5Od9) [淘宝](https://s.taobao.com/search?q=分布式服务架构)\n* 《聊聊架构》 [京东](https://union-click.jd.com/jdc?d=FHooH4) [淘宝](https://s.taobao.com/search?q=聊聊架构)\n* 《云原生应用架构实践》[京东](https://union-click.jd.com/jdc?d=orkJSj) [淘宝](https://s.taobao.com/search?q=云原生应用架构实践)\n* 《亿级流量网站架构核心技术》[京东](https://union-click.jd.com/jdc?d=RnOSP5) [淘宝](https://s.taobao.com/search?q=亿级流量网站架构核心技术)\n* 《淘宝技术这十年》[京东](https://union-click.jd.com/jdc?d=LwrDfD) [淘宝](https://s.taobao.com/search?q=淘宝技术这十年)\n* 《企业IT架构转型之道-中台战略思想与架构实战》 [京东](https://union-click.jd.com/jdc?d=89pAEm) [淘宝](https://s.taobao.com/search?q=企业IT架构转型之道)\n\n* 《高可用架构（第1卷）》[京东](https://item.jd.com/12195481.html) [淘宝](https://s.taobao.com/search?q=高可用架构)\n\n#### 技术管理方面\n* 《CTO说》[京东](https://union-click.jd.com/jdc?d=zhTZyr) [淘宝](https://s.taobao.com/search?q=CTO说)\n* 《技术管理之巅》[京东](https://union-click.jd.com/jdc?d=LgRBUW) [淘宝](https://s.taobao.com/search?q=技术管理之巅)\n* 《网易一千零一夜：互联网产品项目管理实战》[京东](https://union-click.jd.com/jdc?d=jcRz2r) [淘宝](https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战)\n\n#### 基础理论\n* 《数学之美》[京东](https://union-click.jd.com/jdc?d=ghIES2) [淘宝](https://s.taobao.com/search?q=数学之美)\n* 《编程珠玑》[京东](https://union-click.jd.com/jdc?d=YmhdEu) [淘宝](https://s.taobao.com/search?q=编程珠玑)\n\n#### 工具方面\nTODO\n\n#### 大数据方面\n\n# 技术资源\n\n## 开源资源\n* [github](https://github.com)\n\n* [Apache 软件基金会](https://www.apache.org/index.html)\n\n## 手册、文档、教程\n\n**国内：**\n* [W3Cschool](http://w3cschool.cn) \n* [Runoob.com](http://www.runoob.com/)\n\t* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。\n\n* [Love2.io](https://love2.io/)\n\t* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。\n* [gitbook.cn](http://gitbook.cn/)\n\t* 付费电子书。 \n* [ApacheCN](http://www.apachecn.org/)\n\t* AI、大数据方面系列中文文档。\n\n**国外：**\n\n* [Quick Code](http://www.quickcode.co/)\n\t* 免费在线技术教程。\n* [gitbook.com](http://gitbook.com)\n\t* 有部分中文电子书。\n* [Cheatography](https://www.cheatography.com/)\n\t* Cheat Sheets 大全，单页文档网站。\n* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)\n\t* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。\n\n\n## 在线课堂\n\n* [学徒无忧](http://www.xuetuwuyou.com/)\n* [极客时间](https://time.geekbang.org/)\n* [segmentfault](https://segmentfault.com/lives)\n* [斯达克学院](https://new.stuq.org/course/explore)\n* [牛客网](http://nowcoder.com)\n* [极客学院](https://www.jikexueyuan.com/)\n* [51CTO学院](http://edu.51cto.com/)\n\n## 会议、活动\n\n* [QCon](http://www.infoq.com/cn/qcon/)\n* [ArchSummit](https://archsummit.com)\n* [GITC全球互联网技术大会](http://www.thegitc.com/)\n\n**活动发布平台:** \n* [活动行](http://www.huodongxing.com/)\n\n## 常用APP\n\n* [极客时间](https://time.geekbang.org)\n* [得到](https://www.igetget.com)\n\n## 找工作\n* [Boss直聘](https://www.zhipin.com)\n* [拉勾网](https://www.lagou.com)\n* [猎聘](https://www.liepin.com)\n* [100Offer](https://cn.100offer.com/)\n\n## 工具\n\n* [极客搜索](https://s.geekbang.org/)\n\t* 技术文章搜索引擎。\n\n## 代码托管\n\n* [Coding](https://coding.net)\n* [码云](https://gitee.com/)\n\n## 文件服务\n* 七牛\n* 又拍云\n\n## 综合云服务商\n* 阿里云\n* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c)\n* 百度云\n* 新浪云\n* 金山云\n* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)\n* [谷歌云](https://cloud.google.com/?hl=zh-cn)\n* [微软云](https://azure.microsoft.com/zh-cn/)\n\n### VPS\n* [Linode](http://linode.com)\n\n","source":"_posts/architect-awesome.md","raw":"---\ntitle: 后端架构师技术图谱\ndate: 2018-06-19 08:51:42\ncategories: 架构\ntags: 后端架构师技术图谱\n---\n\n列出了后端架构师要掌握的基本知识。少壮不努力，老大徒伤悲……\n\n本文拷贝自https://github.com/xingshaocheng/architect-awesome\n\n\n<h1>《后端架构师技术图谱》</h1>\n\n**更新于20180513**\n* [数据结构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据结构)\n\t* [队列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#队列)\n\t* [集合](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合)\n\t* [链表、数组](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#链表数组)\n\t* [字典、关联数组](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典关联数组)\n\t* [栈](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#栈)\n\t* [树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#树)\n\t\t* [二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉树)\n\t\t* [完全二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#完全二叉树)\n\t\t* [平衡二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平衡二叉树)\n\t\t* [二叉查找树（BST）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉查找树bst)\n\t\t* [红黑树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#红黑树)\n\t\t* [B-，B+，B*树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#b-bb树)\n\t\t* [LSM 树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lsm-树)\n\t* [BitSet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#bitset)\n* [常用算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用算法)\n\t* [排序、查找算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#排序查找算法)\n\t\t* [选择排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#选择排序)\n\t\t* [冒泡排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#冒泡排序)\n\t\t* [插入排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#插入排序)\n\t\t* [快速排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快速排序)\n\t\t* [归并排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#归并排序)\n\t\t* [希尔排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#希尔排序)\n\t\t* [堆排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#堆排序)\n\t\t* [计数排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计数排序)\n\t\t* [桶排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#桶排序)\n\t\t* [基数排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基数排序)\n\t\t* [二分查找](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二分查找)\n\t\t* [Java 中的排序工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-中的排序工具)\n\t* [布隆过滤器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#布隆过滤器)\n\t* [字符串比较](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字符串比较)\n\t\t* [KMP 算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kmp-算法)\n\t* [深度优先、广度优先](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#深度优先广度优先)\n\t* [贪心算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贪心算法)\n\t* [回溯算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回溯算法)\n\t* [剪枝算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#剪枝算法)\n\t* [动态规划](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#动态规划)\n\t* [朴素贝叶斯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#朴素贝叶斯)\n\t* [推荐算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐算法)\n\t* [最小生成树算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最小生成树算法)\n\t* [最短路径算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最短路径算法)\n* [并发](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#并发)\n\t* [多线程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多线程)\n\t* [线程安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程安全)\n\t* [一致性、事务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性事务)\n\t\t* [事务 ACID 特性](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务-acid-特性)\n\t\t* [事务的隔离级别](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务的隔离级别)\n\t\t* [MVCC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvcc)\n\t* [锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#锁)\n\t\t* [Java中的锁和同步类](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java中的锁和同步类)\n\t\t* [公平锁 &amp; 非公平锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公平锁--非公平锁)\n\t\t* [悲观锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#悲观锁)\n\t\t* [乐观锁 &amp; CAS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#乐观锁--cas)\n\t\t* [ABA 问题](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aba-问题)\n\t\t* [CopyOnWrite容器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#copyonwrite容器)\n\t\t* [RingBuffer](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ringbuffer)\n\t\t* [可重入锁 &amp; 不可重入锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#可重入锁--不可重入锁)\n\t\t* [互斥锁 &amp; 共享锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#互斥锁--共享锁)\n\t\t* [死锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#死锁)\n* [操作系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#操作系统)\n\t* [计算机原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计算机原理)\n\t* [CPU](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cpu)\n\t\t* [多级缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多级缓存)\n\t* [进程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#进程)\n\t* [线程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程)\n\t* [协程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协程)\n\t* [Linux](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#linux)\n* [设计模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式)\n\t* [设计模式的六大原则](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式的六大原则)\n\t* [23种常见设计模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#23种常见设计模式)\n\t* [应用场景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景)\n\t* [单例模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单例模式)\n\t* [责任链模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#责任链模式)\n\t* [MVC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvc)\n\t* [IOC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ioc)\n\t* [AOP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aop)\n\t* [UML](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#uml)\n\t* [微服务思想](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#微服务思想)\n\t\t* [康威定律](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#康威定律)\n* [运维 &amp; 统计 &amp; 技术支持](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#运维--统计--技术支持)\n\t* [常规监控](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常规监控)\n\t* [APM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apm)\n\t* [统计分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#统计分析)\n\t* [持续集成(CI/CD)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#持续集成cicd)\n\t\t* [Jenkins](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jenkins)\n\t\t* [环境分离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#环境分离)\n\t* [自动化运维](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自动化运维)\n\t\t* [Ansible](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ansible)\n\t\t* [puppet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#puppet)\n\t\t* [chef](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#chef)\n\t* [测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#测试)\n\t\t* [TDD 理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tdd-理论)\n\t\t* [单元测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单元测试)\n\t\t* [压力测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#压力测试)\n\t\t* [全链路压测](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全链路压测)\n\t\t* [A/B 、灰度、蓝绿测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ab-灰度蓝绿测试)\n\t* [虚拟化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#虚拟化)\n\t\t* [KVM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kvm)\n\t\t* [Xen](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xen)\n\t\t* [OpenVZ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openvz)\n\t* [容器技术](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容器技术)\n\t\t* [Docker](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#docker)\n\t* [云技术](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#云技术)\n\t\t* [OpenStack](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openstack)\n\t* [DevOps](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#devops)\n\t* [文档管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文档管理)\n* [中间件](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#中间件)\n\t* [Web Server](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-server)\n\t\t* [Nginx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx)\n\t\t* [OpenResty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openresty)\n\t\t* [Apache Httpd](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apache-httpd)\n\t\t* [Tomcat](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tomcat)\n\t\t\t* [架构原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构原理)\n\t\t\t* [调优方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#调优方案)\n\t\t* [Jetty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jetty)\n\t* [缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#缓存)\n\t\t* [本地缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#本地缓存)\n\t* [客户端缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#客户端缓存)\n\t* [服务端缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务端缓存)\n\t\t* [Web缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web缓存)\n\t\t* [Memcached](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#memcached)\n\t\t* [Redis](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis)\n\t\t\t* [架构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构)\n\t\t\t* [回收策略](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回收策略)\n\t\t* [Tair](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tair)\n\t* [消息队列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息队列)\n\t\t* [消息总线](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息总线)\n\t\t* [消息的顺序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息的顺序)\n\t\t* [RabbitMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rabbitmq)\n\t\t* [RocketMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rocketmq)\n\t\t* [ActiveMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#activemq)\n\t\t* [Kafka](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka)\n\t\t* [Redis 消息推送](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis-消息推送)\n\t\t* [ZeroMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zeromq)\n\t* [定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#定时调度)\n\t\t* [单机定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单机定时调度)\n\t\t* [分布式定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式定时调度)\n\t* [RPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rpc)\n\t\t* [Dubbo](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dubbo)\n\t\t* [Thrift](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#thrift)\n\t\t* [gRPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#grpc)\n\t* [数据库中间件](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库中间件)\n\t\t* [Sharding Jdbc](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sharding-jdbc)\n\t* [日志系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志系统)\n\t\t* [日志搜集](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志搜集)\n\t* [配置中心](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#配置中心)\n\t* [API 网关](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#api-网关)\n* [网络](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络)\n\t* [协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协议)\n\t\t* [OSI 七层协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#osi-七层协议)\n\t\t* [TCP/IP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcpip)\n\t\t* [HTTP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http)\n\t\t* [HTTP2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http20)\n\t\t* [HTTPS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#https)\n\t* [网络模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络模型)\n\t\t* [Epoll](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#epoll)\n\t\t* [Java NIO](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-nio)\n\t\t* [kqueue](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kqueue)\n\t* [连接和短连接](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接和短连接)\n\t* [框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#框架)\n\t* [零拷贝（Zero-copy）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#零拷贝zero-copy)\n\t* [序列化(二进制协议)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化二进制协议)\n\t\t* [Hessian](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hessian)\n\t\t* [Protobuf](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#protobuf)\n* [数据库](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库)\n\t* [基础理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论)\n\t\t* [数据库设计的三大范式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库设计的三大范式)\n\t* [MySQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mysql)\n\t\t* [原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#原理)\n\t\t* [InnoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#innodb)\n\t\t* [优化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#优化)\n\t\t* [索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#索引)\n\t\t\t* [聚集索引, 非聚集索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#聚集索引-非聚集索引)\n\t\t\t* [复合索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#复合索引)\n\t\t\t* [自适应哈希索引(AHI)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自适应哈希索引ahi)\n\t\t* [explain](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#explain)\n\t* [NoSQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nosql)\n\t\t* [MongoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mongodb)\n\t\t* [Hbase](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hbase)\n* [搜索引擎](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎)\n\t* [搜索引擎原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎原理)\n\t* [Lucene](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lucene)\n\t* [Elasticsearch](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#elasticsearch)\n\t* [Solr](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#solr)\n\t* [sphinx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sphinx)\n* [性能](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能)\n\t* [性能优化方法论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能优化方法论)\n\t* [容量评估](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容量评估)\n\t* [CDN 网络](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cdn-网络)\n\t* [连接池](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接池)\n\t* [性能调优](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能调优)\n* [大数据](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据)\n\t* [流式计算](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#流式计算)\n\t\t* [Storm](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#storm)\n\t\t* [Flink](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#flink)\n\t\t* [Kafka Stream](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka-stream)\n\t\t* [应用场景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景-1)\n\t* [Hadoop](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hadoop)\n\t\t* [HDFS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hdfs)\n\t\t* [MapReduce](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mapreduce)\n\t\t* [Yarn](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#yarn)\n\t* [Spark](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spark)\n* [安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#安全)\n\t* [web 安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-安全)\n\t\t* [XSS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xss)\n\t\t* [CSRF](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#csrf)\n\t\t* [SQL 注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sql-注入)\n\t\t* [Hash Dos](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hash-dos)\n\t\t* [脚本注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#脚本注入)\n\t\t* [漏洞扫描工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#漏洞扫描工具)\n\t\t* [验证码](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#验证码)\n\t* [DDoS 防范](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddos-防范)\n\t* [用户隐私信息保护](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#用户隐私信息保护)\n\t* [序列化漏洞](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化漏洞)\n\t* [加密解密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#加密解密)\n\t\t* [对称加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#对称加密)\n\t\t* [哈希算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#哈希算法)\n\t\t* [非对称加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#非对称加密)\n\t* [服务器安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务器安全)\n\t* [数据安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据安全)\n\t\t* [数据备份](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据备份)\n\t* [网络隔离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络隔离)\n\t\t* [内外网分离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#内外网分离)\n\t\t* [登录跳板机](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#登录跳板机)\n\t* [授权、认证](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#授权认证)\n\t\t* [RBAC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rbac)\n\t\t* [OAuth2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#oauth20)\n\t\t* [双因素认证（2FA）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#双因素认证2fa)\n\t\t* [单点登录(SSO)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单点登录sso)\n* [常用开源框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用开源框架)\n\t* [开源协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源协议)\n\t* [日志框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志框架)\n\t\t* [Log4j、Log4j2](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#log4jlog4j2)\n\t\t* [Logback](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#logback)\n\t* [ORM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#orm)\n\t* [网络框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络框架)\n\t* [Web 框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-框架)\n\t\t* [Spring 家族](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spring-家族)\n\t* [工具框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具框架)\n* [分布式设计](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式设计)\n\t* [扩展性设计](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#扩展性设计)\n\t* [稳定性 &amp; 高可用](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#稳定性--高可用)\n\t\t* [硬件负载均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#硬件负载均衡)\n\t\t* [软件负载均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#软件负载均衡)\n\t\t* [限流](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#限流)\n\t\t* [应用层容灾](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用层容灾)\n\t\t* [跨机房容灾](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#跨机房容灾)\n\t\t* [容灾演练流程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容灾演练流程)\n\t\t* [平滑启动](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平滑启动)\n\t* [数据库扩展](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库扩展)\n\t\t* [读写分离模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#读写分离模式)\n\t\t* [分片模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分片模式)\n\t* [服务治理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务治理)\n\t\t* [服务注册与发现](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务注册与发现)\n\t\t* [服务路由控制](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务路由控制)\n\t* [分布式一致](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致)\n\t\t* [CAP 与 BASE 理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cap-与-base-理论)\n\t\t* [分布式锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式锁)\n\t\t* [分布式一致性算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致性算法)\n\t\t\t* [PAXOS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#paxos)\n\t\t\t* [Zab](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zab)\n\t\t\t* [Raft](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#raft)\n\t\t\t* [Gossip](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#gossip)\n\t\t\t* [两阶段提交、多阶段提交](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#两阶段提交多阶段提交)\n\t\t* [幂等](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#幂等)\n\t\t* [分布式一致方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致方案)\n\t\t* [分布式 Leader 节点选举](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式-leader-节点选举)\n\t\t* [TCC(Try/Confirm/Cancel) 柔性事务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcctryconfirmcancel-柔性事务)\n\t* [分布式文件系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式文件系统)\n\t* [唯一ID 生成](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#唯一id-生成)\n\t\t* [全局唯一ID](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全局唯一id)\n\t* [一致性Hash算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性hash算法)\n* [设计思想 &amp; 开发模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计思想--开发模式)\n\t* [DDD(Domain-driven Design - 领域驱动设计)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddddomain-driven-design---领域驱动设计)\n\t\t* [命令查询职责分离(CQRS)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#命令查询职责分离cqrs)\n\t\t* [贫血，充血模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贫血充血模型)\n\t* [Actor 模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#actor-模式)\n\t* [响应式编程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#响应式编程)\n\t\t* [Reactor](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#reactor)\n\t\t* [RxJava](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rxjava)\n\t\t* [Vert.x](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vertx)\n\t* [DODAF2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dodaf20)\n\t* [Serverless](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#serverless)\n\t* [Service Mesh](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#service-mesh)\n* [项目管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#项目管理)\n\t* [架构评审](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构评审)\n\t* [重构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#重构)\n\t* [代码规范](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码规范)\n\t* [代码 Review](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码-review)\n\t* [RUP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rup)\n\t* [看板管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#看板管理)\n\t* [SCRUM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#scrum)\n\t* [敏捷开发](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#敏捷开发)\n\t* [极限编程（XP）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#极限编程xp)\n\t* [结对编程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#结对编程)\n\t* [FMEA管理模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#fmea管理模式)\n* [通用业务术语](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#通用业务术语)\n* [技术趋势](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术趋势)\n* [政策、法规](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#政策法规)\n\t* [法律](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#法律)\n\t\t* [严格遵守刑法253法条](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#严格遵守刑法253法条)\n* [架构师素质](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构师素质)\n* [团队管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队管理)\n\t* [招聘](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#招聘)\n* [资讯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#资讯)\n\t* [行业资讯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业资讯)\n\t* [公众号列表](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公众号列表)\n\t* [博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#博客)\n\t\t* [团队博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队博客)\n\t\t* [个人博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#个人博客)\n\t* [综合门户、社区](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合门户社区)\n\t* [问答、讨论类社区](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#问答讨论类社区)\n\t* [行业数据分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业数据分析)\n\t* [专项网站](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#专项网站)\n\t* [其他类](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#其他类)\n\t* [推荐参考书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐参考书)\n\t\t* [在线电子书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线电子书)\n\t\t* [纸质书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#纸质书)\n\t\t\t* [开发方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开发方面)\n\t\t\t* [架构方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构方面)\n\t\t\t* [技术管理方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术管理方面)\n\t\t\t* [基础理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论-1)\n\t\t\t* [工具方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具方面)\n\t\t\t* [大数据方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据方面)\n* [技术资源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术资源)\n\t* [开源资源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源资源)\n\t* [手册、文档、教程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#手册文档教程)\n\t* [在线课堂](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线课堂)\n\t* [会议、活动](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#会议活动)\n\t* [常用APP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用app)\n\t* [找工作](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#找工作)\n\t* [工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具)\n\t* [代码托管](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码托管)\n\t* [文件服务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文件服务)\n\t* [综合云服务商](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合云服务商)\n\t\t* [VPS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vps)\n\t\n\n**（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）**\n\n# 数据结构\n\n## 队列\n* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)\n\t* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。\n\t* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。\n\n* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)\n\n## 集合\n* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)\n\n## 链表、数组\n* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)\n\n## 字典、关联数组\n* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)\n\n## 栈\n* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)\n* [《Java Stack 类》](http://www.runoob.com/java/java-stack-class.html)\n* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)\n\t* Stack 是线程安全的。\n\t* 内部使用数组保存数据，不够时翻倍。\n\n## 树\n\n### 二叉树\n\n每个节点最多有两个叶子节点。\n*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)\n\n### 完全二叉树\n* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)\n\t* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。\n\n### 平衡二叉树\n左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n* [《浅谈数据结构-平衡二叉树》](http://www.cnblogs.com/polly333/p/4798944.html)\n* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)\n\n### 二叉查找树（BST）\n二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。\n\n* [《浅谈算法和数据结构: 七 二叉查找树》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)\n\n\n### 红黑树\n* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)\n\t* 添加阶段后，左旋或者右旋从而再次达到平衡。 \n* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)\n\n### B-，B+，B*树\nMySQL是基于B+树聚集索引组织表\n\n* [《B-树，B+树，B\\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)\n* [《B-树，B+树与B\\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)\n\t* B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。\n### LSM 树\n\nLSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。\n\n* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)\n\t* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。\n\t* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n\t\n* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)\n\t* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。\n\t* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。\n\t* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。\n\n## BitSet\n\n经常用于大规模数据的排重检查。\n\n* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)\n* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)\n\n# 常用算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n## 排序、查找算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n### 选择排序\n* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)\n\t* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\n\n### 冒泡排序\n* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)\n\t* 相邻元素前后交换、把最大的排到最后。\n\t* 时间复杂度 O(n²) \n\n### 插入排序\n* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)\n\n### 快速排序\n* [《坐在马桶上看算法：快速排序》](http://developer.51cto.com/art/201403/430986.htm)\n\t* 一侧比另外一次都大或小。 \n### 归并排序\n* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)\n\t* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 \n\n### 希尔排序\nTODO\n\n### 堆排序\n* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)\n\t* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\n\n### 计数排序\n* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)\n\t* 和桶排序过程比较像，差别在于桶的数量。\n\n### 桶排序\n* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)\n* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)\n\t* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。\n\t* 每个桶单独进行排序，然后再遍历每个桶。\n\n### 基数排序\n\n按照个位、十位、百位、...依次来排。\n\n* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)\n* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)\n\n\n### 二分查找\n* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)\n\t* 要求待查找的序列有序。\n\t* 时间复杂度 O(logN)。\n\n* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)\n\t* while + 递归。\n### Java 中的排序工具\n* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)\n\t* Collections.sort算法调用的是合并排序。\n\t* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。\n\n## 布隆过滤器\n\n常用于大数据的排重，比如email，url 等。\n核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。\n优点：空间和时间效率都很高。\n缺点：随着存入的元素数量增加，误算率随之增加。\n\n* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)\n* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)\n* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)\n\t* 基于 Redis 的 Bitmap 数据结构。\n* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)\n\t* 使用Java中的 BitSet 类 和 加权和hash算法。\n\n## 字符串比较\n\n### KMP 算法\nKMP：Knuth-Morris-Pratt算法（简称KMP）\n核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。\n* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n## 深度优先、广度优先\n* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)\n\n## 贪心算法\n* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)\n* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)\n\n## 回溯算法\n* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)\n\n## 剪枝算法\n* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)\n\n## 动态规划\n* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)\n* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)\n\n## 朴素贝叶斯\n\n* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)\n\t* P(B|A)=P(A|B)P(B)/P(A)\n\n* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)\n* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)\n\n\n## 推荐算法\n* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)\n* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)\n\n## 最小生成树算法\n* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)\n\n## 最短路径算法\n\n* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)\n\n# 并发\n\n## Java 并发\n\n* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)\n* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)\n\n## 多线程\n\n* [《40个Java多线程问题总结》](http://www.importnew.com/18459.html)\n\n## 线程安全\n\n* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)\n\n## 一致性、事务\n\n### 事务 ACID 特性\n* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)\n\n### 事务的隔离级别\n\n* 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。\n* 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。\n* 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。\n* 序列化：所有事物串行处理（牺牲了效率）\n\n* [《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)\n* [数据库事务的四大特性及事务隔离级别](https://www.cnblogs.com/z-sm/p/7245981.html)\n\n* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)\n\t* 幻读的例子非常清楚。\n\t* 通过 SELECT ... FOR UPDATE 解决。\n\t\n* [《一篇文章带你读懂MySQL和InnoDB》](http://database.51cto.com/art/201804/570101.htm)\n\t* 图解脏读、不可重复读、幻读问题。\n\n\n### MVCC\n\n\n* [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)\n\t* innodb 中 MVCC 用在 Repeatable-Read 隔离级别。\n\t* MVCC 会产生幻读问题（更新时异常。）\n\n* [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)\n\n\t* 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间\n\t* 每次只操作比当前版本小（或等于）的 行。\n\t\n\n\n## 锁\n\n### Java中的锁和同步类\n\n* [《Java中的锁分类》](https://www.cnblogs.com/qifengshi/p/6831055.html)\n\t* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 \n\n* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)\n\n* [《Java中信号量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)\n\t* 有数量控制\n\t* 申请用 acquire，申请不要则阻塞；释放用 release。\n\n* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)\n\t* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。\t \n\n### 公平锁 & 非公平锁\n\n公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。\n\n* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)\n\t* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。\n\n### 悲观锁 \n\n悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。\n\n* [《【MySQL】悲观锁&乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)\n\t* 乐观锁的方式：版本号+重试方式\n\t* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。\n\n* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)\n\t* mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。\n\t* 锁相同数据的不同索引条件可能会引起死锁。\n\t\n* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)\n\n### 乐观锁 & CAS\n\n* [《乐观锁的一种实现方式——CAS》](http://www.importnew.com/20472.html)\n\t* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。\t \n\n### ABA 问题\n\n由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。\n\n* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)\n* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)\n\t* AtomicStampedReference 和 AtomicStampedReference。 \n\n### CopyOnWrite容器\n\n可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。\n\n* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)\n\t* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  \n\t* 不用加锁，通过最终一致实现一致性。\n\t\n* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)\n\n### RingBuffer \n* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)\n\n### 可重入锁 & 不可重入锁\n\n* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)\n\t* 通过简单代码举例说明可重入锁和不可重入锁。\n\t* 可重入锁指同一个线程可以再次获得之前已经获得的锁。\n\t* 可重入锁可以用户避免死锁。\n\t* Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock\n\n* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)\n\t* synchronized 使用方便，编译器来加锁，是非公平锁。\n\t* ReenTrantLock 使用灵活，锁的公平性可以定制。\n\t* 相同加锁场景下，推荐使用 synchronized。\n\n### 互斥锁 & 共享锁\n\n互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。\n共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。\n\n* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)\n\n### 死锁\n* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)\n\t* 互斥、持有、不可剥夺、环形等待。\n* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)\n\t* JConsole 可以识别死锁。\n\t\n* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)\n\t* jstack 可以显示死锁。\n\t\n# 操作系统\n\n## 计算机原理\n\n* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)\n\n## CPU\n\n### 多级缓存\n典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。\n\n* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)\n\n## 进程\n\nTODO\n\n## 线程\n\n* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)\n\n## 协程\n\n* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)\n\t* 线程的调度是由操作系统负责，协程调度是程序自行负责\n\t* 与线程相比，协程减少了无谓的操作系统切换.\n\t* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.\n\t\n## Linux\n\n* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)\n\n# 设计模式\n\n## 设计模式的六大原则\n* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)\n\t* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。\n\t* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。\n\t* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。\n\t* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。\n\t* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。\n\t* 合成复用原则：尽量使用合成/聚合,而不是使用继承。\n\n## 23种常见设计模式\n* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)\n\n## 应用场景\n* [《细数JDK里的设计模式》](http://blog.jobbole.com/62314/)\n\t* 结构型模式：\n\t\t* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。\n\t\t* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；\n\t\t* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。\n\t\t* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。\n\t\t* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。\n\t\t* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy\n\t\t\n\t* 创建模式:\n\t\t* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。\n\t\t* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。\n\t\t* 工厂方法：就是 **一个返*** 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。\n\t\t* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。\n\t\t* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。\n\t* 行为模式：\n\t\t* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。\n\t\t* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。\n\t\t* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。\n\t\t* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。\n\t\t* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。\n\t\t* 空对象模式：如 java.util.Collections#emptyList()。\n\t\t* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。\n\t\t* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。\n\n* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)\n* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)\n\n## 单例模式\n* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)\n* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)\n\t* 使用枚举类型。\n\n## 责任链模式\nTODO\n\n## MVC\n* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)\n\t* 模型(model)－视图(view)－控制器(controller) \n\n## IOC\n* [《理解 IOC》](https://www.zhihu.com/question/23277575)\n* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)\n\t* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。\n\t* 作用：用于模块解耦。\n\t* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。\n\n## AOP\n\n* [《轻松理解AOP(面向切面编程)》](https://my.oschina.net/yanquan345/blog/203415)\n* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)\n* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)\n\t* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。\n* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)\n\t* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 \n\n\n## UML\n\n* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)\n\n## 微服务思想\n* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)\n* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)\n\n### 康威定律\n* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)\n\t* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。\n\t* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。\n\t* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。\n\t* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。\n\n* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)\n\n# 运维 & 统计 & 技术支持 \n\n## 常规监控\n\n* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)\n\t* 监控的方式：主动、被动、旁路(比如舆情监控)\n\t* 监控类型： 基础监控、服务端监控、客户端监控、\n\t监控、用户端监控\n\t* 监控的目标：全、块、准\n\t* 核心指标：请求量、成功率、耗时\n\n* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)\n\t* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。\n\n* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)\n\n**命令行监控工具**\n\n* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)\n\t* top、sar、tsar、nload\n\n* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)\n\n* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)\n\n## APM\n\nAPM —  Application Performance Management\n\n* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)\n\n* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)\n\n* 主要开源软件，按字母排序\n  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)\n  * [CAT](https://github.com/dianping/cat)\n  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)\n  * [Pinpoint](https://github.com/naver/pinpoint)\n  * [Zipkin](https://github.com/openzipkin/zipkin)\n\n* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)\n\t* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。\n\t\n\n\n## 统计分析\n\n* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)\n\t* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度\n\n* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)\n\t* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。\n\n* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt-mobile-analytics-practice.html)\n\t* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 \n\n\n## 持续集成(CI/CD)\n\n* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n* [《8个流行的持续集成工具》](https://www.testwo.com/article/1170)\n\n### Jenkins\n\n* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)\n\n### 环境分离\n\n开发、测试、生成环境分离。\n\n* [《开发环境、生产环境、测试环境的基本理解和区》](https://my.oschina.net/sancuo/blog/214904)\n\n## 自动化运维\n\n### Ansible\n* [《Ansible中文权威指南》](http://www.ansible.com.cn/)\n* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)\n\n### puppet\n* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)\n\n### chef\n* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)\n\n## 测试\n\n### TDD 理论\n\n* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)\n\t* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.\n\t* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； \n\n### 单元测试\n\n* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)\n* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)\n\t* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 \n* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)\n\t* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 \n\n### 压力测试\n\n* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)\n* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)\n* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)\n* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)\n* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)\n\n\n### 全链路压测\n* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)\n* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)\n* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)\n* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)\n\n\n### A/B 、灰度、蓝绿测试\n\n* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)\n* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)\n\n* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)\n\n## 虚拟化\n\n* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)\n\n### KVM\n* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)\n* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)\n\n### Xen\n* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)\n\n### OpenVZ\n* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)\n\n## 容器技术\n\n### Docker\n* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)\n* [《Docker 核心技术与实现原理》](https://draveness.me/docker)\n* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)\n\n## 云技术\n\n### OpenStack\n* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)\n\n## DevOps\n* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)\n* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)\n\n## 文档管理\n\n* [Confluence-收费文档管理系统](http://www.confluence.cn/)\n* GitLab?\n* Wiki\n\n# 中间件\n\n## Web Server\n\n### Nginx\n* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)\n\t* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。\n\t* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  \n\n* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)\n\t* nginx只适合静态和反向代理，不适合处理动态请求。\n\n### OpenResty\n* [官方网站](http://openresty.org/cn/)\n* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)\n\t* 通过 Lua 模块可以在Nginx上进行开发。 \n\n### Apache Httpd\n* [官方网站](http://httpd.apache.org/)\n\n### Tomcat\n\n#### 架构原理\n* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)\n* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)\n* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)\n\n* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)\n\n* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)\n\t* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。\n\t* Jboss 实现全部了JEE特性，软件开源免费、文档收费。\n\n#### 调优方案\n\n* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)\n\t* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； \n\n* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)\n* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)\n\t* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。\n\t* 并发高时，AJP协议优于HTTP协议。\n\n### Jetty\n* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)\n* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)\n\t* 架构比较:Jetty的架构比Tomcat的更为简单。\n\t* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。\n\t* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 \n\n\n\n## 缓存\n\n* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)\n\n### 本地缓存\n\n* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)\n\n* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)\n\t* 堆内、堆外、磁盘三级缓存。\n\t* 可按照缓存空间容量进行设置。\n\t* 按照时间、次数等过期策略。\n\n* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)\n\t* 简单轻量、无堆外、磁盘缓存。\n\n\n* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)\n\n* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)\n\n## 客户端缓存\n\n* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)\n\t* 主要是利用 Cache-Control 参数。\n\n* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)\n\n## 服务端缓存\n\n### Web缓存\n\n* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache\n* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache\n* [squid](https://github.com/squid-cache/squid) - squid cache\n\n### Memcached\n* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)\n* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)\n\t* 采用多路复用技术提高并发性。\n\t* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。\n* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)\n* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)\n\n* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)\n\t* 区别在于当key存在还是不存在时，返回值是true和false的。\n\n* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)\n\n### Redis\n\n* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)\n* [《redis底层原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)\n\t* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。\n\t* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。\n* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)\n\t* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。\n\t* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。\n\t* 也可以两者结合使用。\n\n* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)\n\n#### 架构\n* [《Redis单线程架构》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)\n\n#### 回收策略\n* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)\n\n### Tair\n\n* [官方网站](https://github.com/alibaba/tair)\n* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)\n* 特点：可以配置备份节点数目，通过异步同步到备份节点\n* 一致性Hash算法。\n* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。\n\n\n几种存储引擎:\n* MDB，完全内存性，可以用来存储Session等数据。\n* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作\n* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。\n* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。\n\n## 消息队列\n\n* [《消息队列-推/拉模式学习 & ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)\n\t* RabbitMQ 消费者默认是推模式（也支持拉模式）。\n\t* Kafka 默认是拉模式。\n\t* Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。\n\t* Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。\n\n* [《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》](https://blog.csdn.net/yunfeng482/article/details/72856762)\n\n### 消息总线\n\n消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。\n\n* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)\n\n### 消息的顺序\n* [《如何保证消费者接收消息的顺序》](https://www.cnblogs.com/cjsblog/p/8267892.html)\n\n### RabbitMQ\n\n支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。\n\n* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)\n* [《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57) \n* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)\n\n### RocketMQ\nJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。\n* [《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)\n* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome)\n\n### ActiveMQ\n纯Java实现，兼容JMS，可以内嵌于Java应用中。\n* [《ActiveMQ消息队列介绍》](https://www.cnblogs.com/wintersun/p/3962302.html)\n\n### Kafka\n高吞吐量、采用拉模式。适合高IO场景，比如日志同步。\n\n* [官方网站](http://kafka.apache.org/)\n* [《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)\n* [《Kafka分区机制介绍与示例》](http://lxw1234.com/archives/2015/10/538.htm)\n\n### Redis 消息推送\n\n生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。\n\n* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)\n\n### ZeroMQ\n TODO\n\n\n## 定时调度\n\n### 单机定时调度\n\n* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)\n\n* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)\n\t* fork 进程 + sleep 轮询\n\n* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)\n* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)\n* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)\n\t* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。\n\n\n### 分布式定时调度\n\n* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)\n\t* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares\n\n* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)\n\t* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 \n* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome)\n* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome)\n\n\n## RPC\n\n* [《从零开始实现RPC框架 - RPC原理及实现》](https://blog.csdn.net/top_code/article/details/54615853)\n\t* 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。\n\n* [《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》](https://blog.csdn.net/testcs_dn/article/details/78050590)\n\n### Dubbo\n* [官方网站](http://dubbo.apache.org/)\n* [dubbo实现原理简单介绍](https://www.cnblogs.com/steven520213/p/7606598.html)\n\n** SPI **\nTODO\n\n### Thrift\n* [官方网站](http://thrift.apache.org/)\n* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)\n\t* 支持多语言，通过中间语言定义接口。\n\n### gRPC\n\n服务端可以认证加密，在外网环境下，可以保证数据安全。\n\n* [官方网站](https://grpc.io/)\n* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)\n\n\n## 数据库中间件\n\n### Sharding Jdbc\n\n* [官网](http://shardingjdbc.io/)\n\n## 日志系统\n\n### 日志搜集\n\n* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)\n* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)\n* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)\n\n## 配置中心\n\n* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)\n\t* Spring Boot 和 Spring Cloud\n\t* 支持推、拉模式更新配置\n\t* 支持多种语言 \n\n* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)\n\n* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)\n\nservlet 3.0 异步特性可用于配置中心的客户端\n* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)\n\n## API 网关\n\n主要职责：请求转发、安全认证、协议转换、容灾。\n\n* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)\n* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)\n\n* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)\n* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome)\n* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)\n\n# 网络\n\n\n## 协议\n\n### OSI 七层协议\n\n* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)\n\n### TCP/IP\n* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)\n* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)\n\n### HTTP\n* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)\n\n### HTTP2.0\n* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)\n* [《HTTP2.0的基本单位为二进制帧》](https://blog.csdn.net/u012657197/article/details/77877840)\n\t* 利用二进制帧负责传输。\n\t* 多路复用。\n\n### HTTPS\n* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)\n\t* 使用非对称加密协商加密算法\n\t* 使用对称加密方式传输数据\n\t* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。\n\n* [《八大免费SSL证书-给你的网站免费添加Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)\n\n## 网络模型\n\n* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)\n\t* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。\n\t* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。\n\n* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)\n\t* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\t* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。\n\t* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。\n\t* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。\n\t\n* [《select，poll，epoll比较  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)\n\t* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。\n\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n\t* NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务\n\n* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)\n\n* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)\n\n### Epoll\n\n* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)\n\n### Java NIO\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)\n\n### kqueue\n* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)\n\n## 连接和短连接\n\n* [《TCP/IP系列——长连接与短连接的区别》](https://www.cnblogs.com/pangguoping/p/5571422.html)\n\n## 框架\n\n* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)\n\t* Reactor 模式介绍。\n\t* Netty 是 Reactor 模式的一种实现。\n\n## 零拷贝（Zero-copy）\n* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)\n\t* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。\n\n## 序列化(二进制协议)\n\n### Hessian\n* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)\nBinary-RPC;不仅仅是序列化\n\n### Protobuf\n* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)\nGoolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。\n* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)\n  \t* 关于协议的解释；缺点：可读性差;\n\n* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)\n\t* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。\n\n# 数据库\n## 基础理论\n### 数据库设计的三大范式\n* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)\n\t* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；\n\t* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；\n\t* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；\n\n## MySQL\n\n### 原理\n* [《MySQL的InnoDB索引原理详解》](http://www.admin10000.com/document/5372.html)\n\n* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)\n\t* 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁\n\n* [《myisam和innodb索引实现的不同》](https://www.2cto.com/database/201211/172380.html)\n\n### InnoDB\n\n* [《一篇文章带你读懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)\n\n### 优化\n\n* [《MySQL36条军规》](http://vdisk.weibo.com/s/muWOT)\n\n* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)\n* [《SQL优化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)\n* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)\n* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)\n* [《 MYSQL分页limit速度太慢优化方法》](https://blog.csdn.net/zy_281870667/article/details/51604540)\n\t* 原则上就是缩小扫描范围。\n\n\n### 索引\n\n#### 聚集索引, 非聚集索引\n\n* [《MySQL 聚集索引/非聚集索引简述》](https://blog.csdn.net/no_endless/article/details/77073549)\n* [《MyISAM和InnoDB的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)\n\nMyISAM 是非聚集，InnoDB 是聚集\n\n#### 复合索引\n\n* [《复合索引的优点和注意事项》](https://www.cnblogs.com/summer0space/p/7247778.html)\n\n#### 自适应哈希索引(AHI)\n\n* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)\n\n\n### explain\n* [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)\n\n## NoSQL\n\n### MongoDB\n\n* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n* [《Mongodb相对于关系型数据库的优缺点》](http://mxdxm.iteye.com/blog/2093603)\n\t* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；\n\t* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；\n\n### Hbase\n\n* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)\n* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)\n* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)\n\n\n* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)\n\t* 空数据不存储，节省空间，且适用于并发。\n\n* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)\n\t* rowkey 按照字典顺序排列，便于批量扫描。\n\t* 通过散列可以避免热点。\n\n# 搜索引擎\n\n## 搜索引擎原理\n\n* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)\n\n## Lucene\n* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)\n\n## Elasticsearch\n\n* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)\n* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)\n\n## Solr\n* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)\n* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)\n\n## sphinx \n* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)\n\n# 性能\n\n## 性能优化方法论\n\n* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)\n\t* 代码层面、业务层面、数据库层面、服务器层面、前端优化。\n\n* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)\n\n## 容量评估\n* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)\n* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect)\n\t* 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS\n\n## CDN 网络\n\n* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)\n* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)\n\n## 连接池\n\n* [《主流Java数据库连接池比较与开发配置实战》](https://blog.csdn.net/fysuccess/article/details/66972554)\n\n## 性能调优\n\n* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)\n\n\n# 大数据\n\n## 流式计算\n\n### Storm\n* [官方网站](http://storm.apache.org/)\n* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)\n\n### Flink\n* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)\n\n### Kafka Stream\n* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)\n\n### 应用场景\n\n例如：\n\n* 广告相关实时统计；\n* 推荐系统用户画像标签实时更新；\n* 线上服务健康状况实时监测；\n* 实时榜单；\n* 实时数据统计。\n\n## Hadoop\n\n* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)\n* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)\n\n### HDFS\n* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)\n\n### MapReduce\n* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)\n* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)\n\n### Yarn\n* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)\n\n## Spark\n* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)\n\n\n# 安全\n\n## web 安全\n\n### XSS\n* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)\n### CSRF\n* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)\n\n### SQL 注入\n\n* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)\n\n### Hash Dos\n\n\n* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)\n\t* 利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。\n* [《一种高级的DoS攻击-Hash碰撞攻击》](https://yq.aliyun.com/articles/92194?t=t1)\n* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)\n\n### 脚本注入\n\n* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)\n\n### 漏洞扫描工具\n* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)\n* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)\n* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)\n\n### 验证码\n\n* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)\n\n* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)\n\t* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。\n\n* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)\n\n## DDoS 防范\n* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)\n* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)\n\n## 用户隐私信息保护\n\n1. 用户密码非明文保存，加动态salt。\n2. 身份证号，手机号如果要显示，用 “\\*” 替代部分字符。\n3. 联系方式在的显示与否由用户自己控制。\n4. TODO\n\n* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)\n* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)\n\n* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)\n\n## 序列化漏洞\n* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)\n\n## 加密解密\n\n### 对称加密\n\n* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)\n\t* DES、3DES、Blowfish、AES\n\t* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。\n\t* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。\n\t\n### 哈希算法\n* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)\n\t* MD5 和 SHA-1 已经不再安全，已被弃用。\n\t* 目前 SHA-256 是比较安全的。\n\t\n* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)\n\n### 非对称加密\n* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)\n\t* RSA、DSA、ECDSA(螺旋曲线加密算法)\n\t* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。\n\t* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。\n\n\t\t[《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)\t\n\n\n## 服务器安全\n* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)\n\n## 数据安全\n\n### 数据备份\n\nTODO\n\n## 网络隔离\n\n### 内外网分离\n\nTODO\n\n### 登录跳板机\n在内外环境中通过跳板机登录到线上主机。\n* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)\n\n## 授权、认证\n### RBAC \n* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)\n* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)\n\n### OAuth2.0\n* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)\n\n### 双因素认证（2FA）\n\n2FA - Two-factor authentication，用于加强登录验证\n\n常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）\n\n* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)\n\n### 单点登录(SSO)\n\n* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)\n\n* [CAS单点登录框架](https://github.com/apereo/cas)\n\n# 常用开源框架\n\n## 开源协议\n\n* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)\n\n* [如何选择一个开源软件协议](http://choosealicense.online/)\n\n## 日志框架\n\n### Log4j、Log4j2\n* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)\n* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)\n* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)\n\t* Log4J 异步日志性能优异。 \n\n### Logback\n* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)\n\n## ORM\n\n* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)\n\t* 主要目的是为了提高开发效率。 \n\n**MyBatis：**\n\n* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)\n\t* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效\n\t* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  \n\n* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)\n\n## 网络框架\n\nTODO\n\n## Web 框架\n\n### Spring 家族\n**Spring**\n* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)\n\n**Spring Boot**\n* [官方网站](http://projects.spring.io/spring-boot/)\n* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n**Spring Cloud**\n\n* [Spring Boot 中文索引站](http://springboot.fun/)\n* [Spring Cloud 中文文档](https://springcloud.cc/)\n* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n## 工具框架\n\n* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)\n* [《Google guava 中文教程》](http://ifeve.com/google-guava/)\n\n\n# 分布式设计\n\n## 扩展性设计\n\n* [《架构师不可不知的十大可扩展架构》](https://blog.csdn.net/hemin1003/article/details/53633926)\n\t* 总结下来，通用的套路就是分布、缓存及异步处理。 \n\n* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)\n\t* 水平切分+垂直切分\n\t* 利用中间件进行分片如，MySQL Proxy。\n\t* 利用分片策略进行切分，如按照ID取模。 \n* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)\n\t* 分布式服务+消息队列。\n\n* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)\n\n## 稳定性 & 高可用\n\n* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)\n\t* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。\n\t* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。\n\t* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。\n\t* 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。\n\t* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。\n\t* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。\n\t* 自动化测试：通过完善的测试，减少发布引起的故障。\n\t* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。\n\n\n* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)\n\t* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。\t \n\n### 硬件负载均衡\n\n* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)\n\t* 主要是和F5对比。\n\n* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)\n\n### 软件负载均衡\n\n* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)\n\t轮寻、权重、负载、最少连接、QoS\n* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)\n\t* 配置简单，更新速度慢。 \n* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)\n\t* 简单轻量、学习成本低；主要适用于web应用。\n\n*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)\n\t* 配置比较负载、只支持到4层，性能较高。\n\n* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)\n\t* 支持到七层（比如HTTP）、功能比较全面，性能也不错。\n\n* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)\n\t* 主要是用户读请求的负载均衡。\n\n* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)\n\n### 限流\n\n* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)\n\t* 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。\n\t* 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。\n\t* 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。\n\t* Nginx 限流：通过 `limit_req` 等模块限制并发连接数。\n\n### 应用层容灾\n\n* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)\n\t* 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 \n\t* 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。\n\t* Hystrix设计原则：\n\t\t* 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。\n\t\t* 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。\n\t\t* 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 \n\n* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)\n* [《缓存击穿、失效以及热点key问题》](https://blog.csdn.net/zeb_perfect/article/details/54135506) \n\t* 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；\n\t* 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；\n\n### 跨机房容灾\n\n* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)\n\t* 通过自研中间件进行数据同步。 \n\n* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)\n\t* 注意延迟问题，多次跨机房调用会将延时放大数倍。\n\t* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。\n\t* 不能依赖于程序端数据双写，要有自动同步方案。 \n\t* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。\n\t* 核心业务和次要业务分而治之，甚至只考虑核心业务。\n\t* 异地多活监控部署、测试也要跟上。\n\t* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。\n\t* 控制跨机房消息体大小，越小越好。\n\t* 考虑使用docker容器虚拟化技术，提高动态调度能力。\n\n* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)\n\n\n### 容灾演练流程\n\n* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)\n\t* 常见故障画像\n\t* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。\n\n### 平滑启动\n\n* 平滑重启应用思路\n1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用\n\n* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)\n推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。\n* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)\nJava、Srping、Dubbo 优雅关闭方式。\n\n## 数据库扩展\n\n### 读写分离模式\n\n* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)\n* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)\n* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)\n\n* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)\n\t* DRDB 进行磁盘复制，避免单点问题。\n\n* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)\n\n### 分片模式\n* [《分库分表需要考虑的问题及方案》](https://www.jianshu.com/p/32b3e91aa22c)\n\t* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。\n\t* 问题：事务、Join、迁移、扩容、ID、分页等。\n\t* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。\n\t* 分库策略：数值范围；取模；日期等。\n\t* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 \n\n* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)\n\t* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。\n\t* 分表：物理上创建不同的表、客户端需要管理分表路由。\n\n## 服务治理\n###  服务注册与发现\n\n* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)\n  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。\n  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。\n* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)\n  * CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）\n  * 作者认为目前 Consul 对 Spring cloud 的支持比较好。\n\n* [《基于Zookeeper的服务注册与发现》](http://mobile.51cto.com/news-502394.htm)\n\t* 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 \n\n### 服务路由控制\n* [《分布式服务框架学习笔记4 服务路由》](https://blog.csdn.net/xundh/article/details/59492750)\n\t* 原则：透明化路由\n\t* 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接\n\t* 本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。\n\t* 配置方式：统一注册表；本地配置；动态下发。\n\n## 分布式一致\n\n### CAP 与 BASE 理论\n\n* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)\n\t* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)\n\t* CAP：一致性、可用性、分区容错性(网络故障引起)\n\t* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）\n\t* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n### 分布式锁\n\n* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)\n\t* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；\n\t* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。\n\t* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。\n* [《基于Zookeeper的分布式锁》](https://www.tuicool.com/articles/VZJr6fY)\n\t* 清楚的原理描述 + Java 代码示例。 \n\n* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)\n\t* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。\n\n* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)\n\t* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。\n\n### 分布式一致性算法\n\n#### PAXOS\n* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)\n* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)\n* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)\n\n#### Zab\n* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)\n\n#### Raft\n* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)\n\t* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）\n\t* 通过随机等待的方式发出投票，得票多的获胜。\n\n#### Gossip\n* [《Gossip算法》](http://blog.51cto.com/tianya23/530743)\n\n#### 两阶段提交、多阶段提交\n\n* [《关于分布式事务、两阶段提交协议、三阶提交协议》](http://blog.jobbole.com/95632/)\n\n### 幂等\n\n* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)\n\t* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。\n\t* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 \n\n### 分布式一致方案\n* [《分布式系统事务一致性解决方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)\n* [《保证分布式系统数据一致性的6种方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)\n\n### 分布式 Leader 节点选举\n* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)\n\n### TCC(Try/Confirm/Cancel) 柔性事务\n* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)\n\t* 基于BASE理论：基本可用、柔性状态、最终一致。\n\t* 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。\n\n## 分布式文件系统\n\n* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？\n* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？\n  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。\n  * FastDFS：轻量级、适合小文件。\n\n## 唯一ID 生成\n\n### 全局唯一ID\n* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)\n\t* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)\n\t* Flicker 方案：MySQL自增ID + \"REPLACE INTO XXX:SELECT LAST_INSERT_ID();\" \n\t* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。\n\t* MongoDB 方案：利用 ObjectId。缺点：不能自增。\n\n* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)\n\t* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。\n\t* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。\n\t* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。\n\n## 一致性Hash算法\n\n* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)\n\n# 设计思想 & 开发模式\n\n## DDD(Domain-driven Design - 领域驱动设计)\n\n* [《浅谈我对DDD领域驱动设计的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)\n  * 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。\n  * 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。\n  * 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。\n  \n* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)\n  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。\n  * 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。\n  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；\n  * 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。\n  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。\n  * 使用的模式：\n    * 关联尽量少，尽量单项，尽量降低整体复杂度。\n    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。\n    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。\n    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。\n    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；\n    * 工厂（Factory）：类似于设计模式中的工厂模式。\n    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。\n\n* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)\n\t* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。\n\n* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](http://www.hollischuang.com/archives/553)\n\n\n### 命令查询职责分离(CQRS)\n\nCQRS — Command Query Responsibility Seperation\n\n* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)\n\t* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。\n\n* [《DDD CQRS架构和传统架构的优缺点比较》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)\n\t* 最终一致的设计理念；依赖于高可用消息中间件。\n\t\n* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)\n\t* 一个实现 CQRS 的抽象案例。\n\n* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)\n\t* CQRS 模式分析 + 12306 抢票案例\n\n### 贫血，充血模型\n\n* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)\n\t* 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。\n\t* 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；\n\t* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。\n\t* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。\n\t* 作者主张使用贫血模式。\n\t\n## Actor 模式\n\nTODO\n\n## 响应式编程\n\n### Reactor\nTODO\n### RxJava\nTODO\n### Vert.x\nTODO\n\n## DODAF2.0\n\n* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)\n* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)\n\n## Serverless\n\n无需过多关系服务器的服务架构理念。\n\n* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)\n\t* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。\n\t* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。\n\t* Serverless 不代表某个具体的框架。\n\n* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)\n\t* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）\n\n\n\n## Service Mesh\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n\n# 项目管理\n\n## 架构评审\n* [《架构设计之如何评审架构设计说明书》](http://developer.51cto.com/art/201506/478486.htm)\n* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)\n\n## 重构\n\n* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)\n\n## 代码规范\n\n* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)\n\n## 代码 Review\n\n\n制度还是制度!\n另外，每个公司需要根据自己的需求和目标制定自己的 check list\n\n* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)\n\t* 代码 review 做的好，在于制度建设。\n\n* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)\n\n* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)\n* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)\n\n* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)\n\n## RUP\n* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)\n\n## 看板管理\n* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)\n\n## SCRUM\n\nSCRUM - 争球\n\n* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。\n* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；\n* 五个价值观：专注、勇气、公开、承诺、尊重。\n\n\n* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)\n\n* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)\n\n## 敏捷开发\n\nTODO\n\n## 极限编程（XP）\n\nXP - eXtreme Programming\n\n* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)\n\t* 是一种指导开发人员的方法论。\n\t* 4大价值：\n\t\t* 沟通：鼓励口头沟通，提高效率。\n\t\t* 简单：够用就好。\n\t\t* 反馈：及时反馈、通知相关人。\n\t\t* 勇气：提倡拥抱变化，敢于重构。\n\t\t\n\t* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。\n\t* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。\n\n## 结对编程\n\n边写码，边review。能够增强代码质量、减少bug。\n\n* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)\n\n## PDCA 循环质量管理\n\nP——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进\n\n* [《PDCA》](http://www.baike.com/wiki/PDCA)\n\n## FMEA管理模式\n\nTODO\n\n# 通用业务术语\n\nTODO\n\n# 技术趋势\n\nTODO\n\n# 政策、法规\n\nTODO\n## 法律\n\n### 严格遵守刑法253法条\n\n我国刑法第253条之一规定：\n\n> * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。\n> * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 \n> * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。\n\n最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”\n\n* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)\n\n\n# 架构师素质\n\n* [《架构师画像》](http://hellojava.info/?p=430)\n\t* 业务理解和抽象能力\n\t* NB的代码能力\n\t* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； \n\t* 全局：是否考虑到了对上下游的系统的影响。\n\t* 权衡：权衡投入产出比；优先级和节奏控制；\n\n* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)\n\t* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。\n\t* 基础设施、配置、测试、开发、运维综合考虑。\n\t* 考虑人、团队、和组织的影响。 \n\n* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) \n\n* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)\n\t* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。\n\t* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 \n\n* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)\n\t* 第一层的架构师看到的只是产品本身\n\t* 第二层的架构师不仅看到自己的产品，还看到了整体的方案\n\t* 第三层的架构师看到的是商业价值 \n\n# 团队管理\n\nTODO\n\n## 招聘\n\n# 资讯\n\n## 行业资讯\n\n* [36kr](http://36kr.com/)\n* [Techweb](http://www.techweb.com.cn/)\n\n## 公众号列表\n\nTODO\n\n## 博客\n\n### 团队博客\n* [阿里中间件博客](http://jm.taobao.org/)\n* [美团点评技术团队博客](https://tech.meituan.com)\n\n### 个人博客\n\n* [阮一峰的网络日志](http://www.ruanyifeng.com/)\n* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)\n* [hellojava-阿里毕玄](http://hellojava.info/)\n* [Cm's Blog](http://cmsblogs.com/)\n* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)\n\n## 综合门户、社区\n\n**国内：**\n\n* [CSDN](http://csdn.net)\n\t 老牌技术社区、不必解释。\n* [51cto.com](http://www.51cto.com/)\n* [ITeye](http://www.iteye.com/)\n\t* 偏 Java 方向 \n* [博客园](https://www.cnblogs.com)\n* [ChinaUnix](http://www.tom.net/)\n\t* 偏 Linux 方向 \n* [开源中国社区](https://www.oschina.net/)\n* [深度开源](http://www.open-open.com/)\n* [伯乐在线](http://www.jobbole.com/)\n\t* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。\n\n* [ITPUB](http://www.itpub.net/)\n* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)\n* [阿里云— 云栖社区](https://yq.aliyun.com/)\n* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)\n* [开发者头条](https://toutiao.io/)\n* [LinkedKeeper](http://www.linkedkeeper.com)\n\n**国外：**\n\n* [DZone](https://dzone.com)\n* [Reddit](https://www.reddit.com)\n\n## 问答、讨论类社区\n\n* [segmentfault](https://segmentfault.com)\n\t* 问答+专栏 \n* [知乎](https://www.zhihu.com/)\n* [stackoverflow](https://stackoverflow.com/)\n\n## 行业数据分析\n\n* [艾瑞网](http://report.iresearch.cn/)\n* [QUEST MOBILE](https://www.questmobile.com.cn)\n\n* [国家数据](http://data.stats.gov.cn/)\n\n* [TalkingData](http://www.talkingdata.com/)\n\n## 专项网站\n\n* 测试:\n\t* [领测国际](http://www.ltesting.net/) \n\t* [测试窝](https://www.testwo.com/)\n\t* [TesterHome](https://testerhome.com)\n\n* 运维:\n  \t* [运维派](http://www.yunweipai.com/) \n  \t* [Abcdocker](https://www.abcdocker.com/)\n  \n* Java:\n\t* [ImportNew](http://www.importnew.com/)\n\t\t* 专注于 Java 技术分享\n\t* [HowToDoInJava](https://howtodoinjava.com/)\n\t\t* 英文博客\n\t\n* 安全\n\t* [红黑联盟](https://www.2cto.com/) \n\t* [FreeBuf](http://www.freebuf.com/)\n\n* 大数据\n\t* [中国大数据](http://www.thebigdata.cn/) \n\n* 其他专题网站：\n\t* [DockerInfo](http://www.dockerinfo.net/)\n\t\t* 专注于 Docker 应用及咨询、教程的网站。\n\t* [Linux公社](https://www.linuxidc.com/)\n\t\t* Linux 主题社区\n\n## 其他类\n\n* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)\n\n## 推荐参考书\n\n\n### 在线电子书\n\n* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)\n\n\n* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)\n* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)\n\n* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)\n\n* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)\n\n* [《架构师之路》](https://www.w3cschool.cn/architectroad/)\n\n### 纸质书\n\n#### 开发方面\n\n* 《阿里巴巴Java开发手册》[京东](https://union-click.jd.com/jdc?d=bVKwZQ) [淘宝](https://s.taobao.com/search?q=阿里巴巴Java开发手册)\n\n#### 架构方面\n* 《软件架构师的12项修炼：技术技能篇》[京东](https://union-click.jd.com/jdc?d=gXvRd8) [淘宝](https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇)\n* 《架构之美》[京东](https://union-click.jd.com/jdc?d=xJit5I) [淘宝](https://s.taobao.com/search?q=架构之美)\n* 《分布式服务架构》[京东](https://union-click.jd.com/jdc?d=JS5Od9) [淘宝](https://s.taobao.com/search?q=分布式服务架构)\n* 《聊聊架构》 [京东](https://union-click.jd.com/jdc?d=FHooH4) [淘宝](https://s.taobao.com/search?q=聊聊架构)\n* 《云原生应用架构实践》[京东](https://union-click.jd.com/jdc?d=orkJSj) [淘宝](https://s.taobao.com/search?q=云原生应用架构实践)\n* 《亿级流量网站架构核心技术》[京东](https://union-click.jd.com/jdc?d=RnOSP5) [淘宝](https://s.taobao.com/search?q=亿级流量网站架构核心技术)\n* 《淘宝技术这十年》[京东](https://union-click.jd.com/jdc?d=LwrDfD) [淘宝](https://s.taobao.com/search?q=淘宝技术这十年)\n* 《企业IT架构转型之道-中台战略思想与架构实战》 [京东](https://union-click.jd.com/jdc?d=89pAEm) [淘宝](https://s.taobao.com/search?q=企业IT架构转型之道)\n\n* 《高可用架构（第1卷）》[京东](https://item.jd.com/12195481.html) [淘宝](https://s.taobao.com/search?q=高可用架构)\n\n#### 技术管理方面\n* 《CTO说》[京东](https://union-click.jd.com/jdc?d=zhTZyr) [淘宝](https://s.taobao.com/search?q=CTO说)\n* 《技术管理之巅》[京东](https://union-click.jd.com/jdc?d=LgRBUW) [淘宝](https://s.taobao.com/search?q=技术管理之巅)\n* 《网易一千零一夜：互联网产品项目管理实战》[京东](https://union-click.jd.com/jdc?d=jcRz2r) [淘宝](https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战)\n\n#### 基础理论\n* 《数学之美》[京东](https://union-click.jd.com/jdc?d=ghIES2) [淘宝](https://s.taobao.com/search?q=数学之美)\n* 《编程珠玑》[京东](https://union-click.jd.com/jdc?d=YmhdEu) [淘宝](https://s.taobao.com/search?q=编程珠玑)\n\n#### 工具方面\nTODO\n\n#### 大数据方面\n\n# 技术资源\n\n## 开源资源\n* [github](https://github.com)\n\n* [Apache 软件基金会](https://www.apache.org/index.html)\n\n## 手册、文档、教程\n\n**国内：**\n* [W3Cschool](http://w3cschool.cn) \n* [Runoob.com](http://www.runoob.com/)\n\t* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。\n\n* [Love2.io](https://love2.io/)\n\t* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。\n* [gitbook.cn](http://gitbook.cn/)\n\t* 付费电子书。 \n* [ApacheCN](http://www.apachecn.org/)\n\t* AI、大数据方面系列中文文档。\n\n**国外：**\n\n* [Quick Code](http://www.quickcode.co/)\n\t* 免费在线技术教程。\n* [gitbook.com](http://gitbook.com)\n\t* 有部分中文电子书。\n* [Cheatography](https://www.cheatography.com/)\n\t* Cheat Sheets 大全，单页文档网站。\n* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)\n\t* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。\n\n\n## 在线课堂\n\n* [学徒无忧](http://www.xuetuwuyou.com/)\n* [极客时间](https://time.geekbang.org/)\n* [segmentfault](https://segmentfault.com/lives)\n* [斯达克学院](https://new.stuq.org/course/explore)\n* [牛客网](http://nowcoder.com)\n* [极客学院](https://www.jikexueyuan.com/)\n* [51CTO学院](http://edu.51cto.com/)\n\n## 会议、活动\n\n* [QCon](http://www.infoq.com/cn/qcon/)\n* [ArchSummit](https://archsummit.com)\n* [GITC全球互联网技术大会](http://www.thegitc.com/)\n\n**活动发布平台:** \n* [活动行](http://www.huodongxing.com/)\n\n## 常用APP\n\n* [极客时间](https://time.geekbang.org)\n* [得到](https://www.igetget.com)\n\n## 找工作\n* [Boss直聘](https://www.zhipin.com)\n* [拉勾网](https://www.lagou.com)\n* [猎聘](https://www.liepin.com)\n* [100Offer](https://cn.100offer.com/)\n\n## 工具\n\n* [极客搜索](https://s.geekbang.org/)\n\t* 技术文章搜索引擎。\n\n## 代码托管\n\n* [Coding](https://coding.net)\n* [码云](https://gitee.com/)\n\n## 文件服务\n* 七牛\n* 又拍云\n\n## 综合云服务商\n* 阿里云\n* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c)\n* 百度云\n* 新浪云\n* 金山云\n* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)\n* [谷歌云](https://cloud.google.com/?hl=zh-cn)\n* [微软云](https://azure.microsoft.com/zh-cn/)\n\n### VPS\n* [Linode](http://linode.com)\n\n","slug":"architect-awesome","published":1,"updated":"2019-06-16T14:38:33.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckatvaqwu00hug4vana04fsnd","content":"<p>列出了后端架构师要掌握的基本知识。少壮不努力，老大徒伤悲……</p>\n<p>本文拷贝自<a href=\"https://github.com/xingshaocheng/architect-awesome\" target=\"_blank\" rel=\"noopener\">https://github.com/xingshaocheng/architect-awesome</a></p>\n<h1>《后端架构师技术图谱》</h1>\n\n<p><strong>更新于20180513</strong></p>\n<ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据结构\" target=\"_blank\" rel=\"noopener\">数据结构</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#队列\" target=\"_blank\" rel=\"noopener\">队列</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合\" target=\"_blank\" rel=\"noopener\">集合</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#链表数组\" target=\"_blank\" rel=\"noopener\">链表、数组</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典关联数组\" target=\"_blank\" rel=\"noopener\">字典、关联数组</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#栈\" target=\"_blank\" rel=\"noopener\">栈</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#树\" target=\"_blank\" rel=\"noopener\">树</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉树\" target=\"_blank\" rel=\"noopener\">二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#完全二叉树\" target=\"_blank\" rel=\"noopener\">完全二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平衡二叉树\" target=\"_blank\" rel=\"noopener\">平衡二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉查找树bst\" target=\"_blank\" rel=\"noopener\">二叉查找树（BST）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#红黑树\" target=\"_blank\" rel=\"noopener\">红黑树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#b-bb树\" target=\"_blank\" rel=\"noopener\">B-，B+，B*树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lsm-树\" target=\"_blank\" rel=\"noopener\">LSM 树</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#bitset\" target=\"_blank\" rel=\"noopener\">BitSet</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用算法\" target=\"_blank\" rel=\"noopener\">常用算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#排序查找算法\" target=\"_blank\" rel=\"noopener\">排序、查找算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#选择排序\" target=\"_blank\" rel=\"noopener\">选择排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#冒泡排序\" target=\"_blank\" rel=\"noopener\">冒泡排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#插入排序\" target=\"_blank\" rel=\"noopener\">插入排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快速排序\" target=\"_blank\" rel=\"noopener\">快速排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#归并排序\" target=\"_blank\" rel=\"noopener\">归并排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#希尔排序\" target=\"_blank\" rel=\"noopener\">希尔排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#堆排序\" target=\"_blank\" rel=\"noopener\">堆排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计数排序\" target=\"_blank\" rel=\"noopener\">计数排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#桶排序\" target=\"_blank\" rel=\"noopener\">桶排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基数排序\" target=\"_blank\" rel=\"noopener\">基数排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二分查找\" target=\"_blank\" rel=\"noopener\">二分查找</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-中的排序工具\" target=\"_blank\" rel=\"noopener\">Java 中的排序工具</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#布隆过滤器\" target=\"_blank\" rel=\"noopener\">布隆过滤器</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字符串比较\" target=\"_blank\" rel=\"noopener\">字符串比较</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kmp-算法\" target=\"_blank\" rel=\"noopener\">KMP 算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#深度优先广度优先\" target=\"_blank\" rel=\"noopener\">深度优先、广度优先</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贪心算法\" target=\"_blank\" rel=\"noopener\">贪心算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回溯算法\" target=\"_blank\" rel=\"noopener\">回溯算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#剪枝算法\" target=\"_blank\" rel=\"noopener\">剪枝算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#动态规划\" target=\"_blank\" rel=\"noopener\">动态规划</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#朴素贝叶斯\" target=\"_blank\" rel=\"noopener\">朴素贝叶斯</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐算法\" target=\"_blank\" rel=\"noopener\">推荐算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最小生成树算法\" target=\"_blank\" rel=\"noopener\">最小生成树算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最短路径算法\" target=\"_blank\" rel=\"noopener\">最短路径算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#并发\" target=\"_blank\" rel=\"noopener\">并发</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多线程\" target=\"_blank\" rel=\"noopener\">多线程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程安全\" target=\"_blank\" rel=\"noopener\">线程安全</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性事务\" target=\"_blank\" rel=\"noopener\">一致性、事务</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务-acid-特性\" target=\"_blank\" rel=\"noopener\">事务 ACID 特性</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务的隔离级别\" target=\"_blank\" rel=\"noopener\">事务的隔离级别</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvcc\" target=\"_blank\" rel=\"noopener\">MVCC</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#锁\" target=\"_blank\" rel=\"noopener\">锁</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java中的锁和同步类\" target=\"_blank\" rel=\"noopener\">Java中的锁和同步类</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公平锁--非公平锁\" target=\"_blank\" rel=\"noopener\">公平锁 &amp; 非公平锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#悲观锁\" target=\"_blank\" rel=\"noopener\">悲观锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#乐观锁--cas\" target=\"_blank\" rel=\"noopener\">乐观锁 &amp; CAS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aba-问题\" target=\"_blank\" rel=\"noopener\">ABA 问题</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#copyonwrite容器\" target=\"_blank\" rel=\"noopener\">CopyOnWrite容器</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ringbuffer\" target=\"_blank\" rel=\"noopener\">RingBuffer</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#可重入锁--不可重入锁\" target=\"_blank\" rel=\"noopener\">可重入锁 &amp; 不可重入锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#互斥锁--共享锁\" target=\"_blank\" rel=\"noopener\">互斥锁 &amp; 共享锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#死锁\" target=\"_blank\" rel=\"noopener\">死锁</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#操作系统\" target=\"_blank\" rel=\"noopener\">操作系统</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计算机原理\" target=\"_blank\" rel=\"noopener\">计算机原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cpu\" target=\"_blank\" rel=\"noopener\">CPU</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多级缓存\" target=\"_blank\" rel=\"noopener\">多级缓存</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#进程\" target=\"_blank\" rel=\"noopener\">进程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程\" target=\"_blank\" rel=\"noopener\">线程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协程\" target=\"_blank\" rel=\"noopener\">协程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#linux\" target=\"_blank\" rel=\"noopener\">Linux</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式\" target=\"_blank\" rel=\"noopener\">设计模式</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式的六大原则\" target=\"_blank\" rel=\"noopener\">设计模式的六大原则</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#23种常见设计模式\" target=\"_blank\" rel=\"noopener\">23种常见设计模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景\" target=\"_blank\" rel=\"noopener\">应用场景</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单例模式\" target=\"_blank\" rel=\"noopener\">单例模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#责任链模式\" target=\"_blank\" rel=\"noopener\">责任链模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvc\" target=\"_blank\" rel=\"noopener\">MVC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ioc\" target=\"_blank\" rel=\"noopener\">IOC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aop\" target=\"_blank\" rel=\"noopener\">AOP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#uml\" target=\"_blank\" rel=\"noopener\">UML</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#微服务思想\" target=\"_blank\" rel=\"noopener\">微服务思想</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#康威定律\" target=\"_blank\" rel=\"noopener\">康威定律</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#运维--统计--技术支持\" target=\"_blank\" rel=\"noopener\">运维 &amp; 统计 &amp; 技术支持</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常规监控\" target=\"_blank\" rel=\"noopener\">常规监控</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apm\" target=\"_blank\" rel=\"noopener\">APM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#统计分析\" target=\"_blank\" rel=\"noopener\">统计分析</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#持续集成cicd\" target=\"_blank\" rel=\"noopener\">持续集成(CI/CD)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jenkins\" target=\"_blank\" rel=\"noopener\">Jenkins</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#环境分离\" target=\"_blank\" rel=\"noopener\">环境分离</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自动化运维\" target=\"_blank\" rel=\"noopener\">自动化运维</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ansible\" target=\"_blank\" rel=\"noopener\">Ansible</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#puppet\" target=\"_blank\" rel=\"noopener\">puppet</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#chef\" target=\"_blank\" rel=\"noopener\">chef</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#测试\" target=\"_blank\" rel=\"noopener\">测试</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tdd-理论\" target=\"_blank\" rel=\"noopener\">TDD 理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单元测试\" target=\"_blank\" rel=\"noopener\">单元测试</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#压力测试\" target=\"_blank\" rel=\"noopener\">压力测试</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全链路压测\" target=\"_blank\" rel=\"noopener\">全链路压测</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ab-灰度蓝绿测试\" target=\"_blank\" rel=\"noopener\">A/B 、灰度、蓝绿测试</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#虚拟化\" target=\"_blank\" rel=\"noopener\">虚拟化</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kvm\" target=\"_blank\" rel=\"noopener\">KVM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xen\" target=\"_blank\" rel=\"noopener\">Xen</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openvz\" target=\"_blank\" rel=\"noopener\">OpenVZ</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容器技术\" target=\"_blank\" rel=\"noopener\">容器技术</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#docker\" target=\"_blank\" rel=\"noopener\">Docker</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#云技术\" target=\"_blank\" rel=\"noopener\">云技术</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openstack\" target=\"_blank\" rel=\"noopener\">OpenStack</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#devops\" target=\"_blank\" rel=\"noopener\">DevOps</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文档管理\" target=\"_blank\" rel=\"noopener\">文档管理</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#中间件\" target=\"_blank\" rel=\"noopener\">中间件</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-server\" target=\"_blank\" rel=\"noopener\">Web Server</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx\" target=\"_blank\" rel=\"noopener\">Nginx</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openresty\" target=\"_blank\" rel=\"noopener\">OpenResty</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apache-httpd\" target=\"_blank\" rel=\"noopener\">Apache Httpd</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tomcat\" target=\"_blank\" rel=\"noopener\">Tomcat</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构原理\" target=\"_blank\" rel=\"noopener\">架构原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#调优方案\" target=\"_blank\" rel=\"noopener\">调优方案</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jetty\" target=\"_blank\" rel=\"noopener\">Jetty</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#缓存\" target=\"_blank\" rel=\"noopener\">缓存</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#本地缓存\" target=\"_blank\" rel=\"noopener\">本地缓存</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#客户端缓存\" target=\"_blank\" rel=\"noopener\">客户端缓存</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务端缓存\" target=\"_blank\" rel=\"noopener\">服务端缓存</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web缓存\" target=\"_blank\" rel=\"noopener\">Web缓存</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#memcached\" target=\"_blank\" rel=\"noopener\">Memcached</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis\" target=\"_blank\" rel=\"noopener\">Redis</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构\" target=\"_blank\" rel=\"noopener\">架构</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回收策略\" target=\"_blank\" rel=\"noopener\">回收策略</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tair\" target=\"_blank\" rel=\"noopener\">Tair</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息队列\" target=\"_blank\" rel=\"noopener\">消息队列</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息总线\" target=\"_blank\" rel=\"noopener\">消息总线</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息的顺序\" target=\"_blank\" rel=\"noopener\">消息的顺序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rabbitmq\" target=\"_blank\" rel=\"noopener\">RabbitMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rocketmq\" target=\"_blank\" rel=\"noopener\">RocketMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#activemq\" target=\"_blank\" rel=\"noopener\">ActiveMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka\" target=\"_blank\" rel=\"noopener\">Kafka</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis-消息推送\" target=\"_blank\" rel=\"noopener\">Redis 消息推送</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zeromq\" target=\"_blank\" rel=\"noopener\">ZeroMQ</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#定时调度\" target=\"_blank\" rel=\"noopener\">定时调度</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单机定时调度\" target=\"_blank\" rel=\"noopener\">单机定时调度</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式定时调度\" target=\"_blank\" rel=\"noopener\">分布式定时调度</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rpc\" target=\"_blank\" rel=\"noopener\">RPC</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dubbo\" target=\"_blank\" rel=\"noopener\">Dubbo</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#thrift\" target=\"_blank\" rel=\"noopener\">Thrift</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#grpc\" target=\"_blank\" rel=\"noopener\">gRPC</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库中间件\" target=\"_blank\" rel=\"noopener\">数据库中间件</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sharding-jdbc\" target=\"_blank\" rel=\"noopener\">Sharding Jdbc</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志系统\" target=\"_blank\" rel=\"noopener\">日志系统</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志搜集\" target=\"_blank\" rel=\"noopener\">日志搜集</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#配置中心\" target=\"_blank\" rel=\"noopener\">配置中心</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#api-网关\" target=\"_blank\" rel=\"noopener\">API 网关</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络\" target=\"_blank\" rel=\"noopener\">网络</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协议\" target=\"_blank\" rel=\"noopener\">协议</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#osi-七层协议\" target=\"_blank\" rel=\"noopener\">OSI 七层协议</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcpip\" target=\"_blank\" rel=\"noopener\">TCP/IP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http\" target=\"_blank\" rel=\"noopener\">HTTP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http20\" target=\"_blank\" rel=\"noopener\">HTTP2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#https\" target=\"_blank\" rel=\"noopener\">HTTPS</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络模型\" target=\"_blank\" rel=\"noopener\">网络模型</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-nio\" target=\"_blank\" rel=\"noopener\">Java NIO</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kqueue\" target=\"_blank\" rel=\"noopener\">kqueue</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接和短连接\" target=\"_blank\" rel=\"noopener\">连接和短连接</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#框架\" target=\"_blank\" rel=\"noopener\">框架</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#零拷贝zero-copy\" target=\"_blank\" rel=\"noopener\">零拷贝（Zero-copy）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化二进制协议\" target=\"_blank\" rel=\"noopener\">序列化(二进制协议)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hessian\" target=\"_blank\" rel=\"noopener\">Hessian</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#protobuf\" target=\"_blank\" rel=\"noopener\">Protobuf</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库\" target=\"_blank\" rel=\"noopener\">数据库</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论\" target=\"_blank\" rel=\"noopener\">基础理论</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库设计的三大范式\" target=\"_blank\" rel=\"noopener\">数据库设计的三大范式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mysql\" target=\"_blank\" rel=\"noopener\">MySQL</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#原理\" target=\"_blank\" rel=\"noopener\">原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#innodb\" target=\"_blank\" rel=\"noopener\">InnoDB</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#优化\" target=\"_blank\" rel=\"noopener\">优化</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#索引\" target=\"_blank\" rel=\"noopener\">索引</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#聚集索引-非聚集索引\" target=\"_blank\" rel=\"noopener\">聚集索引, 非聚集索引</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#复合索引\" target=\"_blank\" rel=\"noopener\">复合索引</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自适应哈希索引ahi\" target=\"_blank\" rel=\"noopener\">自适应哈希索引(AHI)</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#explain\" target=\"_blank\" rel=\"noopener\">explain</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nosql\" target=\"_blank\" rel=\"noopener\">NoSQL</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mongodb\" target=\"_blank\" rel=\"noopener\">MongoDB</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hbase\" target=\"_blank\" rel=\"noopener\">Hbase</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎\" target=\"_blank\" rel=\"noopener\">搜索引擎</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎原理\" target=\"_blank\" rel=\"noopener\">搜索引擎原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lucene\" target=\"_blank\" rel=\"noopener\">Lucene</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#elasticsearch\" target=\"_blank\" rel=\"noopener\">Elasticsearch</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#solr\" target=\"_blank\" rel=\"noopener\">Solr</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sphinx\" target=\"_blank\" rel=\"noopener\">sphinx</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能\" target=\"_blank\" rel=\"noopener\">性能</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能优化方法论\" target=\"_blank\" rel=\"noopener\">性能优化方法论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容量评估\" target=\"_blank\" rel=\"noopener\">容量评估</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cdn-网络\" target=\"_blank\" rel=\"noopener\">CDN 网络</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接池\" target=\"_blank\" rel=\"noopener\">连接池</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能调优\" target=\"_blank\" rel=\"noopener\">性能调优</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据\" target=\"_blank\" rel=\"noopener\">大数据</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#流式计算\" target=\"_blank\" rel=\"noopener\">流式计算</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#storm\" target=\"_blank\" rel=\"noopener\">Storm</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#flink\" target=\"_blank\" rel=\"noopener\">Flink</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka-stream\" target=\"_blank\" rel=\"noopener\">Kafka Stream</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景-1\" target=\"_blank\" rel=\"noopener\">应用场景</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hadoop\" target=\"_blank\" rel=\"noopener\">Hadoop</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hdfs\" target=\"_blank\" rel=\"noopener\">HDFS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mapreduce\" target=\"_blank\" rel=\"noopener\">MapReduce</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#yarn\" target=\"_blank\" rel=\"noopener\">Yarn</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spark\" target=\"_blank\" rel=\"noopener\">Spark</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#安全\" target=\"_blank\" rel=\"noopener\">安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-安全\" target=\"_blank\" rel=\"noopener\">web 安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xss\" target=\"_blank\" rel=\"noopener\">XSS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#csrf\" target=\"_blank\" rel=\"noopener\">CSRF</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sql-注入\" target=\"_blank\" rel=\"noopener\">SQL 注入</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hash-dos\" target=\"_blank\" rel=\"noopener\">Hash Dos</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#脚本注入\" target=\"_blank\" rel=\"noopener\">脚本注入</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#漏洞扫描工具\" target=\"_blank\" rel=\"noopener\">漏洞扫描工具</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#验证码\" target=\"_blank\" rel=\"noopener\">验证码</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddos-防范\" target=\"_blank\" rel=\"noopener\">DDoS 防范</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#用户隐私信息保护\" target=\"_blank\" rel=\"noopener\">用户隐私信息保护</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化漏洞\" target=\"_blank\" rel=\"noopener\">序列化漏洞</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#加密解密\" target=\"_blank\" rel=\"noopener\">加密解密</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#对称加密\" target=\"_blank\" rel=\"noopener\">对称加密</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#哈希算法\" target=\"_blank\" rel=\"noopener\">哈希算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#非对称加密\" target=\"_blank\" rel=\"noopener\">非对称加密</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务器安全\" target=\"_blank\" rel=\"noopener\">服务器安全</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据安全\" target=\"_blank\" rel=\"noopener\">数据安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据备份\" target=\"_blank\" rel=\"noopener\">数据备份</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络隔离\" target=\"_blank\" rel=\"noopener\">网络隔离</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#内外网分离\" target=\"_blank\" rel=\"noopener\">内外网分离</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#登录跳板机\" target=\"_blank\" rel=\"noopener\">登录跳板机</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#授权认证\" target=\"_blank\" rel=\"noopener\">授权、认证</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rbac\" target=\"_blank\" rel=\"noopener\">RBAC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#oauth20\" target=\"_blank\" rel=\"noopener\">OAuth2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#双因素认证2fa\" target=\"_blank\" rel=\"noopener\">双因素认证（2FA）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单点登录sso\" target=\"_blank\" rel=\"noopener\">单点登录(SSO)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用开源框架\" target=\"_blank\" rel=\"noopener\">常用开源框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源协议\" target=\"_blank\" rel=\"noopener\">开源协议</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志框架\" target=\"_blank\" rel=\"noopener\">日志框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#log4jlog4j2\" target=\"_blank\" rel=\"noopener\">Log4j、Log4j2</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#logback\" target=\"_blank\" rel=\"noopener\">Logback</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#orm\" target=\"_blank\" rel=\"noopener\">ORM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络框架\" target=\"_blank\" rel=\"noopener\">网络框架</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-框架\" target=\"_blank\" rel=\"noopener\">Web 框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spring-家族\" target=\"_blank\" rel=\"noopener\">Spring 家族</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具框架\" target=\"_blank\" rel=\"noopener\">工具框架</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式设计\" target=\"_blank\" rel=\"noopener\">分布式设计</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#扩展性设计\" target=\"_blank\" rel=\"noopener\">扩展性设计</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#稳定性--高可用\" target=\"_blank\" rel=\"noopener\">稳定性 &amp; 高可用</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#硬件负载均衡\" target=\"_blank\" rel=\"noopener\">硬件负载均衡</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#软件负载均衡\" target=\"_blank\" rel=\"noopener\">软件负载均衡</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#限流\" target=\"_blank\" rel=\"noopener\">限流</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用层容灾\" target=\"_blank\" rel=\"noopener\">应用层容灾</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#跨机房容灾\" target=\"_blank\" rel=\"noopener\">跨机房容灾</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容灾演练流程\" target=\"_blank\" rel=\"noopener\">容灾演练流程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平滑启动\" target=\"_blank\" rel=\"noopener\">平滑启动</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库扩展\" target=\"_blank\" rel=\"noopener\">数据库扩展</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#读写分离模式\" target=\"_blank\" rel=\"noopener\">读写分离模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分片模式\" target=\"_blank\" rel=\"noopener\">分片模式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务治理\" target=\"_blank\" rel=\"noopener\">服务治理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务注册与发现\" target=\"_blank\" rel=\"noopener\">服务注册与发现</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务路由控制\" target=\"_blank\" rel=\"noopener\">服务路由控制</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致\" target=\"_blank\" rel=\"noopener\">分布式一致</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cap-与-base-理论\" target=\"_blank\" rel=\"noopener\">CAP 与 BASE 理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式锁\" target=\"_blank\" rel=\"noopener\">分布式锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致性算法\" target=\"_blank\" rel=\"noopener\">分布式一致性算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#paxos\" target=\"_blank\" rel=\"noopener\">PAXOS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zab\" target=\"_blank\" rel=\"noopener\">Zab</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#raft\" target=\"_blank\" rel=\"noopener\">Raft</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#gossip\" target=\"_blank\" rel=\"noopener\">Gossip</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#两阶段提交多阶段提交\" target=\"_blank\" rel=\"noopener\">两阶段提交、多阶段提交</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#幂等\" target=\"_blank\" rel=\"noopener\">幂等</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致方案\" target=\"_blank\" rel=\"noopener\">分布式一致方案</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式-leader-节点选举\" target=\"_blank\" rel=\"noopener\">分布式 Leader 节点选举</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcctryconfirmcancel-柔性事务\" target=\"_blank\" rel=\"noopener\">TCC(Try/Confirm/Cancel) 柔性事务</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式文件系统\" target=\"_blank\" rel=\"noopener\">分布式文件系统</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#唯一id-生成\" target=\"_blank\" rel=\"noopener\">唯一ID 生成</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全局唯一id\" target=\"_blank\" rel=\"noopener\">全局唯一ID</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性hash算法\" target=\"_blank\" rel=\"noopener\">一致性Hash算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计思想--开发模式\" target=\"_blank\" rel=\"noopener\">设计思想 &amp; 开发模式</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddddomain-driven-design---领域驱动设计\" target=\"_blank\" rel=\"noopener\">DDD(Domain-driven Design - 领域驱动设计)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#命令查询职责分离cqrs\" target=\"_blank\" rel=\"noopener\">命令查询职责分离(CQRS)</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贫血充血模型\" target=\"_blank\" rel=\"noopener\">贫血，充血模型</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#actor-模式\" target=\"_blank\" rel=\"noopener\">Actor 模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#响应式编程\" target=\"_blank\" rel=\"noopener\">响应式编程</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#reactor\" target=\"_blank\" rel=\"noopener\">Reactor</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rxjava\" target=\"_blank\" rel=\"noopener\">RxJava</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vertx\" target=\"_blank\" rel=\"noopener\">Vert.x</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dodaf20\" target=\"_blank\" rel=\"noopener\">DODAF2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#serverless\" target=\"_blank\" rel=\"noopener\">Serverless</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#service-mesh\" target=\"_blank\" rel=\"noopener\">Service Mesh</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#项目管理\" target=\"_blank\" rel=\"noopener\">项目管理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构评审\" target=\"_blank\" rel=\"noopener\">架构评审</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#重构\" target=\"_blank\" rel=\"noopener\">重构</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码规范\" target=\"_blank\" rel=\"noopener\">代码规范</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码-review\" target=\"_blank\" rel=\"noopener\">代码 Review</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rup\" target=\"_blank\" rel=\"noopener\">RUP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#看板管理\" target=\"_blank\" rel=\"noopener\">看板管理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#scrum\" target=\"_blank\" rel=\"noopener\">SCRUM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#敏捷开发\" target=\"_blank\" rel=\"noopener\">敏捷开发</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#极限编程xp\" target=\"_blank\" rel=\"noopener\">极限编程（XP）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#结对编程\" target=\"_blank\" rel=\"noopener\">结对编程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#fmea管理模式\" target=\"_blank\" rel=\"noopener\">FMEA管理模式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#通用业务术语\" target=\"_blank\" rel=\"noopener\">通用业务术语</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术趋势\" target=\"_blank\" rel=\"noopener\">技术趋势</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#政策法规\" target=\"_blank\" rel=\"noopener\">政策、法规</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#法律\" target=\"_blank\" rel=\"noopener\">法律</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#严格遵守刑法253法条\" target=\"_blank\" rel=\"noopener\">严格遵守刑法253法条</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构师素质\" target=\"_blank\" rel=\"noopener\">架构师素质</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队管理\" target=\"_blank\" rel=\"noopener\">团队管理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#招聘\" target=\"_blank\" rel=\"noopener\">招聘</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#资讯\" target=\"_blank\" rel=\"noopener\">资讯</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业资讯\" target=\"_blank\" rel=\"noopener\">行业资讯</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公众号列表\" target=\"_blank\" rel=\"noopener\">公众号列表</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#博客\" target=\"_blank\" rel=\"noopener\">博客</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队博客\" target=\"_blank\" rel=\"noopener\">团队博客</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#个人博客\" target=\"_blank\" rel=\"noopener\">个人博客</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合门户社区\" target=\"_blank\" rel=\"noopener\">综合门户、社区</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#问答讨论类社区\" target=\"_blank\" rel=\"noopener\">问答、讨论类社区</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业数据分析\" target=\"_blank\" rel=\"noopener\">行业数据分析</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#专项网站\" target=\"_blank\" rel=\"noopener\">专项网站</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#其他类\" target=\"_blank\" rel=\"noopener\">其他类</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐参考书\" target=\"_blank\" rel=\"noopener\">推荐参考书</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线电子书\" target=\"_blank\" rel=\"noopener\">在线电子书</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#纸质书\" target=\"_blank\" rel=\"noopener\">纸质书</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开发方面\" target=\"_blank\" rel=\"noopener\">开发方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构方面\" target=\"_blank\" rel=\"noopener\">架构方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术管理方面\" target=\"_blank\" rel=\"noopener\">技术管理方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论-1\" target=\"_blank\" rel=\"noopener\">基础理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具方面\" target=\"_blank\" rel=\"noopener\">工具方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据方面\" target=\"_blank\" rel=\"noopener\">大数据方面</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术资源\" target=\"_blank\" rel=\"noopener\">技术资源</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源资源\" target=\"_blank\" rel=\"noopener\">开源资源</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#手册文档教程\" target=\"_blank\" rel=\"noopener\">手册、文档、教程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线课堂\" target=\"_blank\" rel=\"noopener\">在线课堂</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#会议活动\" target=\"_blank\" rel=\"noopener\">会议、活动</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用app\" target=\"_blank\" rel=\"noopener\">常用APP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#找工作\" target=\"_blank\" rel=\"noopener\">找工作</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具\" target=\"_blank\" rel=\"noopener\">工具</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码托管\" target=\"_blank\" rel=\"noopener\">代码托管</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文件服务\" target=\"_blank\" rel=\"noopener\">文件服务</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合云服务商\" target=\"_blank\" rel=\"noopener\">综合云服务商</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vps\" target=\"_blank\" rel=\"noopener\">VPS</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>（Toc generated by <a href=\"https://github.com/xingshaocheng/simple-php-github-toc\" target=\"_blank\" rel=\"noopener\">simple-php-github-toc</a> ）</strong></p>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/lemon-flm/p/7877898.html\" target=\"_blank\" rel=\"noopener\">《java队列——queue详细分析》</a></p>\n<ul>\n<li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li>\n<li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/mantu/p/5802393.html\" target=\"_blank\" rel=\"noopener\">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></p>\n</li>\n</ul>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_33642117/article/details/52040345\" target=\"_blank\" rel=\"noopener\">《Java Set集合的详解》</a></li>\n</ul>\n<h2 id=\"链表、数组\"><a href=\"#链表、数组\" class=\"headerlink\" title=\"链表、数组\"></a>链表、数组</h2><ul>\n<li><a href=\"https://blog.csdn.net/wz249863091/article/details/52853360\" target=\"_blank\" rel=\"noopener\">《Java集合详解–什么是List》</a></li>\n</ul>\n<h2 id=\"字典、关联数组\"><a href=\"#字典、关联数组\" class=\"headerlink\" title=\"字典、关联数组\"></a>字典、关联数组</h2><ul>\n<li><a href=\"https://baike.xsoftlab.net/view/250.html\" target=\"_blank\" rel=\"noopener\">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><a href=\"https://blog.csdn.net/javazejian/article/details/53362993\" target=\"_blank\" rel=\"noopener\">《java数据结构与算法之栈（Stack）设计与实现》</a></li>\n<li><a href=\"http://www.runoob.com/java/java-stack-class.html\" target=\"_blank\" rel=\"noopener\">《Java Stack 类》</a></li>\n<li><a href=\"https://blog.csdn.net/f2006116/article/details/51375225\" target=\"_blank\" rel=\"noopener\">《java stack的详细实现分析》</a><ul>\n<li>Stack 是线程安全的。</li>\n<li>内部使用数组保存数据，不够时翻倍。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/cai2016/article/details/52589952\" target=\"_blank\" rel=\"noopener\">《二叉树》</a></li>\n</ul>\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin\" target=\"_blank\" rel=\"noopener\">《完全二叉树》</a><ul>\n<li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/polly333/p/4798944.html\" target=\"_blank\" rel=\"noopener\">《浅谈数据结构-平衡二叉树》</a></li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li>\n</ul>\n<h3 id=\"二叉查找树（BST）\"><a href=\"#二叉查找树（BST）\" class=\"headerlink\" title=\"二叉查找树（BST）\"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 七 二叉查找树》</a></li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><ul>\n<li><a href=\"https://blog.csdn.net/sun_tttt/article/details/65445754\" target=\"_blank\" rel=\"noopener\">《最容易懂得红黑树》</a><ul>\n<li>添加阶段后，左旋或者右旋从而再次达到平衡。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li>\n</ul>\n<h3 id=\"B-，B-，B-树\"><a href=\"#B-，B-，B-树\" class=\"headerlink\" title=\"B-，B+，B*树\"></a>B-，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/aqzwss/article/details/53074186\" target=\"_blank\" rel=\"noopener\">《B-树，B+树，B*树详解》</a></li>\n<li><a href=\"https://blog.csdn.net/bigtree_3721/article/details/73632405\" target=\"_blank\" rel=\"noopener\">《B-树，B+树与B*树的优缺点比较》</a><ul>\n<li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。<h3 id=\"LSM-树\"><a href=\"#LSM-树\" class=\"headerlink\" title=\"LSM 树\"></a>LSM 树</h3></li>\n</ul>\n</li>\n</ul>\n<p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。<br>Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/dbanote/article/details/8897599\" target=\"_blank\" rel=\"noopener\">《LSM树 VS B+树》</a></p>\n<ul>\n<li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。</li>\n<li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014774781/article/details/52105708\" target=\"_blank\" rel=\"noopener\">《LSM树（Log-Structured Merge Tree）存储引擎》</a></p>\n<ul>\n<li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li>\n<li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li>\n<li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"BitSet\"><a href=\"#BitSet\" class=\"headerlink\" title=\"BitSet\"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p>\n<ul>\n<li><a href=\"http://www.runoob.com/java/java-bitset-class.html\" target=\"_blank\" rel=\"noopener\">《Java Bitset类》</a></li>\n<li><a href=\"https://blog.csdn.net/caiandyong/article/details/51581160\" target=\"_blank\" rel=\"noopener\">《Java BitSet（位集）》</a></li>\n</ul>\n<h1 id=\"常用算法\"><a href=\"#常用算法\" class=\"headerlink\" title=\"常用算法\"></a>常用算法</h1><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\" target=\"_blank\" rel=\"noopener\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h2 id=\"排序、查找算法\"><a href=\"#排序、查找算法\" class=\"headerlink\" title=\"排序、查找算法\"></a>排序、查找算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\" target=\"_blank\" rel=\"noopener\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/shen-hua/p/5424059.html\" target=\"_blank\" rel=\"noopener\">《Java中的经典算法之选择排序（SelectionSort）》</a><ul>\n<li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li><a href=\"https://blog.csdn.net/shuaizai88/article/details/73250615\" target=\"_blank\" rel=\"noopener\">《冒泡排序的2种写法》</a><ul>\n<li>相邻元素前后交换、把最大的排到最后。</li>\n<li>时间复杂度 O(n²) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/hapjin/p/5517667.html\" target=\"_blank\" rel=\"noopener\">《排序算法总结之插入排序》</a></li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li><a href=\"http://developer.51cto.com/art/201403/430986.htm\" target=\"_blank\" rel=\"noopener\">《坐在马桶上看算法：快速排序》</a><ul>\n<li>一侧比另外一次都大或小。 <h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3></li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/chengxiao/p/6194356.html\" target=\"_blank\" rel=\"noopener\">《图解排序算法(四)之归并排序》</a><ul>\n<li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>TODO</p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/chengxiao/p/6129630.html\" target=\"_blank\" rel=\"noopener\">《图解排序算法(三)之堆排序》</a><ul>\n<li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/suvllian/p/5495780.html\" target=\"_blank\" rel=\"noopener\">《计数排序和桶排序》</a><ul>\n<li>和桶排序过程比较像，差别在于桶的数量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li><a href=\"http://blog.51cto.com/ahalei/1362789\" target=\"_blank\" rel=\"noopener\">《【啊哈！算法】最快最简单的排序——桶排序》</a></li>\n<li><a href=\"https://blog.csdn.net/sunjinshengli/article/details/70738527\" target=\"_blank\" rel=\"noopener\">《排序算法（三）：计数排序与桶排序》</a><ul>\n<li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li>\n<li>每个桶单独进行排序，然后再遍历每个桶。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/51695211\" target=\"_blank\" rel=\"noopener\">《排序算法系列：基数排序》</a></li>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/3603669.html\" target=\"_blank\" rel=\"noopener\">《基数排序》</a></li>\n</ul>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/coderising/p/5708632.html\" target=\"_blank\" rel=\"noopener\">《二分查找(java实现)》</a></p>\n<ul>\n<li>要求待查找的序列有序。</li>\n<li>时间复杂度 O(logN)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/maoyuanming0806/article/details/78176957\" target=\"_blank\" rel=\"noopener\">《java实现二分查找-两种方式》</a></p>\n<ul>\n<li>while + 递归。<h3 id=\"Java-中的排序工具\"><a href=\"#Java-中的排序工具\" class=\"headerlink\" title=\"Java 中的排序工具\"></a>Java 中的排序工具</h3></li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&amp;fps=1\" target=\"_blank\" rel=\"noopener\">《Arrays.sort和Collections.sort实现原理解析》</a><ul>\n<li>Collections.sort算法调用的是合并排序。</li>\n<li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。<br>核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。<br>优点：空间和时间效率都很高。<br>缺点：随着存入的元素数量增加，误算率随之增加。</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000002729689\" target=\"_blank\" rel=\"noopener\">《布隆过滤器 – 空间效率很高的数据结构》</a></li>\n<li><a href=\"https://blog.csdn.net/zdxiq000/article/details/57626464\" target=\"_blank\" rel=\"noopener\">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li>\n<li><a href=\"https://blog.csdn.net/qq_30242609/article/details/71024458\" target=\"_blank\" rel=\"noopener\">《基于Redis的布隆过滤器的实现》</a><ul>\n<li>基于 Redis 的 Bitmap 数据结构。</li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/47973715\" target=\"_blank\" rel=\"noopener\">《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》</a><ul>\n<li>使用Java中的 BitSet 类 和 加权和hash算法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h2><h3 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP）<br>核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\" target=\"_blank\" rel=\"noopener\">《字符串匹配的KMP算法》</a></li>\n</ul>\n<h2 id=\"深度优先、广度优先\"><a href=\"#深度优先、广度优先\" class=\"headerlink\" title=\"深度优先、广度优先\"></a>深度优先、广度优先</h2><ul>\n<li><a href=\"https://www.cnblogs.com/0kk470/p/7555033.html\" target=\"_blank\" rel=\"noopener\">《广度优先搜索BFS和深度优先搜索DFS》</a></li>\n</ul>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><ul>\n<li><a href=\"https://www.cnblogs.com/MrSaver/p/8641971.html\" target=\"_blank\" rel=\"noopener\">《算法：贪婪算法基础》</a></li>\n<li><a href=\"https://blog.csdn.net/a345017062/article/details/52443781\" target=\"_blank\" rel=\"noopener\">《常见算法及问题场景——贪心算法》</a></li>\n</ul>\n<h2 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qfikh/article/details/51960331\" target=\"_blank\" rel=\"noopener\">《 五大常用算法之四：回溯法》</a></li>\n</ul>\n<h2 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luningcsdn/article/details/50930276\" target=\"_blank\" rel=\"noopener\">《α-β剪枝算法》</a></li>\n</ul>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><ul>\n<li><a href=\"https://www.cnblogs.com/little-YTMM/p/5372680.html\" target=\"_blank\" rel=\"noopener\">《详解动态规划——邹博讲动态规划》</a></li>\n<li><a href=\"https://blog.csdn.net/yao_zi_jie/article/details/54580283\" target=\"_blank\" rel=\"noopener\">《动态规划算法的个人理解》</a></li>\n</ul>\n<h2 id=\"朴素贝叶斯\"><a href=\"#朴素贝叶斯\" class=\"headerlink\" title=\"朴素贝叶斯\"></a>朴素贝叶斯</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/amds123/article/details/70173402\" target=\"_blank\" rel=\"noopener\">《带你搞懂朴素贝叶斯分类算法》</a></p>\n<ul>\n<li>P(B|A)=P(A|B)P(B)/P(A)</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html\" target=\"_blank\" rel=\"noopener\">《贝叶斯推断及其互联网应用1》</a></p>\n</li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html\" target=\"_blank\" rel=\"noopener\">《贝叶斯推断及其互联网应用2》</a></li>\n</ul>\n<h2 id=\"推荐算法\"><a href=\"#推荐算法\" class=\"headerlink\" title=\"推荐算法\"></a>推荐算法</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01\" target=\"_blank\" rel=\"noopener\">《推荐算法综述》</a></li>\n<li><a href=\"https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems\" target=\"_blank\" rel=\"noopener\">《TOP 10 开源的推荐系统简介》</a></li>\n</ul>\n<h2 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luoshixian099/article/details/51908175\" target=\"_blank\" rel=\"noopener\">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li>\n</ul>\n<h2 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_35644234/article/details/60870719\" target=\"_blank\" rel=\"noopener\">《Dijkstra算法详解》</a></li>\n</ul>\n<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h1><h2 id=\"Java-并发\"><a href=\"#Java-并发\" class=\"headerlink\" title=\"Java 并发\"></a>Java 并发</h2><ul>\n<li><a href=\"https://github.com/CL0610/Java-concurrency\" target=\"_blank\" rel=\"noopener\">Java 并发知识合集</a></li>\n<li><a href=\"https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png\" target=\"_blank\" rel=\"noopener\">JAVA并发知识图谱</a></li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><ul>\n<li><a href=\"http://www.importnew.com/18459.html\" target=\"_blank\" rel=\"noopener\">《40个Java多线程问题总结》</a></li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><ul>\n<li><a href=\"https://www.cnblogs.com/zhanht/p/5450325.html\" target=\"_blank\" rel=\"noopener\">《Java并发编程——线程安全及解决机制简介》</a></li>\n</ul>\n<h2 id=\"一致性、事务\"><a href=\"#一致性、事务\" class=\"headerlink\" title=\"一致性、事务\"></a>一致性、事务</h2><h3 id=\"事务-ACID-特性\"><a href=\"#事务-ACID-特性\" class=\"headerlink\" title=\"事务 ACID 特性\"></a>事务 ACID 特性</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012440687/article/details/52116108\" target=\"_blank\" rel=\"noopener\">《数据库事务ACID特性》</a></li>\n</ul>\n<h3 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h3><ul>\n<li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li>\n<li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li>\n<li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li>\n<li><p>序列化：所有事物串行处理（牺牲了效率）</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_33290787/article/details/51924963\" target=\"_blank\" rel=\"noopener\">《理解事务的4种隔离级别》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/z-sm/p/7245981.html\" target=\"_blank\" rel=\"noopener\">数据库事务的四大特性及事务隔离级别</a></p>\n</li>\n<li><p><a href=\"http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html\" target=\"_blank\" rel=\"noopener\">《MySQL的InnoDB的幻读问题 》</a></p>\n<ul>\n<li>幻读的例子非常清楚。</li>\n<li>通过 SELECT … FOR UPDATE 解决。</li>\n</ul>\n</li>\n<li><p><a href=\"http://database.51cto.com/art/201804/570101.htm\" target=\"_blank\" rel=\"noopener\">《一篇文章带你读懂MySQL和InnoDB》</a></p>\n<ul>\n<li>图解脏读、不可重复读、幻读问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/chenpingzhao/p/5065316.html\" target=\"_blank\" rel=\"noopener\">《【mysql】关于innodb中MVCC的一些理解》</a></p>\n<ul>\n<li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li>\n<li>MVCC 会产生幻读问题（更新时异常。）</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/whoamiyang/article/details/51901888\" target=\"_blank\" rel=\"noopener\">《轻松理解MYSQL MVCC 实现机制》</a></p>\n<ul>\n<li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li>\n<li>每次只操作比当前版本小（或等于）的 行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"Java中的锁和同步类\"><a href=\"#Java中的锁和同步类\" class=\"headerlink\" title=\"Java中的锁和同步类\"></a>Java中的锁和同步类</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/qifengshi/p/6831055.html\" target=\"_blank\" rel=\"noopener\">《Java中的锁分类》</a></p>\n<ul>\n<li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener\">《Java并发之AQS详解》</a></p>\n</li>\n<li><p><a href=\"http://cuisuqiang.iteye.com/blog/2020146\" target=\"_blank\" rel=\"noopener\">《Java中信号量 Semaphore》</a></p>\n<ul>\n<li>有数量控制</li>\n<li>申请用 acquire，申请不要则阻塞；释放用 release。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/davidwang456/p/6094947.html\" target=\"_blank\" rel=\"noopener\">《java开发中的Mutex vs Semaphore》</a></p>\n<ul>\n<li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"公平锁-amp-非公平锁\"><a href=\"#公平锁-amp-非公平锁\" class=\"headerlink\" title=\"公平锁 &amp; 非公平锁\"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/EthanWhite/article/details/55508357\" target=\"_blank\" rel=\"noopener\">《公平锁与非公平锁》</a><ul>\n<li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/zhiqian-ali/p/6200874.html\" target=\"_blank\" rel=\"noopener\">《【MySQL】悲观锁&amp;乐观锁》</a></p>\n<ul>\n<li>乐观锁的方式：版本号+重试方式</li>\n<li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/Lawson/p/5008741.html\" target=\"_blank\" rel=\"noopener\">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a></p>\n<ul>\n<li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li>\n<li>锁相同数据的不同索引条件可能会引起死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zejin2008/p/5262751.html\" target=\"_blank\" rel=\"noopener\">《Mysql并发时经典常见的死锁原因及解决方法》</a></p>\n</li>\n</ul>\n<h3 id=\"乐观锁-amp-CAS\"><a href=\"#乐观锁-amp-CAS\" class=\"headerlink\" title=\"乐观锁 &amp; CAS\"></a>乐观锁 &amp; CAS</h3><ul>\n<li><a href=\"http://www.importnew.com/20472.html\" target=\"_blank\" rel=\"noopener\">《乐观锁的一种实现方式——CAS》</a><ul>\n<li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ABA-问题\"><a href=\"#ABA-问题\" class=\"headerlink\" title=\"ABA 问题\"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/549294286/p/3766717.html\" target=\"_blank\" rel=\"noopener\">《Java CAS 和ABA问题》</a></li>\n<li><a href=\"https://blog.csdn.net/li954644351/article/details/50511879\" target=\"_blank\" rel=\"noopener\">《Java 中 ABA问题及避免》</a><ul>\n<li>AtomicStampedReference 和 AtomicStampedReference。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CopyOnWrite容器\"><a href=\"#CopyOnWrite容器\" class=\"headerlink\" title=\"CopyOnWrite容器\"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/hapjin/p/4840107.html\" target=\"_blank\" rel=\"noopener\">《JAVA中写时复制(Copy-On-Write)Map实现》</a></p>\n<ul>\n<li>实现读写分离，读取发生在原始数据上，写入发生在副本上。  </li>\n<li>不用加锁，通过最终一致实现一致性。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/a494303877/article/details/53404623\" target=\"_blank\" rel=\"noopener\">《聊聊并发-Java中的Copy-On-Write容器》</a></p>\n</li>\n</ul>\n<h3 id=\"RingBuffer\"><a href=\"#RingBuffer\" class=\"headerlink\" title=\"RingBuffer\"></a>RingBuffer</h3><ul>\n<li><a href=\"http://www.cnblogs.com/l00l/p/4115001.html\" target=\"_blank\" rel=\"noopener\">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li>\n</ul>\n<h3 id=\"可重入锁-amp-不可重入锁\"><a href=\"#可重入锁-amp-不可重入锁\" class=\"headerlink\" title=\"可重入锁 &amp; 不可重入锁\"></a>可重入锁 &amp; 不可重入锁</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/dj3839/p/6580765.html\" target=\"_blank\" rel=\"noopener\">《可重入锁和不可重入锁》</a></p>\n<ul>\n<li>通过简单代码举例说明可重入锁和不可重入锁。</li>\n<li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li>\n<li>可重入锁可以用户避免死锁。</li>\n<li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/baizhanshi/p/7211802.html\" target=\"_blank\" rel=\"noopener\">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a></p>\n<ul>\n<li>synchronized 使用方便，编译器来加锁，是非公平锁。</li>\n<li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li>\n<li>相同加锁场景下，推荐使用 synchronized。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"互斥锁-amp-共享锁\"><a href=\"#互斥锁-amp-共享锁\" class=\"headerlink\" title=\"互斥锁 &amp; 共享锁\"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。<br>共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/liang1101/p/6475555.html\" target=\"_blank\" rel=\"noopener\">《ReadWriteLock场景应用》</a></li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><ul>\n<li><a href=\"https://blog.csdn.net/yunfenglw/article/details/45950305\" target=\"_blank\" rel=\"noopener\">《“死锁”四个必要条件的合理解释》</a><ul>\n<li>互斥、持有、不可剥夺、环形等待。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014039577/article/details/52351626\" target=\"_blank\" rel=\"noopener\">Java如何查看死锁？</a></p>\n<ul>\n<li>JConsole 可以识别死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/bohu83/article/details/51135061\" target=\"_blank\" rel=\"noopener\">java多线程系列：死锁及检测</a></p>\n<ul>\n<li>jstack 可以显示死锁。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><h2 id=\"计算机原理\"><a href=\"#计算机原理\" class=\"headerlink\" title=\"计算机原理\"></a>计算机原理</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000003692840\" target=\"_blank\" rel=\"noopener\">《操作系统基础知识——操作系统的原理，类型和结构》</a></li>\n</ul>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><h3 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/zero__007/article/details/54089730\" target=\"_blank\" rel=\"noopener\">《从Java视角理解CPU缓存和伪共享》</a></li>\n</ul>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>TODO</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ul>\n<li><a href=\"https://blog.csdn.net/asdf_1024/article/details/78978437\" target=\"_blank\" rel=\"noopener\">《线程的生命周期及状态转换详解》</a></li>\n</ul>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><ul>\n<li><a href=\"https://www.thinksaas.cn/group/topic/839375/\" target=\"_blank\" rel=\"noopener\">《终结python协程—-从yield到actor模型的实现》</a><ul>\n<li>线程的调度是由操作系统负责，协程调度是程序自行负责</li>\n<li>与线程相比，协程减少了无谓的操作系统切换.</li>\n<li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><ul>\n<li><a href=\"http://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener\">《Linux 命令大全》</a></li>\n</ul>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h2 id=\"设计模式的六大原则\"><a href=\"#设计模式的六大原则\" class=\"headerlink\" title=\"设计模式的六大原则\"></a>设计模式的六大原则</h2><ul>\n<li><a href=\"https://blog.csdn.net/q291611265/article/details/48465113\" target=\"_blank\" rel=\"noopener\">《设计模式的六大原则》</a><ul>\n<li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li>\n<li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li>\n<li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li>\n<li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li>\n<li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li>\n<li>合成复用原则：尽量使用合成/聚合,而不是使用继承。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"23种常见设计模式\"><a href=\"#23种常见设计模式\" class=\"headerlink\" title=\"23种常见设计模式\"></a>23种常见设计模式</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/design-pattern-tutorial.html\" target=\"_blank\" rel=\"noopener\">《设计模式》</a></li>\n<li><a href=\"https://www.cnblogs.com/susanws/p/5510229.html\" target=\"_blank\" rel=\"noopener\">《23种设计模式全解析》</a></li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li><p><a href=\"http://blog.jobbole.com/62314/\" target=\"_blank\" rel=\"noopener\">《细数JDK里的设计模式》</a></p>\n<ul>\n<li><p>结构型模式：</p>\n<ul>\n<li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li>\n<li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li>\n<li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li>\n<li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li>\n<li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li>\n<li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li>\n</ul>\n</li>\n<li><p>创建模式:</p>\n<ul>\n<li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li>\n<li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li>\n<li>工厂方法：就是 <strong>一个返*</strong> 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li>\n<li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li>\n<li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li>\n</ul>\n</li>\n<li>行为模式：<ul>\n<li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li>\n<li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li>\n<li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li>\n<li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li>\n<li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li>\n<li>空对象模式：如 java.util.Collections#emptyList()。</li>\n<li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li>\n<li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/hwaggLee/p/4510687.html\" target=\"_blank\" rel=\"noopener\">《Spring-涉及到的设计模式汇总》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/u012387062/article/details/54719114\" target=\"_blank\" rel=\"noopener\">《Mybatis使用的设计模式》</a></li>\n</ul>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><ul>\n<li><a href=\"https://blog.csdn.net/YECrazy/article/details/79481964\" target=\"_blank\" rel=\"noopener\">《单例模式的三种实现 以及各自的优缺点》</a></li>\n<li><a href=\"https://www.cnblogs.com/ttylinux/p/6498822.html\" target=\"_blank\" rel=\"noopener\">《单例模式－－反射－－防止序列化破坏单例模式》</a><ul>\n<li>使用枚举类型。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>TODO</p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/mvc-pattern.html\" target=\"_blank\" rel=\"noopener\">《MVC 模式》</a><ul>\n<li>模型(model)－视图(view)－控制器(controller) </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/23277575\" target=\"_blank\" rel=\"noopener\">《理解 IOC》</a></li>\n<li><a href=\"https://www.cnblogs.com/NancyStartOnce/p/6813162.html\" target=\"_blank\" rel=\"noopener\">《IOC 的理解与解释》</a><ul>\n<li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li>\n<li>作用：用于模块解耦。</li>\n<li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><ul>\n<li><a href=\"https://my.oschina.net/yanquan345/blog/203415\" target=\"_blank\" rel=\"noopener\">《轻松理解AOP(面向切面编程)》</a></li>\n<li><a href=\"https://www.cnblogs.com/hongwz/p/5764917.html\" target=\"_blank\" rel=\"noopener\">《Spring AOP详解》</a></li>\n<li><a href=\"http://www.importnew.com/24305.html\" target=\"_blank\" rel=\"noopener\">《Spring AOP的实现原理》</a><ul>\n<li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li>\n</ul>\n</li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/\" target=\"_blank\" rel=\"noopener\">《Spring AOP 实现原理与 CGLIB 应用》</a><ul>\n<li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><ul>\n<li><a href=\"https://www.w3cschool.cn/uml_tutorial/\" target=\"_blank\" rel=\"noopener\">《UML教程》</a></li>\n</ul>\n<h2 id=\"微服务思想\"><a href=\"#微服务思想\" class=\"headerlink\" title=\"微服务思想\"></a>微服务思想</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/6219259.html\" target=\"_blank\" rel=\"noopener\">《微服务架构设计》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/micro-service-technology-stack\" target=\"_blank\" rel=\"noopener\">《微服务架构技术栈选型手册》</a></li>\n</ul>\n<h3 id=\"康威定律\"><a href=\"#康威定律\" class=\"headerlink\" title=\"康威定律\"></a>康威定律</h3><ul>\n<li><p><a href=\"https://yq.aliyun.com/articles/8611\" target=\"_blank\" rel=\"noopener\">《微服务架构的理论基础 - 康威定律》</a></p>\n<ul>\n<li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li>\n<li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li>\n<li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li>\n<li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li>\n</ul>\n</li>\n<li><p><a href=\"https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf\" target=\"_blank\" rel=\"noopener\">《微服务架构核⼼20讲》</a></p>\n</li>\n</ul>\n<h1 id=\"运维-amp-统计-amp-技术支持\"><a href=\"#运维-amp-统计-amp-技术支持\" class=\"headerlink\" title=\"运维 &amp; 统计 &amp; 技术支持\"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id=\"常规监控\"><a href=\"#常规监控\" class=\"headerlink\" title=\"常规监控\"></a>常规监控</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/77849205\" target=\"_blank\" rel=\"noopener\">《腾讯业务系统监控的修炼之路》</a></p>\n<ul>\n<li>监控的方式：主动、被动、旁路(比如舆情监控)</li>\n<li>监控类型： 基础监控、服务端监控、客户端监控、<br>监控、用户端监控</li>\n<li>监控的目标：全、块、准</li>\n<li>核心指标：请求量、成功率、耗时</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.oschina.net/news/67525/monitoring-tools\" target=\"_blank\" rel=\"noopener\">《开源还是商用？十大云运维监控工具横评》</a></p>\n<ul>\n<li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li>\n</ul>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/201612/525373.htm\" target=\"_blank\" rel=\"noopener\">《监控报警系统搭建及二次开发经验》</a></p>\n</li>\n</ul>\n<p><strong>命令行监控工具</strong></p>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html\" target=\"_blank\" rel=\"noopener\">《常用命令行监控工具》</a></p>\n<ul>\n<li>top、sar、tsar、nload</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.jobbole.com/96846/\" target=\"_blank\" rel=\"noopener\">《20个命令行工具监控 Linux 系统性能》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/feichexia/blog/196575\" target=\"_blank\" rel=\"noopener\">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></p>\n</li>\n</ul>\n<h2 id=\"APM\"><a href=\"#APM\" class=\"headerlink\" title=\"APM\"></a>APM</h2><p>APM —  Application Performance Management</p>\n<ul>\n<li><p><a href=\"http://bigbully.github.io/Dapper-translation/\" target=\"_blank\" rel=\"noopener\">《Dapper，大规模分布式系统的跟踪系统》</a></p>\n</li>\n<li><p><a href=\"http://opentracing.io\" target=\"_blank\" rel=\"noopener\">CNCF OpenTracing</a>，<a href=\"https://github.com/opentracing-contrib/opentracing-specification-zh\" target=\"_blank\" rel=\"noopener\">中文版</a></p>\n</li>\n<li><p>主要开源软件，按字母排序</p>\n<ul>\n<li><a href=\"https://github.com/apache/incubator-skywalking\" target=\"_blank\" rel=\"noopener\">Apache SkyWalking</a></li>\n<li><a href=\"https://github.com/dianping/cat\" target=\"_blank\" rel=\"noopener\">CAT</a></li>\n<li><a href=\"https://github.com/jaegertracing/jaeger\" target=\"_blank\" rel=\"noopener\">CNCF jaeger</a></li>\n<li><a href=\"https://github.com/naver/pinpoint\" target=\"_blank\" rel=\"noopener\">Pinpoint</a></li>\n<li><a href=\"https://github.com/openzipkin/zipkin\" target=\"_blank\" rel=\"noopener\">Zipkin</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/apm-Pinpoint-practice\" target=\"_blank\" rel=\"noopener\">《开源APM技术选型与实战》</a></p>\n<ul>\n<li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"统计分析\"><a href=\"#统计分析\" class=\"headerlink\" title=\"统计分析\"></a>统计分析</h2><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/25195217\" target=\"_blank\" rel=\"noopener\">《流量统计的基础：埋点》</a></p>\n<ul>\n<li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.25xt.com/company/17066.html\" target=\"_blank\" rel=\"noopener\">《APP埋点常用的统计工具、埋点目标和埋点内容》</a></p>\n<ul>\n<li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li>\n</ul>\n</li>\n<li><p><a href=\"https://tech.meituan.com/mt-mobile-analytics-practice.html\" target=\"_blank\" rel=\"noopener\">《美团点评前端无痕埋点实践》</a></p>\n<ul>\n<li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"持续集成-CI-CD\"><a href=\"#持续集成-CI-CD\" class=\"headerlink\" title=\"持续集成(CI/CD)\"></a>持续集成(CI/CD)</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">《持续集成是什么？》</a></li>\n<li><a href=\"https://www.testwo.com/article/1170\" target=\"_blank\" rel=\"noopener\">《8个流行的持续集成工具》</a></li>\n</ul>\n<h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><ul>\n<li><a href=\"https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000\" target=\"_blank\" rel=\"noopener\">《使用Jenkins进行持续集成》</a></li>\n</ul>\n<h3 id=\"环境分离\"><a href=\"#环境分离\" class=\"headerlink\" title=\"环境分离\"></a>环境分离</h3><p>开发、测试、生成环境分离。</p>\n<ul>\n<li><a href=\"https://my.oschina.net/sancuo/blog/214904\" target=\"_blank\" rel=\"noopener\">《开发环境、生产环境、测试环境的基本理解和区》</a></li>\n</ul>\n<h2 id=\"自动化运维\"><a href=\"#自动化运维\" class=\"headerlink\" title=\"自动化运维\"></a>自动化运维</h2><h3 id=\"Ansible\"><a href=\"#Ansible\" class=\"headerlink\" title=\"Ansible\"></a>Ansible</h3><ul>\n<li><a href=\"http://www.ansible.com.cn/\" target=\"_blank\" rel=\"noopener\">《Ansible中文权威指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/heiye123/articles/7855890.html\" target=\"_blank\" rel=\"noopener\">《Ansible基础配置和企业级项目实用案例》</a></li>\n</ul>\n<h3 id=\"puppet\"><a href=\"#puppet\" class=\"headerlink\" title=\"puppet\"></a>puppet</h3><ul>\n<li><a href=\"https://www.cnblogs.com/keerya/p/8040071.html\" target=\"_blank\" rel=\"noopener\">《自动化运维工具——puppet详解》</a></li>\n</ul>\n<h3 id=\"chef\"><a href=\"#chef\" class=\"headerlink\" title=\"chef\"></a>chef</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/\" target=\"_blank\" rel=\"noopener\">《Chef 的安装与使用》</a></li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"TDD-理论\"><a href=\"#TDD-理论\" class=\"headerlink\" title=\"TDD 理论\"></a>TDD 理论</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/62f16cd4fef3\" target=\"_blank\" rel=\"noopener\">《深度解读 - TDD（测试驱动开发）》</a><ul>\n<li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li>\n<li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyzm/p/6482886.html\" target=\"_blank\" rel=\"noopener\">《Java单元测试之JUnit篇》</a></li>\n<li><a href=\"https://blog.csdn.net/hotdust/article/details/53406086\" target=\"_blank\" rel=\"noopener\">《JUnit 4 与 TestNG 对比》</a><ul>\n<li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 </li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/wqetfg/article/details/50900512\" target=\"_blank\" rel=\"noopener\">《单元测试主要的测试功能点》</a><ul>\n<li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h3><ul>\n<li><a href=\"https://blog.csdn.net/blueheart20/article/details/52170790\" target=\"_blank\" rel=\"noopener\">《Apache ab 测试使用指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/binyue/p/6141088.html\" target=\"_blank\" rel=\"noopener\">《大型网站压力测试及优化方案》</a></li>\n<li><a href=\"http://news.chinabyte.com/466/14126966.shtml\" target=\"_blank\" rel=\"noopener\">《10大主流压力/负载/性能测试工具推荐》</a></li>\n<li><a href=\"http://quentinxxz.iteye.com/blog/2249799\" target=\"_blank\" rel=\"noopener\">《真实流量压测工具 tcpcopy应用浅析》</a></li>\n<li><a href=\"https://www.cnblogs.com/jwentest/p/7136727.html\" target=\"_blank\" rel=\"noopener\">《nGrinder 简易使用教程》</a></li>\n</ul>\n<h3 id=\"全链路压测\"><a href=\"#全链路压测\" class=\"headerlink\" title=\"全链路压测\"></a>全链路压测</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot\" target=\"_blank\" rel=\"noopener\">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30306892\" target=\"_blank\" rel=\"noopener\">《饿了么全链路压测的探索与实践》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28355759\" target=\"_blank\" rel=\"noopener\">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li>\n<li><a href=\"https://www.jianshu.com/p/27060fd61f72\" target=\"_blank\" rel=\"noopener\">《全链路压测经验》</a></li>\n</ul>\n<h3 id=\"A-B-、灰度、蓝绿测试\"><a href=\"#A-B-、灰度、蓝绿测试\" class=\"headerlink\" title=\"A/B 、灰度、蓝绿测试\"></a>A/B 、灰度、蓝绿测试</h3><ul>\n<li><a href=\"https://testerhome.com/topics/11165\" target=\"_blank\" rel=\"noopener\">《技术干货 | AB 测试和灰度发布探索及实践》</a></li>\n<li><p><a href=\"http://blog.51cto.com/purplegrape/1403123\" target=\"_blank\" rel=\"noopener\">《nginx 根据IP 进行灰度发布》</a></p>\n</li>\n<li><p><a href=\"https://www.v2ex.com/t/344341\" target=\"_blank\" rel=\"noopener\">《蓝绿部署、A/B 测试以及灰度发布》</a></p>\n</li>\n</ul>\n<h2 id=\"虚拟化\"><a href=\"#虚拟化\" class=\"headerlink\" title=\"虚拟化\"></a>虚拟化</h2><ul>\n<li><a href=\"https://blog.csdn.net/enweitech/article/details/52910082\" target=\"_blank\" rel=\"noopener\">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li>\n</ul>\n<h3 id=\"KVM\"><a href=\"#KVM\" class=\"headerlink\" title=\"KVM\"></a>KVM</h3><ul>\n<li><a href=\"http://blog.chinaunix.net/uid-20201831-id-5775661.html\" target=\"_blank\" rel=\"noopener\">《KVM详解，太详细太深入了，经典》</a></li>\n<li><a href=\"https://www.coderxing.com/kvm-install.html\" target=\"_blank\" rel=\"noopener\">《【图文】KVM 虚拟机安装详解》</a></li>\n</ul>\n<h3 id=\"Xen\"><a href=\"#Xen\" class=\"headerlink\" title=\"Xen\"></a>Xen</h3><ul>\n<li><a href=\"https://www.cnblogs.com/sddai/p/5931201.html\" target=\"_blank\" rel=\"noopener\">《Xen虚拟化基本原理详解》</a></li>\n</ul>\n<h3 id=\"OpenVZ\"><a href=\"#OpenVZ\" class=\"headerlink\" title=\"OpenVZ\"></a>OpenVZ</h3><ul>\n<li><a href=\"https://blog.csdn.net/longerzone/article/details/44829255\" target=\"_blank\" rel=\"noopener\">《开源Linux容器 OpenVZ 快速上手指南》</a></li>\n</ul>\n<h2 id=\"容器技术\"><a href=\"#容器技术\" class=\"headerlink\" title=\"容器技术\"></a>容器技术</h2><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ul>\n<li><a href=\"https://www.cnblogs.com/SzeCheng/p/6822905.html\" target=\"_blank\" rel=\"noopener\">《几张图帮你理解 docker 基本原理及快速入门》</a></li>\n<li><a href=\"https://draveness.me/docker\" target=\"_blank\" rel=\"noopener\">《Docker 核心技术与实现原理》</a></li>\n<li><a href=\"http://www.runoob.com/docker/docker-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Docker 教程》</a></li>\n</ul>\n<h2 id=\"云技术\"><a href=\"#云技术\" class=\"headerlink\" title=\"云技术\"></a>云技术</h2><h3 id=\"OpenStack\"><a href=\"#OpenStack\" class=\"headerlink\" title=\"OpenStack\"></a>OpenStack</h3><ul>\n<li><a href=\"https://www.cnblogs.com/klb561/p/8660264.html\" target=\"_blank\" rel=\"noopener\">《OpenStack构架知识梳理》</a></li>\n</ul>\n<h2 id=\"DevOps\"><a href=\"#DevOps\" class=\"headerlink\" title=\"DevOps\"></a>DevOps</h2><ul>\n<li><a href=\"https://www.cnblogs.com/jetzhang/p/6068773.html\" target=\"_blank\" rel=\"noopener\">《一分钟告诉你究竟DevOps是什么鬼？》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/detail-analysis-of-devops\" target=\"_blank\" rel=\"noopener\">《DevOps详解》</a></li>\n</ul>\n<h2 id=\"文档管理\"><a href=\"#文档管理\" class=\"headerlink\" title=\"文档管理\"></a>文档管理</h2><ul>\n<li><a href=\"http://www.confluence.cn/\" target=\"_blank\" rel=\"noopener\">Confluence-收费文档管理系统</a></li>\n<li>GitLab?</li>\n<li>Wiki</li>\n</ul>\n<h1 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h1><h2 id=\"Web-Server\"><a href=\"#Web-Server\" class=\"headerlink\" title=\"Web Server\"></a>Web Server</h2><h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_25797077/article/details/52200722\" target=\"_blank\" rel=\"noopener\">《Ngnix的基本学习-多进程和Apache的比较》</a></p>\n<ul>\n<li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li>\n<li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/cunkouzh/p/5410154.html\" target=\"_blank\" rel=\"noopener\">《nginx与Apache的对比以及优缺点》</a></p>\n<ul>\n<li>nginx只适合静态和反向代理，不适合处理动态请求。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"OpenResty\"><a href=\"#OpenResty\" class=\"headerlink\" title=\"OpenResty\"></a>OpenResty</h3><ul>\n<li><a href=\"http://openresty.org/cn/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://www.linkedkeeper.com/detail/blog.action?bid=1034\" target=\"_blank\" rel=\"noopener\">《浅谈 OpenResty》</a><ul>\n<li>通过 Lua 模块可以在Nginx上进行开发。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Apache-Httpd\"><a href=\"#Apache-Httpd\" class=\"headerlink\" title=\"Apache Httpd\"></a>Apache Httpd</h3><ul>\n<li><a href=\"http://httpd.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n</ul>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><h4 id=\"架构原理\"><a href=\"#架构原理\" class=\"headerlink\" title=\"架构原理\"></a>架构原理</h4><ul>\n<li><a href=\"https://www.cnblogs.com/hggen/p/6264475.html\" target=\"_blank\" rel=\"noopener\">《TOMCAT原理详解及请求过程》</a></li>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4706223.html\" target=\"_blank\" rel=\"noopener\">《Tomcat服务器原理详解》</a></li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/\" target=\"_blank\" rel=\"noopener\">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xlgen157387/article/details/79006434\" target=\"_blank\" rel=\"noopener\">《四张图带你了解Tomcat系统架构》</a></p>\n</li>\n<li><p><a href=\"https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/\" target=\"_blank\" rel=\"noopener\">《JBoss vs. Tomcat: Choosing A Java Application Server》</a></p>\n<ul>\n<li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。</li>\n<li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"调优方案\"><a href=\"#调优方案\" class=\"headerlink\" title=\"调优方案\"></a>调优方案</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/sunfenqing/p/7339058.html\" target=\"_blank\" rel=\"noopener\">《Tomcat 调优方案》</a></p>\n<ul>\n<li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.chinaunix.net/uid-20662363-id-3012760.html\" target=\"_blank\" rel=\"noopener\">《tomcat http协议与ajp协议》</a></p>\n</li>\n<li><a href=\"http://dmouse.iteye.com/blog/1354527\" target=\"_blank\" rel=\"noopener\">《AJP与HTTP比较和分析》</a><ul>\n<li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li>\n<li>并发高时，AJP协议优于HTTP协议。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Jetty\"><a href=\"#Jetty\" class=\"headerlink\" title=\"Jetty\"></a>Jetty</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jetty/\" target=\"_blank\" rel=\"noopener\">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li>\n<li><a href=\"https://blog.csdn.net/doutao6677/article/details/51957288\" target=\"_blank\" rel=\"noopener\">《jetty和tomcat优势比较》</a><ul>\n<li>架构比较:Jetty的架构比Tomcat的更为简单。</li>\n<li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li>\n<li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ul>\n<li><a href=\"https://blog.csdn.net/clementad/article/details/48229243\" target=\"_blank\" rel=\"noopener\">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li>\n</ul>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html\" target=\"_blank\" rel=\"noopener\">《HashMap本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html\" target=\"_blank\" rel=\"noopener\">《EhCache本地缓存》</a></p>\n<ul>\n<li>堆内、堆外、磁盘三级缓存。</li>\n<li>可按照缓存空间容量进行设置。</li>\n<li>按照时间、次数等过期策略。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html\" target=\"_blank\" rel=\"noopener\">《Guava Cache》</a></p>\n<ul>\n<li>简单轻量、无堆外、磁盘缓存。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html\" target=\"_blank\" rel=\"noopener\">《Nginx本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html\" target=\"_blank\" rel=\"noopener\">《Pagespeed—懒人工具，服务器端加速》</a></p>\n</li>\n</ul>\n<h2 id=\"客户端缓存\"><a href=\"#客户端缓存\" class=\"headerlink\" title=\"客户端缓存\"></a>客户端缓存</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html\" target=\"_blank\" rel=\"noopener\">《浏览器端缓存》</a></p>\n<ul>\n<li>主要是利用 Cache-Control 参数。</li>\n</ul>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w\" target=\"_blank\" rel=\"noopener\">《H5 和移动端 WebView 缓存机制解析与实战》</a></p>\n</li>\n</ul>\n<h2 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a>服务端缓存</h2><h3 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h3><ul>\n<li><a href=\"https://github.com/jiangwenyuan/nuster\" target=\"_blank\" rel=\"noopener\">nuster</a> - nuster cache</li>\n<li><a href=\"https://github.com/varnishcache/varnish-cache\" target=\"_blank\" rel=\"noopener\">varnish</a> - varnish cache</li>\n<li><a href=\"https://github.com/squid-cache/squid\" target=\"_blank\" rel=\"noopener\">squid</a> - squid cache</li>\n</ul>\n<h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><ul>\n<li><a href=\"http://www.runoob.com/Memcached/Memcached-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Memcached 教程》</a></li>\n<li><a href=\"https://blog.csdn.net/chenleixing/article/details/47035453\" target=\"_blank\" rel=\"noopener\">《深入理解Memcached原理》</a><ul>\n<li>采用多路复用技术提高并发性。</li>\n<li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li>\n</ul>\n</li>\n<li><a href=\"https://www.jianshu.com/p/36e5cd400580\" target=\"_blank\" rel=\"noopener\">《Memcached软件工作原理》</a></li>\n<li><p><a href=\"http://zhihuzeye.com/archives/2361\" target=\"_blank\" rel=\"noopener\">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/liu251890347/article/details/37690045\" target=\"_blank\" rel=\"noopener\">《memcache 中 add 、 set 、replace 的区别》</a></p>\n<ul>\n<li>区别在于当key存在还是不存在时，返回值是true和false的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1qX00Lti?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=\" target=\"_blank\" rel=\"noopener\"><strong>《memcached全面剖析》</strong></a></p>\n</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ul>\n<li><a href=\"http://www.runoob.com/redis/redis-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Redis 教程》</a></li>\n<li><a href=\"https://blog.csdn.net/wcf373722432/article/details/78678504\" target=\"_blank\" rel=\"noopener\">《redis底层原理》</a><ul>\n<li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li>\n<li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://doc.redisfans.com/topic/persistence.html\" target=\"_blank\" rel=\"noopener\">《Redis持久化方式》</a></p>\n<ul>\n<li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li>\n<li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li>\n<li>也可以两者结合使用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chunlongyu/article/details/53346436\" target=\"_blank\" rel=\"noopener\">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><a href=\"https://blog.csdn.net/sunhuiliang85/article/details/73656830\" target=\"_blank\" rel=\"noopener\">《Redis单线程架构》</a></li>\n</ul>\n<h4 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h4><ul>\n<li><a href=\"https://blog.csdn.net/qq_29108585/article/details/63251491\" target=\"_blank\" rel=\"noopener\">《redis的回收策略》</a></li>\n</ul>\n<h3 id=\"Tair\"><a href=\"#Tair\" class=\"headerlink\" title=\"Tair\"></a>Tair</h3><ul>\n<li><a href=\"https://github.com/alibaba/tair\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://blog.csdn.net/farphone/article/details/53522383\" target=\"_blank\" rel=\"noopener\">《Tair和Redis的对比》</a></li>\n<li>特点：可以配置备份节点数目，通过异步同步到备份节点</li>\n<li>一致性Hash算法。</li>\n<li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li>\n</ul>\n<p>几种存储引擎:</p>\n<ul>\n<li>MDB，完全内存性，可以用来存储Session等数据。</li>\n<li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li>\n<li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li>\n<li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li>\n</ul>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/charlesblc/p/6045238.html\" target=\"_blank\" rel=\"noopener\">《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》</a></p>\n<ul>\n<li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li>\n<li>Kafka 默认是拉模式。</li>\n<li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li>\n<li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yunfeng482/article/details/72856762\" target=\"_blank\" rel=\"noopener\">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></p>\n</li>\n</ul>\n<h3 id=\"消息总线\"><a href=\"#消息总线\" class=\"headerlink\" title=\"消息总线\"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanghua_kobe/article/details/43877281\" target=\"_blank\" rel=\"noopener\">《消息总线VS消息队列》</a></li>\n</ul>\n<h3 id=\"消息的顺序\"><a href=\"#消息的顺序\" class=\"headerlink\" title=\"消息的顺序\"></a>消息的顺序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/cjsblog/p/8267892.html\" target=\"_blank\" rel=\"noopener\">《如何保证消费者接收消息的顺序》</a></li>\n</ul>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/whoamiyang/article/details/54954780\" target=\"_blank\" rel=\"noopener\">《RabbitMQ的应用场景以及基本原理介绍》</a></li>\n<li><a href=\"https://www.jianshu.com/p/79ca08116d57\" target=\"_blank\" rel=\"noopener\">《消息队列之 RabbitMQ》</a> </li>\n<li><a href=\"https://blog.csdn.net/u013256816/article/details/55515234\" target=\"_blank\" rel=\"noopener\">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li>\n</ul>\n<h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/824066d70da8\" target=\"_blank\" rel=\"noopener\">《RocketMQ 实战之快速入门》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/RocketMQ/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《RocketMQ 源码解析》</a></li>\n</ul>\n<h3 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/3962302.html\" target=\"_blank\" rel=\"noopener\">《ActiveMQ消息队列介绍》</a></li>\n</ul>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p>\n<ul>\n<li><a href=\"http://kafka.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/allthesametome/article/details/47362451\" target=\"_blank\" rel=\"noopener\">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li>\n<li><a href=\"http://lxw1234.com/archives/2015/10/538.htm\" target=\"_blank\" rel=\"noopener\">《Kafka分区机制介绍与示例》</a></li>\n</ul>\n<h3 id=\"Redis-消息推送\"><a href=\"#Redis-消息推送\" class=\"headerlink\" title=\"Redis 消息推送\"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_34212276/article/details/78455004\" target=\"_blank\" rel=\"noopener\">《Redis学习笔记之十：Redis用作消息队列》</a></li>\n</ul>\n<h3 id=\"ZeroMQ\"><a href=\"#ZeroMQ\" class=\"headerlink\" title=\"ZeroMQ\"></a>ZeroMQ</h3><p> TODO</p>\n<h2 id=\"定时调度\"><a href=\"#定时调度\" class=\"headerlink\" title=\"定时调度\"></a>定时调度</h2><h3 id=\"单机定时调度\"><a href=\"#单机定时调度\" class=\"headerlink\" title=\"单机定时调度\"></a>单机定时调度</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/shuaiqing/p/7742382.html\" target=\"_blank\" rel=\"noopener\">《linux定时任务cron配置》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/daquan/blog/483305\" target=\"_blank\" rel=\"noopener\">《Linux cron运行原理》</a></p>\n<ul>\n<li>fork 进程 + sleep 轮询</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/drift-ice/p/3817269.html\" target=\"_blank\" rel=\"noopener\">《Quartz使用总结》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/wenniuwuren/article/details/42082981/\" target=\"_blank\" rel=\"noopener\">《Quartz源码解析 —- 触发器按时启动原理》</a></li>\n<li><a href=\"https://www.jianshu.com/p/bab8e4e32952\" target=\"_blank\" rel=\"noopener\">《quartz原理揭秘和源码解读》</a><ul>\n<li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式定时调度\"><a href=\"#分布式定时调度\" class=\"headerlink\" title=\"分布式定时调度\"></a>分布式定时调度</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_16216221/article/details/70314337\" target=\"_blank\" rel=\"noopener\">《这些优秀的国产分布式任务调度系统，你用过几个？》</a></p>\n<ul>\n<li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html\" target=\"_blank\" rel=\"noopener\">《Quartz任务调度的基本实现原理》</a></p>\n<ul>\n<li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 </li>\n</ul>\n</li>\n<li><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Elastic-Job-Lite 源码解析》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Elastic-Job-Cloud 源码解析》</a></li>\n</ul>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/top_code/article/details/54615853\" target=\"_blank\" rel=\"noopener\">《从零开始实现RPC框架 - RPC原理及实现》</a></p>\n<ul>\n<li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/testcs_dn/article/details/78050590\" target=\"_blank\" rel=\"noopener\">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></p>\n</li>\n</ul>\n<h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><ul>\n<li><a href=\"http://dubbo.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/steven520213/p/7606598.html\" target=\"_blank\" rel=\"noopener\">dubbo实现原理简单介绍</a></li>\n</ul>\n<p><strong> SPI </strong><br>TODO</p>\n<h3 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h3><ul>\n<li><a href=\"http://thrift.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/kesonyk/article/details/50924489\" target=\"_blank\" rel=\"noopener\">《Thrift RPC详解》</a><ul>\n<li>支持多语言，通过中间语言定义接口。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p>\n<ul>\n<li><a href=\"https://grpc.io/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/LBSer/p/4853234.html\" target=\"_blank\" rel=\"noopener\">《你应该知道的RPC原理》</a></li>\n</ul>\n<h2 id=\"数据库中间件\"><a href=\"#数据库中间件\" class=\"headerlink\" title=\"数据库中间件\"></a>数据库中间件</h2><h3 id=\"Sharding-Jdbc\"><a href=\"#Sharding-Jdbc\" class=\"headerlink\" title=\"Sharding Jdbc\"></a>Sharding Jdbc</h3><ul>\n<li><a href=\"http://shardingjdbc.io/\" target=\"_blank\" rel=\"noopener\">官网</a></li>\n</ul>\n<h2 id=\"日志系统\"><a href=\"#日志系统\" class=\"headerlink\" title=\"日志系统\"></a>日志系统</h2><h3 id=\"日志搜集\"><a href=\"#日志搜集\" class=\"headerlink\" title=\"日志搜集\"></a>日志搜集</h3><ul>\n<li><a href=\"http://cjting.me/misc/build-log-system-with-elkb/\" target=\"_blank\" rel=\"noopener\">《从零开始搭建一个ELKB日志收集系统》</a></li>\n<li><a href=\"https://blog.csdn.net/lzw_2006/article/details/51280058\" target=\"_blank\" rel=\"noopener\">《用ELK搭建简单的日志收集分析系统》</a></li>\n<li><a href=\"https://www.cnblogs.com/beginmind/p/6058194.html\" target=\"_blank\" rel=\"noopener\">《日志收集系统-探究》</a></li>\n</ul>\n<h2 id=\"配置中心\"><a href=\"#配置中心\" class=\"headerlink\" title=\"配置中心\"></a>配置中心</h2><ul>\n<li><p><a href=\"https://github.com/ctripcorp/apollo\" target=\"_blank\" rel=\"noopener\">Apollo - 携程开源的配置中心应用</a></p>\n<ul>\n<li>Spring Boot 和 Spring Cloud</li>\n<li>支持推、拉模式更新配置</li>\n<li>支持多种语言 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011320740/article/details/78742625\" target=\"_blank\" rel=\"noopener\">《基于zookeeper实现统一配置管理》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/shamo89/p/8016908.html\" target=\"_blank\" rel=\"noopener\">《 Spring Cloud Config 分布式配置中心使用教程》</a></p>\n</li>\n</ul>\n<p>servlet 3.0 异步特性可用于配置中心的客户端</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/dogdogwang/p/7151866.html\" target=\"_blank\" rel=\"noopener\">《servlet3.0 新特性——异步处理》</a></li>\n</ul>\n<h2 id=\"API-网关\"><a href=\"#API-网关\" class=\"headerlink\" title=\"API 网关\"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p>\n<ul>\n<li><a href=\"http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/\" target=\"_blank\" rel=\"noopener\">《API网关那些儿》</a></li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo\" target=\"_blank\" rel=\"noopener\">《谈API网关的背景、架构以及落地方案》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhanglh046/article/details/78651993\" target=\"_blank\" rel=\"noopener\">《使用Zuul构建API Gateway》</a></p>\n</li>\n<li><a href=\"http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Spring Cloud Gateway 源码解析》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A\" target=\"_blank\" rel=\"noopener\">《HTTP API网关选择之一Kong介绍》</a></li>\n</ul>\n<h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><h3 id=\"OSI-七层协议\"><a href=\"#OSI-七层协议\" class=\"headerlink\" title=\"OSI 七层协议\"></a>OSI 七层协议</h3><ul>\n<li><a href=\"https://www.cnblogs.com/Robin-YB/p/6668762.html\" target=\"_blank\" rel=\"noopener\">《OSI七层协议模型、TCP/IP四层模型学习笔记》</a></li>\n</ul>\n<h3 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/onepixel/p/7092302.html\" target=\"_blank\" rel=\"noopener\">《深入浅出 TCP/IP 协议》</a></li>\n<li><a href=\"https://blog.csdn.net/whuslei/article/details/6667471/\" target=\"_blank\" rel=\"noopener\">《TCP协议中的三次握手和四次挥手》</a></li>\n</ul>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wangning528/p/6388464.html\" target=\"_blank\" rel=\"noopener\">《http协议详解(超详细)》</a></li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li><a href=\"https://blog.csdn.net/zhuyiquan/article/details/69257126\" target=\"_blank\" rel=\"noopener\">《HTTP 2.0 原理详细分析》</a></li>\n<li><a href=\"https://blog.csdn.net/u012657197/article/details/77877840\" target=\"_blank\" rel=\"noopener\">《HTTP2.0的基本单位为二进制帧》</a><ul>\n<li>利用二进制帧负责传输。</li>\n<li>多路复用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/zhangshitong/p/6478721.html\" target=\"_blank\" rel=\"noopener\">《https原理通俗了解》</a></p>\n<ul>\n<li>使用非对称加密协商加密算法</li>\n<li>使用对称加密方式传输数据</li>\n<li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/53213862\" target=\"_blank\" rel=\"noopener\">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></p>\n</li>\n</ul>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><ul>\n<li><p><a href=\"http://blog.51cto.com/litaotao/1289790\" target=\"_blank\" rel=\"noopener\">《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》</a></p>\n<ul>\n<li>五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li>\n<li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Anker/p/3265058.html\" target=\"_blank\" rel=\"noopener\">《select、poll、epoll之间的区别总结》</a></p>\n<ul>\n<li>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li>\n<li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li>\n<li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li>\n<li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li>\n</ul>\n</li>\n<li><p><a href=\"http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/\" target=\"_blank\" rel=\"noopener\">《select，poll，epoll比较  》</a></p>\n<ul>\n<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/geason/p/5774096.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java NIO》</a></p>\n<ul>\n<li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/skiof007/article/details/52873421\" target=\"_blank\" rel=\"noopener\">《BIO与NIO、AIO的区别》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u013074465/article/details/46276967\" target=\"_blank\" rel=\"noopener\">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></p>\n</li>\n</ul>\n<h3 id=\"Epoll\"><a href=\"#Epoll\" class=\"headerlink\" title=\"Epoll\"></a>Epoll</h3><ul>\n<li><a href=\"https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html\" target=\"_blank\" rel=\"noopener\">《epoll使用详解（精髓）》</a></li>\n</ul>\n<h3 id=\"Java-NIO\"><a href=\"#Java-NIO\" class=\"headerlink\" title=\"Java NIO\"></a>Java NIO</h3><ul>\n<li><a href=\"https://www.cnblogs.com/geason/p/5774096.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java NIO》</a></li>\n<li><a href=\"https://blog.csdn.net/xidianliuy/article/details/51612676\" target=\"_blank\" rel=\"noopener\">《Java NIO编写Socket服务器的一个例子》</a></li>\n</ul>\n<h3 id=\"kqueue\"><a href=\"#kqueue\" class=\"headerlink\" title=\"kqueue\"></a>kqueue</h3><ul>\n<li><a href=\"http://www.cnblogs.com/luminocean/p/5631336.html\" target=\"_blank\" rel=\"noopener\">《kqueue用法简介》</a></li>\n</ul>\n<h2 id=\"连接和短连接\"><a href=\"#连接和短连接\" class=\"headerlink\" title=\"连接和短连接\"></a>连接和短连接</h2><ul>\n<li><a href=\"https://www.cnblogs.com/pangguoping/p/5571422.html\" target=\"_blank\" rel=\"noopener\">《TCP/IP系列——长连接与短连接的区别》</a></li>\n</ul>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><ul>\n<li><a href=\"https://blog.csdn.net/excellentyuxiao/article/details/53390408\" target=\"_blank\" rel=\"noopener\">《Netty原理剖析》</a><ul>\n<li>Reactor 模式介绍。</li>\n<li>Netty 是 Reactor 模式的一种实现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"零拷贝（Zero-copy）\"><a href=\"#零拷贝（Zero-copy）\" class=\"headerlink\" title=\"零拷贝（Zero-copy）\"></a>零拷贝（Zero-copy）</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\" target=\"_blank\" rel=\"noopener\">《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》</a><ul>\n<li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"序列化-二进制协议\"><a href=\"#序列化-二进制协议\" class=\"headerlink\" title=\"序列化(二进制协议)\"></a>序列化(二进制协议)</h2><h3 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyday56/p/4268249.html\" target=\"_blank\" rel=\"noopener\">《Hessian原理分析》</a><br>Binary-RPC;不仅仅是序列化</li>\n</ul>\n<h3 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h3><ul>\n<li><a href=\"https://blog.csdn.net/antgan/article/details/52103966\" target=\"_blank\" rel=\"noopener\">《Protobuf协议的Java应用例子》</a><br>Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。</li>\n<li><p><a href=\"https://worktile.com/tech/share/prototol-buffers\" target=\"_blank\" rel=\"noopener\">《Protocol Buffers序列化协议及应用》</a></p>\n<pre><code>* 关于协议的解释；缺点：可读性差;\n</code></pre></li>\n<li><p><a href=\"https://blog.csdn.net/eric520zenobia/article/details/53766571\" target=\"_blank\" rel=\"noopener\">《简单的使用 protobuf 和 protostuff》</a></p>\n<ul>\n<li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"基础理论\"><a href=\"#基础理论\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h2><h3 id=\"数据库设计的三大范式\"><a href=\"#数据库设计的三大范式\" class=\"headerlink\" title=\"数据库设计的三大范式\"></a>数据库设计的三大范式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/waj6511988/p/7027127.html\" target=\"_blank\" rel=\"noopener\">《数据库的三大范式以及五大约束》</a><ul>\n<li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li>\n<li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>\n<li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li><p><a href=\"http://www.admin10000.com/document/5372.html\" target=\"_blank\" rel=\"noopener\">《MySQL的InnoDB索引原理详解》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xifeijian/article/details/20316775\" target=\"_blank\" rel=\"noopener\">《MySQL存储引擎－－MyISAM与InnoDB区别》</a></p>\n<ul>\n<li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201211/172380.html\" target=\"_blank\" rel=\"noopener\">《myisam和innodb索引实现的不同》</a></p>\n</li>\n</ul>\n<h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><ul>\n<li><a href=\"https://my.oschina.net/kailuncen/blog/1504217\" target=\"_blank\" rel=\"noopener\">《一篇文章带你读懂Mysql和InnoDB》</a></li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><ul>\n<li><p><a href=\"http://vdisk.weibo.com/s/muWOT\" target=\"_blank\" rel=\"noopener\">《MySQL36条军规》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhouyusheng/p/8038224.html\" target=\"_blank\" rel=\"noopener\">《MYSQL性能优化的最佳20+条经验》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/when_less_is_more/article/details/70187459\" target=\"_blank\" rel=\"noopener\">《SQL优化之道》</a></li>\n<li><a href=\"https://www.cnblogs.com/sivkun/p/7518540.html\" target=\"_blank\" rel=\"noopener\">《mysql数据库死锁的产生原因及解决办法》</a></li>\n<li><a href=\"https://blog.csdn.net/monkey_d_feilong/article/details/52291556\" target=\"_blank\" rel=\"noopener\">《导致索引失效的可能情况》</a></li>\n<li><a href=\"https://blog.csdn.net/zy_281870667/article/details/51604540\" target=\"_blank\" rel=\"noopener\">《 MYSQL分页limit速度太慢优化方法》</a><ul>\n<li>原则上就是缩小扫描范围。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"聚集索引-非聚集索引\"><a href=\"#聚集索引-非聚集索引\" class=\"headerlink\" title=\"聚集索引, 非聚集索引\"></a>聚集索引, 非聚集索引</h4><ul>\n<li><a href=\"https://blog.csdn.net/no_endless/article/details/77073549\" target=\"_blank\" rel=\"noopener\">《MySQL 聚集索引/非聚集索引简述》</a></li>\n<li><a href=\"https://www.cnblogs.com/zlcxbb/p/5757245.html\" target=\"_blank\" rel=\"noopener\">《MyISAM和InnoDB的索引实现》</a></li>\n</ul>\n<p>MyISAM 是非聚集，InnoDB 是聚集</p>\n<h4 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h4><ul>\n<li><a href=\"https://www.cnblogs.com/summer0space/p/7247778.html\" target=\"_blank\" rel=\"noopener\">《复合索引的优点和注意事项》</a></li>\n</ul>\n<h4 id=\"自适应哈希索引-AHI\"><a href=\"#自适应哈希索引-AHI\" class=\"headerlink\" title=\"自适应哈希索引(AHI)\"></a>自适应哈希索引(AHI)</h4><ul>\n<li><a href=\"https://blog.csdn.net/Linux_ever/article/details/62043708\" target=\"_blank\" rel=\"noopener\">《InnoDB存储引擎——自适应哈希索引》</a></li>\n</ul>\n<h3 id=\"explain\"><a href=\"#explain\" class=\"headerlink\" title=\"explain\"></a>explain</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008131735\" target=\"_blank\" rel=\"noopener\">《MySQL 性能优化神器 Explain 使用分析》</a></li>\n</ul>\n<h2 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h2><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><ul>\n<li><a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\" target=\"_blank\" rel=\"noopener\">MongoDB 教程</a></li>\n<li><a href=\"http://mxdxm.iteye.com/blog/2093603\" target=\"_blank\" rel=\"noopener\">《Mongodb相对于关系型数据库的优缺点》</a><ul>\n<li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li>\n<li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hbase\"><a href=\"#Hbase\" class=\"headerlink\" title=\"Hbase\"></a>Hbase</h3><ul>\n<li><a href=\"http://www.thebigdata.cn/HBase/35831.html\" target=\"_blank\" rel=\"noopener\">《简明 HBase 入门教程（开篇）》</a></li>\n<li><a href=\"https://www.cnblogs.com/qiaoyihang/p/6246424.html\" target=\"_blank\" rel=\"noopener\">《深入学习HBase架构原理》</a></li>\n<li><a href=\"https://blog.csdn.net/youzhouliu/article/details/67632882\" target=\"_blank\" rel=\"noopener\">《传统的行存储和（HBase）列存储的区别》</a></li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/lifuxiangcaohui/article/details/39891099\" target=\"_blank\" rel=\"noopener\">《Hbase与传统数据库的区别》</a></p>\n<ul>\n<li>空数据不存储，节省空间，且适用于并发。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014091123/article/details/73163088\" target=\"_blank\" rel=\"noopener\">《HBase Rowkey设计》</a></p>\n<ul>\n<li>rowkey 按照字典顺序排列，便于批量扫描。</li>\n<li>通过散列可以避免热点。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"搜索引擎\"><a href=\"#搜索引擎\" class=\"headerlink\" title=\"搜索引擎\"></a>搜索引擎</h1><h2 id=\"搜索引擎原理\"><a href=\"#搜索引擎原理\" class=\"headerlink\" title=\"搜索引擎原理\"></a>搜索引擎原理</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/0193dc44135b\" target=\"_blank\" rel=\"noopener\">《倒排索引–搜索引擎入门》</a></li>\n</ul>\n<h2 id=\"Lucene\"><a href=\"#Lucene\" class=\"headerlink\" title=\"Lucene\"></a>Lucene</h2><ul>\n<li><a href=\"https://www.cnblogs.com/rodge-run/p/6551152.html\" target=\"_blank\" rel=\"noopener\">《Lucene入门简介》</a></li>\n</ul>\n<h2 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h2><ul>\n<li><a href=\"https://blog.csdn.net/laoyang360/article/details/52244917\" target=\"_blank\" rel=\"noopener\">《Elasticsearch学习，请先看这一篇！》</a></li>\n<li><a href=\"https://blog.csdn.net/cyony/article/details/65437708\" target=\"_blank\" rel=\"noopener\">《Elasticsearch索引原理》</a></li>\n</ul>\n<h2 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h2><ul>\n<li><a href=\"https://blog.csdn.net/u011936655/article/details/51960005\" target=\"_blank\" rel=\"noopener\">《 Apache Solr入门教程》</a></li>\n<li><a href=\"https://blog.csdn.net/convict_eva/article/details/53537837\" target=\"_blank\" rel=\"noopener\">《elasticsearch与solr比较》</a></li>\n</ul>\n<h2 id=\"sphinx\"><a href=\"#sphinx\" class=\"headerlink\" title=\"sphinx\"></a>sphinx</h2><ul>\n<li><a href=\"http://blog.jobbole.com/101672/\" target=\"_blank\" rel=\"noopener\">《Sphinx 的介绍和原理探索》</a></li>\n</ul>\n<h1 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h1><h2 id=\"性能优化方法论\"><a href=\"#性能优化方法论\" class=\"headerlink\" title=\"性能优化方法论\"></a>性能优化方法论</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread\" target=\"_blank\" rel=\"noopener\">《15天的性能优化工作，5方面的调优经验》</a></p>\n<ul>\n<li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/tenglizhe/article/details/44563135\" target=\"_blank\" rel=\"noopener\">《系统性能优化的几个方面》</a></p>\n</li>\n</ul>\n<h2 id=\"容量评估\"><a href=\"#容量评估\" class=\"headerlink\" title=\"容量评估\"></a>容量评估</h2><ul>\n<li><a href=\"https://blog.csdn.net/u012528360/article/details/70054156\" target=\"_blank\" rel=\"noopener\">《联网性能与容量评估的方法论和典型案例》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959542&amp;idx=1&amp;sn=2494bbea9a855e0e1c3ccd6d2562a600&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">《互联网架构，如何进行容量设计？》</a><ul>\n<li>评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CDN-网络\"><a href=\"#CDN-网络\" class=\"headerlink\" title=\"CDN 网络\"></a>CDN 网络</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wxiaona/p/5867685.html\" target=\"_blank\" rel=\"noopener\">《CDN加速原理》</a></li>\n<li><a href=\"https://www.zhihu.com/question/20536932\" target=\"_blank\" rel=\"noopener\">《国内有哪些比较好的 CDN？》</a></li>\n</ul>\n<h2 id=\"连接池\"><a href=\"#连接池\" class=\"headerlink\" title=\"连接池\"></a>连接池</h2><ul>\n<li><a href=\"https://blog.csdn.net/fysuccess/article/details/66972554\" target=\"_blank\" rel=\"noopener\">《主流Java数据库连接池比较与开发配置实战》</a></li>\n</ul>\n<h2 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h2><ul>\n<li><a href=\"https://blog.csdn.net/yethyeth/article/details/73266455\" target=\"_blank\" rel=\"noopener\">《九大Java性能调试工具，必备至少一款》</a></li>\n</ul>\n<h1 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h1><h2 id=\"流式计算\"><a href=\"#流式计算\" class=\"headerlink\" title=\"流式计算\"></a>流式计算</h2><h3 id=\"Storm\"><a href=\"#Storm\" class=\"headerlink\" title=\"Storm\"></a>Storm</h3><ul>\n<li><a href=\"http://storm.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/uisoul/article/details/77989927\" target=\"_blank\" rel=\"noopener\">《最详细的Storm入门教程》</a></li>\n</ul>\n<h3 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h3><ul>\n<li><a href=\"https://blog.csdn.net/lisi1129/article/details/54844919\" target=\"_blank\" rel=\"noopener\">《Flink之一 Flink基本原理介绍》</a></li>\n</ul>\n<h3 id=\"Kafka-Stream\"><a href=\"#Kafka-Stream\" class=\"headerlink\" title=\"Kafka Stream\"></a>Kafka Stream</h3><ul>\n<li><a href=\"https://yq.aliyun.com/articles/58382\" target=\"_blank\" rel=\"noopener\">《Kafka Stream调研：一种轻量级流计算模式》</a></li>\n</ul>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>例如：</p>\n<ul>\n<li>广告相关实时统计；</li>\n<li>推荐系统用户画像标签实时更新；</li>\n<li>线上服务健康状况实时监测；</li>\n<li>实时榜单；</li>\n<li>实时数据统计。</li>\n</ul>\n<h2 id=\"Hadoop\"><a href=\"#Hadoop\" class=\"headerlink\" title=\"Hadoop\"></a>Hadoop</h2><ul>\n<li><a href=\"https://blog.csdn.net/houbin0912/article/details/72967178\" target=\"_blank\" rel=\"noopener\">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li>\n<li><a href=\"http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html\" target=\"_blank\" rel=\"noopener\">《史上最详细的Hadoop环境搭建》</a></li>\n</ul>\n<h3 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000011575458\" target=\"_blank\" rel=\"noopener\">《【Hadoop学习】HDFS基本原理》</a></li>\n</ul>\n<h3 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h3><ul>\n<li><a href=\"https://blog.csdn.net/oppo62258801/article/details/72884633\" target=\"_blank\" rel=\"noopener\">《用通俗易懂的大白话讲解Map/Reduce原理》</a></li>\n<li><a href=\"https://blog.csdn.net/foye12/article/details/78358292\" target=\"_blank\" rel=\"noopener\">《 简单的map-reduce的java例子》</a></li>\n</ul>\n<h3 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h3><ul>\n<li><a href=\"http://www.cnblogs.com/codeOfLife/p/5492740.html\" target=\"_blank\" rel=\"noopener\">《初步掌握Yarn的架构及原理》</a></li>\n</ul>\n<h2 id=\"Spark\"><a href=\"#Spark\" class=\"headerlink\" title=\"Spark\"></a>Spark</h2><ul>\n<li><a href=\"http://www.cnblogs.com/tgzhu/p/5818374.html\" target=\"_blank\" rel=\"noopener\">《Spark(一): 基本架构及原理》</a></li>\n</ul>\n<h1 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h1><h2 id=\"web-安全\"><a href=\"#web-安全\" class=\"headerlink\" title=\"web 安全\"></a>web 安全</h2><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><ul>\n<li><a href=\"https://blog.csdn.net/qq_21956483/article/details/54377947\" target=\"_blank\" rel=\"noopener\">《xss攻击原理与解决方法》</a><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html\" target=\"_blank\" rel=\"noopener\">《CSRF原理及防范》</a></li>\n</ul>\n<h3 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html\" target=\"_blank\" rel=\"noopener\">《SQL注入》</a></li>\n</ul>\n<h3 id=\"Hash-Dos\"><a href=\"#Hash-Dos\" class=\"headerlink\" title=\"Hash Dos\"></a>Hash Dos</h3><ul>\n<li><a href=\"http://www.freebuf.com/articles/web/14199.html\" target=\"_blank\" rel=\"noopener\">《邪恶的JAVA HASH DOS攻击》</a><ul>\n<li>利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li>\n</ul>\n</li>\n<li><a href=\"https://yq.aliyun.com/articles/92194?t=t1\" target=\"_blank\" rel=\"noopener\">《一种高级的DoS攻击-Hash碰撞攻击》</a></li>\n<li><a href=\"http://www.iteye.com/news/23939/\" target=\"_blank\" rel=\"noopener\">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li>\n</ul>\n<h3 id=\"脚本注入\"><a href=\"#脚本注入\" class=\"headerlink\" title=\"脚本注入\"></a>脚本注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html\" target=\"_blank\" rel=\"noopener\">《上传文件漏洞原理及防范》</a></li>\n</ul>\n<h3 id=\"漏洞扫描工具\"><a href=\"#漏洞扫描工具\" class=\"headerlink\" title=\"漏洞扫描工具\"></a>漏洞扫描工具</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html\" target=\"_blank\" rel=\"noopener\">《DVWA》</a></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html\" target=\"_blank\" rel=\"noopener\">W3af</a></li>\n<li><a href=\"https://blog.csdn.net/xygg0801/article/details/53610640\" target=\"_blank\" rel=\"noopener\">OpenVAS详解</a></li>\n</ul>\n<h3 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/niaonao/article/details/51112686\" target=\"_blank\" rel=\"noopener\">《验证码原理分析及实现》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/jiangbianwanghai/blog/1031031\" target=\"_blank\" rel=\"noopener\">《详解滑动验证码的实现原理》</a></p>\n<ul>\n<li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/xcj26/p/5242758.html\" target=\"_blank\" rel=\"noopener\">《淘宝滑动验证码研究》</a></p>\n</li>\n</ul>\n<h2 id=\"DDoS-防范\"><a href=\"#DDoS-防范\" class=\"headerlink\" title=\"DDoS 防范\"></a>DDoS 防范</h2><ul>\n<li><a href=\"http://netsecurity.51cto.com/art/201601/503799.htm\" target=\"_blank\" rel=\"noopener\">《学习手册：DDoS的攻击方式及防御手段》</a></li>\n<li><a href=\"http://netsecurity.51cto.com/art/201406/442756.htm\" target=\"_blank\" rel=\"noopener\">《免费DDoS攻击测试工具大合集》</a></li>\n</ul>\n<h2 id=\"用户隐私信息保护\"><a href=\"#用户隐私信息保护\" class=\"headerlink\" title=\"用户隐私信息保护\"></a>用户隐私信息保护</h2><ol>\n<li>用户密码非明文保存，加动态salt。</li>\n<li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li>\n<li>联系方式在的显示与否由用户自己控制。</li>\n<li>TODO</li>\n</ol>\n<ul>\n<li><a href=\"https://zhidao.baidu.com/question/1988017976673661587.html\" target=\"_blank\" rel=\"noopener\">《个人隐私包括哪些》</a></li>\n<li><p><a href=\"https://www.zhihu.com/question/20137108\" target=\"_blank\" rel=\"noopener\">《在互联网上，隐私的范围包括哪些？》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html\" target=\"_blank\" rel=\"noopener\">《用户密码保存》</a></p>\n</li>\n</ul>\n<h2 id=\"序列化漏洞\"><a href=\"#序列化漏洞\" class=\"headerlink\" title=\"序列化漏洞\"></a>序列化漏洞</h2><ul>\n<li><a href=\"https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/\" target=\"_blank\" rel=\"noopener\">《Lib之过？Java反序列化漏洞通用利用分析》</a></li>\n</ul>\n<h2 id=\"加密解密\"><a href=\"#加密解密\" class=\"headerlink\" title=\"加密解密\"></a>加密解密</h2><h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html\" target=\"_blank\" rel=\"noopener\">《常见对称加密算法》</a><ul>\n<li>DES、3DES、Blowfish、AES</li>\n<li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li>\n<li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html\" target=\"_blank\" rel=\"noopener\">《常用的哈希算法》</a></p>\n<ul>\n<li>MD5 和 SHA-1 已经不再安全，已被弃用。</li>\n<li>目前 SHA-256 是比较安全的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhangruhong168/article/details/78033202\" target=\"_blank\" rel=\"noopener\">《基于Hash摘要签名的公网URL签名验证设计方案》</a></p>\n</li>\n</ul>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html\" target=\"_blank\" rel=\"noopener\">《常见非对称加密算法》</a></p>\n<ul>\n<li>RSA、DSA、ECDSA(螺旋曲线加密算法)</li>\n<li>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</li>\n<li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p>\n<p>  <a href=\"http://baijiahao.baidu.com/s?id=1578348858092033763&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">《区块链的加密技术》</a>    </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务器安全\"><a href=\"#服务器安全\" class=\"headerlink\" title=\"服务器安全\"></a>服务器安全</h2><ul>\n<li><a href=\"http://www.freebuf.com/articles/system/121540.html\" target=\"_blank\" rel=\"noopener\">《Linux强化论：15步打造一个安全的Linux服务器》</a></li>\n</ul>\n<h2 id=\"数据安全\"><a href=\"#数据安全\" class=\"headerlink\" title=\"数据安全\"></a>数据安全</h2><h3 id=\"数据备份\"><a href=\"#数据备份\" class=\"headerlink\" title=\"数据备份\"></a>数据备份</h3><p>TODO</p>\n<h2 id=\"网络隔离\"><a href=\"#网络隔离\" class=\"headerlink\" title=\"网络隔离\"></a>网络隔离</h2><h3 id=\"内外网分离\"><a href=\"#内外网分离\" class=\"headerlink\" title=\"内外网分离\"></a>内外网分离</h3><p>TODO</p>\n<h3 id=\"登录跳板机\"><a href=\"#登录跳板机\" class=\"headerlink\" title=\"登录跳板机\"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p>\n<ul>\n<li><a href=\"http://blog.51cto.com/zero01/2062618\" target=\"_blank\" rel=\"noopener\">《搭建简易堡垒机》</a></li>\n</ul>\n<h2 id=\"授权、认证\"><a href=\"#授权、认证\" class=\"headerlink\" title=\"授权、认证\"></a>授权、认证</h2><h3 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h3><ul>\n<li><a href=\"https://www.cnblogs.com/zq8024/p/5003050.html\" target=\"_blank\" rel=\"noopener\">《基于组织角色的权限设计》</a></li>\n<li><a href=\"https://www.cnblogs.com/shijiaqi1066/p/3793894.html\" target=\"_blank\" rel=\"noopener\">《权限系统与RBAC模型概述》</a></li>\n<li><a href=\"https://blog.csdn.net/he90227/article/details/38663553\" target=\"_blank\" rel=\"noopener\">《Spring整合Shiro做权限控制模块详细案例分析》</a></li>\n</ul>\n<h3 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">《理解OAuth 2.0》</a></li>\n<li><a href=\"https://www.cnblogs.com/flashsun/p/7424071.html\" target=\"_blank\" rel=\"noopener\">《一张图搞定OAuth2.0》</a></li>\n</ul>\n<h3 id=\"双因素认证（2FA）\"><a href=\"#双因素认证（2FA）\" class=\"headerlink\" title=\"双因素认证（2FA）\"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p>\n<p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p>\n<ul>\n<li>【《双因素认证（2FA）教程》】(<a href=\"http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a>)</li>\n</ul>\n<h3 id=\"单点登录-SSO\"><a href=\"#单点登录-SSO\" class=\"headerlink\" title=\"单点登录(SSO)\"></a>单点登录(SSO)</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/ywlaker/p/6113927.html\" target=\"_blank\" rel=\"noopener\">《单点登录原理与简单实现》</a></p>\n</li>\n<li><p><a href=\"https://github.com/apereo/cas\" target=\"_blank\" rel=\"noopener\">CAS单点登录框架</a></p>\n</li>\n</ul>\n<h1 id=\"常用开源框架\"><a href=\"#常用开源框架\" class=\"headerlink\" title=\"常用开源框架\"></a>常用开源框架</h1><h2 id=\"开源协议\"><a href=\"#开源协议\" class=\"headerlink\" title=\"开源协议\"></a>开源协议</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html\" target=\"_blank\" rel=\"noopener\">《开源协议的选择》</a></p>\n</li>\n<li><p><a href=\"http://choosealicense.online/\" target=\"_blank\" rel=\"noopener\">如何选择一个开源软件协议</a></p>\n</li>\n</ul>\n<h2 id=\"日志框架\"><a href=\"#日志框架\" class=\"headerlink\" title=\"日志框架\"></a>日志框架</h2><h3 id=\"Log4j、Log4j2\"><a href=\"#Log4j、Log4j2\" class=\"headerlink\" title=\"Log4j、Log4j2\"></a>Log4j、Log4j2</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012422446/article/details/51199724\" target=\"_blank\" rel=\"noopener\">《log4j 详细讲解》</a></li>\n<li><a href=\"https://blog.csdn.net/vbirdbest/article/details/71751835\" target=\"_blank\" rel=\"noopener\">《log4j2 实际使用详解》</a></li>\n<li><a href=\"https://my.oschina.net/OutOfMemory/blog/789267\" target=\"_blank\" rel=\"noopener\">《Log4j1,Logback以及Log4j2性能测试对比》</a><ul>\n<li>Log4J 异步日志性能优异。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Logback\"><a href=\"#Logback\" class=\"headerlink\" title=\"Logback\"></a>Logback</h3><ul>\n<li><a href=\"https://blog.csdn.net/rulon147/article/details/52620541\" target=\"_blank\" rel=\"noopener\">《最全LogBack 详解、含java案例和配置说明》</a></li>\n</ul>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><ul>\n<li><a href=\"https://blog.csdn.net/sinat_34093604/article/details/53082000\" target=\"_blank\" rel=\"noopener\">《ORM框架使用优缺点》</a><ul>\n<li>主要目的是为了提高开发效率。 </li>\n</ul>\n</li>\n</ul>\n<p><strong>MyBatis：</strong></p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/winclpt/articles/7511672.html\" target=\"_blank\" rel=\"noopener\">《mybatis缓存机制详解》</a></p>\n<ul>\n<li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li>\n<li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/baidu_32877851/article/details/53959268\" target=\"_blank\" rel=\"noopener\">《MyBatis学习之代码生成器Generator》</a></p>\n</li>\n</ul>\n<h2 id=\"网络框架\"><a href=\"#网络框架\" class=\"headerlink\" title=\"网络框架\"></a>网络框架</h2><p>TODO</p>\n<h2 id=\"Web-框架\"><a href=\"#Web-框架\" class=\"headerlink\" title=\"Web 框架\"></a>Web 框架</h2><h3 id=\"Spring-家族\"><a href=\"#Spring-家族\" class=\"headerlink\" title=\"Spring 家族\"></a>Spring 家族</h3><p><strong>Spring</strong></p>\n<ul>\n<li><a href=\"https://www.w3cschool.cn/wkspring/\" target=\"_blank\" rel=\"noopener\">Spring 简明教程</a></li>\n</ul>\n<p><strong>Spring Boot</strong></p>\n<ul>\n<li><a href=\"http://projects.spring.io/spring-boot/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">《Spring Boot基础教程》</a></li>\n</ul>\n<p><strong>Spring Cloud</strong></p>\n<ul>\n<li><a href=\"http://springboot.fun/\" target=\"_blank\" rel=\"noopener\">Spring Boot 中文索引站</a></li>\n<li><a href=\"https://springcloud.cc/\" target=\"_blank\" rel=\"noopener\">Spring Cloud 中文文档</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">《Spring Cloud基础教程》</a></li>\n</ul>\n<h2 id=\"工具框架\"><a href=\"#工具框架\" class=\"headerlink\" title=\"工具框架\"></a>工具框架</h2><ul>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4872236.html\" target=\"_blank\" rel=\"noopener\">《Apache Commons 工具类介绍及简单使用》</a></li>\n<li><a href=\"http://ifeve.com/google-guava/\" target=\"_blank\" rel=\"noopener\">《Google guava 中文教程》</a></li>\n</ul>\n<h1 id=\"分布式设计\"><a href=\"#分布式设计\" class=\"headerlink\" title=\"分布式设计\"></a>分布式设计</h1><h2 id=\"扩展性设计\"><a href=\"#扩展性设计\" class=\"headerlink\" title=\"扩展性设计\"></a>扩展性设计</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/hemin1003/article/details/53633926\" target=\"_blank\" rel=\"noopener\">《架构师不可不知的十大可扩展架构》</a></p>\n<ul>\n<li>总结下来，通用的套路就是分布、缓存及异步处理。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://yq.aliyun.com/articles/38119\" target=\"_blank\" rel=\"noopener\">《可扩展性设计之数据切分》</a></p>\n<ul>\n<li>水平切分+垂直切分</li>\n<li>利用中间件进行分片如，MySQL Proxy。</li>\n<li>利用分片策略进行切分，如按照ID取模。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/deniro_li/article/details/78458306\" target=\"_blank\" rel=\"noopener\">《说说如何实现可扩展性的大型网站架构》</a></p>\n<ul>\n<li>分布式服务+消息队列。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chaofanwei/article/details/29191073\" target=\"_blank\" rel=\"noopener\">《大型网站技术架构（七）–网站的可扩展性架构》</a></p>\n</li>\n</ul>\n<h2 id=\"稳定性-amp-高可用\"><a href=\"#稳定性-amp-高可用\" class=\"headerlink\" title=\"稳定性 &amp; 高可用\"></a>稳定性 &amp; 高可用</h2><ul>\n<li><a href=\"https://blog.csdn.net/hustspy1990/article/details/78008324\" target=\"_blank\" rel=\"noopener\">《系统设计：关于高可用系统的一些技术方案》</a><ul>\n<li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li>\n<li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li>\n<li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li>\n<li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li>\n<li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li>\n<li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li>\n<li>自动化测试：通过完善的测试，减少发布引起的故障。</li>\n<li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><a href=\"https://coolshell.cn/articles/17459.html\" target=\"_blank\" rel=\"noopener\">《关于高可用的系统》</a><ul>\n<li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"硬件负载均衡\"><a href=\"#硬件负载均衡\" class=\"headerlink\" title=\"硬件负载均衡\"></a>硬件负载均衡</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/wuyun-blog/p/6186198.html\" target=\"_blank\" rel=\"noopener\">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a></p>\n<ul>\n<li>主要是和F5对比。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lcword/p/5773296.html\" target=\"_blank\" rel=\"noopener\">《软/硬件负载均衡产品 你知多少？》</a></p>\n</li>\n</ul>\n<h3 id=\"软件负载均衡\"><a href=\"#软件负载均衡\" class=\"headerlink\" title=\"软件负载均衡\"></a>软件负载均衡</h3><ul>\n<li><a href=\"https://www.cnblogs.com/tianzhiliang/articles/2317808.html\" target=\"_blank\" rel=\"noopener\">《几种负载均衡算法》</a><br>  轮寻、权重、负载、最少连接、QoS</li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html\" target=\"_blank\" rel=\"noopener\">《DNS负载均衡》</a><ul>\n<li>配置简单，更新速度慢。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html\" target=\"_blank\" rel=\"noopener\">《Nginx负载均衡》</a></p>\n<ul>\n<li>简单轻量、学习成本低；主要适用于web应用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/edisonchou/p/4281978.html\" target=\"_blank\" rel=\"noopener\">《借助LVS+Keepalived实现负载均衡 》</a></p>\n<ul>\n<li>配置比较负载、只支持到4层，性能较高。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ttlsa.com/linux/haproxy-study-tutorial/\" target=\"_blank\" rel=\"noopener\">《HAProxy用法详解 全网最详细中文文档》</a></p>\n<ul>\n<li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.itpub.net/25704976/viewspace-1319781/\" target=\"_blank\" rel=\"noopener\">《Haproxy+Keepalived+MySQL实现读均衡负载》</a></p>\n<ul>\n<li>主要是用户读请求的负载均衡。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lylife/p/5584019.html\" target=\"_blank\" rel=\"noopener\">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></p>\n</li>\n</ul>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><ul>\n<li><a href=\"https://www.cnblogs.com/haoxinyue/p/6792309.html\" target=\"_blank\" rel=\"noopener\">《谈谈高并发系统的限流》</a><ul>\n<li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li>\n<li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li>\n<li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li>\n<li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层容灾\"><a href=\"#应用层容灾\" class=\"headerlink\" title=\"应用层容灾\"></a>应用层容灾</h3><ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000005988895\" target=\"_blank\" rel=\"noopener\">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a></p>\n<ul>\n<li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 </li>\n<li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li>\n<li>Hystrix设计原则：<ul>\n<li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li>\n<li>熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。</li>\n<li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\" target=\"_blank\" rel=\"noopener\">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\" target=\"_blank\" rel=\"noopener\">《缓存击穿、失效以及热点key问题》</a> <ul>\n<li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li>\n<li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"跨机房容灾\"><a href=\"#跨机房容灾\" class=\"headerlink\" title=\"跨机房容灾\"></a>跨机房容灾</h3><ul>\n<li><p><a href=\"http://dc.idcquan.com/ywgl/71559.shtml\" target=\"_blank\" rel=\"noopener\">《“异地多活”多机房部署经验谈》</a></p>\n<ul>\n<li>通过自研中间件进行数据同步。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/jeffreynicole/article/details/48135093\" target=\"_blank\" rel=\"noopener\">《异地多活（异地双活）实践经验》</a></p>\n<ul>\n<li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li>\n<li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li>\n<li>不能依赖于程序端数据双写，要有自动同步方案。 </li>\n<li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li>\n<li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li>\n<li>异地多活监控部署、测试也要跟上。</li>\n<li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li>\n<li>控制跨机房消息体大小，越小越好。</li>\n<li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yoara/article/details/38013751\" target=\"_blank\" rel=\"noopener\">容灾技术及建设经验介绍</a></p>\n</li>\n</ul>\n<h3 id=\"容灾演练流程\"><a href=\"#容灾演练流程\" class=\"headerlink\" title=\"容灾演练流程\"></a>容灾演练流程</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650996320&amp;idx=1&amp;sn=0ed3be190bbee4a9277886ef88cbb2e5\" target=\"_blank\" rel=\"noopener\">《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》</a><ul>\n<li>常见故障画像</li>\n<li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平滑启动\"><a href=\"#平滑启动\" class=\"headerlink\" title=\"平滑启动\"></a>平滑启动</h3><ul>\n<li><p>平滑重启应用思路<br>1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011001084/article/details/73480432\" target=\"_blank\" rel=\"noopener\">《JVM安全退出（如何优雅的关闭java服务）》</a><br>推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</p>\n</li>\n<li><a href=\"http://ju.outofmemory.cn/entry/337235\" target=\"_blank\" rel=\"noopener\">《常见Java应用如何优雅关闭》</a><br>Java、Srping、Dubbo 优雅关闭方式。</li>\n</ul>\n<h2 id=\"数据库扩展\"><a href=\"#数据库扩展\" class=\"headerlink\" title=\"数据库扩展\"></a>数据库扩展</h2><h3 id=\"读写分离模式\"><a href=\"#读写分离模式\" class=\"headerlink\" title=\"读写分离模式\"></a>读写分离模式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/houdj/p/6563771.html\" target=\"_blank\" rel=\"noopener\">《Mysql主从方案的实现》</a></li>\n<li><a href=\"https://www.cnblogs.com/edisonchou/p/4133148.html\" target=\"_blank\" rel=\"noopener\">《搭建MySQL主从复制经典架构》</a></li>\n<li><p><a href=\"https://blog.csdn.net/nimasike/article/details/48048341\" target=\"_blank\" rel=\"noopener\">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhangsubai/p/6801764.html\" target=\"_blank\" rel=\"noopener\">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a></p>\n<ul>\n<li>DRDB 进行磁盘复制，避免单点问题。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html\" target=\"_blank\" rel=\"noopener\">《MySQL Cluster 方式》</a></p>\n</li>\n</ul>\n<h3 id=\"分片模式\"><a href=\"#分片模式\" class=\"headerlink\" title=\"分片模式\"></a>分片模式</h3><ul>\n<li><p><a href=\"https://www.jianshu.com/p/32b3e91aa22c\" target=\"_blank\" rel=\"noopener\">《分库分表需要考虑的问题及方案》</a></p>\n<ul>\n<li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li>\n<li>问题：事务、Join、迁移、扩容、ID、分页等。</li>\n<li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li>\n<li>分库策略：数值范围；取模；日期等。</li>\n<li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201503/380348.html\" target=\"_blank\" rel=\"noopener\">《MySql分表和表分区详解》</a></p>\n<ul>\n<li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li>\n<li>分表：物理上创建不同的表、客户端需要管理分表路由。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h2><h3 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h3><ul>\n<li><a href=\"https://blog.csdn.net/jiaolongdy/article/details/51188798\" target=\"_blank\" rel=\"noopener\">《永不失联！如何实现微服务架构中的服务发现？》</a><ul>\n<li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li>\n<li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u010963948/article/details/71730165\" target=\"_blank\" rel=\"noopener\">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a></p>\n<ul>\n<li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li>\n<li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://mobile.51cto.com/news-502394.htm\" target=\"_blank\" rel=\"noopener\">《基于Zookeeper的服务注册与发现》</a></p>\n<ul>\n<li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务路由控制\"><a href=\"#服务路由控制\" class=\"headerlink\" title=\"服务路由控制\"></a>服务路由控制</h3><ul>\n<li><a href=\"https://blog.csdn.net/xundh/article/details/59492750\" target=\"_blank\" rel=\"noopener\">《分布式服务框架学习笔记4 服务路由》</a><ul>\n<li>原则：透明化路由</li>\n<li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li>\n<li>本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li>\n<li>配置方式：统一注册表；本地配置；动态下发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式一致\"><a href=\"#分布式一致\" class=\"headerlink\" title=\"分布式一致\"></a>分布式一致</h2><h3 id=\"CAP-与-BASE-理论\"><a href=\"#CAP-与-BASE-理论\" class=\"headerlink\" title=\"CAP 与 BASE 理论\"></a>CAP 与 BASE 理论</h3><ul>\n<li><a href=\"http://www.cnblogs.com/szlbm/p/5588543.html\" target=\"_blank\" rel=\"noopener\">《从分布式一致性谈到CAP理论、BASE理论》</a><ul>\n<li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li>\n<li>CAP：一致性、可用性、分区容错性(网络故障引起)</li>\n<li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li>\n<li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><a href=\"http://www.hollischuang.com/archives/1716\" target=\"_blank\" rel=\"noopener\">《分布式锁的几种实现方式》</a><ul>\n<li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li>\n<li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li>\n<li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.tuicool.com/articles/VZJr6fY\" target=\"_blank\" rel=\"noopener\">《基于Zookeeper的分布式锁》</a></p>\n<ul>\n<li>清楚的原理描述 + Java 代码示例。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/0201zcr/p/5942748.html\" target=\"_blank\" rel=\"noopener\">《jedisLock—redis分布式锁实现》</a></p>\n<ul>\n<li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/albertfly/article/details/77412333\" target=\"_blank\" rel=\"noopener\">《Memcached 和 Redis 分布式锁方案》</a></p>\n<ul>\n<li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致性算法\"><a href=\"#分布式一致性算法\" class=\"headerlink\" title=\"分布式一致性算法\"></a>分布式一致性算法</h3><h4 id=\"PAXOS\"><a href=\"#PAXOS\" class=\"headerlink\" title=\"PAXOS\"></a>PAXOS</h4><ul>\n<li><a href=\"https://www.cnblogs.com/linbingdong/p/6253479.html\" target=\"_blank\" rel=\"noopener\">《分布式系列文章——Paxos算法原理与推导》</a></li>\n<li><a href=\"https://blog.csdn.net/u010039929/article/details/70171672\" target=\"_blank\" rel=\"noopener\">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li>\n<li><a href=\"https://www.cnblogs.com/leesf456/p/6012777.html\" target=\"_blank\" rel=\"noopener\">《【分布式】Zookeeper与Paxos》</a></li>\n</ul>\n<h4 id=\"Zab\"><a href=\"#Zab\" class=\"headerlink\" title=\"Zab\"></a>Zab</h4><ul>\n<li><a href=\"https://www.jianshu.com/p/fb527a64deee\" target=\"_blank\" rel=\"noopener\">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li>\n</ul>\n<h4 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h4><ul>\n<li><a href=\"http://www.cnblogs.com/mindwind/p/5231986.html\" target=\"_blank\" rel=\"noopener\">《Raft 为什么是更易理解的分布式一致性算法》</a><ul>\n<li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li>\n<li>通过随机等待的方式发出投票，得票多的获胜。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Gossip\"><a href=\"#Gossip\" class=\"headerlink\" title=\"Gossip\"></a>Gossip</h4><ul>\n<li><a href=\"http://blog.51cto.com/tianya23/530743\" target=\"_blank\" rel=\"noopener\">《Gossip算法》</a></li>\n</ul>\n<h4 id=\"两阶段提交、多阶段提交\"><a href=\"#两阶段提交、多阶段提交\" class=\"headerlink\" title=\"两阶段提交、多阶段提交\"></a>两阶段提交、多阶段提交</h4><ul>\n<li><a href=\"http://blog.jobbole.com/95632/\" target=\"_blank\" rel=\"noopener\">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li>\n</ul>\n<h3 id=\"幂等\"><a href=\"#幂等\" class=\"headerlink\" title=\"幂等\"></a>幂等</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wxgblogs/p/6639272.html\" target=\"_blank\" rel=\"noopener\">《分布式系统—幂等性设计》</a><ul>\n<li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li>\n<li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致方案\"><a href=\"#分布式一致方案\" class=\"headerlink\" title=\"分布式一致方案\"></a>分布式一致方案</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency\" target=\"_blank\" rel=\"noopener\">《分布式系统事务一致性解决方案》</a></li>\n<li><a href=\"https://weibo.com/ttarticle/p/show?id=2309403965965003062676\" target=\"_blank\" rel=\"noopener\">《保证分布式系统数据一致性的6种方案》</a></li>\n</ul>\n<h3 id=\"分布式-Leader-节点选举\"><a href=\"#分布式-Leader-节点选举\" class=\"headerlink\" title=\"分布式 Leader 节点选举\"></a>分布式 Leader 节点选举</h3><ul>\n<li><a href=\"https://blog.csdn.net/johnson_moon/article/details/78809995\" target=\"_blank\" rel=\"noopener\">《利用zookeeper实现分布式leader节点选举》</a></li>\n</ul>\n<h3 id=\"TCC-Try-Confirm-Cancel-柔性事务\"><a href=\"#TCC-Try-Confirm-Cancel-柔性事务\" class=\"headerlink\" title=\"TCC(Try/Confirm/Cancel) 柔性事务\"></a>TCC(Try/Confirm/Cancel) 柔性事务</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/ab1a1c6b08a1\" target=\"_blank\" rel=\"noopener\">《传统事务与柔性事务》</a><ul>\n<li>基于BASE理论：基本可用、柔性状态、最终一致。</li>\n<li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式文件系统\"><a href=\"#分布式文件系统\" class=\"headerlink\" title=\"分布式文件系统\"></a>分布式文件系统</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27666295\" target=\"_blank\" rel=\"noopener\">说说分布式文件存储系统-基本架构</a> ？</li>\n<li><a href=\"https://blog.csdn.net/gatieme/article/details/44982961\" target=\"_blank\" rel=\"noopener\">《各种分布式文件系统的比较》</a> ？<ul>\n<li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li>\n<li>FastDFS：轻量级、适合小文件。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"唯一ID-生成\"><a href=\"#唯一ID-生成\" class=\"headerlink\" title=\"唯一ID 生成\"></a>唯一ID 生成</h2><h3 id=\"全局唯一ID\"><a href=\"#全局唯一ID\" class=\"headerlink\" title=\"全局唯一ID\"></a>全局唯一ID</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/baiwa/p/5318432.html\" target=\"_blank\" rel=\"noopener\">《高并发分布式系统中生成全局唯一Id汇总》</a></p>\n<ul>\n<li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li>\n<li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” </li>\n<li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li>\n<li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/hdu09075340/article/details/79103851\" target=\"_blank\" rel=\"noopener\">《TDDL 在分布式下的SEQUENCE原理》</a></p>\n<ul>\n<li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li>\n<li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li>\n<li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一致性Hash算法\"><a href=\"#一致性Hash算法\" class=\"headerlink\" title=\"一致性Hash算法\"></a>一致性Hash算法</h2><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html\" target=\"_blank\" rel=\"noopener\">《一致性哈希算法》</a></li>\n</ul>\n<h1 id=\"设计思想-amp-开发模式\"><a href=\"#设计思想-amp-开发模式\" class=\"headerlink\" title=\"设计思想 &amp; 开发模式\"></a>设计思想 &amp; 开发模式</h1><h2 id=\"DDD-Domain-driven-Design-领域驱动设计\"><a href=\"#DDD-Domain-driven-Design-领域驱动设计\" class=\"headerlink\" title=\"DDD(Domain-driven Design - 领域驱动设计)\"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/netfocus/p/5548025.html\" target=\"_blank\" rel=\"noopener\">《浅谈我对DDD领域驱动设计的理解》</a></p>\n<ul>\n<li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li>\n<li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li>\n<li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/butterfly100/p/7827870.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计的基础知识总结》</a></p>\n<ul>\n<li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li>\n<li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li>\n<li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li>\n<li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li>\n<li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li>\n<li>使用的模式：<ul>\n<li>关联尽量少，尽量单项，尽量降低整体复杂度。</li>\n<li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li>\n<li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li>\n<li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li>\n<li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li>\n<li>工厂（Factory）：类似于设计模式中的工厂模式。</li>\n<li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Leo_wl/p/3866629.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计(DDD)实现之路》</a></p>\n<ul>\n<li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.hollischuang.com/archives/553\" target=\"_blank\" rel=\"noopener\">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></p>\n</li>\n</ul>\n<h3 id=\"命令查询职责分离-CQRS\"><a href=\"#命令查询职责分离-CQRS\" class=\"headerlink\" title=\"命令查询职责分离(CQRS)\"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/cnblogsfans/p/4551990.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计系列 (六)：CQRS》</a></p>\n<ul>\n<li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml\" target=\"_blank\" rel=\"noopener\">《DDD CQRS架构和传统架构的优缺点比较》</a></p>\n<ul>\n<li>最终一致的设计理念；依赖于高可用消息中间件。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/netfocus/p/4055346.html\" target=\"_blank\" rel=\"noopener\">《CQRS架构简介》</a></p>\n<ul>\n<li>一个实现 CQRS 的抽象案例。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.uml.org.cn/zjjs/201609221.asp\" target=\"_blank\" rel=\"noopener\">《深度长文：我对CQRS/EventSourcing架构的思考》</a></p>\n<ul>\n<li>CQRS 模式分析 + 12306 抢票案例</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"贫血，充血模型\"><a href=\"#贫血，充血模型\" class=\"headerlink\" title=\"贫血，充血模型\"></a>贫血，充血模型</h3><ul>\n<li><a href=\"https://kb.cnblogs.com/page/520743/\" target=\"_blank\" rel=\"noopener\">《贫血，充血模型的解释以及一些经验》</a><ul>\n<li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li>\n<li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li>\n<li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li>\n<li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li>\n<li>作者主张使用贫血模式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Actor-模式\"><a href=\"#Actor-模式\" class=\"headerlink\" title=\"Actor 模式\"></a>Actor 模式</h2><p>TODO</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><h3 id=\"Reactor\"><a href=\"#Reactor\" class=\"headerlink\" title=\"Reactor\"></a>Reactor</h3><p>TODO</p>\n<h3 id=\"RxJava\"><a href=\"#RxJava\" class=\"headerlink\" title=\"RxJava\"></a>RxJava</h3><p>TODO</p>\n<h3 id=\"Vert-x\"><a href=\"#Vert-x\" class=\"headerlink\" title=\"Vert.x\"></a>Vert.x</h3><p>TODO</p>\n<h2 id=\"DODAF2-0\"><a href=\"#DODAF2-0\" class=\"headerlink\" title=\"DODAF2.0\"></a>DODAF2.0</h2><ul>\n<li><a href=\"http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml\" target=\"_blank\" rel=\"noopener\">《DODAF2.0方法论》</a></li>\n<li><a href=\"http://blog.51cto.com/xiaoyong/1553164\" target=\"_blank\" rel=\"noopener\">《DODAF2.0之能力视角如何落地》</a></li>\n</ul>\n<h2 id=\"Serverless\"><a href=\"#Serverless\" class=\"headerlink\" title=\"Serverless\"></a>Serverless</h2><p>无需过多关系服务器的服务架构理念。</p>\n<ul>\n<li><p><a href=\"http://www.jdon.com/soa/serverless.html\" target=\"_blank\" rel=\"noopener\">《什么是Serverless无服务器架构？》</a></p>\n<ul>\n<li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li>\n<li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li>\n<li>Serverless 不代表某个具体的框架。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless\" target=\"_blank\" rel=\"noopener\">《如何理解Serverless？》</a></p>\n<ul>\n<li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Service-Mesh\"><a href=\"#Service-Mesh\" class=\"headerlink\" title=\"Service Mesh\"></a>Service Mesh</h2><ul>\n<li><a href=\"https://time.geekbang.org/article/2355\" target=\"_blank\" rel=\"noopener\">《什么是Service Mesh？》</a></li>\n<li><p><a href=\"https://www.jianshu.com/p/e23e3e74538e\" target=\"_blank\" rel=\"noopener\">《初识 Service Mesh》</a></p>\n</li>\n<li><p><a href=\"https://time.geekbang.org/article/2355\" target=\"_blank\" rel=\"noopener\">《什么是Service Mesh？》</a></p>\n</li>\n</ul>\n<h1 id=\"项目管理\"><a href=\"#项目管理\" class=\"headerlink\" title=\"项目管理\"></a>项目管理</h1><h2 id=\"架构评审\"><a href=\"#架构评审\" class=\"headerlink\" title=\"架构评审\"></a>架构评审</h2><ul>\n<li><a href=\"http://developer.51cto.com/art/201506/478486.htm\" target=\"_blank\" rel=\"noopener\">《架构设计之如何评审架构设计说明书》</a></li>\n<li><a href=\"https://blog.csdn.net/wireless_com/article/details/45935591\" target=\"_blank\" rel=\"noopener\">《人人都是架构师：非功能性需求》</a></li>\n</ul>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/architect-12-rules-complete/\" target=\"_blank\" rel=\"noopener\">《架构之重构的12条军规》</a></li>\n</ul>\n<h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><ul>\n<li><a href=\"https://github.com/alibaba/p3c\" target=\"_blank\" rel=\"noopener\">《阿里巴巴Java开发手册》</a></li>\n</ul>\n<h2 id=\"代码-Review\"><a href=\"#代码-Review\" class=\"headerlink\" title=\"代码 Review\"></a>代码 Review</h2><p>制度还是制度!<br>另外，每个公司需要根据自己的需求和目标制定自己的 check list</p>\n<ul>\n<li><p><a href=\"http://www.sohu.com/a/229745352_181657\" target=\"_blank\" rel=\"noopener\">《为什么你做不好 Code Review？》</a></p>\n<ul>\n<li>代码 review 做的好，在于制度建设。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/uxyheaven/article/details/49773619\" target=\"_blank\" rel=\"noopener\">《从零开始Code Review》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zuoping/p/5477047.html\" target=\"_blank\" rel=\"noopener\">《Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://dzone.com/articles/java-code-review-checklist\" target=\"_blank\" rel=\"noopener\">《Java Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/legend0011/article/details/45585575\" target=\"_blank\" rel=\"noopener\">《如何用 gitlab 做 code review》</a></p>\n</li>\n</ul>\n<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2><ul>\n<li><a href=\"https://blog.csdn.net/apanious/article/details/51011946\" target=\"_blank\" rel=\"noopener\">《运用RUP 4+1视图方法进行软件架构设计》</a></li>\n</ul>\n<h2 id=\"看板管理\"><a href=\"#看板管理\" class=\"headerlink\" title=\"看板管理\"></a>看板管理</h2><ul>\n<li><a href=\"https://blog.csdn.net/tkchen/article/details/51637643\" target=\"_blank\" rel=\"noopener\">《说说看板在项目中的应用》</a></li>\n</ul>\n<h2 id=\"SCRUM\"><a href=\"#SCRUM\" class=\"headerlink\" title=\"SCRUM\"></a>SCRUM</h2><p>SCRUM - 争球</p>\n<ul>\n<li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li>\n<li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li>\n<li>五个价值观：专注、勇气、公开、承诺、尊重。</li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/inny100_100/article/details/54633757\" target=\"_blank\" rel=\"noopener\">《敏捷项目管理流程-Scrum框架最全总结！》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/superkunkun/article/details/52951142\" target=\"_blank\" rel=\"noopener\">《敏捷其实很简单3—敏捷方法之scrum》</a></p>\n</li>\n</ul>\n<h2 id=\"敏捷开发\"><a href=\"#敏捷开发\" class=\"headerlink\" title=\"敏捷开发\"></a>敏捷开发</h2><p>TODO</p>\n<h2 id=\"极限编程（XP）\"><a href=\"#极限编程（XP）\" class=\"headerlink\" title=\"极限编程（XP）\"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p>\n<ul>\n<li><p><a href=\"http://www.woshipm.com/pmd/406917.html\" target=\"_blank\" rel=\"noopener\">《主流敏捷开发方法：极限编程XP》</a></p>\n<ul>\n<li>是一种指导开发人员的方法论。</li>\n<li><p>4大价值：</p>\n<ul>\n<li>沟通：鼓励口头沟通，提高效率。</li>\n<li>简单：够用就好。</li>\n<li>反馈：及时反馈、通知相关人。</li>\n<li>勇气：提倡拥抱变化，敢于重构。</li>\n</ul>\n</li>\n<li><p>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</p>\n</li>\n<li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"结对编程\"><a href=\"#结对编程\" class=\"headerlink\" title=\"结对编程\"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">《结对编程》</a></li>\n</ul>\n<h2 id=\"PDCA-循环质量管理\"><a href=\"#PDCA-循环质量管理\" class=\"headerlink\" title=\"PDCA 循环质量管理\"></a>PDCA 循环质量管理</h2><p>P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/PDCA\" target=\"_blank\" rel=\"noopener\">《PDCA》</a></li>\n</ul>\n<h2 id=\"FMEA管理模式\"><a href=\"#FMEA管理模式\" class=\"headerlink\" title=\"FMEA管理模式\"></a>FMEA管理模式</h2><p>TODO</p>\n<h1 id=\"通用业务术语\"><a href=\"#通用业务术语\" class=\"headerlink\" title=\"通用业务术语\"></a>通用业务术语</h1><p>TODO</p>\n<h1 id=\"技术趋势\"><a href=\"#技术趋势\" class=\"headerlink\" title=\"技术趋势\"></a>技术趋势</h1><p>TODO</p>\n<h1 id=\"政策、法规\"><a href=\"#政策、法规\" class=\"headerlink\" title=\"政策、法规\"></a>政策、法规</h1><p>TODO</p>\n<h2 id=\"法律\"><a href=\"#法律\" class=\"headerlink\" title=\"法律\"></a>法律</h2><h3 id=\"严格遵守刑法253法条\"><a href=\"#严格遵守刑法253法条\" class=\"headerlink\" title=\"严格遵守刑法253法条\"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p>\n<blockquote>\n<ul>\n<li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li>\n<li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 </li>\n<li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li>\n</ul>\n</blockquote>\n<p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA\" target=\"_blank\" rel=\"noopener\">《非法获取公民个人信息罪》</a></li>\n</ul>\n<h1 id=\"架构师素质\"><a href=\"#架构师素质\" class=\"headerlink\" title=\"架构师素质\"></a>架构师素质</h1><ul>\n<li><p><a href=\"http://hellojava.info/?p=430\" target=\"_blank\" rel=\"noopener\">《架构师画像》</a></p>\n<ul>\n<li>业务理解和抽象能力</li>\n<li>NB的代码能力</li>\n<li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； </li>\n<li>全局：是否考虑到了对上下游的系统的影响。</li>\n<li>权衡：权衡投入产出比；优先级和节奏控制；</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know\" target=\"_blank\" rel=\"noopener\">《关于架构优化和设计，架构师必须知道的事情》</a></p>\n<ul>\n<li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。</li>\n<li>基础设施、配置、测试、开发、运维综合考虑。</li>\n<li>考虑人、团队、和组织的影响。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/19841397\" target=\"_blank\" rel=\"noopener\">《如何才能真正的提高自己，成为一名出色的架构师？》</a> </p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129\" target=\"_blank\" rel=\"noopener\">《架构师的必备素质和成长途径》</a></p>\n<ul>\n<li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li>\n<li>成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.51cto.com/frankfan/1248401\" target=\"_blank\" rel=\"noopener\">《架构设计师—你在哪层楼？》</a></p>\n<ul>\n<li>第一层的架构师看到的只是产品本身</li>\n<li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li>\n<li>第三层的架构师看到的是商业价值 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"团队管理\"><a href=\"#团队管理\" class=\"headerlink\" title=\"团队管理\"></a>团队管理</h1><p>TODO</p>\n<h2 id=\"招聘\"><a href=\"#招聘\" class=\"headerlink\" title=\"招聘\"></a>招聘</h2><h1 id=\"资讯\"><a href=\"#资讯\" class=\"headerlink\" title=\"资讯\"></a>资讯</h1><h2 id=\"行业资讯\"><a href=\"#行业资讯\" class=\"headerlink\" title=\"行业资讯\"></a>行业资讯</h2><ul>\n<li><a href=\"http://36kr.com/\" target=\"_blank\" rel=\"noopener\">36kr</a></li>\n<li><a href=\"http://www.techweb.com.cn/\" target=\"_blank\" rel=\"noopener\">Techweb</a></li>\n</ul>\n<h2 id=\"公众号列表\"><a href=\"#公众号列表\" class=\"headerlink\" title=\"公众号列表\"></a>公众号列表</h2><p>TODO</p>\n<h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><h3 id=\"团队博客\"><a href=\"#团队博客\" class=\"headerlink\" title=\"团队博客\"></a>团队博客</h3><ul>\n<li><a href=\"http://jm.taobao.org/\" target=\"_blank\" rel=\"noopener\">阿里中间件博客</a></li>\n<li><a href=\"https://tech.meituan.com\" target=\"_blank\" rel=\"noopener\">美团点评技术团队博客</a></li>\n</ul>\n<h3 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></li>\n<li><a href=\"https://coolshell.cn/\" target=\"_blank\" rel=\"noopener\">酷壳 - COOLSHELL-陈皓</a></li>\n<li><a href=\"http://hellojava.info/\" target=\"_blank\" rel=\"noopener\">hellojava-阿里毕玄</a></li>\n<li><a href=\"http://cmsblogs.com/\" target=\"_blank\" rel=\"noopener\">Cm’s Blog</a></li>\n<li><a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li>\n</ul>\n<h2 id=\"综合门户、社区\"><a href=\"#综合门户、社区\" class=\"headerlink\" title=\"综合门户、社区\"></a>综合门户、社区</h2><p><strong>国内：</strong></p>\n<ul>\n<li><a href=\"http://csdn.net\" target=\"_blank\" rel=\"noopener\">CSDN</a><br>   老牌技术社区、不必解释。</li>\n<li><a href=\"http://www.51cto.com/\" target=\"_blank\" rel=\"noopener\">51cto.com</a></li>\n<li><a href=\"http://www.iteye.com/\" target=\"_blank\" rel=\"noopener\">ITeye</a><ul>\n<li>偏 Java 方向 </li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com\" target=\"_blank\" rel=\"noopener\">博客园</a></li>\n<li><a href=\"http://www.tom.net/\" target=\"_blank\" rel=\"noopener\">ChinaUnix</a><ul>\n<li>偏 Linux 方向 </li>\n</ul>\n</li>\n<li><a href=\"https://www.oschina.net/\" target=\"_blank\" rel=\"noopener\">开源中国社区</a></li>\n<li><a href=\"http://www.open-open.com/\" target=\"_blank\" rel=\"noopener\">深度开源</a></li>\n<li><p><a href=\"http://www.jobbole.com/\" target=\"_blank\" rel=\"noopener\">伯乐在线</a></p>\n<ul>\n<li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.itpub.net/\" target=\"_blank\" rel=\"noopener\">ITPUB</a></p>\n</li>\n<li><a href=\"https://cloud.tencent.com/developer/column\" target=\"_blank\" rel=\"noopener\">腾讯云— 云+社区</a></li>\n<li><a href=\"https://yq.aliyun.com/\" target=\"_blank\" rel=\"noopener\">阿里云— 云栖社区</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/\" target=\"_blank\" rel=\"noopener\">IBM DeveloperWorks</a></li>\n<li><a href=\"https://toutiao.io/\" target=\"_blank\" rel=\"noopener\">开发者头条</a></li>\n<li><a href=\"http://www.linkedkeeper.com\" target=\"_blank\" rel=\"noopener\">LinkedKeeper</a></li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"https://dzone.com\" target=\"_blank\" rel=\"noopener\">DZone</a></li>\n<li><a href=\"https://www.reddit.com\" target=\"_blank\" rel=\"noopener\">Reddit</a></li>\n</ul>\n<h2 id=\"问答、讨论类社区\"><a href=\"#问答、讨论类社区\" class=\"headerlink\" title=\"问答、讨论类社区\"></a>问答、讨论类社区</h2><ul>\n<li><a href=\"https://segmentfault.com\" target=\"_blank\" rel=\"noopener\">segmentfault</a><ul>\n<li>问答+专栏 </li>\n</ul>\n</li>\n<li><a href=\"https://www.zhihu.com/\" target=\"_blank\" rel=\"noopener\">知乎</a></li>\n<li><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></li>\n</ul>\n<h2 id=\"行业数据分析\"><a href=\"#行业数据分析\" class=\"headerlink\" title=\"行业数据分析\"></a>行业数据分析</h2><ul>\n<li><a href=\"http://report.iresearch.cn/\" target=\"_blank\" rel=\"noopener\">艾瑞网</a></li>\n<li><p><a href=\"https://www.questmobile.com.cn\" target=\"_blank\" rel=\"noopener\">QUEST MOBILE</a></p>\n</li>\n<li><p><a href=\"http://data.stats.gov.cn/\" target=\"_blank\" rel=\"noopener\">国家数据</a></p>\n</li>\n<li><p><a href=\"http://www.talkingdata.com/\" target=\"_blank\" rel=\"noopener\">TalkingData</a></p>\n</li>\n</ul>\n<h2 id=\"专项网站\"><a href=\"#专项网站\" class=\"headerlink\" title=\"专项网站\"></a>专项网站</h2><ul>\n<li><p>测试:</p>\n<ul>\n<li><a href=\"http://www.ltesting.net/\" target=\"_blank\" rel=\"noopener\">领测国际</a> </li>\n<li><a href=\"https://www.testwo.com/\" target=\"_blank\" rel=\"noopener\">测试窝</a></li>\n<li><a href=\"https://testerhome.com\" target=\"_blank\" rel=\"noopener\">TesterHome</a></li>\n</ul>\n</li>\n<li><p>运维:</p>\n<pre><code>* [运维派](http://www.yunweipai.com/) \n* [Abcdocker](https://www.abcdocker.com/)\n</code></pre></li>\n<li><p>Java:</p>\n<ul>\n<li><a href=\"http://www.importnew.com/\" target=\"_blank\" rel=\"noopener\">ImportNew</a><ul>\n<li>专注于 Java 技术分享</li>\n</ul>\n</li>\n<li><a href=\"https://howtodoinjava.com/\" target=\"_blank\" rel=\"noopener\">HowToDoInJava</a><ul>\n<li>英文博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>安全</p>\n<ul>\n<li><a href=\"https://www.2cto.com/\" target=\"_blank\" rel=\"noopener\">红黑联盟</a> </li>\n<li><a href=\"http://www.freebuf.com/\" target=\"_blank\" rel=\"noopener\">FreeBuf</a></li>\n</ul>\n</li>\n<li><p>大数据</p>\n<ul>\n<li><a href=\"http://www.thebigdata.cn/\" target=\"_blank\" rel=\"noopener\">中国大数据</a> </li>\n</ul>\n</li>\n<li><p>其他专题网站：</p>\n<ul>\n<li><a href=\"http://www.dockerinfo.net/\" target=\"_blank\" rel=\"noopener\">DockerInfo</a><ul>\n<li>专注于 Docker 应用及咨询、教程的网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.linuxidc.com/\" target=\"_blank\" rel=\"noopener\">Linux公社</a><ul>\n<li>Linux 主题社区</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其他类\"><a href=\"#其他类\" class=\"headerlink\" title=\"其他类\"></a>其他类</h2><ul>\n<li><a href=\"https://github.com/TeamStuQ/skill-map\" target=\"_blank\" rel=\"noopener\">程序员技能图谱</a></li>\n</ul>\n<h2 id=\"推荐参考书\"><a href=\"#推荐参考书\" class=\"headerlink\" title=\"推荐参考书\"></a>推荐参考书</h2><h3 id=\"在线电子书\"><a href=\"#在线电子书\" class=\"headerlink\" title=\"在线电子书\"></a>在线电子书</h3><ul>\n<li><a href=\"https://github.com/forezp/SpringCloudLearning\" target=\"_blank\" rel=\"noopener\">《深入理解Spring Cloud与微服务构建》</a></li>\n</ul>\n<ul>\n<li><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf\" target=\"_blank\" rel=\"noopener\">《阿里技术参考图册-研发篇》</a></li>\n<li><p><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf\" target=\"_blank\" rel=\"noopener\">《阿里技术参考图册-算法篇》</a></p>\n</li>\n<li><p><a href=\"http://dpurl.cn/n/1lqcX\" target=\"_blank\" rel=\"noopener\">《2018美团点评技术年货（合辑）》70M</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/architect/\" target=\"_blank\" rel=\"noopener\">InfoQ《架构师》月刊</a></p>\n</li>\n<li><p><a href=\"https://www.w3cschool.cn/architectroad/\" target=\"_blank\" rel=\"noopener\">《架构师之路》</a></p>\n</li>\n</ul>\n<h3 id=\"纸质书\"><a href=\"#纸质书\" class=\"headerlink\" title=\"纸质书\"></a>纸质书</h3><h4 id=\"开发方面\"><a href=\"#开发方面\" class=\"headerlink\" title=\"开发方面\"></a>开发方面</h4><ul>\n<li>《阿里巴巴Java开发手册》<a href=\"https://union-click.jd.com/jdc?d=bVKwZQ\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=阿里巴巴Java开发手册\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"架构方面\"><a href=\"#架构方面\" class=\"headerlink\" title=\"架构方面\"></a>架构方面</h4><ul>\n<li>《软件架构师的12项修炼：技术技能篇》<a href=\"https://union-click.jd.com/jdc?d=gXvRd8\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《架构之美》<a href=\"https://union-click.jd.com/jdc?d=xJit5I\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=架构之美\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《分布式服务架构》<a href=\"https://union-click.jd.com/jdc?d=JS5Od9\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=分布式服务架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《聊聊架构》 <a href=\"https://union-click.jd.com/jdc?d=FHooH4\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=聊聊架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《云原生应用架构实践》<a href=\"https://union-click.jd.com/jdc?d=orkJSj\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=云原生应用架构实践\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《亿级流量网站架构核心技术》<a href=\"https://union-click.jd.com/jdc?d=RnOSP5\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=亿级流量网站架构核心技术\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《淘宝技术这十年》<a href=\"https://union-click.jd.com/jdc?d=LwrDfD\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=淘宝技术这十年\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li><p>《企业IT架构转型之道-中台战略思想与架构实战》 <a href=\"https://union-click.jd.com/jdc?d=89pAEm\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=企业IT架构转型之道\" target=\"_blank\" rel=\"noopener\">淘宝</a></p>\n</li>\n<li><p>《高可用架构（第1卷）》<a href=\"https://item.jd.com/12195481.html\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=高可用架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></p>\n</li>\n</ul>\n<h4 id=\"技术管理方面\"><a href=\"#技术管理方面\" class=\"headerlink\" title=\"技术管理方面\"></a>技术管理方面</h4><ul>\n<li>《CTO说》<a href=\"https://union-click.jd.com/jdc?d=zhTZyr\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=CTO说\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《技术管理之巅》<a href=\"https://union-click.jd.com/jdc?d=LgRBUW\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=技术管理之巅\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《网易一千零一夜：互联网产品项目管理实战》<a href=\"https://union-click.jd.com/jdc?d=jcRz2r\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"基础理论-1\"><a href=\"#基础理论-1\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h4><ul>\n<li>《数学之美》<a href=\"https://union-click.jd.com/jdc?d=ghIES2\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=数学之美\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《编程珠玑》<a href=\"https://union-click.jd.com/jdc?d=YmhdEu\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=编程珠玑\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"工具方面\"><a href=\"#工具方面\" class=\"headerlink\" title=\"工具方面\"></a>工具方面</h4><p>TODO</p>\n<h4 id=\"大数据方面\"><a href=\"#大数据方面\" class=\"headerlink\" title=\"大数据方面\"></a>大数据方面</h4><h1 id=\"技术资源\"><a href=\"#技术资源\" class=\"headerlink\" title=\"技术资源\"></a>技术资源</h1><h2 id=\"开源资源\"><a href=\"#开源资源\" class=\"headerlink\" title=\"开源资源\"></a>开源资源</h2><ul>\n<li><p><a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n</li>\n<li><p><a href=\"https://www.apache.org/index.html\" target=\"_blank\" rel=\"noopener\">Apache 软件基金会</a></p>\n</li>\n</ul>\n<h2 id=\"手册、文档、教程\"><a href=\"#手册、文档、教程\" class=\"headerlink\" title=\"手册、文档、教程\"></a>手册、文档、教程</h2><p><strong>国内：</strong></p>\n<ul>\n<li><a href=\"http://w3cschool.cn\" target=\"_blank\" rel=\"noopener\">W3Cschool</a> </li>\n<li><p><a href=\"http://www.runoob.com/\" target=\"_blank\" rel=\"noopener\">Runoob.com</a></p>\n<ul>\n<li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li>\n</ul>\n</li>\n<li><p><a href=\"https://love2.io/\" target=\"_blank\" rel=\"noopener\">Love2.io</a></p>\n<ul>\n<li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.cn/\" target=\"_blank\" rel=\"noopener\">gitbook.cn</a><ul>\n<li>付费电子书。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.apachecn.org/\" target=\"_blank\" rel=\"noopener\">ApacheCN</a><ul>\n<li>AI、大数据方面系列中文文档。</li>\n</ul>\n</li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"http://www.quickcode.co/\" target=\"_blank\" rel=\"noopener\">Quick Code</a><ul>\n<li>免费在线技术教程。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.com\" target=\"_blank\" rel=\"noopener\">gitbook.com</a><ul>\n<li>有部分中文电子书。</li>\n</ul>\n</li>\n<li><a href=\"https://www.cheatography.com/\" target=\"_blank\" rel=\"noopener\">Cheatography</a><ul>\n<li>Cheat Sheets 大全，单页文档网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.tutorialspoint.com/index.htm\" target=\"_blank\" rel=\"noopener\">Tutorialspoint</a><ul>\n<li>知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在线课堂\"><a href=\"#在线课堂\" class=\"headerlink\" title=\"在线课堂\"></a>在线课堂</h2><ul>\n<li><a href=\"http://www.xuetuwuyou.com/\" target=\"_blank\" rel=\"noopener\">学徒无忧</a></li>\n<li><a href=\"https://time.geekbang.org/\" target=\"_blank\" rel=\"noopener\">极客时间</a></li>\n<li><a href=\"https://segmentfault.com/lives\" target=\"_blank\" rel=\"noopener\">segmentfault</a></li>\n<li><a href=\"https://new.stuq.org/course/explore\" target=\"_blank\" rel=\"noopener\">斯达克学院</a></li>\n<li><a href=\"http://nowcoder.com\" target=\"_blank\" rel=\"noopener\">牛客网</a></li>\n<li><a href=\"https://www.jikexueyuan.com/\" target=\"_blank\" rel=\"noopener\">极客学院</a></li>\n<li><a href=\"http://edu.51cto.com/\" target=\"_blank\" rel=\"noopener\">51CTO学院</a></li>\n</ul>\n<h2 id=\"会议、活动\"><a href=\"#会议、活动\" class=\"headerlink\" title=\"会议、活动\"></a>会议、活动</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/qcon/\" target=\"_blank\" rel=\"noopener\">QCon</a></li>\n<li><a href=\"https://archsummit.com\" target=\"_blank\" rel=\"noopener\">ArchSummit</a></li>\n<li><a href=\"http://www.thegitc.com/\" target=\"_blank\" rel=\"noopener\">GITC全球互联网技术大会</a></li>\n</ul>\n<p><strong>活动发布平台:</strong> </p>\n<ul>\n<li><a href=\"http://www.huodongxing.com/\" target=\"_blank\" rel=\"noopener\">活动行</a></li>\n</ul>\n<h2 id=\"常用APP\"><a href=\"#常用APP\" class=\"headerlink\" title=\"常用APP\"></a>常用APP</h2><ul>\n<li><a href=\"https://time.geekbang.org\" target=\"_blank\" rel=\"noopener\">极客时间</a></li>\n<li><a href=\"https://www.igetget.com\" target=\"_blank\" rel=\"noopener\">得到</a></li>\n</ul>\n<h2 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h2><ul>\n<li><a href=\"https://www.zhipin.com\" target=\"_blank\" rel=\"noopener\">Boss直聘</a></li>\n<li><a href=\"https://www.lagou.com\" target=\"_blank\" rel=\"noopener\">拉勾网</a></li>\n<li><a href=\"https://www.liepin.com\" target=\"_blank\" rel=\"noopener\">猎聘</a></li>\n<li><a href=\"https://cn.100offer.com/\" target=\"_blank\" rel=\"noopener\">100Offer</a></li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><a href=\"https://s.geekbang.org/\" target=\"_blank\" rel=\"noopener\">极客搜索</a><ul>\n<li>技术文章搜索引擎。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码托管\"><a href=\"#代码托管\" class=\"headerlink\" title=\"代码托管\"></a>代码托管</h2><ul>\n<li><a href=\"https://coding.net\" target=\"_blank\" rel=\"noopener\">Coding</a></li>\n<li><a href=\"https://gitee.com/\" target=\"_blank\" rel=\"noopener\">码云</a></li>\n</ul>\n<h2 id=\"文件服务\"><a href=\"#文件服务\" class=\"headerlink\" title=\"文件服务\"></a>文件服务</h2><ul>\n<li>七牛</li>\n<li>又拍云</li>\n</ul>\n<h2 id=\"综合云服务商\"><a href=\"#综合云服务商\" class=\"headerlink\" title=\"综合云服务商\"></a>综合云服务商</h2><ul>\n<li>阿里云</li>\n<li><a href=\"https://cloud.tencent.com/redirect.php?redirect=1012&amp;cps_key=c2665015d90871c0cb20fef91b7afc3c\" target=\"_blank\" rel=\"noopener\">腾讯云</a></li>\n<li>百度云</li>\n<li>新浪云</li>\n<li>金山云</li>\n<li><a href=\"https://amazonaws-china.com/cn/\" target=\"_blank\" rel=\"noopener\">亚马逊云(AWS)</a></li>\n<li><a href=\"https://cloud.google.com/?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">谷歌云</a></li>\n<li><a href=\"https://azure.microsoft.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">微软云</a></li>\n</ul>\n<h3 id=\"VPS\"><a href=\"#VPS\" class=\"headerlink\" title=\"VPS\"></a>VPS</h3><ul>\n<li><a href=\"http://linode.com\" target=\"_blank\" rel=\"noopener\">Linode</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>列出了后端架构师要掌握的基本知识。少壮不努力，老大徒伤悲……</p>\n<p>本文拷贝自<a href=\"https://github.com/xingshaocheng/architect-awesome\" target=\"_blank\" rel=\"noopener\">https://github.com/xingshaocheng/architect-awesome</a></p>\n<h1>《后端架构师技术图谱》</h1>\n\n<p><strong>更新于20180513</strong></p>\n<ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据结构\" target=\"_blank\" rel=\"noopener\">数据结构</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#队列\" target=\"_blank\" rel=\"noopener\">队列</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合\" target=\"_blank\" rel=\"noopener\">集合</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#链表数组\" target=\"_blank\" rel=\"noopener\">链表、数组</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典关联数组\" target=\"_blank\" rel=\"noopener\">字典、关联数组</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#栈\" target=\"_blank\" rel=\"noopener\">栈</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#树\" target=\"_blank\" rel=\"noopener\">树</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉树\" target=\"_blank\" rel=\"noopener\">二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#完全二叉树\" target=\"_blank\" rel=\"noopener\">完全二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平衡二叉树\" target=\"_blank\" rel=\"noopener\">平衡二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉查找树bst\" target=\"_blank\" rel=\"noopener\">二叉查找树（BST）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#红黑树\" target=\"_blank\" rel=\"noopener\">红黑树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#b-bb树\" target=\"_blank\" rel=\"noopener\">B-，B+，B*树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lsm-树\" target=\"_blank\" rel=\"noopener\">LSM 树</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#bitset\" target=\"_blank\" rel=\"noopener\">BitSet</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用算法\" target=\"_blank\" rel=\"noopener\">常用算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#排序查找算法\" target=\"_blank\" rel=\"noopener\">排序、查找算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#选择排序\" target=\"_blank\" rel=\"noopener\">选择排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#冒泡排序\" target=\"_blank\" rel=\"noopener\">冒泡排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#插入排序\" target=\"_blank\" rel=\"noopener\">插入排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快速排序\" target=\"_blank\" rel=\"noopener\">快速排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#归并排序\" target=\"_blank\" rel=\"noopener\">归并排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#希尔排序\" target=\"_blank\" rel=\"noopener\">希尔排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#堆排序\" target=\"_blank\" rel=\"noopener\">堆排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计数排序\" target=\"_blank\" rel=\"noopener\">计数排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#桶排序\" target=\"_blank\" rel=\"noopener\">桶排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基数排序\" target=\"_blank\" rel=\"noopener\">基数排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二分查找\" target=\"_blank\" rel=\"noopener\">二分查找</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-中的排序工具\" target=\"_blank\" rel=\"noopener\">Java 中的排序工具</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#布隆过滤器\" target=\"_blank\" rel=\"noopener\">布隆过滤器</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字符串比较\" target=\"_blank\" rel=\"noopener\">字符串比较</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kmp-算法\" target=\"_blank\" rel=\"noopener\">KMP 算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#深度优先广度优先\" target=\"_blank\" rel=\"noopener\">深度优先、广度优先</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贪心算法\" target=\"_blank\" rel=\"noopener\">贪心算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回溯算法\" target=\"_blank\" rel=\"noopener\">回溯算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#剪枝算法\" target=\"_blank\" rel=\"noopener\">剪枝算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#动态规划\" target=\"_blank\" rel=\"noopener\">动态规划</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#朴素贝叶斯\" target=\"_blank\" rel=\"noopener\">朴素贝叶斯</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐算法\" target=\"_blank\" rel=\"noopener\">推荐算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最小生成树算法\" target=\"_blank\" rel=\"noopener\">最小生成树算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最短路径算法\" target=\"_blank\" rel=\"noopener\">最短路径算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#并发\" target=\"_blank\" rel=\"noopener\">并发</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多线程\" target=\"_blank\" rel=\"noopener\">多线程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程安全\" target=\"_blank\" rel=\"noopener\">线程安全</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性事务\" target=\"_blank\" rel=\"noopener\">一致性、事务</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务-acid-特性\" target=\"_blank\" rel=\"noopener\">事务 ACID 特性</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务的隔离级别\" target=\"_blank\" rel=\"noopener\">事务的隔离级别</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvcc\" target=\"_blank\" rel=\"noopener\">MVCC</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#锁\" target=\"_blank\" rel=\"noopener\">锁</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java中的锁和同步类\" target=\"_blank\" rel=\"noopener\">Java中的锁和同步类</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公平锁--非公平锁\" target=\"_blank\" rel=\"noopener\">公平锁 &amp; 非公平锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#悲观锁\" target=\"_blank\" rel=\"noopener\">悲观锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#乐观锁--cas\" target=\"_blank\" rel=\"noopener\">乐观锁 &amp; CAS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aba-问题\" target=\"_blank\" rel=\"noopener\">ABA 问题</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#copyonwrite容器\" target=\"_blank\" rel=\"noopener\">CopyOnWrite容器</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ringbuffer\" target=\"_blank\" rel=\"noopener\">RingBuffer</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#可重入锁--不可重入锁\" target=\"_blank\" rel=\"noopener\">可重入锁 &amp; 不可重入锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#互斥锁--共享锁\" target=\"_blank\" rel=\"noopener\">互斥锁 &amp; 共享锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#死锁\" target=\"_blank\" rel=\"noopener\">死锁</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#操作系统\" target=\"_blank\" rel=\"noopener\">操作系统</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计算机原理\" target=\"_blank\" rel=\"noopener\">计算机原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cpu\" target=\"_blank\" rel=\"noopener\">CPU</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多级缓存\" target=\"_blank\" rel=\"noopener\">多级缓存</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#进程\" target=\"_blank\" rel=\"noopener\">进程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程\" target=\"_blank\" rel=\"noopener\">线程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协程\" target=\"_blank\" rel=\"noopener\">协程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#linux\" target=\"_blank\" rel=\"noopener\">Linux</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式\" target=\"_blank\" rel=\"noopener\">设计模式</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式的六大原则\" target=\"_blank\" rel=\"noopener\">设计模式的六大原则</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#23种常见设计模式\" target=\"_blank\" rel=\"noopener\">23种常见设计模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景\" target=\"_blank\" rel=\"noopener\">应用场景</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单例模式\" target=\"_blank\" rel=\"noopener\">单例模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#责任链模式\" target=\"_blank\" rel=\"noopener\">责任链模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvc\" target=\"_blank\" rel=\"noopener\">MVC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ioc\" target=\"_blank\" rel=\"noopener\">IOC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aop\" target=\"_blank\" rel=\"noopener\">AOP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#uml\" target=\"_blank\" rel=\"noopener\">UML</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#微服务思想\" target=\"_blank\" rel=\"noopener\">微服务思想</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#康威定律\" target=\"_blank\" rel=\"noopener\">康威定律</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#运维--统计--技术支持\" target=\"_blank\" rel=\"noopener\">运维 &amp; 统计 &amp; 技术支持</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常规监控\" target=\"_blank\" rel=\"noopener\">常规监控</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apm\" target=\"_blank\" rel=\"noopener\">APM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#统计分析\" target=\"_blank\" rel=\"noopener\">统计分析</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#持续集成cicd\" target=\"_blank\" rel=\"noopener\">持续集成(CI/CD)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jenkins\" target=\"_blank\" rel=\"noopener\">Jenkins</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#环境分离\" target=\"_blank\" rel=\"noopener\">环境分离</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自动化运维\" target=\"_blank\" rel=\"noopener\">自动化运维</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ansible\" target=\"_blank\" rel=\"noopener\">Ansible</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#puppet\" target=\"_blank\" rel=\"noopener\">puppet</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#chef\" target=\"_blank\" rel=\"noopener\">chef</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#测试\" target=\"_blank\" rel=\"noopener\">测试</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tdd-理论\" target=\"_blank\" rel=\"noopener\">TDD 理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单元测试\" target=\"_blank\" rel=\"noopener\">单元测试</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#压力测试\" target=\"_blank\" rel=\"noopener\">压力测试</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全链路压测\" target=\"_blank\" rel=\"noopener\">全链路压测</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ab-灰度蓝绿测试\" target=\"_blank\" rel=\"noopener\">A/B 、灰度、蓝绿测试</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#虚拟化\" target=\"_blank\" rel=\"noopener\">虚拟化</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kvm\" target=\"_blank\" rel=\"noopener\">KVM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xen\" target=\"_blank\" rel=\"noopener\">Xen</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openvz\" target=\"_blank\" rel=\"noopener\">OpenVZ</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容器技术\" target=\"_blank\" rel=\"noopener\">容器技术</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#docker\" target=\"_blank\" rel=\"noopener\">Docker</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#云技术\" target=\"_blank\" rel=\"noopener\">云技术</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openstack\" target=\"_blank\" rel=\"noopener\">OpenStack</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#devops\" target=\"_blank\" rel=\"noopener\">DevOps</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文档管理\" target=\"_blank\" rel=\"noopener\">文档管理</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#中间件\" target=\"_blank\" rel=\"noopener\">中间件</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-server\" target=\"_blank\" rel=\"noopener\">Web Server</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx\" target=\"_blank\" rel=\"noopener\">Nginx</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openresty\" target=\"_blank\" rel=\"noopener\">OpenResty</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apache-httpd\" target=\"_blank\" rel=\"noopener\">Apache Httpd</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tomcat\" target=\"_blank\" rel=\"noopener\">Tomcat</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构原理\" target=\"_blank\" rel=\"noopener\">架构原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#调优方案\" target=\"_blank\" rel=\"noopener\">调优方案</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jetty\" target=\"_blank\" rel=\"noopener\">Jetty</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#缓存\" target=\"_blank\" rel=\"noopener\">缓存</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#本地缓存\" target=\"_blank\" rel=\"noopener\">本地缓存</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#客户端缓存\" target=\"_blank\" rel=\"noopener\">客户端缓存</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务端缓存\" target=\"_blank\" rel=\"noopener\">服务端缓存</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web缓存\" target=\"_blank\" rel=\"noopener\">Web缓存</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#memcached\" target=\"_blank\" rel=\"noopener\">Memcached</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis\" target=\"_blank\" rel=\"noopener\">Redis</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构\" target=\"_blank\" rel=\"noopener\">架构</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回收策略\" target=\"_blank\" rel=\"noopener\">回收策略</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tair\" target=\"_blank\" rel=\"noopener\">Tair</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息队列\" target=\"_blank\" rel=\"noopener\">消息队列</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息总线\" target=\"_blank\" rel=\"noopener\">消息总线</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息的顺序\" target=\"_blank\" rel=\"noopener\">消息的顺序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rabbitmq\" target=\"_blank\" rel=\"noopener\">RabbitMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rocketmq\" target=\"_blank\" rel=\"noopener\">RocketMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#activemq\" target=\"_blank\" rel=\"noopener\">ActiveMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka\" target=\"_blank\" rel=\"noopener\">Kafka</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis-消息推送\" target=\"_blank\" rel=\"noopener\">Redis 消息推送</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zeromq\" target=\"_blank\" rel=\"noopener\">ZeroMQ</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#定时调度\" target=\"_blank\" rel=\"noopener\">定时调度</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单机定时调度\" target=\"_blank\" rel=\"noopener\">单机定时调度</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式定时调度\" target=\"_blank\" rel=\"noopener\">分布式定时调度</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rpc\" target=\"_blank\" rel=\"noopener\">RPC</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dubbo\" target=\"_blank\" rel=\"noopener\">Dubbo</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#thrift\" target=\"_blank\" rel=\"noopener\">Thrift</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#grpc\" target=\"_blank\" rel=\"noopener\">gRPC</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库中间件\" target=\"_blank\" rel=\"noopener\">数据库中间件</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sharding-jdbc\" target=\"_blank\" rel=\"noopener\">Sharding Jdbc</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志系统\" target=\"_blank\" rel=\"noopener\">日志系统</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志搜集\" target=\"_blank\" rel=\"noopener\">日志搜集</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#配置中心\" target=\"_blank\" rel=\"noopener\">配置中心</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#api-网关\" target=\"_blank\" rel=\"noopener\">API 网关</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络\" target=\"_blank\" rel=\"noopener\">网络</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协议\" target=\"_blank\" rel=\"noopener\">协议</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#osi-七层协议\" target=\"_blank\" rel=\"noopener\">OSI 七层协议</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcpip\" target=\"_blank\" rel=\"noopener\">TCP/IP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http\" target=\"_blank\" rel=\"noopener\">HTTP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http20\" target=\"_blank\" rel=\"noopener\">HTTP2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#https\" target=\"_blank\" rel=\"noopener\">HTTPS</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络模型\" target=\"_blank\" rel=\"noopener\">网络模型</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-nio\" target=\"_blank\" rel=\"noopener\">Java NIO</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kqueue\" target=\"_blank\" rel=\"noopener\">kqueue</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接和短连接\" target=\"_blank\" rel=\"noopener\">连接和短连接</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#框架\" target=\"_blank\" rel=\"noopener\">框架</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#零拷贝zero-copy\" target=\"_blank\" rel=\"noopener\">零拷贝（Zero-copy）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化二进制协议\" target=\"_blank\" rel=\"noopener\">序列化(二进制协议)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hessian\" target=\"_blank\" rel=\"noopener\">Hessian</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#protobuf\" target=\"_blank\" rel=\"noopener\">Protobuf</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库\" target=\"_blank\" rel=\"noopener\">数据库</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论\" target=\"_blank\" rel=\"noopener\">基础理论</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库设计的三大范式\" target=\"_blank\" rel=\"noopener\">数据库设计的三大范式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mysql\" target=\"_blank\" rel=\"noopener\">MySQL</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#原理\" target=\"_blank\" rel=\"noopener\">原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#innodb\" target=\"_blank\" rel=\"noopener\">InnoDB</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#优化\" target=\"_blank\" rel=\"noopener\">优化</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#索引\" target=\"_blank\" rel=\"noopener\">索引</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#聚集索引-非聚集索引\" target=\"_blank\" rel=\"noopener\">聚集索引, 非聚集索引</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#复合索引\" target=\"_blank\" rel=\"noopener\">复合索引</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自适应哈希索引ahi\" target=\"_blank\" rel=\"noopener\">自适应哈希索引(AHI)</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#explain\" target=\"_blank\" rel=\"noopener\">explain</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nosql\" target=\"_blank\" rel=\"noopener\">NoSQL</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mongodb\" target=\"_blank\" rel=\"noopener\">MongoDB</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hbase\" target=\"_blank\" rel=\"noopener\">Hbase</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎\" target=\"_blank\" rel=\"noopener\">搜索引擎</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎原理\" target=\"_blank\" rel=\"noopener\">搜索引擎原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lucene\" target=\"_blank\" rel=\"noopener\">Lucene</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#elasticsearch\" target=\"_blank\" rel=\"noopener\">Elasticsearch</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#solr\" target=\"_blank\" rel=\"noopener\">Solr</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sphinx\" target=\"_blank\" rel=\"noopener\">sphinx</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能\" target=\"_blank\" rel=\"noopener\">性能</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能优化方法论\" target=\"_blank\" rel=\"noopener\">性能优化方法论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容量评估\" target=\"_blank\" rel=\"noopener\">容量评估</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cdn-网络\" target=\"_blank\" rel=\"noopener\">CDN 网络</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接池\" target=\"_blank\" rel=\"noopener\">连接池</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能调优\" target=\"_blank\" rel=\"noopener\">性能调优</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据\" target=\"_blank\" rel=\"noopener\">大数据</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#流式计算\" target=\"_blank\" rel=\"noopener\">流式计算</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#storm\" target=\"_blank\" rel=\"noopener\">Storm</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#flink\" target=\"_blank\" rel=\"noopener\">Flink</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka-stream\" target=\"_blank\" rel=\"noopener\">Kafka Stream</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景-1\" target=\"_blank\" rel=\"noopener\">应用场景</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hadoop\" target=\"_blank\" rel=\"noopener\">Hadoop</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hdfs\" target=\"_blank\" rel=\"noopener\">HDFS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mapreduce\" target=\"_blank\" rel=\"noopener\">MapReduce</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#yarn\" target=\"_blank\" rel=\"noopener\">Yarn</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spark\" target=\"_blank\" rel=\"noopener\">Spark</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#安全\" target=\"_blank\" rel=\"noopener\">安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-安全\" target=\"_blank\" rel=\"noopener\">web 安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xss\" target=\"_blank\" rel=\"noopener\">XSS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#csrf\" target=\"_blank\" rel=\"noopener\">CSRF</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sql-注入\" target=\"_blank\" rel=\"noopener\">SQL 注入</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hash-dos\" target=\"_blank\" rel=\"noopener\">Hash Dos</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#脚本注入\" target=\"_blank\" rel=\"noopener\">脚本注入</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#漏洞扫描工具\" target=\"_blank\" rel=\"noopener\">漏洞扫描工具</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#验证码\" target=\"_blank\" rel=\"noopener\">验证码</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddos-防范\" target=\"_blank\" rel=\"noopener\">DDoS 防范</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#用户隐私信息保护\" target=\"_blank\" rel=\"noopener\">用户隐私信息保护</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化漏洞\" target=\"_blank\" rel=\"noopener\">序列化漏洞</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#加密解密\" target=\"_blank\" rel=\"noopener\">加密解密</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#对称加密\" target=\"_blank\" rel=\"noopener\">对称加密</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#哈希算法\" target=\"_blank\" rel=\"noopener\">哈希算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#非对称加密\" target=\"_blank\" rel=\"noopener\">非对称加密</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务器安全\" target=\"_blank\" rel=\"noopener\">服务器安全</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据安全\" target=\"_blank\" rel=\"noopener\">数据安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据备份\" target=\"_blank\" rel=\"noopener\">数据备份</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络隔离\" target=\"_blank\" rel=\"noopener\">网络隔离</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#内外网分离\" target=\"_blank\" rel=\"noopener\">内外网分离</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#登录跳板机\" target=\"_blank\" rel=\"noopener\">登录跳板机</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#授权认证\" target=\"_blank\" rel=\"noopener\">授权、认证</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rbac\" target=\"_blank\" rel=\"noopener\">RBAC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#oauth20\" target=\"_blank\" rel=\"noopener\">OAuth2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#双因素认证2fa\" target=\"_blank\" rel=\"noopener\">双因素认证（2FA）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单点登录sso\" target=\"_blank\" rel=\"noopener\">单点登录(SSO)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用开源框架\" target=\"_blank\" rel=\"noopener\">常用开源框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源协议\" target=\"_blank\" rel=\"noopener\">开源协议</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志框架\" target=\"_blank\" rel=\"noopener\">日志框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#log4jlog4j2\" target=\"_blank\" rel=\"noopener\">Log4j、Log4j2</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#logback\" target=\"_blank\" rel=\"noopener\">Logback</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#orm\" target=\"_blank\" rel=\"noopener\">ORM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络框架\" target=\"_blank\" rel=\"noopener\">网络框架</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-框架\" target=\"_blank\" rel=\"noopener\">Web 框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spring-家族\" target=\"_blank\" rel=\"noopener\">Spring 家族</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具框架\" target=\"_blank\" rel=\"noopener\">工具框架</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式设计\" target=\"_blank\" rel=\"noopener\">分布式设计</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#扩展性设计\" target=\"_blank\" rel=\"noopener\">扩展性设计</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#稳定性--高可用\" target=\"_blank\" rel=\"noopener\">稳定性 &amp; 高可用</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#硬件负载均衡\" target=\"_blank\" rel=\"noopener\">硬件负载均衡</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#软件负载均衡\" target=\"_blank\" rel=\"noopener\">软件负载均衡</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#限流\" target=\"_blank\" rel=\"noopener\">限流</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用层容灾\" target=\"_blank\" rel=\"noopener\">应用层容灾</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#跨机房容灾\" target=\"_blank\" rel=\"noopener\">跨机房容灾</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容灾演练流程\" target=\"_blank\" rel=\"noopener\">容灾演练流程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平滑启动\" target=\"_blank\" rel=\"noopener\">平滑启动</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库扩展\" target=\"_blank\" rel=\"noopener\">数据库扩展</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#读写分离模式\" target=\"_blank\" rel=\"noopener\">读写分离模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分片模式\" target=\"_blank\" rel=\"noopener\">分片模式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务治理\" target=\"_blank\" rel=\"noopener\">服务治理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务注册与发现\" target=\"_blank\" rel=\"noopener\">服务注册与发现</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务路由控制\" target=\"_blank\" rel=\"noopener\">服务路由控制</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致\" target=\"_blank\" rel=\"noopener\">分布式一致</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cap-与-base-理论\" target=\"_blank\" rel=\"noopener\">CAP 与 BASE 理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式锁\" target=\"_blank\" rel=\"noopener\">分布式锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致性算法\" target=\"_blank\" rel=\"noopener\">分布式一致性算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#paxos\" target=\"_blank\" rel=\"noopener\">PAXOS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zab\" target=\"_blank\" rel=\"noopener\">Zab</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#raft\" target=\"_blank\" rel=\"noopener\">Raft</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#gossip\" target=\"_blank\" rel=\"noopener\">Gossip</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#两阶段提交多阶段提交\" target=\"_blank\" rel=\"noopener\">两阶段提交、多阶段提交</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#幂等\" target=\"_blank\" rel=\"noopener\">幂等</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致方案\" target=\"_blank\" rel=\"noopener\">分布式一致方案</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式-leader-节点选举\" target=\"_blank\" rel=\"noopener\">分布式 Leader 节点选举</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcctryconfirmcancel-柔性事务\" target=\"_blank\" rel=\"noopener\">TCC(Try/Confirm/Cancel) 柔性事务</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式文件系统\" target=\"_blank\" rel=\"noopener\">分布式文件系统</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#唯一id-生成\" target=\"_blank\" rel=\"noopener\">唯一ID 生成</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全局唯一id\" target=\"_blank\" rel=\"noopener\">全局唯一ID</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性hash算法\" target=\"_blank\" rel=\"noopener\">一致性Hash算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计思想--开发模式\" target=\"_blank\" rel=\"noopener\">设计思想 &amp; 开发模式</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddddomain-driven-design---领域驱动设计\" target=\"_blank\" rel=\"noopener\">DDD(Domain-driven Design - 领域驱动设计)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#命令查询职责分离cqrs\" target=\"_blank\" rel=\"noopener\">命令查询职责分离(CQRS)</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贫血充血模型\" target=\"_blank\" rel=\"noopener\">贫血，充血模型</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#actor-模式\" target=\"_blank\" rel=\"noopener\">Actor 模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#响应式编程\" target=\"_blank\" rel=\"noopener\">响应式编程</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#reactor\" target=\"_blank\" rel=\"noopener\">Reactor</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rxjava\" target=\"_blank\" rel=\"noopener\">RxJava</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vertx\" target=\"_blank\" rel=\"noopener\">Vert.x</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dodaf20\" target=\"_blank\" rel=\"noopener\">DODAF2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#serverless\" target=\"_blank\" rel=\"noopener\">Serverless</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#service-mesh\" target=\"_blank\" rel=\"noopener\">Service Mesh</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#项目管理\" target=\"_blank\" rel=\"noopener\">项目管理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构评审\" target=\"_blank\" rel=\"noopener\">架构评审</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#重构\" target=\"_blank\" rel=\"noopener\">重构</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码规范\" target=\"_blank\" rel=\"noopener\">代码规范</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码-review\" target=\"_blank\" rel=\"noopener\">代码 Review</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rup\" target=\"_blank\" rel=\"noopener\">RUP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#看板管理\" target=\"_blank\" rel=\"noopener\">看板管理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#scrum\" target=\"_blank\" rel=\"noopener\">SCRUM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#敏捷开发\" target=\"_blank\" rel=\"noopener\">敏捷开发</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#极限编程xp\" target=\"_blank\" rel=\"noopener\">极限编程（XP）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#结对编程\" target=\"_blank\" rel=\"noopener\">结对编程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#fmea管理模式\" target=\"_blank\" rel=\"noopener\">FMEA管理模式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#通用业务术语\" target=\"_blank\" rel=\"noopener\">通用业务术语</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术趋势\" target=\"_blank\" rel=\"noopener\">技术趋势</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#政策法规\" target=\"_blank\" rel=\"noopener\">政策、法规</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#法律\" target=\"_blank\" rel=\"noopener\">法律</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#严格遵守刑法253法条\" target=\"_blank\" rel=\"noopener\">严格遵守刑法253法条</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构师素质\" target=\"_blank\" rel=\"noopener\">架构师素质</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队管理\" target=\"_blank\" rel=\"noopener\">团队管理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#招聘\" target=\"_blank\" rel=\"noopener\">招聘</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#资讯\" target=\"_blank\" rel=\"noopener\">资讯</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业资讯\" target=\"_blank\" rel=\"noopener\">行业资讯</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公众号列表\" target=\"_blank\" rel=\"noopener\">公众号列表</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#博客\" target=\"_blank\" rel=\"noopener\">博客</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队博客\" target=\"_blank\" rel=\"noopener\">团队博客</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#个人博客\" target=\"_blank\" rel=\"noopener\">个人博客</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合门户社区\" target=\"_blank\" rel=\"noopener\">综合门户、社区</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#问答讨论类社区\" target=\"_blank\" rel=\"noopener\">问答、讨论类社区</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业数据分析\" target=\"_blank\" rel=\"noopener\">行业数据分析</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#专项网站\" target=\"_blank\" rel=\"noopener\">专项网站</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#其他类\" target=\"_blank\" rel=\"noopener\">其他类</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐参考书\" target=\"_blank\" rel=\"noopener\">推荐参考书</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线电子书\" target=\"_blank\" rel=\"noopener\">在线电子书</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#纸质书\" target=\"_blank\" rel=\"noopener\">纸质书</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开发方面\" target=\"_blank\" rel=\"noopener\">开发方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构方面\" target=\"_blank\" rel=\"noopener\">架构方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术管理方面\" target=\"_blank\" rel=\"noopener\">技术管理方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论-1\" target=\"_blank\" rel=\"noopener\">基础理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具方面\" target=\"_blank\" rel=\"noopener\">工具方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据方面\" target=\"_blank\" rel=\"noopener\">大数据方面</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术资源\" target=\"_blank\" rel=\"noopener\">技术资源</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源资源\" target=\"_blank\" rel=\"noopener\">开源资源</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#手册文档教程\" target=\"_blank\" rel=\"noopener\">手册、文档、教程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线课堂\" target=\"_blank\" rel=\"noopener\">在线课堂</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#会议活动\" target=\"_blank\" rel=\"noopener\">会议、活动</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用app\" target=\"_blank\" rel=\"noopener\">常用APP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#找工作\" target=\"_blank\" rel=\"noopener\">找工作</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具\" target=\"_blank\" rel=\"noopener\">工具</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码托管\" target=\"_blank\" rel=\"noopener\">代码托管</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文件服务\" target=\"_blank\" rel=\"noopener\">文件服务</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合云服务商\" target=\"_blank\" rel=\"noopener\">综合云服务商</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vps\" target=\"_blank\" rel=\"noopener\">VPS</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>（Toc generated by <a href=\"https://github.com/xingshaocheng/simple-php-github-toc\" target=\"_blank\" rel=\"noopener\">simple-php-github-toc</a> ）</strong></p>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/lemon-flm/p/7877898.html\" target=\"_blank\" rel=\"noopener\">《java队列——queue详细分析》</a></p>\n<ul>\n<li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li>\n<li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/mantu/p/5802393.html\" target=\"_blank\" rel=\"noopener\">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></p>\n</li>\n</ul>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_33642117/article/details/52040345\" target=\"_blank\" rel=\"noopener\">《Java Set集合的详解》</a></li>\n</ul>\n<h2 id=\"链表、数组\"><a href=\"#链表、数组\" class=\"headerlink\" title=\"链表、数组\"></a>链表、数组</h2><ul>\n<li><a href=\"https://blog.csdn.net/wz249863091/article/details/52853360\" target=\"_blank\" rel=\"noopener\">《Java集合详解–什么是List》</a></li>\n</ul>\n<h2 id=\"字典、关联数组\"><a href=\"#字典、关联数组\" class=\"headerlink\" title=\"字典、关联数组\"></a>字典、关联数组</h2><ul>\n<li><a href=\"https://baike.xsoftlab.net/view/250.html\" target=\"_blank\" rel=\"noopener\">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><a href=\"https://blog.csdn.net/javazejian/article/details/53362993\" target=\"_blank\" rel=\"noopener\">《java数据结构与算法之栈（Stack）设计与实现》</a></li>\n<li><a href=\"http://www.runoob.com/java/java-stack-class.html\" target=\"_blank\" rel=\"noopener\">《Java Stack 类》</a></li>\n<li><a href=\"https://blog.csdn.net/f2006116/article/details/51375225\" target=\"_blank\" rel=\"noopener\">《java stack的详细实现分析》</a><ul>\n<li>Stack 是线程安全的。</li>\n<li>内部使用数组保存数据，不够时翻倍。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/cai2016/article/details/52589952\" target=\"_blank\" rel=\"noopener\">《二叉树》</a></li>\n</ul>\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin\" target=\"_blank\" rel=\"noopener\">《完全二叉树》</a><ul>\n<li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/polly333/p/4798944.html\" target=\"_blank\" rel=\"noopener\">《浅谈数据结构-平衡二叉树》</a></li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li>\n</ul>\n<h3 id=\"二叉查找树（BST）\"><a href=\"#二叉查找树（BST）\" class=\"headerlink\" title=\"二叉查找树（BST）\"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 七 二叉查找树》</a></li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><ul>\n<li><a href=\"https://blog.csdn.net/sun_tttt/article/details/65445754\" target=\"_blank\" rel=\"noopener\">《最容易懂得红黑树》</a><ul>\n<li>添加阶段后，左旋或者右旋从而再次达到平衡。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li>\n</ul>\n<h3 id=\"B-，B-，B-树\"><a href=\"#B-，B-，B-树\" class=\"headerlink\" title=\"B-，B+，B*树\"></a>B-，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/aqzwss/article/details/53074186\" target=\"_blank\" rel=\"noopener\">《B-树，B+树，B*树详解》</a></li>\n<li><a href=\"https://blog.csdn.net/bigtree_3721/article/details/73632405\" target=\"_blank\" rel=\"noopener\">《B-树，B+树与B*树的优缺点比较》</a><ul>\n<li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。<h3 id=\"LSM-树\"><a href=\"#LSM-树\" class=\"headerlink\" title=\"LSM 树\"></a>LSM 树</h3></li>\n</ul>\n</li>\n</ul>\n<p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。<br>Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/dbanote/article/details/8897599\" target=\"_blank\" rel=\"noopener\">《LSM树 VS B+树》</a></p>\n<ul>\n<li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。</li>\n<li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014774781/article/details/52105708\" target=\"_blank\" rel=\"noopener\">《LSM树（Log-Structured Merge Tree）存储引擎》</a></p>\n<ul>\n<li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li>\n<li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li>\n<li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"BitSet\"><a href=\"#BitSet\" class=\"headerlink\" title=\"BitSet\"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p>\n<ul>\n<li><a href=\"http://www.runoob.com/java/java-bitset-class.html\" target=\"_blank\" rel=\"noopener\">《Java Bitset类》</a></li>\n<li><a href=\"https://blog.csdn.net/caiandyong/article/details/51581160\" target=\"_blank\" rel=\"noopener\">《Java BitSet（位集）》</a></li>\n</ul>\n<h1 id=\"常用算法\"><a href=\"#常用算法\" class=\"headerlink\" title=\"常用算法\"></a>常用算法</h1><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\" target=\"_blank\" rel=\"noopener\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h2 id=\"排序、查找算法\"><a href=\"#排序、查找算法\" class=\"headerlink\" title=\"排序、查找算法\"></a>排序、查找算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\" target=\"_blank\" rel=\"noopener\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/shen-hua/p/5424059.html\" target=\"_blank\" rel=\"noopener\">《Java中的经典算法之选择排序（SelectionSort）》</a><ul>\n<li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li><a href=\"https://blog.csdn.net/shuaizai88/article/details/73250615\" target=\"_blank\" rel=\"noopener\">《冒泡排序的2种写法》</a><ul>\n<li>相邻元素前后交换、把最大的排到最后。</li>\n<li>时间复杂度 O(n²) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/hapjin/p/5517667.html\" target=\"_blank\" rel=\"noopener\">《排序算法总结之插入排序》</a></li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li><a href=\"http://developer.51cto.com/art/201403/430986.htm\" target=\"_blank\" rel=\"noopener\">《坐在马桶上看算法：快速排序》</a><ul>\n<li>一侧比另外一次都大或小。 <h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3></li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/chengxiao/p/6194356.html\" target=\"_blank\" rel=\"noopener\">《图解排序算法(四)之归并排序》</a><ul>\n<li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>TODO</p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/chengxiao/p/6129630.html\" target=\"_blank\" rel=\"noopener\">《图解排序算法(三)之堆排序》</a><ul>\n<li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/suvllian/p/5495780.html\" target=\"_blank\" rel=\"noopener\">《计数排序和桶排序》</a><ul>\n<li>和桶排序过程比较像，差别在于桶的数量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li><a href=\"http://blog.51cto.com/ahalei/1362789\" target=\"_blank\" rel=\"noopener\">《【啊哈！算法】最快最简单的排序——桶排序》</a></li>\n<li><a href=\"https://blog.csdn.net/sunjinshengli/article/details/70738527\" target=\"_blank\" rel=\"noopener\">《排序算法（三）：计数排序与桶排序》</a><ul>\n<li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li>\n<li>每个桶单独进行排序，然后再遍历每个桶。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/51695211\" target=\"_blank\" rel=\"noopener\">《排序算法系列：基数排序》</a></li>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/3603669.html\" target=\"_blank\" rel=\"noopener\">《基数排序》</a></li>\n</ul>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/coderising/p/5708632.html\" target=\"_blank\" rel=\"noopener\">《二分查找(java实现)》</a></p>\n<ul>\n<li>要求待查找的序列有序。</li>\n<li>时间复杂度 O(logN)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/maoyuanming0806/article/details/78176957\" target=\"_blank\" rel=\"noopener\">《java实现二分查找-两种方式》</a></p>\n<ul>\n<li>while + 递归。<h3 id=\"Java-中的排序工具\"><a href=\"#Java-中的排序工具\" class=\"headerlink\" title=\"Java 中的排序工具\"></a>Java 中的排序工具</h3></li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&amp;fps=1\" target=\"_blank\" rel=\"noopener\">《Arrays.sort和Collections.sort实现原理解析》</a><ul>\n<li>Collections.sort算法调用的是合并排序。</li>\n<li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。<br>核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。<br>优点：空间和时间效率都很高。<br>缺点：随着存入的元素数量增加，误算率随之增加。</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000002729689\" target=\"_blank\" rel=\"noopener\">《布隆过滤器 – 空间效率很高的数据结构》</a></li>\n<li><a href=\"https://blog.csdn.net/zdxiq000/article/details/57626464\" target=\"_blank\" rel=\"noopener\">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li>\n<li><a href=\"https://blog.csdn.net/qq_30242609/article/details/71024458\" target=\"_blank\" rel=\"noopener\">《基于Redis的布隆过滤器的实现》</a><ul>\n<li>基于 Redis 的 Bitmap 数据结构。</li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/47973715\" target=\"_blank\" rel=\"noopener\">《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》</a><ul>\n<li>使用Java中的 BitSet 类 和 加权和hash算法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h2><h3 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP）<br>核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\" target=\"_blank\" rel=\"noopener\">《字符串匹配的KMP算法》</a></li>\n</ul>\n<h2 id=\"深度优先、广度优先\"><a href=\"#深度优先、广度优先\" class=\"headerlink\" title=\"深度优先、广度优先\"></a>深度优先、广度优先</h2><ul>\n<li><a href=\"https://www.cnblogs.com/0kk470/p/7555033.html\" target=\"_blank\" rel=\"noopener\">《广度优先搜索BFS和深度优先搜索DFS》</a></li>\n</ul>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><ul>\n<li><a href=\"https://www.cnblogs.com/MrSaver/p/8641971.html\" target=\"_blank\" rel=\"noopener\">《算法：贪婪算法基础》</a></li>\n<li><a href=\"https://blog.csdn.net/a345017062/article/details/52443781\" target=\"_blank\" rel=\"noopener\">《常见算法及问题场景——贪心算法》</a></li>\n</ul>\n<h2 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qfikh/article/details/51960331\" target=\"_blank\" rel=\"noopener\">《 五大常用算法之四：回溯法》</a></li>\n</ul>\n<h2 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luningcsdn/article/details/50930276\" target=\"_blank\" rel=\"noopener\">《α-β剪枝算法》</a></li>\n</ul>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><ul>\n<li><a href=\"https://www.cnblogs.com/little-YTMM/p/5372680.html\" target=\"_blank\" rel=\"noopener\">《详解动态规划——邹博讲动态规划》</a></li>\n<li><a href=\"https://blog.csdn.net/yao_zi_jie/article/details/54580283\" target=\"_blank\" rel=\"noopener\">《动态规划算法的个人理解》</a></li>\n</ul>\n<h2 id=\"朴素贝叶斯\"><a href=\"#朴素贝叶斯\" class=\"headerlink\" title=\"朴素贝叶斯\"></a>朴素贝叶斯</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/amds123/article/details/70173402\" target=\"_blank\" rel=\"noopener\">《带你搞懂朴素贝叶斯分类算法》</a></p>\n<ul>\n<li>P(B|A)=P(A|B)P(B)/P(A)</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html\" target=\"_blank\" rel=\"noopener\">《贝叶斯推断及其互联网应用1》</a></p>\n</li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html\" target=\"_blank\" rel=\"noopener\">《贝叶斯推断及其互联网应用2》</a></li>\n</ul>\n<h2 id=\"推荐算法\"><a href=\"#推荐算法\" class=\"headerlink\" title=\"推荐算法\"></a>推荐算法</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01\" target=\"_blank\" rel=\"noopener\">《推荐算法综述》</a></li>\n<li><a href=\"https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems\" target=\"_blank\" rel=\"noopener\">《TOP 10 开源的推荐系统简介》</a></li>\n</ul>\n<h2 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luoshixian099/article/details/51908175\" target=\"_blank\" rel=\"noopener\">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li>\n</ul>\n<h2 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_35644234/article/details/60870719\" target=\"_blank\" rel=\"noopener\">《Dijkstra算法详解》</a></li>\n</ul>\n<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h1><h2 id=\"Java-并发\"><a href=\"#Java-并发\" class=\"headerlink\" title=\"Java 并发\"></a>Java 并发</h2><ul>\n<li><a href=\"https://github.com/CL0610/Java-concurrency\" target=\"_blank\" rel=\"noopener\">Java 并发知识合集</a></li>\n<li><a href=\"https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png\" target=\"_blank\" rel=\"noopener\">JAVA并发知识图谱</a></li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><ul>\n<li><a href=\"http://www.importnew.com/18459.html\" target=\"_blank\" rel=\"noopener\">《40个Java多线程问题总结》</a></li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><ul>\n<li><a href=\"https://www.cnblogs.com/zhanht/p/5450325.html\" target=\"_blank\" rel=\"noopener\">《Java并发编程——线程安全及解决机制简介》</a></li>\n</ul>\n<h2 id=\"一致性、事务\"><a href=\"#一致性、事务\" class=\"headerlink\" title=\"一致性、事务\"></a>一致性、事务</h2><h3 id=\"事务-ACID-特性\"><a href=\"#事务-ACID-特性\" class=\"headerlink\" title=\"事务 ACID 特性\"></a>事务 ACID 特性</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012440687/article/details/52116108\" target=\"_blank\" rel=\"noopener\">《数据库事务ACID特性》</a></li>\n</ul>\n<h3 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h3><ul>\n<li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li>\n<li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li>\n<li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li>\n<li><p>序列化：所有事物串行处理（牺牲了效率）</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_33290787/article/details/51924963\" target=\"_blank\" rel=\"noopener\">《理解事务的4种隔离级别》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/z-sm/p/7245981.html\" target=\"_blank\" rel=\"noopener\">数据库事务的四大特性及事务隔离级别</a></p>\n</li>\n<li><p><a href=\"http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html\" target=\"_blank\" rel=\"noopener\">《MySQL的InnoDB的幻读问题 》</a></p>\n<ul>\n<li>幻读的例子非常清楚。</li>\n<li>通过 SELECT … FOR UPDATE 解决。</li>\n</ul>\n</li>\n<li><p><a href=\"http://database.51cto.com/art/201804/570101.htm\" target=\"_blank\" rel=\"noopener\">《一篇文章带你读懂MySQL和InnoDB》</a></p>\n<ul>\n<li>图解脏读、不可重复读、幻读问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/chenpingzhao/p/5065316.html\" target=\"_blank\" rel=\"noopener\">《【mysql】关于innodb中MVCC的一些理解》</a></p>\n<ul>\n<li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li>\n<li>MVCC 会产生幻读问题（更新时异常。）</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/whoamiyang/article/details/51901888\" target=\"_blank\" rel=\"noopener\">《轻松理解MYSQL MVCC 实现机制》</a></p>\n<ul>\n<li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li>\n<li>每次只操作比当前版本小（或等于）的 行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"Java中的锁和同步类\"><a href=\"#Java中的锁和同步类\" class=\"headerlink\" title=\"Java中的锁和同步类\"></a>Java中的锁和同步类</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/qifengshi/p/6831055.html\" target=\"_blank\" rel=\"noopener\">《Java中的锁分类》</a></p>\n<ul>\n<li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener\">《Java并发之AQS详解》</a></p>\n</li>\n<li><p><a href=\"http://cuisuqiang.iteye.com/blog/2020146\" target=\"_blank\" rel=\"noopener\">《Java中信号量 Semaphore》</a></p>\n<ul>\n<li>有数量控制</li>\n<li>申请用 acquire，申请不要则阻塞；释放用 release。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/davidwang456/p/6094947.html\" target=\"_blank\" rel=\"noopener\">《java开发中的Mutex vs Semaphore》</a></p>\n<ul>\n<li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"公平锁-amp-非公平锁\"><a href=\"#公平锁-amp-非公平锁\" class=\"headerlink\" title=\"公平锁 &amp; 非公平锁\"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/EthanWhite/article/details/55508357\" target=\"_blank\" rel=\"noopener\">《公平锁与非公平锁》</a><ul>\n<li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/zhiqian-ali/p/6200874.html\" target=\"_blank\" rel=\"noopener\">《【MySQL】悲观锁&amp;乐观锁》</a></p>\n<ul>\n<li>乐观锁的方式：版本号+重试方式</li>\n<li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/Lawson/p/5008741.html\" target=\"_blank\" rel=\"noopener\">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a></p>\n<ul>\n<li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li>\n<li>锁相同数据的不同索引条件可能会引起死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zejin2008/p/5262751.html\" target=\"_blank\" rel=\"noopener\">《Mysql并发时经典常见的死锁原因及解决方法》</a></p>\n</li>\n</ul>\n<h3 id=\"乐观锁-amp-CAS\"><a href=\"#乐观锁-amp-CAS\" class=\"headerlink\" title=\"乐观锁 &amp; CAS\"></a>乐观锁 &amp; CAS</h3><ul>\n<li><a href=\"http://www.importnew.com/20472.html\" target=\"_blank\" rel=\"noopener\">《乐观锁的一种实现方式——CAS》</a><ul>\n<li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ABA-问题\"><a href=\"#ABA-问题\" class=\"headerlink\" title=\"ABA 问题\"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/549294286/p/3766717.html\" target=\"_blank\" rel=\"noopener\">《Java CAS 和ABA问题》</a></li>\n<li><a href=\"https://blog.csdn.net/li954644351/article/details/50511879\" target=\"_blank\" rel=\"noopener\">《Java 中 ABA问题及避免》</a><ul>\n<li>AtomicStampedReference 和 AtomicStampedReference。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CopyOnWrite容器\"><a href=\"#CopyOnWrite容器\" class=\"headerlink\" title=\"CopyOnWrite容器\"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/hapjin/p/4840107.html\" target=\"_blank\" rel=\"noopener\">《JAVA中写时复制(Copy-On-Write)Map实现》</a></p>\n<ul>\n<li>实现读写分离，读取发生在原始数据上，写入发生在副本上。  </li>\n<li>不用加锁，通过最终一致实现一致性。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/a494303877/article/details/53404623\" target=\"_blank\" rel=\"noopener\">《聊聊并发-Java中的Copy-On-Write容器》</a></p>\n</li>\n</ul>\n<h3 id=\"RingBuffer\"><a href=\"#RingBuffer\" class=\"headerlink\" title=\"RingBuffer\"></a>RingBuffer</h3><ul>\n<li><a href=\"http://www.cnblogs.com/l00l/p/4115001.html\" target=\"_blank\" rel=\"noopener\">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li>\n</ul>\n<h3 id=\"可重入锁-amp-不可重入锁\"><a href=\"#可重入锁-amp-不可重入锁\" class=\"headerlink\" title=\"可重入锁 &amp; 不可重入锁\"></a>可重入锁 &amp; 不可重入锁</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/dj3839/p/6580765.html\" target=\"_blank\" rel=\"noopener\">《可重入锁和不可重入锁》</a></p>\n<ul>\n<li>通过简单代码举例说明可重入锁和不可重入锁。</li>\n<li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li>\n<li>可重入锁可以用户避免死锁。</li>\n<li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/baizhanshi/p/7211802.html\" target=\"_blank\" rel=\"noopener\">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a></p>\n<ul>\n<li>synchronized 使用方便，编译器来加锁，是非公平锁。</li>\n<li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li>\n<li>相同加锁场景下，推荐使用 synchronized。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"互斥锁-amp-共享锁\"><a href=\"#互斥锁-amp-共享锁\" class=\"headerlink\" title=\"互斥锁 &amp; 共享锁\"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。<br>共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/liang1101/p/6475555.html\" target=\"_blank\" rel=\"noopener\">《ReadWriteLock场景应用》</a></li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><ul>\n<li><a href=\"https://blog.csdn.net/yunfenglw/article/details/45950305\" target=\"_blank\" rel=\"noopener\">《“死锁”四个必要条件的合理解释》</a><ul>\n<li>互斥、持有、不可剥夺、环形等待。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014039577/article/details/52351626\" target=\"_blank\" rel=\"noopener\">Java如何查看死锁？</a></p>\n<ul>\n<li>JConsole 可以识别死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/bohu83/article/details/51135061\" target=\"_blank\" rel=\"noopener\">java多线程系列：死锁及检测</a></p>\n<ul>\n<li>jstack 可以显示死锁。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><h2 id=\"计算机原理\"><a href=\"#计算机原理\" class=\"headerlink\" title=\"计算机原理\"></a>计算机原理</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000003692840\" target=\"_blank\" rel=\"noopener\">《操作系统基础知识——操作系统的原理，类型和结构》</a></li>\n</ul>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><h3 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/zero__007/article/details/54089730\" target=\"_blank\" rel=\"noopener\">《从Java视角理解CPU缓存和伪共享》</a></li>\n</ul>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>TODO</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ul>\n<li><a href=\"https://blog.csdn.net/asdf_1024/article/details/78978437\" target=\"_blank\" rel=\"noopener\">《线程的生命周期及状态转换详解》</a></li>\n</ul>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><ul>\n<li><a href=\"https://www.thinksaas.cn/group/topic/839375/\" target=\"_blank\" rel=\"noopener\">《终结python协程—-从yield到actor模型的实现》</a><ul>\n<li>线程的调度是由操作系统负责，协程调度是程序自行负责</li>\n<li>与线程相比，协程减少了无谓的操作系统切换.</li>\n<li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><ul>\n<li><a href=\"http://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener\">《Linux 命令大全》</a></li>\n</ul>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h2 id=\"设计模式的六大原则\"><a href=\"#设计模式的六大原则\" class=\"headerlink\" title=\"设计模式的六大原则\"></a>设计模式的六大原则</h2><ul>\n<li><a href=\"https://blog.csdn.net/q291611265/article/details/48465113\" target=\"_blank\" rel=\"noopener\">《设计模式的六大原则》</a><ul>\n<li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li>\n<li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li>\n<li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li>\n<li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li>\n<li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li>\n<li>合成复用原则：尽量使用合成/聚合,而不是使用继承。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"23种常见设计模式\"><a href=\"#23种常见设计模式\" class=\"headerlink\" title=\"23种常见设计模式\"></a>23种常见设计模式</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/design-pattern-tutorial.html\" target=\"_blank\" rel=\"noopener\">《设计模式》</a></li>\n<li><a href=\"https://www.cnblogs.com/susanws/p/5510229.html\" target=\"_blank\" rel=\"noopener\">《23种设计模式全解析》</a></li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li><p><a href=\"http://blog.jobbole.com/62314/\" target=\"_blank\" rel=\"noopener\">《细数JDK里的设计模式》</a></p>\n<ul>\n<li><p>结构型模式：</p>\n<ul>\n<li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li>\n<li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li>\n<li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li>\n<li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li>\n<li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li>\n<li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li>\n</ul>\n</li>\n<li><p>创建模式:</p>\n<ul>\n<li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li>\n<li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li>\n<li>工厂方法：就是 <strong>一个返*</strong> 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li>\n<li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li>\n<li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li>\n</ul>\n</li>\n<li>行为模式：<ul>\n<li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li>\n<li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li>\n<li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li>\n<li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li>\n<li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li>\n<li>空对象模式：如 java.util.Collections#emptyList()。</li>\n<li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li>\n<li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/hwaggLee/p/4510687.html\" target=\"_blank\" rel=\"noopener\">《Spring-涉及到的设计模式汇总》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/u012387062/article/details/54719114\" target=\"_blank\" rel=\"noopener\">《Mybatis使用的设计模式》</a></li>\n</ul>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><ul>\n<li><a href=\"https://blog.csdn.net/YECrazy/article/details/79481964\" target=\"_blank\" rel=\"noopener\">《单例模式的三种实现 以及各自的优缺点》</a></li>\n<li><a href=\"https://www.cnblogs.com/ttylinux/p/6498822.html\" target=\"_blank\" rel=\"noopener\">《单例模式－－反射－－防止序列化破坏单例模式》</a><ul>\n<li>使用枚举类型。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>TODO</p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/mvc-pattern.html\" target=\"_blank\" rel=\"noopener\">《MVC 模式》</a><ul>\n<li>模型(model)－视图(view)－控制器(controller) </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/23277575\" target=\"_blank\" rel=\"noopener\">《理解 IOC》</a></li>\n<li><a href=\"https://www.cnblogs.com/NancyStartOnce/p/6813162.html\" target=\"_blank\" rel=\"noopener\">《IOC 的理解与解释》</a><ul>\n<li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li>\n<li>作用：用于模块解耦。</li>\n<li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><ul>\n<li><a href=\"https://my.oschina.net/yanquan345/blog/203415\" target=\"_blank\" rel=\"noopener\">《轻松理解AOP(面向切面编程)》</a></li>\n<li><a href=\"https://www.cnblogs.com/hongwz/p/5764917.html\" target=\"_blank\" rel=\"noopener\">《Spring AOP详解》</a></li>\n<li><a href=\"http://www.importnew.com/24305.html\" target=\"_blank\" rel=\"noopener\">《Spring AOP的实现原理》</a><ul>\n<li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li>\n</ul>\n</li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/\" target=\"_blank\" rel=\"noopener\">《Spring AOP 实现原理与 CGLIB 应用》</a><ul>\n<li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><ul>\n<li><a href=\"https://www.w3cschool.cn/uml_tutorial/\" target=\"_blank\" rel=\"noopener\">《UML教程》</a></li>\n</ul>\n<h2 id=\"微服务思想\"><a href=\"#微服务思想\" class=\"headerlink\" title=\"微服务思想\"></a>微服务思想</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/6219259.html\" target=\"_blank\" rel=\"noopener\">《微服务架构设计》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/micro-service-technology-stack\" target=\"_blank\" rel=\"noopener\">《微服务架构技术栈选型手册》</a></li>\n</ul>\n<h3 id=\"康威定律\"><a href=\"#康威定律\" class=\"headerlink\" title=\"康威定律\"></a>康威定律</h3><ul>\n<li><p><a href=\"https://yq.aliyun.com/articles/8611\" target=\"_blank\" rel=\"noopener\">《微服务架构的理论基础 - 康威定律》</a></p>\n<ul>\n<li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li>\n<li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li>\n<li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li>\n<li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li>\n</ul>\n</li>\n<li><p><a href=\"https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf\" target=\"_blank\" rel=\"noopener\">《微服务架构核⼼20讲》</a></p>\n</li>\n</ul>\n<h1 id=\"运维-amp-统计-amp-技术支持\"><a href=\"#运维-amp-统计-amp-技术支持\" class=\"headerlink\" title=\"运维 &amp; 统计 &amp; 技术支持\"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id=\"常规监控\"><a href=\"#常规监控\" class=\"headerlink\" title=\"常规监控\"></a>常规监控</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/77849205\" target=\"_blank\" rel=\"noopener\">《腾讯业务系统监控的修炼之路》</a></p>\n<ul>\n<li>监控的方式：主动、被动、旁路(比如舆情监控)</li>\n<li>监控类型： 基础监控、服务端监控、客户端监控、<br>监控、用户端监控</li>\n<li>监控的目标：全、块、准</li>\n<li>核心指标：请求量、成功率、耗时</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.oschina.net/news/67525/monitoring-tools\" target=\"_blank\" rel=\"noopener\">《开源还是商用？十大云运维监控工具横评》</a></p>\n<ul>\n<li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li>\n</ul>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/201612/525373.htm\" target=\"_blank\" rel=\"noopener\">《监控报警系统搭建及二次开发经验》</a></p>\n</li>\n</ul>\n<p><strong>命令行监控工具</strong></p>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html\" target=\"_blank\" rel=\"noopener\">《常用命令行监控工具》</a></p>\n<ul>\n<li>top、sar、tsar、nload</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.jobbole.com/96846/\" target=\"_blank\" rel=\"noopener\">《20个命令行工具监控 Linux 系统性能》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/feichexia/blog/196575\" target=\"_blank\" rel=\"noopener\">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></p>\n</li>\n</ul>\n<h2 id=\"APM\"><a href=\"#APM\" class=\"headerlink\" title=\"APM\"></a>APM</h2><p>APM —  Application Performance Management</p>\n<ul>\n<li><p><a href=\"http://bigbully.github.io/Dapper-translation/\" target=\"_blank\" rel=\"noopener\">《Dapper，大规模分布式系统的跟踪系统》</a></p>\n</li>\n<li><p><a href=\"http://opentracing.io\" target=\"_blank\" rel=\"noopener\">CNCF OpenTracing</a>，<a href=\"https://github.com/opentracing-contrib/opentracing-specification-zh\" target=\"_blank\" rel=\"noopener\">中文版</a></p>\n</li>\n<li><p>主要开源软件，按字母排序</p>\n<ul>\n<li><a href=\"https://github.com/apache/incubator-skywalking\" target=\"_blank\" rel=\"noopener\">Apache SkyWalking</a></li>\n<li><a href=\"https://github.com/dianping/cat\" target=\"_blank\" rel=\"noopener\">CAT</a></li>\n<li><a href=\"https://github.com/jaegertracing/jaeger\" target=\"_blank\" rel=\"noopener\">CNCF jaeger</a></li>\n<li><a href=\"https://github.com/naver/pinpoint\" target=\"_blank\" rel=\"noopener\">Pinpoint</a></li>\n<li><a href=\"https://github.com/openzipkin/zipkin\" target=\"_blank\" rel=\"noopener\">Zipkin</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/apm-Pinpoint-practice\" target=\"_blank\" rel=\"noopener\">《开源APM技术选型与实战》</a></p>\n<ul>\n<li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"统计分析\"><a href=\"#统计分析\" class=\"headerlink\" title=\"统计分析\"></a>统计分析</h2><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/25195217\" target=\"_blank\" rel=\"noopener\">《流量统计的基础：埋点》</a></p>\n<ul>\n<li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.25xt.com/company/17066.html\" target=\"_blank\" rel=\"noopener\">《APP埋点常用的统计工具、埋点目标和埋点内容》</a></p>\n<ul>\n<li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li>\n</ul>\n</li>\n<li><p><a href=\"https://tech.meituan.com/mt-mobile-analytics-practice.html\" target=\"_blank\" rel=\"noopener\">《美团点评前端无痕埋点实践》</a></p>\n<ul>\n<li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"持续集成-CI-CD\"><a href=\"#持续集成-CI-CD\" class=\"headerlink\" title=\"持续集成(CI/CD)\"></a>持续集成(CI/CD)</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">《持续集成是什么？》</a></li>\n<li><a href=\"https://www.testwo.com/article/1170\" target=\"_blank\" rel=\"noopener\">《8个流行的持续集成工具》</a></li>\n</ul>\n<h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><ul>\n<li><a href=\"https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000\" target=\"_blank\" rel=\"noopener\">《使用Jenkins进行持续集成》</a></li>\n</ul>\n<h3 id=\"环境分离\"><a href=\"#环境分离\" class=\"headerlink\" title=\"环境分离\"></a>环境分离</h3><p>开发、测试、生成环境分离。</p>\n<ul>\n<li><a href=\"https://my.oschina.net/sancuo/blog/214904\" target=\"_blank\" rel=\"noopener\">《开发环境、生产环境、测试环境的基本理解和区》</a></li>\n</ul>\n<h2 id=\"自动化运维\"><a href=\"#自动化运维\" class=\"headerlink\" title=\"自动化运维\"></a>自动化运维</h2><h3 id=\"Ansible\"><a href=\"#Ansible\" class=\"headerlink\" title=\"Ansible\"></a>Ansible</h3><ul>\n<li><a href=\"http://www.ansible.com.cn/\" target=\"_blank\" rel=\"noopener\">《Ansible中文权威指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/heiye123/articles/7855890.html\" target=\"_blank\" rel=\"noopener\">《Ansible基础配置和企业级项目实用案例》</a></li>\n</ul>\n<h3 id=\"puppet\"><a href=\"#puppet\" class=\"headerlink\" title=\"puppet\"></a>puppet</h3><ul>\n<li><a href=\"https://www.cnblogs.com/keerya/p/8040071.html\" target=\"_blank\" rel=\"noopener\">《自动化运维工具——puppet详解》</a></li>\n</ul>\n<h3 id=\"chef\"><a href=\"#chef\" class=\"headerlink\" title=\"chef\"></a>chef</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/\" target=\"_blank\" rel=\"noopener\">《Chef 的安装与使用》</a></li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"TDD-理论\"><a href=\"#TDD-理论\" class=\"headerlink\" title=\"TDD 理论\"></a>TDD 理论</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/62f16cd4fef3\" target=\"_blank\" rel=\"noopener\">《深度解读 - TDD（测试驱动开发）》</a><ul>\n<li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li>\n<li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyzm/p/6482886.html\" target=\"_blank\" rel=\"noopener\">《Java单元测试之JUnit篇》</a></li>\n<li><a href=\"https://blog.csdn.net/hotdust/article/details/53406086\" target=\"_blank\" rel=\"noopener\">《JUnit 4 与 TestNG 对比》</a><ul>\n<li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 </li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/wqetfg/article/details/50900512\" target=\"_blank\" rel=\"noopener\">《单元测试主要的测试功能点》</a><ul>\n<li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h3><ul>\n<li><a href=\"https://blog.csdn.net/blueheart20/article/details/52170790\" target=\"_blank\" rel=\"noopener\">《Apache ab 测试使用指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/binyue/p/6141088.html\" target=\"_blank\" rel=\"noopener\">《大型网站压力测试及优化方案》</a></li>\n<li><a href=\"http://news.chinabyte.com/466/14126966.shtml\" target=\"_blank\" rel=\"noopener\">《10大主流压力/负载/性能测试工具推荐》</a></li>\n<li><a href=\"http://quentinxxz.iteye.com/blog/2249799\" target=\"_blank\" rel=\"noopener\">《真实流量压测工具 tcpcopy应用浅析》</a></li>\n<li><a href=\"https://www.cnblogs.com/jwentest/p/7136727.html\" target=\"_blank\" rel=\"noopener\">《nGrinder 简易使用教程》</a></li>\n</ul>\n<h3 id=\"全链路压测\"><a href=\"#全链路压测\" class=\"headerlink\" title=\"全链路压测\"></a>全链路压测</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot\" target=\"_blank\" rel=\"noopener\">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30306892\" target=\"_blank\" rel=\"noopener\">《饿了么全链路压测的探索与实践》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28355759\" target=\"_blank\" rel=\"noopener\">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li>\n<li><a href=\"https://www.jianshu.com/p/27060fd61f72\" target=\"_blank\" rel=\"noopener\">《全链路压测经验》</a></li>\n</ul>\n<h3 id=\"A-B-、灰度、蓝绿测试\"><a href=\"#A-B-、灰度、蓝绿测试\" class=\"headerlink\" title=\"A/B 、灰度、蓝绿测试\"></a>A/B 、灰度、蓝绿测试</h3><ul>\n<li><a href=\"https://testerhome.com/topics/11165\" target=\"_blank\" rel=\"noopener\">《技术干货 | AB 测试和灰度发布探索及实践》</a></li>\n<li><p><a href=\"http://blog.51cto.com/purplegrape/1403123\" target=\"_blank\" rel=\"noopener\">《nginx 根据IP 进行灰度发布》</a></p>\n</li>\n<li><p><a href=\"https://www.v2ex.com/t/344341\" target=\"_blank\" rel=\"noopener\">《蓝绿部署、A/B 测试以及灰度发布》</a></p>\n</li>\n</ul>\n<h2 id=\"虚拟化\"><a href=\"#虚拟化\" class=\"headerlink\" title=\"虚拟化\"></a>虚拟化</h2><ul>\n<li><a href=\"https://blog.csdn.net/enweitech/article/details/52910082\" target=\"_blank\" rel=\"noopener\">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li>\n</ul>\n<h3 id=\"KVM\"><a href=\"#KVM\" class=\"headerlink\" title=\"KVM\"></a>KVM</h3><ul>\n<li><a href=\"http://blog.chinaunix.net/uid-20201831-id-5775661.html\" target=\"_blank\" rel=\"noopener\">《KVM详解，太详细太深入了，经典》</a></li>\n<li><a href=\"https://www.coderxing.com/kvm-install.html\" target=\"_blank\" rel=\"noopener\">《【图文】KVM 虚拟机安装详解》</a></li>\n</ul>\n<h3 id=\"Xen\"><a href=\"#Xen\" class=\"headerlink\" title=\"Xen\"></a>Xen</h3><ul>\n<li><a href=\"https://www.cnblogs.com/sddai/p/5931201.html\" target=\"_blank\" rel=\"noopener\">《Xen虚拟化基本原理详解》</a></li>\n</ul>\n<h3 id=\"OpenVZ\"><a href=\"#OpenVZ\" class=\"headerlink\" title=\"OpenVZ\"></a>OpenVZ</h3><ul>\n<li><a href=\"https://blog.csdn.net/longerzone/article/details/44829255\" target=\"_blank\" rel=\"noopener\">《开源Linux容器 OpenVZ 快速上手指南》</a></li>\n</ul>\n<h2 id=\"容器技术\"><a href=\"#容器技术\" class=\"headerlink\" title=\"容器技术\"></a>容器技术</h2><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ul>\n<li><a href=\"https://www.cnblogs.com/SzeCheng/p/6822905.html\" target=\"_blank\" rel=\"noopener\">《几张图帮你理解 docker 基本原理及快速入门》</a></li>\n<li><a href=\"https://draveness.me/docker\" target=\"_blank\" rel=\"noopener\">《Docker 核心技术与实现原理》</a></li>\n<li><a href=\"http://www.runoob.com/docker/docker-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Docker 教程》</a></li>\n</ul>\n<h2 id=\"云技术\"><a href=\"#云技术\" class=\"headerlink\" title=\"云技术\"></a>云技术</h2><h3 id=\"OpenStack\"><a href=\"#OpenStack\" class=\"headerlink\" title=\"OpenStack\"></a>OpenStack</h3><ul>\n<li><a href=\"https://www.cnblogs.com/klb561/p/8660264.html\" target=\"_blank\" rel=\"noopener\">《OpenStack构架知识梳理》</a></li>\n</ul>\n<h2 id=\"DevOps\"><a href=\"#DevOps\" class=\"headerlink\" title=\"DevOps\"></a>DevOps</h2><ul>\n<li><a href=\"https://www.cnblogs.com/jetzhang/p/6068773.html\" target=\"_blank\" rel=\"noopener\">《一分钟告诉你究竟DevOps是什么鬼？》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/detail-analysis-of-devops\" target=\"_blank\" rel=\"noopener\">《DevOps详解》</a></li>\n</ul>\n<h2 id=\"文档管理\"><a href=\"#文档管理\" class=\"headerlink\" title=\"文档管理\"></a>文档管理</h2><ul>\n<li><a href=\"http://www.confluence.cn/\" target=\"_blank\" rel=\"noopener\">Confluence-收费文档管理系统</a></li>\n<li>GitLab?</li>\n<li>Wiki</li>\n</ul>\n<h1 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h1><h2 id=\"Web-Server\"><a href=\"#Web-Server\" class=\"headerlink\" title=\"Web Server\"></a>Web Server</h2><h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_25797077/article/details/52200722\" target=\"_blank\" rel=\"noopener\">《Ngnix的基本学习-多进程和Apache的比较》</a></p>\n<ul>\n<li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li>\n<li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/cunkouzh/p/5410154.html\" target=\"_blank\" rel=\"noopener\">《nginx与Apache的对比以及优缺点》</a></p>\n<ul>\n<li>nginx只适合静态和反向代理，不适合处理动态请求。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"OpenResty\"><a href=\"#OpenResty\" class=\"headerlink\" title=\"OpenResty\"></a>OpenResty</h3><ul>\n<li><a href=\"http://openresty.org/cn/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://www.linkedkeeper.com/detail/blog.action?bid=1034\" target=\"_blank\" rel=\"noopener\">《浅谈 OpenResty》</a><ul>\n<li>通过 Lua 模块可以在Nginx上进行开发。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Apache-Httpd\"><a href=\"#Apache-Httpd\" class=\"headerlink\" title=\"Apache Httpd\"></a>Apache Httpd</h3><ul>\n<li><a href=\"http://httpd.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n</ul>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><h4 id=\"架构原理\"><a href=\"#架构原理\" class=\"headerlink\" title=\"架构原理\"></a>架构原理</h4><ul>\n<li><a href=\"https://www.cnblogs.com/hggen/p/6264475.html\" target=\"_blank\" rel=\"noopener\">《TOMCAT原理详解及请求过程》</a></li>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4706223.html\" target=\"_blank\" rel=\"noopener\">《Tomcat服务器原理详解》</a></li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/\" target=\"_blank\" rel=\"noopener\">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xlgen157387/article/details/79006434\" target=\"_blank\" rel=\"noopener\">《四张图带你了解Tomcat系统架构》</a></p>\n</li>\n<li><p><a href=\"https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/\" target=\"_blank\" rel=\"noopener\">《JBoss vs. Tomcat: Choosing A Java Application Server》</a></p>\n<ul>\n<li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。</li>\n<li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"调优方案\"><a href=\"#调优方案\" class=\"headerlink\" title=\"调优方案\"></a>调优方案</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/sunfenqing/p/7339058.html\" target=\"_blank\" rel=\"noopener\">《Tomcat 调优方案》</a></p>\n<ul>\n<li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.chinaunix.net/uid-20662363-id-3012760.html\" target=\"_blank\" rel=\"noopener\">《tomcat http协议与ajp协议》</a></p>\n</li>\n<li><a href=\"http://dmouse.iteye.com/blog/1354527\" target=\"_blank\" rel=\"noopener\">《AJP与HTTP比较和分析》</a><ul>\n<li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li>\n<li>并发高时，AJP协议优于HTTP协议。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Jetty\"><a href=\"#Jetty\" class=\"headerlink\" title=\"Jetty\"></a>Jetty</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jetty/\" target=\"_blank\" rel=\"noopener\">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li>\n<li><a href=\"https://blog.csdn.net/doutao6677/article/details/51957288\" target=\"_blank\" rel=\"noopener\">《jetty和tomcat优势比较》</a><ul>\n<li>架构比较:Jetty的架构比Tomcat的更为简单。</li>\n<li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li>\n<li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ul>\n<li><a href=\"https://blog.csdn.net/clementad/article/details/48229243\" target=\"_blank\" rel=\"noopener\">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li>\n</ul>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html\" target=\"_blank\" rel=\"noopener\">《HashMap本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html\" target=\"_blank\" rel=\"noopener\">《EhCache本地缓存》</a></p>\n<ul>\n<li>堆内、堆外、磁盘三级缓存。</li>\n<li>可按照缓存空间容量进行设置。</li>\n<li>按照时间、次数等过期策略。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html\" target=\"_blank\" rel=\"noopener\">《Guava Cache》</a></p>\n<ul>\n<li>简单轻量、无堆外、磁盘缓存。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html\" target=\"_blank\" rel=\"noopener\">《Nginx本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html\" target=\"_blank\" rel=\"noopener\">《Pagespeed—懒人工具，服务器端加速》</a></p>\n</li>\n</ul>\n<h2 id=\"客户端缓存\"><a href=\"#客户端缓存\" class=\"headerlink\" title=\"客户端缓存\"></a>客户端缓存</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html\" target=\"_blank\" rel=\"noopener\">《浏览器端缓存》</a></p>\n<ul>\n<li>主要是利用 Cache-Control 参数。</li>\n</ul>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w\" target=\"_blank\" rel=\"noopener\">《H5 和移动端 WebView 缓存机制解析与实战》</a></p>\n</li>\n</ul>\n<h2 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a>服务端缓存</h2><h3 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h3><ul>\n<li><a href=\"https://github.com/jiangwenyuan/nuster\" target=\"_blank\" rel=\"noopener\">nuster</a> - nuster cache</li>\n<li><a href=\"https://github.com/varnishcache/varnish-cache\" target=\"_blank\" rel=\"noopener\">varnish</a> - varnish cache</li>\n<li><a href=\"https://github.com/squid-cache/squid\" target=\"_blank\" rel=\"noopener\">squid</a> - squid cache</li>\n</ul>\n<h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><ul>\n<li><a href=\"http://www.runoob.com/Memcached/Memcached-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Memcached 教程》</a></li>\n<li><a href=\"https://blog.csdn.net/chenleixing/article/details/47035453\" target=\"_blank\" rel=\"noopener\">《深入理解Memcached原理》</a><ul>\n<li>采用多路复用技术提高并发性。</li>\n<li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li>\n</ul>\n</li>\n<li><a href=\"https://www.jianshu.com/p/36e5cd400580\" target=\"_blank\" rel=\"noopener\">《Memcached软件工作原理》</a></li>\n<li><p><a href=\"http://zhihuzeye.com/archives/2361\" target=\"_blank\" rel=\"noopener\">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/liu251890347/article/details/37690045\" target=\"_blank\" rel=\"noopener\">《memcache 中 add 、 set 、replace 的区别》</a></p>\n<ul>\n<li>区别在于当key存在还是不存在时，返回值是true和false的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1qX00Lti?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=\" target=\"_blank\" rel=\"noopener\"><strong>《memcached全面剖析》</strong></a></p>\n</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ul>\n<li><a href=\"http://www.runoob.com/redis/redis-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Redis 教程》</a></li>\n<li><a href=\"https://blog.csdn.net/wcf373722432/article/details/78678504\" target=\"_blank\" rel=\"noopener\">《redis底层原理》</a><ul>\n<li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li>\n<li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://doc.redisfans.com/topic/persistence.html\" target=\"_blank\" rel=\"noopener\">《Redis持久化方式》</a></p>\n<ul>\n<li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li>\n<li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li>\n<li>也可以两者结合使用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chunlongyu/article/details/53346436\" target=\"_blank\" rel=\"noopener\">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><a href=\"https://blog.csdn.net/sunhuiliang85/article/details/73656830\" target=\"_blank\" rel=\"noopener\">《Redis单线程架构》</a></li>\n</ul>\n<h4 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h4><ul>\n<li><a href=\"https://blog.csdn.net/qq_29108585/article/details/63251491\" target=\"_blank\" rel=\"noopener\">《redis的回收策略》</a></li>\n</ul>\n<h3 id=\"Tair\"><a href=\"#Tair\" class=\"headerlink\" title=\"Tair\"></a>Tair</h3><ul>\n<li><a href=\"https://github.com/alibaba/tair\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://blog.csdn.net/farphone/article/details/53522383\" target=\"_blank\" rel=\"noopener\">《Tair和Redis的对比》</a></li>\n<li>特点：可以配置备份节点数目，通过异步同步到备份节点</li>\n<li>一致性Hash算法。</li>\n<li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li>\n</ul>\n<p>几种存储引擎:</p>\n<ul>\n<li>MDB，完全内存性，可以用来存储Session等数据。</li>\n<li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li>\n<li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li>\n<li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li>\n</ul>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/charlesblc/p/6045238.html\" target=\"_blank\" rel=\"noopener\">《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》</a></p>\n<ul>\n<li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li>\n<li>Kafka 默认是拉模式。</li>\n<li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li>\n<li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yunfeng482/article/details/72856762\" target=\"_blank\" rel=\"noopener\">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></p>\n</li>\n</ul>\n<h3 id=\"消息总线\"><a href=\"#消息总线\" class=\"headerlink\" title=\"消息总线\"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanghua_kobe/article/details/43877281\" target=\"_blank\" rel=\"noopener\">《消息总线VS消息队列》</a></li>\n</ul>\n<h3 id=\"消息的顺序\"><a href=\"#消息的顺序\" class=\"headerlink\" title=\"消息的顺序\"></a>消息的顺序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/cjsblog/p/8267892.html\" target=\"_blank\" rel=\"noopener\">《如何保证消费者接收消息的顺序》</a></li>\n</ul>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/whoamiyang/article/details/54954780\" target=\"_blank\" rel=\"noopener\">《RabbitMQ的应用场景以及基本原理介绍》</a></li>\n<li><a href=\"https://www.jianshu.com/p/79ca08116d57\" target=\"_blank\" rel=\"noopener\">《消息队列之 RabbitMQ》</a> </li>\n<li><a href=\"https://blog.csdn.net/u013256816/article/details/55515234\" target=\"_blank\" rel=\"noopener\">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li>\n</ul>\n<h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/824066d70da8\" target=\"_blank\" rel=\"noopener\">《RocketMQ 实战之快速入门》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/RocketMQ/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《RocketMQ 源码解析》</a></li>\n</ul>\n<h3 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/3962302.html\" target=\"_blank\" rel=\"noopener\">《ActiveMQ消息队列介绍》</a></li>\n</ul>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p>\n<ul>\n<li><a href=\"http://kafka.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/allthesametome/article/details/47362451\" target=\"_blank\" rel=\"noopener\">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li>\n<li><a href=\"http://lxw1234.com/archives/2015/10/538.htm\" target=\"_blank\" rel=\"noopener\">《Kafka分区机制介绍与示例》</a></li>\n</ul>\n<h3 id=\"Redis-消息推送\"><a href=\"#Redis-消息推送\" class=\"headerlink\" title=\"Redis 消息推送\"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_34212276/article/details/78455004\" target=\"_blank\" rel=\"noopener\">《Redis学习笔记之十：Redis用作消息队列》</a></li>\n</ul>\n<h3 id=\"ZeroMQ\"><a href=\"#ZeroMQ\" class=\"headerlink\" title=\"ZeroMQ\"></a>ZeroMQ</h3><p> TODO</p>\n<h2 id=\"定时调度\"><a href=\"#定时调度\" class=\"headerlink\" title=\"定时调度\"></a>定时调度</h2><h3 id=\"单机定时调度\"><a href=\"#单机定时调度\" class=\"headerlink\" title=\"单机定时调度\"></a>单机定时调度</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/shuaiqing/p/7742382.html\" target=\"_blank\" rel=\"noopener\">《linux定时任务cron配置》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/daquan/blog/483305\" target=\"_blank\" rel=\"noopener\">《Linux cron运行原理》</a></p>\n<ul>\n<li>fork 进程 + sleep 轮询</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/drift-ice/p/3817269.html\" target=\"_blank\" rel=\"noopener\">《Quartz使用总结》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/wenniuwuren/article/details/42082981/\" target=\"_blank\" rel=\"noopener\">《Quartz源码解析 —- 触发器按时启动原理》</a></li>\n<li><a href=\"https://www.jianshu.com/p/bab8e4e32952\" target=\"_blank\" rel=\"noopener\">《quartz原理揭秘和源码解读》</a><ul>\n<li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式定时调度\"><a href=\"#分布式定时调度\" class=\"headerlink\" title=\"分布式定时调度\"></a>分布式定时调度</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_16216221/article/details/70314337\" target=\"_blank\" rel=\"noopener\">《这些优秀的国产分布式任务调度系统，你用过几个？》</a></p>\n<ul>\n<li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html\" target=\"_blank\" rel=\"noopener\">《Quartz任务调度的基本实现原理》</a></p>\n<ul>\n<li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 </li>\n</ul>\n</li>\n<li><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Elastic-Job-Lite 源码解析》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Elastic-Job-Cloud 源码解析》</a></li>\n</ul>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/top_code/article/details/54615853\" target=\"_blank\" rel=\"noopener\">《从零开始实现RPC框架 - RPC原理及实现》</a></p>\n<ul>\n<li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/testcs_dn/article/details/78050590\" target=\"_blank\" rel=\"noopener\">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></p>\n</li>\n</ul>\n<h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><ul>\n<li><a href=\"http://dubbo.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/steven520213/p/7606598.html\" target=\"_blank\" rel=\"noopener\">dubbo实现原理简单介绍</a></li>\n</ul>\n<p><strong> SPI </strong><br>TODO</p>\n<h3 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h3><ul>\n<li><a href=\"http://thrift.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/kesonyk/article/details/50924489\" target=\"_blank\" rel=\"noopener\">《Thrift RPC详解》</a><ul>\n<li>支持多语言，通过中间语言定义接口。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p>\n<ul>\n<li><a href=\"https://grpc.io/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/LBSer/p/4853234.html\" target=\"_blank\" rel=\"noopener\">《你应该知道的RPC原理》</a></li>\n</ul>\n<h2 id=\"数据库中间件\"><a href=\"#数据库中间件\" class=\"headerlink\" title=\"数据库中间件\"></a>数据库中间件</h2><h3 id=\"Sharding-Jdbc\"><a href=\"#Sharding-Jdbc\" class=\"headerlink\" title=\"Sharding Jdbc\"></a>Sharding Jdbc</h3><ul>\n<li><a href=\"http://shardingjdbc.io/\" target=\"_blank\" rel=\"noopener\">官网</a></li>\n</ul>\n<h2 id=\"日志系统\"><a href=\"#日志系统\" class=\"headerlink\" title=\"日志系统\"></a>日志系统</h2><h3 id=\"日志搜集\"><a href=\"#日志搜集\" class=\"headerlink\" title=\"日志搜集\"></a>日志搜集</h3><ul>\n<li><a href=\"http://cjting.me/misc/build-log-system-with-elkb/\" target=\"_blank\" rel=\"noopener\">《从零开始搭建一个ELKB日志收集系统》</a></li>\n<li><a href=\"https://blog.csdn.net/lzw_2006/article/details/51280058\" target=\"_blank\" rel=\"noopener\">《用ELK搭建简单的日志收集分析系统》</a></li>\n<li><a href=\"https://www.cnblogs.com/beginmind/p/6058194.html\" target=\"_blank\" rel=\"noopener\">《日志收集系统-探究》</a></li>\n</ul>\n<h2 id=\"配置中心\"><a href=\"#配置中心\" class=\"headerlink\" title=\"配置中心\"></a>配置中心</h2><ul>\n<li><p><a href=\"https://github.com/ctripcorp/apollo\" target=\"_blank\" rel=\"noopener\">Apollo - 携程开源的配置中心应用</a></p>\n<ul>\n<li>Spring Boot 和 Spring Cloud</li>\n<li>支持推、拉模式更新配置</li>\n<li>支持多种语言 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011320740/article/details/78742625\" target=\"_blank\" rel=\"noopener\">《基于zookeeper实现统一配置管理》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/shamo89/p/8016908.html\" target=\"_blank\" rel=\"noopener\">《 Spring Cloud Config 分布式配置中心使用教程》</a></p>\n</li>\n</ul>\n<p>servlet 3.0 异步特性可用于配置中心的客户端</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/dogdogwang/p/7151866.html\" target=\"_blank\" rel=\"noopener\">《servlet3.0 新特性——异步处理》</a></li>\n</ul>\n<h2 id=\"API-网关\"><a href=\"#API-网关\" class=\"headerlink\" title=\"API 网关\"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p>\n<ul>\n<li><a href=\"http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/\" target=\"_blank\" rel=\"noopener\">《API网关那些儿》</a></li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo\" target=\"_blank\" rel=\"noopener\">《谈API网关的背景、架构以及落地方案》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhanglh046/article/details/78651993\" target=\"_blank\" rel=\"noopener\">《使用Zuul构建API Gateway》</a></p>\n</li>\n<li><a href=\"http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Spring Cloud Gateway 源码解析》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A\" target=\"_blank\" rel=\"noopener\">《HTTP API网关选择之一Kong介绍》</a></li>\n</ul>\n<h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><h3 id=\"OSI-七层协议\"><a href=\"#OSI-七层协议\" class=\"headerlink\" title=\"OSI 七层协议\"></a>OSI 七层协议</h3><ul>\n<li><a href=\"https://www.cnblogs.com/Robin-YB/p/6668762.html\" target=\"_blank\" rel=\"noopener\">《OSI七层协议模型、TCP/IP四层模型学习笔记》</a></li>\n</ul>\n<h3 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/onepixel/p/7092302.html\" target=\"_blank\" rel=\"noopener\">《深入浅出 TCP/IP 协议》</a></li>\n<li><a href=\"https://blog.csdn.net/whuslei/article/details/6667471/\" target=\"_blank\" rel=\"noopener\">《TCP协议中的三次握手和四次挥手》</a></li>\n</ul>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wangning528/p/6388464.html\" target=\"_blank\" rel=\"noopener\">《http协议详解(超详细)》</a></li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li><a href=\"https://blog.csdn.net/zhuyiquan/article/details/69257126\" target=\"_blank\" rel=\"noopener\">《HTTP 2.0 原理详细分析》</a></li>\n<li><a href=\"https://blog.csdn.net/u012657197/article/details/77877840\" target=\"_blank\" rel=\"noopener\">《HTTP2.0的基本单位为二进制帧》</a><ul>\n<li>利用二进制帧负责传输。</li>\n<li>多路复用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/zhangshitong/p/6478721.html\" target=\"_blank\" rel=\"noopener\">《https原理通俗了解》</a></p>\n<ul>\n<li>使用非对称加密协商加密算法</li>\n<li>使用对称加密方式传输数据</li>\n<li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/53213862\" target=\"_blank\" rel=\"noopener\">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></p>\n</li>\n</ul>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><ul>\n<li><p><a href=\"http://blog.51cto.com/litaotao/1289790\" target=\"_blank\" rel=\"noopener\">《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》</a></p>\n<ul>\n<li>五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li>\n<li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Anker/p/3265058.html\" target=\"_blank\" rel=\"noopener\">《select、poll、epoll之间的区别总结》</a></p>\n<ul>\n<li>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li>\n<li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li>\n<li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li>\n<li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li>\n</ul>\n</li>\n<li><p><a href=\"http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/\" target=\"_blank\" rel=\"noopener\">《select，poll，epoll比较  》</a></p>\n<ul>\n<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/geason/p/5774096.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java NIO》</a></p>\n<ul>\n<li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/skiof007/article/details/52873421\" target=\"_blank\" rel=\"noopener\">《BIO与NIO、AIO的区别》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u013074465/article/details/46276967\" target=\"_blank\" rel=\"noopener\">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></p>\n</li>\n</ul>\n<h3 id=\"Epoll\"><a href=\"#Epoll\" class=\"headerlink\" title=\"Epoll\"></a>Epoll</h3><ul>\n<li><a href=\"https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html\" target=\"_blank\" rel=\"noopener\">《epoll使用详解（精髓）》</a></li>\n</ul>\n<h3 id=\"Java-NIO\"><a href=\"#Java-NIO\" class=\"headerlink\" title=\"Java NIO\"></a>Java NIO</h3><ul>\n<li><a href=\"https://www.cnblogs.com/geason/p/5774096.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java NIO》</a></li>\n<li><a href=\"https://blog.csdn.net/xidianliuy/article/details/51612676\" target=\"_blank\" rel=\"noopener\">《Java NIO编写Socket服务器的一个例子》</a></li>\n</ul>\n<h3 id=\"kqueue\"><a href=\"#kqueue\" class=\"headerlink\" title=\"kqueue\"></a>kqueue</h3><ul>\n<li><a href=\"http://www.cnblogs.com/luminocean/p/5631336.html\" target=\"_blank\" rel=\"noopener\">《kqueue用法简介》</a></li>\n</ul>\n<h2 id=\"连接和短连接\"><a href=\"#连接和短连接\" class=\"headerlink\" title=\"连接和短连接\"></a>连接和短连接</h2><ul>\n<li><a href=\"https://www.cnblogs.com/pangguoping/p/5571422.html\" target=\"_blank\" rel=\"noopener\">《TCP/IP系列——长连接与短连接的区别》</a></li>\n</ul>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><ul>\n<li><a href=\"https://blog.csdn.net/excellentyuxiao/article/details/53390408\" target=\"_blank\" rel=\"noopener\">《Netty原理剖析》</a><ul>\n<li>Reactor 模式介绍。</li>\n<li>Netty 是 Reactor 模式的一种实现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"零拷贝（Zero-copy）\"><a href=\"#零拷贝（Zero-copy）\" class=\"headerlink\" title=\"零拷贝（Zero-copy）\"></a>零拷贝（Zero-copy）</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\" target=\"_blank\" rel=\"noopener\">《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》</a><ul>\n<li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"序列化-二进制协议\"><a href=\"#序列化-二进制协议\" class=\"headerlink\" title=\"序列化(二进制协议)\"></a>序列化(二进制协议)</h2><h3 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyday56/p/4268249.html\" target=\"_blank\" rel=\"noopener\">《Hessian原理分析》</a><br>Binary-RPC;不仅仅是序列化</li>\n</ul>\n<h3 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h3><ul>\n<li><a href=\"https://blog.csdn.net/antgan/article/details/52103966\" target=\"_blank\" rel=\"noopener\">《Protobuf协议的Java应用例子》</a><br>Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。</li>\n<li><p><a href=\"https://worktile.com/tech/share/prototol-buffers\" target=\"_blank\" rel=\"noopener\">《Protocol Buffers序列化协议及应用》</a></p>\n<pre><code>* 关于协议的解释；缺点：可读性差;\n</code></pre></li>\n<li><p><a href=\"https://blog.csdn.net/eric520zenobia/article/details/53766571\" target=\"_blank\" rel=\"noopener\">《简单的使用 protobuf 和 protostuff》</a></p>\n<ul>\n<li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"基础理论\"><a href=\"#基础理论\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h2><h3 id=\"数据库设计的三大范式\"><a href=\"#数据库设计的三大范式\" class=\"headerlink\" title=\"数据库设计的三大范式\"></a>数据库设计的三大范式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/waj6511988/p/7027127.html\" target=\"_blank\" rel=\"noopener\">《数据库的三大范式以及五大约束》</a><ul>\n<li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li>\n<li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>\n<li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li><p><a href=\"http://www.admin10000.com/document/5372.html\" target=\"_blank\" rel=\"noopener\">《MySQL的InnoDB索引原理详解》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xifeijian/article/details/20316775\" target=\"_blank\" rel=\"noopener\">《MySQL存储引擎－－MyISAM与InnoDB区别》</a></p>\n<ul>\n<li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201211/172380.html\" target=\"_blank\" rel=\"noopener\">《myisam和innodb索引实现的不同》</a></p>\n</li>\n</ul>\n<h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><ul>\n<li><a href=\"https://my.oschina.net/kailuncen/blog/1504217\" target=\"_blank\" rel=\"noopener\">《一篇文章带你读懂Mysql和InnoDB》</a></li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><ul>\n<li><p><a href=\"http://vdisk.weibo.com/s/muWOT\" target=\"_blank\" rel=\"noopener\">《MySQL36条军规》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhouyusheng/p/8038224.html\" target=\"_blank\" rel=\"noopener\">《MYSQL性能优化的最佳20+条经验》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/when_less_is_more/article/details/70187459\" target=\"_blank\" rel=\"noopener\">《SQL优化之道》</a></li>\n<li><a href=\"https://www.cnblogs.com/sivkun/p/7518540.html\" target=\"_blank\" rel=\"noopener\">《mysql数据库死锁的产生原因及解决办法》</a></li>\n<li><a href=\"https://blog.csdn.net/monkey_d_feilong/article/details/52291556\" target=\"_blank\" rel=\"noopener\">《导致索引失效的可能情况》</a></li>\n<li><a href=\"https://blog.csdn.net/zy_281870667/article/details/51604540\" target=\"_blank\" rel=\"noopener\">《 MYSQL分页limit速度太慢优化方法》</a><ul>\n<li>原则上就是缩小扫描范围。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"聚集索引-非聚集索引\"><a href=\"#聚集索引-非聚集索引\" class=\"headerlink\" title=\"聚集索引, 非聚集索引\"></a>聚集索引, 非聚集索引</h4><ul>\n<li><a href=\"https://blog.csdn.net/no_endless/article/details/77073549\" target=\"_blank\" rel=\"noopener\">《MySQL 聚集索引/非聚集索引简述》</a></li>\n<li><a href=\"https://www.cnblogs.com/zlcxbb/p/5757245.html\" target=\"_blank\" rel=\"noopener\">《MyISAM和InnoDB的索引实现》</a></li>\n</ul>\n<p>MyISAM 是非聚集，InnoDB 是聚集</p>\n<h4 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h4><ul>\n<li><a href=\"https://www.cnblogs.com/summer0space/p/7247778.html\" target=\"_blank\" rel=\"noopener\">《复合索引的优点和注意事项》</a></li>\n</ul>\n<h4 id=\"自适应哈希索引-AHI\"><a href=\"#自适应哈希索引-AHI\" class=\"headerlink\" title=\"自适应哈希索引(AHI)\"></a>自适应哈希索引(AHI)</h4><ul>\n<li><a href=\"https://blog.csdn.net/Linux_ever/article/details/62043708\" target=\"_blank\" rel=\"noopener\">《InnoDB存储引擎——自适应哈希索引》</a></li>\n</ul>\n<h3 id=\"explain\"><a href=\"#explain\" class=\"headerlink\" title=\"explain\"></a>explain</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008131735\" target=\"_blank\" rel=\"noopener\">《MySQL 性能优化神器 Explain 使用分析》</a></li>\n</ul>\n<h2 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h2><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><ul>\n<li><a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\" target=\"_blank\" rel=\"noopener\">MongoDB 教程</a></li>\n<li><a href=\"http://mxdxm.iteye.com/blog/2093603\" target=\"_blank\" rel=\"noopener\">《Mongodb相对于关系型数据库的优缺点》</a><ul>\n<li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li>\n<li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hbase\"><a href=\"#Hbase\" class=\"headerlink\" title=\"Hbase\"></a>Hbase</h3><ul>\n<li><a href=\"http://www.thebigdata.cn/HBase/35831.html\" target=\"_blank\" rel=\"noopener\">《简明 HBase 入门教程（开篇）》</a></li>\n<li><a href=\"https://www.cnblogs.com/qiaoyihang/p/6246424.html\" target=\"_blank\" rel=\"noopener\">《深入学习HBase架构原理》</a></li>\n<li><a href=\"https://blog.csdn.net/youzhouliu/article/details/67632882\" target=\"_blank\" rel=\"noopener\">《传统的行存储和（HBase）列存储的区别》</a></li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/lifuxiangcaohui/article/details/39891099\" target=\"_blank\" rel=\"noopener\">《Hbase与传统数据库的区别》</a></p>\n<ul>\n<li>空数据不存储，节省空间，且适用于并发。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014091123/article/details/73163088\" target=\"_blank\" rel=\"noopener\">《HBase Rowkey设计》</a></p>\n<ul>\n<li>rowkey 按照字典顺序排列，便于批量扫描。</li>\n<li>通过散列可以避免热点。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"搜索引擎\"><a href=\"#搜索引擎\" class=\"headerlink\" title=\"搜索引擎\"></a>搜索引擎</h1><h2 id=\"搜索引擎原理\"><a href=\"#搜索引擎原理\" class=\"headerlink\" title=\"搜索引擎原理\"></a>搜索引擎原理</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/0193dc44135b\" target=\"_blank\" rel=\"noopener\">《倒排索引–搜索引擎入门》</a></li>\n</ul>\n<h2 id=\"Lucene\"><a href=\"#Lucene\" class=\"headerlink\" title=\"Lucene\"></a>Lucene</h2><ul>\n<li><a href=\"https://www.cnblogs.com/rodge-run/p/6551152.html\" target=\"_blank\" rel=\"noopener\">《Lucene入门简介》</a></li>\n</ul>\n<h2 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h2><ul>\n<li><a href=\"https://blog.csdn.net/laoyang360/article/details/52244917\" target=\"_blank\" rel=\"noopener\">《Elasticsearch学习，请先看这一篇！》</a></li>\n<li><a href=\"https://blog.csdn.net/cyony/article/details/65437708\" target=\"_blank\" rel=\"noopener\">《Elasticsearch索引原理》</a></li>\n</ul>\n<h2 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h2><ul>\n<li><a href=\"https://blog.csdn.net/u011936655/article/details/51960005\" target=\"_blank\" rel=\"noopener\">《 Apache Solr入门教程》</a></li>\n<li><a href=\"https://blog.csdn.net/convict_eva/article/details/53537837\" target=\"_blank\" rel=\"noopener\">《elasticsearch与solr比较》</a></li>\n</ul>\n<h2 id=\"sphinx\"><a href=\"#sphinx\" class=\"headerlink\" title=\"sphinx\"></a>sphinx</h2><ul>\n<li><a href=\"http://blog.jobbole.com/101672/\" target=\"_blank\" rel=\"noopener\">《Sphinx 的介绍和原理探索》</a></li>\n</ul>\n<h1 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h1><h2 id=\"性能优化方法论\"><a href=\"#性能优化方法论\" class=\"headerlink\" title=\"性能优化方法论\"></a>性能优化方法论</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread\" target=\"_blank\" rel=\"noopener\">《15天的性能优化工作，5方面的调优经验》</a></p>\n<ul>\n<li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/tenglizhe/article/details/44563135\" target=\"_blank\" rel=\"noopener\">《系统性能优化的几个方面》</a></p>\n</li>\n</ul>\n<h2 id=\"容量评估\"><a href=\"#容量评估\" class=\"headerlink\" title=\"容量评估\"></a>容量评估</h2><ul>\n<li><a href=\"https://blog.csdn.net/u012528360/article/details/70054156\" target=\"_blank\" rel=\"noopener\">《联网性能与容量评估的方法论和典型案例》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959542&amp;idx=1&amp;sn=2494bbea9a855e0e1c3ccd6d2562a600&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">《互联网架构，如何进行容量设计？》</a><ul>\n<li>评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CDN-网络\"><a href=\"#CDN-网络\" class=\"headerlink\" title=\"CDN 网络\"></a>CDN 网络</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wxiaona/p/5867685.html\" target=\"_blank\" rel=\"noopener\">《CDN加速原理》</a></li>\n<li><a href=\"https://www.zhihu.com/question/20536932\" target=\"_blank\" rel=\"noopener\">《国内有哪些比较好的 CDN？》</a></li>\n</ul>\n<h2 id=\"连接池\"><a href=\"#连接池\" class=\"headerlink\" title=\"连接池\"></a>连接池</h2><ul>\n<li><a href=\"https://blog.csdn.net/fysuccess/article/details/66972554\" target=\"_blank\" rel=\"noopener\">《主流Java数据库连接池比较与开发配置实战》</a></li>\n</ul>\n<h2 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h2><ul>\n<li><a href=\"https://blog.csdn.net/yethyeth/article/details/73266455\" target=\"_blank\" rel=\"noopener\">《九大Java性能调试工具，必备至少一款》</a></li>\n</ul>\n<h1 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h1><h2 id=\"流式计算\"><a href=\"#流式计算\" class=\"headerlink\" title=\"流式计算\"></a>流式计算</h2><h3 id=\"Storm\"><a href=\"#Storm\" class=\"headerlink\" title=\"Storm\"></a>Storm</h3><ul>\n<li><a href=\"http://storm.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/uisoul/article/details/77989927\" target=\"_blank\" rel=\"noopener\">《最详细的Storm入门教程》</a></li>\n</ul>\n<h3 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h3><ul>\n<li><a href=\"https://blog.csdn.net/lisi1129/article/details/54844919\" target=\"_blank\" rel=\"noopener\">《Flink之一 Flink基本原理介绍》</a></li>\n</ul>\n<h3 id=\"Kafka-Stream\"><a href=\"#Kafka-Stream\" class=\"headerlink\" title=\"Kafka Stream\"></a>Kafka Stream</h3><ul>\n<li><a href=\"https://yq.aliyun.com/articles/58382\" target=\"_blank\" rel=\"noopener\">《Kafka Stream调研：一种轻量级流计算模式》</a></li>\n</ul>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>例如：</p>\n<ul>\n<li>广告相关实时统计；</li>\n<li>推荐系统用户画像标签实时更新；</li>\n<li>线上服务健康状况实时监测；</li>\n<li>实时榜单；</li>\n<li>实时数据统计。</li>\n</ul>\n<h2 id=\"Hadoop\"><a href=\"#Hadoop\" class=\"headerlink\" title=\"Hadoop\"></a>Hadoop</h2><ul>\n<li><a href=\"https://blog.csdn.net/houbin0912/article/details/72967178\" target=\"_blank\" rel=\"noopener\">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li>\n<li><a href=\"http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html\" target=\"_blank\" rel=\"noopener\">《史上最详细的Hadoop环境搭建》</a></li>\n</ul>\n<h3 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000011575458\" target=\"_blank\" rel=\"noopener\">《【Hadoop学习】HDFS基本原理》</a></li>\n</ul>\n<h3 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h3><ul>\n<li><a href=\"https://blog.csdn.net/oppo62258801/article/details/72884633\" target=\"_blank\" rel=\"noopener\">《用通俗易懂的大白话讲解Map/Reduce原理》</a></li>\n<li><a href=\"https://blog.csdn.net/foye12/article/details/78358292\" target=\"_blank\" rel=\"noopener\">《 简单的map-reduce的java例子》</a></li>\n</ul>\n<h3 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h3><ul>\n<li><a href=\"http://www.cnblogs.com/codeOfLife/p/5492740.html\" target=\"_blank\" rel=\"noopener\">《初步掌握Yarn的架构及原理》</a></li>\n</ul>\n<h2 id=\"Spark\"><a href=\"#Spark\" class=\"headerlink\" title=\"Spark\"></a>Spark</h2><ul>\n<li><a href=\"http://www.cnblogs.com/tgzhu/p/5818374.html\" target=\"_blank\" rel=\"noopener\">《Spark(一): 基本架构及原理》</a></li>\n</ul>\n<h1 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h1><h2 id=\"web-安全\"><a href=\"#web-安全\" class=\"headerlink\" title=\"web 安全\"></a>web 安全</h2><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><ul>\n<li><a href=\"https://blog.csdn.net/qq_21956483/article/details/54377947\" target=\"_blank\" rel=\"noopener\">《xss攻击原理与解决方法》</a><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html\" target=\"_blank\" rel=\"noopener\">《CSRF原理及防范》</a></li>\n</ul>\n<h3 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html\" target=\"_blank\" rel=\"noopener\">《SQL注入》</a></li>\n</ul>\n<h3 id=\"Hash-Dos\"><a href=\"#Hash-Dos\" class=\"headerlink\" title=\"Hash Dos\"></a>Hash Dos</h3><ul>\n<li><a href=\"http://www.freebuf.com/articles/web/14199.html\" target=\"_blank\" rel=\"noopener\">《邪恶的JAVA HASH DOS攻击》</a><ul>\n<li>利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li>\n</ul>\n</li>\n<li><a href=\"https://yq.aliyun.com/articles/92194?t=t1\" target=\"_blank\" rel=\"noopener\">《一种高级的DoS攻击-Hash碰撞攻击》</a></li>\n<li><a href=\"http://www.iteye.com/news/23939/\" target=\"_blank\" rel=\"noopener\">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li>\n</ul>\n<h3 id=\"脚本注入\"><a href=\"#脚本注入\" class=\"headerlink\" title=\"脚本注入\"></a>脚本注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html\" target=\"_blank\" rel=\"noopener\">《上传文件漏洞原理及防范》</a></li>\n</ul>\n<h3 id=\"漏洞扫描工具\"><a href=\"#漏洞扫描工具\" class=\"headerlink\" title=\"漏洞扫描工具\"></a>漏洞扫描工具</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html\" target=\"_blank\" rel=\"noopener\">《DVWA》</a></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html\" target=\"_blank\" rel=\"noopener\">W3af</a></li>\n<li><a href=\"https://blog.csdn.net/xygg0801/article/details/53610640\" target=\"_blank\" rel=\"noopener\">OpenVAS详解</a></li>\n</ul>\n<h3 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/niaonao/article/details/51112686\" target=\"_blank\" rel=\"noopener\">《验证码原理分析及实现》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/jiangbianwanghai/blog/1031031\" target=\"_blank\" rel=\"noopener\">《详解滑动验证码的实现原理》</a></p>\n<ul>\n<li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/xcj26/p/5242758.html\" target=\"_blank\" rel=\"noopener\">《淘宝滑动验证码研究》</a></p>\n</li>\n</ul>\n<h2 id=\"DDoS-防范\"><a href=\"#DDoS-防范\" class=\"headerlink\" title=\"DDoS 防范\"></a>DDoS 防范</h2><ul>\n<li><a href=\"http://netsecurity.51cto.com/art/201601/503799.htm\" target=\"_blank\" rel=\"noopener\">《学习手册：DDoS的攻击方式及防御手段》</a></li>\n<li><a href=\"http://netsecurity.51cto.com/art/201406/442756.htm\" target=\"_blank\" rel=\"noopener\">《免费DDoS攻击测试工具大合集》</a></li>\n</ul>\n<h2 id=\"用户隐私信息保护\"><a href=\"#用户隐私信息保护\" class=\"headerlink\" title=\"用户隐私信息保护\"></a>用户隐私信息保护</h2><ol>\n<li>用户密码非明文保存，加动态salt。</li>\n<li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li>\n<li>联系方式在的显示与否由用户自己控制。</li>\n<li>TODO</li>\n</ol>\n<ul>\n<li><a href=\"https://zhidao.baidu.com/question/1988017976673661587.html\" target=\"_blank\" rel=\"noopener\">《个人隐私包括哪些》</a></li>\n<li><p><a href=\"https://www.zhihu.com/question/20137108\" target=\"_blank\" rel=\"noopener\">《在互联网上，隐私的范围包括哪些？》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html\" target=\"_blank\" rel=\"noopener\">《用户密码保存》</a></p>\n</li>\n</ul>\n<h2 id=\"序列化漏洞\"><a href=\"#序列化漏洞\" class=\"headerlink\" title=\"序列化漏洞\"></a>序列化漏洞</h2><ul>\n<li><a href=\"https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/\" target=\"_blank\" rel=\"noopener\">《Lib之过？Java反序列化漏洞通用利用分析》</a></li>\n</ul>\n<h2 id=\"加密解密\"><a href=\"#加密解密\" class=\"headerlink\" title=\"加密解密\"></a>加密解密</h2><h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html\" target=\"_blank\" rel=\"noopener\">《常见对称加密算法》</a><ul>\n<li>DES、3DES、Blowfish、AES</li>\n<li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li>\n<li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html\" target=\"_blank\" rel=\"noopener\">《常用的哈希算法》</a></p>\n<ul>\n<li>MD5 和 SHA-1 已经不再安全，已被弃用。</li>\n<li>目前 SHA-256 是比较安全的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhangruhong168/article/details/78033202\" target=\"_blank\" rel=\"noopener\">《基于Hash摘要签名的公网URL签名验证设计方案》</a></p>\n</li>\n</ul>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html\" target=\"_blank\" rel=\"noopener\">《常见非对称加密算法》</a></p>\n<ul>\n<li>RSA、DSA、ECDSA(螺旋曲线加密算法)</li>\n<li>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</li>\n<li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p>\n<p>  <a href=\"http://baijiahao.baidu.com/s?id=1578348858092033763&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">《区块链的加密技术》</a>    </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务器安全\"><a href=\"#服务器安全\" class=\"headerlink\" title=\"服务器安全\"></a>服务器安全</h2><ul>\n<li><a href=\"http://www.freebuf.com/articles/system/121540.html\" target=\"_blank\" rel=\"noopener\">《Linux强化论：15步打造一个安全的Linux服务器》</a></li>\n</ul>\n<h2 id=\"数据安全\"><a href=\"#数据安全\" class=\"headerlink\" title=\"数据安全\"></a>数据安全</h2><h3 id=\"数据备份\"><a href=\"#数据备份\" class=\"headerlink\" title=\"数据备份\"></a>数据备份</h3><p>TODO</p>\n<h2 id=\"网络隔离\"><a href=\"#网络隔离\" class=\"headerlink\" title=\"网络隔离\"></a>网络隔离</h2><h3 id=\"内外网分离\"><a href=\"#内外网分离\" class=\"headerlink\" title=\"内外网分离\"></a>内外网分离</h3><p>TODO</p>\n<h3 id=\"登录跳板机\"><a href=\"#登录跳板机\" class=\"headerlink\" title=\"登录跳板机\"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p>\n<ul>\n<li><a href=\"http://blog.51cto.com/zero01/2062618\" target=\"_blank\" rel=\"noopener\">《搭建简易堡垒机》</a></li>\n</ul>\n<h2 id=\"授权、认证\"><a href=\"#授权、认证\" class=\"headerlink\" title=\"授权、认证\"></a>授权、认证</h2><h3 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h3><ul>\n<li><a href=\"https://www.cnblogs.com/zq8024/p/5003050.html\" target=\"_blank\" rel=\"noopener\">《基于组织角色的权限设计》</a></li>\n<li><a href=\"https://www.cnblogs.com/shijiaqi1066/p/3793894.html\" target=\"_blank\" rel=\"noopener\">《权限系统与RBAC模型概述》</a></li>\n<li><a href=\"https://blog.csdn.net/he90227/article/details/38663553\" target=\"_blank\" rel=\"noopener\">《Spring整合Shiro做权限控制模块详细案例分析》</a></li>\n</ul>\n<h3 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">《理解OAuth 2.0》</a></li>\n<li><a href=\"https://www.cnblogs.com/flashsun/p/7424071.html\" target=\"_blank\" rel=\"noopener\">《一张图搞定OAuth2.0》</a></li>\n</ul>\n<h3 id=\"双因素认证（2FA）\"><a href=\"#双因素认证（2FA）\" class=\"headerlink\" title=\"双因素认证（2FA）\"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p>\n<p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p>\n<ul>\n<li>【《双因素认证（2FA）教程》】(<a href=\"http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a>)</li>\n</ul>\n<h3 id=\"单点登录-SSO\"><a href=\"#单点登录-SSO\" class=\"headerlink\" title=\"单点登录(SSO)\"></a>单点登录(SSO)</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/ywlaker/p/6113927.html\" target=\"_blank\" rel=\"noopener\">《单点登录原理与简单实现》</a></p>\n</li>\n<li><p><a href=\"https://github.com/apereo/cas\" target=\"_blank\" rel=\"noopener\">CAS单点登录框架</a></p>\n</li>\n</ul>\n<h1 id=\"常用开源框架\"><a href=\"#常用开源框架\" class=\"headerlink\" title=\"常用开源框架\"></a>常用开源框架</h1><h2 id=\"开源协议\"><a href=\"#开源协议\" class=\"headerlink\" title=\"开源协议\"></a>开源协议</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html\" target=\"_blank\" rel=\"noopener\">《开源协议的选择》</a></p>\n</li>\n<li><p><a href=\"http://choosealicense.online/\" target=\"_blank\" rel=\"noopener\">如何选择一个开源软件协议</a></p>\n</li>\n</ul>\n<h2 id=\"日志框架\"><a href=\"#日志框架\" class=\"headerlink\" title=\"日志框架\"></a>日志框架</h2><h3 id=\"Log4j、Log4j2\"><a href=\"#Log4j、Log4j2\" class=\"headerlink\" title=\"Log4j、Log4j2\"></a>Log4j、Log4j2</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012422446/article/details/51199724\" target=\"_blank\" rel=\"noopener\">《log4j 详细讲解》</a></li>\n<li><a href=\"https://blog.csdn.net/vbirdbest/article/details/71751835\" target=\"_blank\" rel=\"noopener\">《log4j2 实际使用详解》</a></li>\n<li><a href=\"https://my.oschina.net/OutOfMemory/blog/789267\" target=\"_blank\" rel=\"noopener\">《Log4j1,Logback以及Log4j2性能测试对比》</a><ul>\n<li>Log4J 异步日志性能优异。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Logback\"><a href=\"#Logback\" class=\"headerlink\" title=\"Logback\"></a>Logback</h3><ul>\n<li><a href=\"https://blog.csdn.net/rulon147/article/details/52620541\" target=\"_blank\" rel=\"noopener\">《最全LogBack 详解、含java案例和配置说明》</a></li>\n</ul>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><ul>\n<li><a href=\"https://blog.csdn.net/sinat_34093604/article/details/53082000\" target=\"_blank\" rel=\"noopener\">《ORM框架使用优缺点》</a><ul>\n<li>主要目的是为了提高开发效率。 </li>\n</ul>\n</li>\n</ul>\n<p><strong>MyBatis：</strong></p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/winclpt/articles/7511672.html\" target=\"_blank\" rel=\"noopener\">《mybatis缓存机制详解》</a></p>\n<ul>\n<li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li>\n<li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/baidu_32877851/article/details/53959268\" target=\"_blank\" rel=\"noopener\">《MyBatis学习之代码生成器Generator》</a></p>\n</li>\n</ul>\n<h2 id=\"网络框架\"><a href=\"#网络框架\" class=\"headerlink\" title=\"网络框架\"></a>网络框架</h2><p>TODO</p>\n<h2 id=\"Web-框架\"><a href=\"#Web-框架\" class=\"headerlink\" title=\"Web 框架\"></a>Web 框架</h2><h3 id=\"Spring-家族\"><a href=\"#Spring-家族\" class=\"headerlink\" title=\"Spring 家族\"></a>Spring 家族</h3><p><strong>Spring</strong></p>\n<ul>\n<li><a href=\"https://www.w3cschool.cn/wkspring/\" target=\"_blank\" rel=\"noopener\">Spring 简明教程</a></li>\n</ul>\n<p><strong>Spring Boot</strong></p>\n<ul>\n<li><a href=\"http://projects.spring.io/spring-boot/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">《Spring Boot基础教程》</a></li>\n</ul>\n<p><strong>Spring Cloud</strong></p>\n<ul>\n<li><a href=\"http://springboot.fun/\" target=\"_blank\" rel=\"noopener\">Spring Boot 中文索引站</a></li>\n<li><a href=\"https://springcloud.cc/\" target=\"_blank\" rel=\"noopener\">Spring Cloud 中文文档</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">《Spring Cloud基础教程》</a></li>\n</ul>\n<h2 id=\"工具框架\"><a href=\"#工具框架\" class=\"headerlink\" title=\"工具框架\"></a>工具框架</h2><ul>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4872236.html\" target=\"_blank\" rel=\"noopener\">《Apache Commons 工具类介绍及简单使用》</a></li>\n<li><a href=\"http://ifeve.com/google-guava/\" target=\"_blank\" rel=\"noopener\">《Google guava 中文教程》</a></li>\n</ul>\n<h1 id=\"分布式设计\"><a href=\"#分布式设计\" class=\"headerlink\" title=\"分布式设计\"></a>分布式设计</h1><h2 id=\"扩展性设计\"><a href=\"#扩展性设计\" class=\"headerlink\" title=\"扩展性设计\"></a>扩展性设计</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/hemin1003/article/details/53633926\" target=\"_blank\" rel=\"noopener\">《架构师不可不知的十大可扩展架构》</a></p>\n<ul>\n<li>总结下来，通用的套路就是分布、缓存及异步处理。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://yq.aliyun.com/articles/38119\" target=\"_blank\" rel=\"noopener\">《可扩展性设计之数据切分》</a></p>\n<ul>\n<li>水平切分+垂直切分</li>\n<li>利用中间件进行分片如，MySQL Proxy。</li>\n<li>利用分片策略进行切分，如按照ID取模。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/deniro_li/article/details/78458306\" target=\"_blank\" rel=\"noopener\">《说说如何实现可扩展性的大型网站架构》</a></p>\n<ul>\n<li>分布式服务+消息队列。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chaofanwei/article/details/29191073\" target=\"_blank\" rel=\"noopener\">《大型网站技术架构（七）–网站的可扩展性架构》</a></p>\n</li>\n</ul>\n<h2 id=\"稳定性-amp-高可用\"><a href=\"#稳定性-amp-高可用\" class=\"headerlink\" title=\"稳定性 &amp; 高可用\"></a>稳定性 &amp; 高可用</h2><ul>\n<li><a href=\"https://blog.csdn.net/hustspy1990/article/details/78008324\" target=\"_blank\" rel=\"noopener\">《系统设计：关于高可用系统的一些技术方案》</a><ul>\n<li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li>\n<li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li>\n<li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li>\n<li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li>\n<li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li>\n<li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li>\n<li>自动化测试：通过完善的测试，减少发布引起的故障。</li>\n<li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><a href=\"https://coolshell.cn/articles/17459.html\" target=\"_blank\" rel=\"noopener\">《关于高可用的系统》</a><ul>\n<li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"硬件负载均衡\"><a href=\"#硬件负载均衡\" class=\"headerlink\" title=\"硬件负载均衡\"></a>硬件负载均衡</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/wuyun-blog/p/6186198.html\" target=\"_blank\" rel=\"noopener\">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a></p>\n<ul>\n<li>主要是和F5对比。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lcword/p/5773296.html\" target=\"_blank\" rel=\"noopener\">《软/硬件负载均衡产品 你知多少？》</a></p>\n</li>\n</ul>\n<h3 id=\"软件负载均衡\"><a href=\"#软件负载均衡\" class=\"headerlink\" title=\"软件负载均衡\"></a>软件负载均衡</h3><ul>\n<li><a href=\"https://www.cnblogs.com/tianzhiliang/articles/2317808.html\" target=\"_blank\" rel=\"noopener\">《几种负载均衡算法》</a><br>  轮寻、权重、负载、最少连接、QoS</li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html\" target=\"_blank\" rel=\"noopener\">《DNS负载均衡》</a><ul>\n<li>配置简单，更新速度慢。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html\" target=\"_blank\" rel=\"noopener\">《Nginx负载均衡》</a></p>\n<ul>\n<li>简单轻量、学习成本低；主要适用于web应用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/edisonchou/p/4281978.html\" target=\"_blank\" rel=\"noopener\">《借助LVS+Keepalived实现负载均衡 》</a></p>\n<ul>\n<li>配置比较负载、只支持到4层，性能较高。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ttlsa.com/linux/haproxy-study-tutorial/\" target=\"_blank\" rel=\"noopener\">《HAProxy用法详解 全网最详细中文文档》</a></p>\n<ul>\n<li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.itpub.net/25704976/viewspace-1319781/\" target=\"_blank\" rel=\"noopener\">《Haproxy+Keepalived+MySQL实现读均衡负载》</a></p>\n<ul>\n<li>主要是用户读请求的负载均衡。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lylife/p/5584019.html\" target=\"_blank\" rel=\"noopener\">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></p>\n</li>\n</ul>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><ul>\n<li><a href=\"https://www.cnblogs.com/haoxinyue/p/6792309.html\" target=\"_blank\" rel=\"noopener\">《谈谈高并发系统的限流》</a><ul>\n<li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li>\n<li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li>\n<li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li>\n<li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层容灾\"><a href=\"#应用层容灾\" class=\"headerlink\" title=\"应用层容灾\"></a>应用层容灾</h3><ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000005988895\" target=\"_blank\" rel=\"noopener\">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a></p>\n<ul>\n<li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 </li>\n<li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li>\n<li>Hystrix设计原则：<ul>\n<li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li>\n<li>熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。</li>\n<li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\" target=\"_blank\" rel=\"noopener\">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\" target=\"_blank\" rel=\"noopener\">《缓存击穿、失效以及热点key问题》</a> <ul>\n<li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li>\n<li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"跨机房容灾\"><a href=\"#跨机房容灾\" class=\"headerlink\" title=\"跨机房容灾\"></a>跨机房容灾</h3><ul>\n<li><p><a href=\"http://dc.idcquan.com/ywgl/71559.shtml\" target=\"_blank\" rel=\"noopener\">《“异地多活”多机房部署经验谈》</a></p>\n<ul>\n<li>通过自研中间件进行数据同步。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/jeffreynicole/article/details/48135093\" target=\"_blank\" rel=\"noopener\">《异地多活（异地双活）实践经验》</a></p>\n<ul>\n<li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li>\n<li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li>\n<li>不能依赖于程序端数据双写，要有自动同步方案。 </li>\n<li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li>\n<li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li>\n<li>异地多活监控部署、测试也要跟上。</li>\n<li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li>\n<li>控制跨机房消息体大小，越小越好。</li>\n<li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yoara/article/details/38013751\" target=\"_blank\" rel=\"noopener\">容灾技术及建设经验介绍</a></p>\n</li>\n</ul>\n<h3 id=\"容灾演练流程\"><a href=\"#容灾演练流程\" class=\"headerlink\" title=\"容灾演练流程\"></a>容灾演练流程</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650996320&amp;idx=1&amp;sn=0ed3be190bbee4a9277886ef88cbb2e5\" target=\"_blank\" rel=\"noopener\">《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》</a><ul>\n<li>常见故障画像</li>\n<li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平滑启动\"><a href=\"#平滑启动\" class=\"headerlink\" title=\"平滑启动\"></a>平滑启动</h3><ul>\n<li><p>平滑重启应用思路<br>1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011001084/article/details/73480432\" target=\"_blank\" rel=\"noopener\">《JVM安全退出（如何优雅的关闭java服务）》</a><br>推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</p>\n</li>\n<li><a href=\"http://ju.outofmemory.cn/entry/337235\" target=\"_blank\" rel=\"noopener\">《常见Java应用如何优雅关闭》</a><br>Java、Srping、Dubbo 优雅关闭方式。</li>\n</ul>\n<h2 id=\"数据库扩展\"><a href=\"#数据库扩展\" class=\"headerlink\" title=\"数据库扩展\"></a>数据库扩展</h2><h3 id=\"读写分离模式\"><a href=\"#读写分离模式\" class=\"headerlink\" title=\"读写分离模式\"></a>读写分离模式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/houdj/p/6563771.html\" target=\"_blank\" rel=\"noopener\">《Mysql主从方案的实现》</a></li>\n<li><a href=\"https://www.cnblogs.com/edisonchou/p/4133148.html\" target=\"_blank\" rel=\"noopener\">《搭建MySQL主从复制经典架构》</a></li>\n<li><p><a href=\"https://blog.csdn.net/nimasike/article/details/48048341\" target=\"_blank\" rel=\"noopener\">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhangsubai/p/6801764.html\" target=\"_blank\" rel=\"noopener\">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a></p>\n<ul>\n<li>DRDB 进行磁盘复制，避免单点问题。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html\" target=\"_blank\" rel=\"noopener\">《MySQL Cluster 方式》</a></p>\n</li>\n</ul>\n<h3 id=\"分片模式\"><a href=\"#分片模式\" class=\"headerlink\" title=\"分片模式\"></a>分片模式</h3><ul>\n<li><p><a href=\"https://www.jianshu.com/p/32b3e91aa22c\" target=\"_blank\" rel=\"noopener\">《分库分表需要考虑的问题及方案》</a></p>\n<ul>\n<li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li>\n<li>问题：事务、Join、迁移、扩容、ID、分页等。</li>\n<li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li>\n<li>分库策略：数值范围；取模；日期等。</li>\n<li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201503/380348.html\" target=\"_blank\" rel=\"noopener\">《MySql分表和表分区详解》</a></p>\n<ul>\n<li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li>\n<li>分表：物理上创建不同的表、客户端需要管理分表路由。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h2><h3 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h3><ul>\n<li><a href=\"https://blog.csdn.net/jiaolongdy/article/details/51188798\" target=\"_blank\" rel=\"noopener\">《永不失联！如何实现微服务架构中的服务发现？》</a><ul>\n<li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li>\n<li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u010963948/article/details/71730165\" target=\"_blank\" rel=\"noopener\">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a></p>\n<ul>\n<li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li>\n<li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://mobile.51cto.com/news-502394.htm\" target=\"_blank\" rel=\"noopener\">《基于Zookeeper的服务注册与发现》</a></p>\n<ul>\n<li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务路由控制\"><a href=\"#服务路由控制\" class=\"headerlink\" title=\"服务路由控制\"></a>服务路由控制</h3><ul>\n<li><a href=\"https://blog.csdn.net/xundh/article/details/59492750\" target=\"_blank\" rel=\"noopener\">《分布式服务框架学习笔记4 服务路由》</a><ul>\n<li>原则：透明化路由</li>\n<li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li>\n<li>本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li>\n<li>配置方式：统一注册表；本地配置；动态下发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式一致\"><a href=\"#分布式一致\" class=\"headerlink\" title=\"分布式一致\"></a>分布式一致</h2><h3 id=\"CAP-与-BASE-理论\"><a href=\"#CAP-与-BASE-理论\" class=\"headerlink\" title=\"CAP 与 BASE 理论\"></a>CAP 与 BASE 理论</h3><ul>\n<li><a href=\"http://www.cnblogs.com/szlbm/p/5588543.html\" target=\"_blank\" rel=\"noopener\">《从分布式一致性谈到CAP理论、BASE理论》</a><ul>\n<li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li>\n<li>CAP：一致性、可用性、分区容错性(网络故障引起)</li>\n<li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li>\n<li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><a href=\"http://www.hollischuang.com/archives/1716\" target=\"_blank\" rel=\"noopener\">《分布式锁的几种实现方式》</a><ul>\n<li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li>\n<li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li>\n<li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.tuicool.com/articles/VZJr6fY\" target=\"_blank\" rel=\"noopener\">《基于Zookeeper的分布式锁》</a></p>\n<ul>\n<li>清楚的原理描述 + Java 代码示例。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/0201zcr/p/5942748.html\" target=\"_blank\" rel=\"noopener\">《jedisLock—redis分布式锁实现》</a></p>\n<ul>\n<li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/albertfly/article/details/77412333\" target=\"_blank\" rel=\"noopener\">《Memcached 和 Redis 分布式锁方案》</a></p>\n<ul>\n<li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致性算法\"><a href=\"#分布式一致性算法\" class=\"headerlink\" title=\"分布式一致性算法\"></a>分布式一致性算法</h3><h4 id=\"PAXOS\"><a href=\"#PAXOS\" class=\"headerlink\" title=\"PAXOS\"></a>PAXOS</h4><ul>\n<li><a href=\"https://www.cnblogs.com/linbingdong/p/6253479.html\" target=\"_blank\" rel=\"noopener\">《分布式系列文章——Paxos算法原理与推导》</a></li>\n<li><a href=\"https://blog.csdn.net/u010039929/article/details/70171672\" target=\"_blank\" rel=\"noopener\">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li>\n<li><a href=\"https://www.cnblogs.com/leesf456/p/6012777.html\" target=\"_blank\" rel=\"noopener\">《【分布式】Zookeeper与Paxos》</a></li>\n</ul>\n<h4 id=\"Zab\"><a href=\"#Zab\" class=\"headerlink\" title=\"Zab\"></a>Zab</h4><ul>\n<li><a href=\"https://www.jianshu.com/p/fb527a64deee\" target=\"_blank\" rel=\"noopener\">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li>\n</ul>\n<h4 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h4><ul>\n<li><a href=\"http://www.cnblogs.com/mindwind/p/5231986.html\" target=\"_blank\" rel=\"noopener\">《Raft 为什么是更易理解的分布式一致性算法》</a><ul>\n<li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li>\n<li>通过随机等待的方式发出投票，得票多的获胜。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Gossip\"><a href=\"#Gossip\" class=\"headerlink\" title=\"Gossip\"></a>Gossip</h4><ul>\n<li><a href=\"http://blog.51cto.com/tianya23/530743\" target=\"_blank\" rel=\"noopener\">《Gossip算法》</a></li>\n</ul>\n<h4 id=\"两阶段提交、多阶段提交\"><a href=\"#两阶段提交、多阶段提交\" class=\"headerlink\" title=\"两阶段提交、多阶段提交\"></a>两阶段提交、多阶段提交</h4><ul>\n<li><a href=\"http://blog.jobbole.com/95632/\" target=\"_blank\" rel=\"noopener\">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li>\n</ul>\n<h3 id=\"幂等\"><a href=\"#幂等\" class=\"headerlink\" title=\"幂等\"></a>幂等</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wxgblogs/p/6639272.html\" target=\"_blank\" rel=\"noopener\">《分布式系统—幂等性设计》</a><ul>\n<li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li>\n<li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致方案\"><a href=\"#分布式一致方案\" class=\"headerlink\" title=\"分布式一致方案\"></a>分布式一致方案</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency\" target=\"_blank\" rel=\"noopener\">《分布式系统事务一致性解决方案》</a></li>\n<li><a href=\"https://weibo.com/ttarticle/p/show?id=2309403965965003062676\" target=\"_blank\" rel=\"noopener\">《保证分布式系统数据一致性的6种方案》</a></li>\n</ul>\n<h3 id=\"分布式-Leader-节点选举\"><a href=\"#分布式-Leader-节点选举\" class=\"headerlink\" title=\"分布式 Leader 节点选举\"></a>分布式 Leader 节点选举</h3><ul>\n<li><a href=\"https://blog.csdn.net/johnson_moon/article/details/78809995\" target=\"_blank\" rel=\"noopener\">《利用zookeeper实现分布式leader节点选举》</a></li>\n</ul>\n<h3 id=\"TCC-Try-Confirm-Cancel-柔性事务\"><a href=\"#TCC-Try-Confirm-Cancel-柔性事务\" class=\"headerlink\" title=\"TCC(Try/Confirm/Cancel) 柔性事务\"></a>TCC(Try/Confirm/Cancel) 柔性事务</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/ab1a1c6b08a1\" target=\"_blank\" rel=\"noopener\">《传统事务与柔性事务》</a><ul>\n<li>基于BASE理论：基本可用、柔性状态、最终一致。</li>\n<li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式文件系统\"><a href=\"#分布式文件系统\" class=\"headerlink\" title=\"分布式文件系统\"></a>分布式文件系统</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27666295\" target=\"_blank\" rel=\"noopener\">说说分布式文件存储系统-基本架构</a> ？</li>\n<li><a href=\"https://blog.csdn.net/gatieme/article/details/44982961\" target=\"_blank\" rel=\"noopener\">《各种分布式文件系统的比较》</a> ？<ul>\n<li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li>\n<li>FastDFS：轻量级、适合小文件。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"唯一ID-生成\"><a href=\"#唯一ID-生成\" class=\"headerlink\" title=\"唯一ID 生成\"></a>唯一ID 生成</h2><h3 id=\"全局唯一ID\"><a href=\"#全局唯一ID\" class=\"headerlink\" title=\"全局唯一ID\"></a>全局唯一ID</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/baiwa/p/5318432.html\" target=\"_blank\" rel=\"noopener\">《高并发分布式系统中生成全局唯一Id汇总》</a></p>\n<ul>\n<li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li>\n<li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” </li>\n<li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li>\n<li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/hdu09075340/article/details/79103851\" target=\"_blank\" rel=\"noopener\">《TDDL 在分布式下的SEQUENCE原理》</a></p>\n<ul>\n<li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li>\n<li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li>\n<li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一致性Hash算法\"><a href=\"#一致性Hash算法\" class=\"headerlink\" title=\"一致性Hash算法\"></a>一致性Hash算法</h2><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html\" target=\"_blank\" rel=\"noopener\">《一致性哈希算法》</a></li>\n</ul>\n<h1 id=\"设计思想-amp-开发模式\"><a href=\"#设计思想-amp-开发模式\" class=\"headerlink\" title=\"设计思想 &amp; 开发模式\"></a>设计思想 &amp; 开发模式</h1><h2 id=\"DDD-Domain-driven-Design-领域驱动设计\"><a href=\"#DDD-Domain-driven-Design-领域驱动设计\" class=\"headerlink\" title=\"DDD(Domain-driven Design - 领域驱动设计)\"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/netfocus/p/5548025.html\" target=\"_blank\" rel=\"noopener\">《浅谈我对DDD领域驱动设计的理解》</a></p>\n<ul>\n<li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li>\n<li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li>\n<li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/butterfly100/p/7827870.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计的基础知识总结》</a></p>\n<ul>\n<li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li>\n<li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li>\n<li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li>\n<li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li>\n<li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li>\n<li>使用的模式：<ul>\n<li>关联尽量少，尽量单项，尽量降低整体复杂度。</li>\n<li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li>\n<li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li>\n<li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li>\n<li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li>\n<li>工厂（Factory）：类似于设计模式中的工厂模式。</li>\n<li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Leo_wl/p/3866629.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计(DDD)实现之路》</a></p>\n<ul>\n<li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.hollischuang.com/archives/553\" target=\"_blank\" rel=\"noopener\">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></p>\n</li>\n</ul>\n<h3 id=\"命令查询职责分离-CQRS\"><a href=\"#命令查询职责分离-CQRS\" class=\"headerlink\" title=\"命令查询职责分离(CQRS)\"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/cnblogsfans/p/4551990.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计系列 (六)：CQRS》</a></p>\n<ul>\n<li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml\" target=\"_blank\" rel=\"noopener\">《DDD CQRS架构和传统架构的优缺点比较》</a></p>\n<ul>\n<li>最终一致的设计理念；依赖于高可用消息中间件。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/netfocus/p/4055346.html\" target=\"_blank\" rel=\"noopener\">《CQRS架构简介》</a></p>\n<ul>\n<li>一个实现 CQRS 的抽象案例。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.uml.org.cn/zjjs/201609221.asp\" target=\"_blank\" rel=\"noopener\">《深度长文：我对CQRS/EventSourcing架构的思考》</a></p>\n<ul>\n<li>CQRS 模式分析 + 12306 抢票案例</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"贫血，充血模型\"><a href=\"#贫血，充血模型\" class=\"headerlink\" title=\"贫血，充血模型\"></a>贫血，充血模型</h3><ul>\n<li><a href=\"https://kb.cnblogs.com/page/520743/\" target=\"_blank\" rel=\"noopener\">《贫血，充血模型的解释以及一些经验》</a><ul>\n<li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li>\n<li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li>\n<li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li>\n<li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li>\n<li>作者主张使用贫血模式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Actor-模式\"><a href=\"#Actor-模式\" class=\"headerlink\" title=\"Actor 模式\"></a>Actor 模式</h2><p>TODO</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><h3 id=\"Reactor\"><a href=\"#Reactor\" class=\"headerlink\" title=\"Reactor\"></a>Reactor</h3><p>TODO</p>\n<h3 id=\"RxJava\"><a href=\"#RxJava\" class=\"headerlink\" title=\"RxJava\"></a>RxJava</h3><p>TODO</p>\n<h3 id=\"Vert-x\"><a href=\"#Vert-x\" class=\"headerlink\" title=\"Vert.x\"></a>Vert.x</h3><p>TODO</p>\n<h2 id=\"DODAF2-0\"><a href=\"#DODAF2-0\" class=\"headerlink\" title=\"DODAF2.0\"></a>DODAF2.0</h2><ul>\n<li><a href=\"http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml\" target=\"_blank\" rel=\"noopener\">《DODAF2.0方法论》</a></li>\n<li><a href=\"http://blog.51cto.com/xiaoyong/1553164\" target=\"_blank\" rel=\"noopener\">《DODAF2.0之能力视角如何落地》</a></li>\n</ul>\n<h2 id=\"Serverless\"><a href=\"#Serverless\" class=\"headerlink\" title=\"Serverless\"></a>Serverless</h2><p>无需过多关系服务器的服务架构理念。</p>\n<ul>\n<li><p><a href=\"http://www.jdon.com/soa/serverless.html\" target=\"_blank\" rel=\"noopener\">《什么是Serverless无服务器架构？》</a></p>\n<ul>\n<li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li>\n<li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li>\n<li>Serverless 不代表某个具体的框架。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless\" target=\"_blank\" rel=\"noopener\">《如何理解Serverless？》</a></p>\n<ul>\n<li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Service-Mesh\"><a href=\"#Service-Mesh\" class=\"headerlink\" title=\"Service Mesh\"></a>Service Mesh</h2><ul>\n<li><a href=\"https://time.geekbang.org/article/2355\" target=\"_blank\" rel=\"noopener\">《什么是Service Mesh？》</a></li>\n<li><p><a href=\"https://www.jianshu.com/p/e23e3e74538e\" target=\"_blank\" rel=\"noopener\">《初识 Service Mesh》</a></p>\n</li>\n<li><p><a href=\"https://time.geekbang.org/article/2355\" target=\"_blank\" rel=\"noopener\">《什么是Service Mesh？》</a></p>\n</li>\n</ul>\n<h1 id=\"项目管理\"><a href=\"#项目管理\" class=\"headerlink\" title=\"项目管理\"></a>项目管理</h1><h2 id=\"架构评审\"><a href=\"#架构评审\" class=\"headerlink\" title=\"架构评审\"></a>架构评审</h2><ul>\n<li><a href=\"http://developer.51cto.com/art/201506/478486.htm\" target=\"_blank\" rel=\"noopener\">《架构设计之如何评审架构设计说明书》</a></li>\n<li><a href=\"https://blog.csdn.net/wireless_com/article/details/45935591\" target=\"_blank\" rel=\"noopener\">《人人都是架构师：非功能性需求》</a></li>\n</ul>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/architect-12-rules-complete/\" target=\"_blank\" rel=\"noopener\">《架构之重构的12条军规》</a></li>\n</ul>\n<h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><ul>\n<li><a href=\"https://github.com/alibaba/p3c\" target=\"_blank\" rel=\"noopener\">《阿里巴巴Java开发手册》</a></li>\n</ul>\n<h2 id=\"代码-Review\"><a href=\"#代码-Review\" class=\"headerlink\" title=\"代码 Review\"></a>代码 Review</h2><p>制度还是制度!<br>另外，每个公司需要根据自己的需求和目标制定自己的 check list</p>\n<ul>\n<li><p><a href=\"http://www.sohu.com/a/229745352_181657\" target=\"_blank\" rel=\"noopener\">《为什么你做不好 Code Review？》</a></p>\n<ul>\n<li>代码 review 做的好，在于制度建设。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/uxyheaven/article/details/49773619\" target=\"_blank\" rel=\"noopener\">《从零开始Code Review》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zuoping/p/5477047.html\" target=\"_blank\" rel=\"noopener\">《Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://dzone.com/articles/java-code-review-checklist\" target=\"_blank\" rel=\"noopener\">《Java Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/legend0011/article/details/45585575\" target=\"_blank\" rel=\"noopener\">《如何用 gitlab 做 code review》</a></p>\n</li>\n</ul>\n<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2><ul>\n<li><a href=\"https://blog.csdn.net/apanious/article/details/51011946\" target=\"_blank\" rel=\"noopener\">《运用RUP 4+1视图方法进行软件架构设计》</a></li>\n</ul>\n<h2 id=\"看板管理\"><a href=\"#看板管理\" class=\"headerlink\" title=\"看板管理\"></a>看板管理</h2><ul>\n<li><a href=\"https://blog.csdn.net/tkchen/article/details/51637643\" target=\"_blank\" rel=\"noopener\">《说说看板在项目中的应用》</a></li>\n</ul>\n<h2 id=\"SCRUM\"><a href=\"#SCRUM\" class=\"headerlink\" title=\"SCRUM\"></a>SCRUM</h2><p>SCRUM - 争球</p>\n<ul>\n<li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li>\n<li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li>\n<li>五个价值观：专注、勇气、公开、承诺、尊重。</li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/inny100_100/article/details/54633757\" target=\"_blank\" rel=\"noopener\">《敏捷项目管理流程-Scrum框架最全总结！》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/superkunkun/article/details/52951142\" target=\"_blank\" rel=\"noopener\">《敏捷其实很简单3—敏捷方法之scrum》</a></p>\n</li>\n</ul>\n<h2 id=\"敏捷开发\"><a href=\"#敏捷开发\" class=\"headerlink\" title=\"敏捷开发\"></a>敏捷开发</h2><p>TODO</p>\n<h2 id=\"极限编程（XP）\"><a href=\"#极限编程（XP）\" class=\"headerlink\" title=\"极限编程（XP）\"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p>\n<ul>\n<li><p><a href=\"http://www.woshipm.com/pmd/406917.html\" target=\"_blank\" rel=\"noopener\">《主流敏捷开发方法：极限编程XP》</a></p>\n<ul>\n<li>是一种指导开发人员的方法论。</li>\n<li><p>4大价值：</p>\n<ul>\n<li>沟通：鼓励口头沟通，提高效率。</li>\n<li>简单：够用就好。</li>\n<li>反馈：及时反馈、通知相关人。</li>\n<li>勇气：提倡拥抱变化，敢于重构。</li>\n</ul>\n</li>\n<li><p>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</p>\n</li>\n<li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"结对编程\"><a href=\"#结对编程\" class=\"headerlink\" title=\"结对编程\"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">《结对编程》</a></li>\n</ul>\n<h2 id=\"PDCA-循环质量管理\"><a href=\"#PDCA-循环质量管理\" class=\"headerlink\" title=\"PDCA 循环质量管理\"></a>PDCA 循环质量管理</h2><p>P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/PDCA\" target=\"_blank\" rel=\"noopener\">《PDCA》</a></li>\n</ul>\n<h2 id=\"FMEA管理模式\"><a href=\"#FMEA管理模式\" class=\"headerlink\" title=\"FMEA管理模式\"></a>FMEA管理模式</h2><p>TODO</p>\n<h1 id=\"通用业务术语\"><a href=\"#通用业务术语\" class=\"headerlink\" title=\"通用业务术语\"></a>通用业务术语</h1><p>TODO</p>\n<h1 id=\"技术趋势\"><a href=\"#技术趋势\" class=\"headerlink\" title=\"技术趋势\"></a>技术趋势</h1><p>TODO</p>\n<h1 id=\"政策、法规\"><a href=\"#政策、法规\" class=\"headerlink\" title=\"政策、法规\"></a>政策、法规</h1><p>TODO</p>\n<h2 id=\"法律\"><a href=\"#法律\" class=\"headerlink\" title=\"法律\"></a>法律</h2><h3 id=\"严格遵守刑法253法条\"><a href=\"#严格遵守刑法253法条\" class=\"headerlink\" title=\"严格遵守刑法253法条\"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p>\n<blockquote>\n<ul>\n<li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li>\n<li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 </li>\n<li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li>\n</ul>\n</blockquote>\n<p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA\" target=\"_blank\" rel=\"noopener\">《非法获取公民个人信息罪》</a></li>\n</ul>\n<h1 id=\"架构师素质\"><a href=\"#架构师素质\" class=\"headerlink\" title=\"架构师素质\"></a>架构师素质</h1><ul>\n<li><p><a href=\"http://hellojava.info/?p=430\" target=\"_blank\" rel=\"noopener\">《架构师画像》</a></p>\n<ul>\n<li>业务理解和抽象能力</li>\n<li>NB的代码能力</li>\n<li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； </li>\n<li>全局：是否考虑到了对上下游的系统的影响。</li>\n<li>权衡：权衡投入产出比；优先级和节奏控制；</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know\" target=\"_blank\" rel=\"noopener\">《关于架构优化和设计，架构师必须知道的事情》</a></p>\n<ul>\n<li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。</li>\n<li>基础设施、配置、测试、开发、运维综合考虑。</li>\n<li>考虑人、团队、和组织的影响。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/19841397\" target=\"_blank\" rel=\"noopener\">《如何才能真正的提高自己，成为一名出色的架构师？》</a> </p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129\" target=\"_blank\" rel=\"noopener\">《架构师的必备素质和成长途径》</a></p>\n<ul>\n<li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li>\n<li>成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.51cto.com/frankfan/1248401\" target=\"_blank\" rel=\"noopener\">《架构设计师—你在哪层楼？》</a></p>\n<ul>\n<li>第一层的架构师看到的只是产品本身</li>\n<li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li>\n<li>第三层的架构师看到的是商业价值 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"团队管理\"><a href=\"#团队管理\" class=\"headerlink\" title=\"团队管理\"></a>团队管理</h1><p>TODO</p>\n<h2 id=\"招聘\"><a href=\"#招聘\" class=\"headerlink\" title=\"招聘\"></a>招聘</h2><h1 id=\"资讯\"><a href=\"#资讯\" class=\"headerlink\" title=\"资讯\"></a>资讯</h1><h2 id=\"行业资讯\"><a href=\"#行业资讯\" class=\"headerlink\" title=\"行业资讯\"></a>行业资讯</h2><ul>\n<li><a href=\"http://36kr.com/\" target=\"_blank\" rel=\"noopener\">36kr</a></li>\n<li><a href=\"http://www.techweb.com.cn/\" target=\"_blank\" rel=\"noopener\">Techweb</a></li>\n</ul>\n<h2 id=\"公众号列表\"><a href=\"#公众号列表\" class=\"headerlink\" title=\"公众号列表\"></a>公众号列表</h2><p>TODO</p>\n<h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><h3 id=\"团队博客\"><a href=\"#团队博客\" class=\"headerlink\" title=\"团队博客\"></a>团队博客</h3><ul>\n<li><a href=\"http://jm.taobao.org/\" target=\"_blank\" rel=\"noopener\">阿里中间件博客</a></li>\n<li><a href=\"https://tech.meituan.com\" target=\"_blank\" rel=\"noopener\">美团点评技术团队博客</a></li>\n</ul>\n<h3 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></li>\n<li><a href=\"https://coolshell.cn/\" target=\"_blank\" rel=\"noopener\">酷壳 - COOLSHELL-陈皓</a></li>\n<li><a href=\"http://hellojava.info/\" target=\"_blank\" rel=\"noopener\">hellojava-阿里毕玄</a></li>\n<li><a href=\"http://cmsblogs.com/\" target=\"_blank\" rel=\"noopener\">Cm’s Blog</a></li>\n<li><a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li>\n</ul>\n<h2 id=\"综合门户、社区\"><a href=\"#综合门户、社区\" class=\"headerlink\" title=\"综合门户、社区\"></a>综合门户、社区</h2><p><strong>国内：</strong></p>\n<ul>\n<li><a href=\"http://csdn.net\" target=\"_blank\" rel=\"noopener\">CSDN</a><br>   老牌技术社区、不必解释。</li>\n<li><a href=\"http://www.51cto.com/\" target=\"_blank\" rel=\"noopener\">51cto.com</a></li>\n<li><a href=\"http://www.iteye.com/\" target=\"_blank\" rel=\"noopener\">ITeye</a><ul>\n<li>偏 Java 方向 </li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com\" target=\"_blank\" rel=\"noopener\">博客园</a></li>\n<li><a href=\"http://www.tom.net/\" target=\"_blank\" rel=\"noopener\">ChinaUnix</a><ul>\n<li>偏 Linux 方向 </li>\n</ul>\n</li>\n<li><a href=\"https://www.oschina.net/\" target=\"_blank\" rel=\"noopener\">开源中国社区</a></li>\n<li><a href=\"http://www.open-open.com/\" target=\"_blank\" rel=\"noopener\">深度开源</a></li>\n<li><p><a href=\"http://www.jobbole.com/\" target=\"_blank\" rel=\"noopener\">伯乐在线</a></p>\n<ul>\n<li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.itpub.net/\" target=\"_blank\" rel=\"noopener\">ITPUB</a></p>\n</li>\n<li><a href=\"https://cloud.tencent.com/developer/column\" target=\"_blank\" rel=\"noopener\">腾讯云— 云+社区</a></li>\n<li><a href=\"https://yq.aliyun.com/\" target=\"_blank\" rel=\"noopener\">阿里云— 云栖社区</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/\" target=\"_blank\" rel=\"noopener\">IBM DeveloperWorks</a></li>\n<li><a href=\"https://toutiao.io/\" target=\"_blank\" rel=\"noopener\">开发者头条</a></li>\n<li><a href=\"http://www.linkedkeeper.com\" target=\"_blank\" rel=\"noopener\">LinkedKeeper</a></li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"https://dzone.com\" target=\"_blank\" rel=\"noopener\">DZone</a></li>\n<li><a href=\"https://www.reddit.com\" target=\"_blank\" rel=\"noopener\">Reddit</a></li>\n</ul>\n<h2 id=\"问答、讨论类社区\"><a href=\"#问答、讨论类社区\" class=\"headerlink\" title=\"问答、讨论类社区\"></a>问答、讨论类社区</h2><ul>\n<li><a href=\"https://segmentfault.com\" target=\"_blank\" rel=\"noopener\">segmentfault</a><ul>\n<li>问答+专栏 </li>\n</ul>\n</li>\n<li><a href=\"https://www.zhihu.com/\" target=\"_blank\" rel=\"noopener\">知乎</a></li>\n<li><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></li>\n</ul>\n<h2 id=\"行业数据分析\"><a href=\"#行业数据分析\" class=\"headerlink\" title=\"行业数据分析\"></a>行业数据分析</h2><ul>\n<li><a href=\"http://report.iresearch.cn/\" target=\"_blank\" rel=\"noopener\">艾瑞网</a></li>\n<li><p><a href=\"https://www.questmobile.com.cn\" target=\"_blank\" rel=\"noopener\">QUEST MOBILE</a></p>\n</li>\n<li><p><a href=\"http://data.stats.gov.cn/\" target=\"_blank\" rel=\"noopener\">国家数据</a></p>\n</li>\n<li><p><a href=\"http://www.talkingdata.com/\" target=\"_blank\" rel=\"noopener\">TalkingData</a></p>\n</li>\n</ul>\n<h2 id=\"专项网站\"><a href=\"#专项网站\" class=\"headerlink\" title=\"专项网站\"></a>专项网站</h2><ul>\n<li><p>测试:</p>\n<ul>\n<li><a href=\"http://www.ltesting.net/\" target=\"_blank\" rel=\"noopener\">领测国际</a> </li>\n<li><a href=\"https://www.testwo.com/\" target=\"_blank\" rel=\"noopener\">测试窝</a></li>\n<li><a href=\"https://testerhome.com\" target=\"_blank\" rel=\"noopener\">TesterHome</a></li>\n</ul>\n</li>\n<li><p>运维:</p>\n<pre><code>* [运维派](http://www.yunweipai.com/) \n* [Abcdocker](https://www.abcdocker.com/)\n</code></pre></li>\n<li><p>Java:</p>\n<ul>\n<li><a href=\"http://www.importnew.com/\" target=\"_blank\" rel=\"noopener\">ImportNew</a><ul>\n<li>专注于 Java 技术分享</li>\n</ul>\n</li>\n<li><a href=\"https://howtodoinjava.com/\" target=\"_blank\" rel=\"noopener\">HowToDoInJava</a><ul>\n<li>英文博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>安全</p>\n<ul>\n<li><a href=\"https://www.2cto.com/\" target=\"_blank\" rel=\"noopener\">红黑联盟</a> </li>\n<li><a href=\"http://www.freebuf.com/\" target=\"_blank\" rel=\"noopener\">FreeBuf</a></li>\n</ul>\n</li>\n<li><p>大数据</p>\n<ul>\n<li><a href=\"http://www.thebigdata.cn/\" target=\"_blank\" rel=\"noopener\">中国大数据</a> </li>\n</ul>\n</li>\n<li><p>其他专题网站：</p>\n<ul>\n<li><a href=\"http://www.dockerinfo.net/\" target=\"_blank\" rel=\"noopener\">DockerInfo</a><ul>\n<li>专注于 Docker 应用及咨询、教程的网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.linuxidc.com/\" target=\"_blank\" rel=\"noopener\">Linux公社</a><ul>\n<li>Linux 主题社区</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其他类\"><a href=\"#其他类\" class=\"headerlink\" title=\"其他类\"></a>其他类</h2><ul>\n<li><a href=\"https://github.com/TeamStuQ/skill-map\" target=\"_blank\" rel=\"noopener\">程序员技能图谱</a></li>\n</ul>\n<h2 id=\"推荐参考书\"><a href=\"#推荐参考书\" class=\"headerlink\" title=\"推荐参考书\"></a>推荐参考书</h2><h3 id=\"在线电子书\"><a href=\"#在线电子书\" class=\"headerlink\" title=\"在线电子书\"></a>在线电子书</h3><ul>\n<li><a href=\"https://github.com/forezp/SpringCloudLearning\" target=\"_blank\" rel=\"noopener\">《深入理解Spring Cloud与微服务构建》</a></li>\n</ul>\n<ul>\n<li><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf\" target=\"_blank\" rel=\"noopener\">《阿里技术参考图册-研发篇》</a></li>\n<li><p><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf\" target=\"_blank\" rel=\"noopener\">《阿里技术参考图册-算法篇》</a></p>\n</li>\n<li><p><a href=\"http://dpurl.cn/n/1lqcX\" target=\"_blank\" rel=\"noopener\">《2018美团点评技术年货（合辑）》70M</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/architect/\" target=\"_blank\" rel=\"noopener\">InfoQ《架构师》月刊</a></p>\n</li>\n<li><p><a href=\"https://www.w3cschool.cn/architectroad/\" target=\"_blank\" rel=\"noopener\">《架构师之路》</a></p>\n</li>\n</ul>\n<h3 id=\"纸质书\"><a href=\"#纸质书\" class=\"headerlink\" title=\"纸质书\"></a>纸质书</h3><h4 id=\"开发方面\"><a href=\"#开发方面\" class=\"headerlink\" title=\"开发方面\"></a>开发方面</h4><ul>\n<li>《阿里巴巴Java开发手册》<a href=\"https://union-click.jd.com/jdc?d=bVKwZQ\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=阿里巴巴Java开发手册\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"架构方面\"><a href=\"#架构方面\" class=\"headerlink\" title=\"架构方面\"></a>架构方面</h4><ul>\n<li>《软件架构师的12项修炼：技术技能篇》<a href=\"https://union-click.jd.com/jdc?d=gXvRd8\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《架构之美》<a href=\"https://union-click.jd.com/jdc?d=xJit5I\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=架构之美\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《分布式服务架构》<a href=\"https://union-click.jd.com/jdc?d=JS5Od9\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=分布式服务架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《聊聊架构》 <a href=\"https://union-click.jd.com/jdc?d=FHooH4\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=聊聊架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《云原生应用架构实践》<a href=\"https://union-click.jd.com/jdc?d=orkJSj\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=云原生应用架构实践\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《亿级流量网站架构核心技术》<a href=\"https://union-click.jd.com/jdc?d=RnOSP5\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=亿级流量网站架构核心技术\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《淘宝技术这十年》<a href=\"https://union-click.jd.com/jdc?d=LwrDfD\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=淘宝技术这十年\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li><p>《企业IT架构转型之道-中台战略思想与架构实战》 <a href=\"https://union-click.jd.com/jdc?d=89pAEm\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=企业IT架构转型之道\" target=\"_blank\" rel=\"noopener\">淘宝</a></p>\n</li>\n<li><p>《高可用架构（第1卷）》<a href=\"https://item.jd.com/12195481.html\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=高可用架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></p>\n</li>\n</ul>\n<h4 id=\"技术管理方面\"><a href=\"#技术管理方面\" class=\"headerlink\" title=\"技术管理方面\"></a>技术管理方面</h4><ul>\n<li>《CTO说》<a href=\"https://union-click.jd.com/jdc?d=zhTZyr\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=CTO说\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《技术管理之巅》<a href=\"https://union-click.jd.com/jdc?d=LgRBUW\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=技术管理之巅\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《网易一千零一夜：互联网产品项目管理实战》<a href=\"https://union-click.jd.com/jdc?d=jcRz2r\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"基础理论-1\"><a href=\"#基础理论-1\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h4><ul>\n<li>《数学之美》<a href=\"https://union-click.jd.com/jdc?d=ghIES2\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=数学之美\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《编程珠玑》<a href=\"https://union-click.jd.com/jdc?d=YmhdEu\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=编程珠玑\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"工具方面\"><a href=\"#工具方面\" class=\"headerlink\" title=\"工具方面\"></a>工具方面</h4><p>TODO</p>\n<h4 id=\"大数据方面\"><a href=\"#大数据方面\" class=\"headerlink\" title=\"大数据方面\"></a>大数据方面</h4><h1 id=\"技术资源\"><a href=\"#技术资源\" class=\"headerlink\" title=\"技术资源\"></a>技术资源</h1><h2 id=\"开源资源\"><a href=\"#开源资源\" class=\"headerlink\" title=\"开源资源\"></a>开源资源</h2><ul>\n<li><p><a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n</li>\n<li><p><a href=\"https://www.apache.org/index.html\" target=\"_blank\" rel=\"noopener\">Apache 软件基金会</a></p>\n</li>\n</ul>\n<h2 id=\"手册、文档、教程\"><a href=\"#手册、文档、教程\" class=\"headerlink\" title=\"手册、文档、教程\"></a>手册、文档、教程</h2><p><strong>国内：</strong></p>\n<ul>\n<li><a href=\"http://w3cschool.cn\" target=\"_blank\" rel=\"noopener\">W3Cschool</a> </li>\n<li><p><a href=\"http://www.runoob.com/\" target=\"_blank\" rel=\"noopener\">Runoob.com</a></p>\n<ul>\n<li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li>\n</ul>\n</li>\n<li><p><a href=\"https://love2.io/\" target=\"_blank\" rel=\"noopener\">Love2.io</a></p>\n<ul>\n<li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.cn/\" target=\"_blank\" rel=\"noopener\">gitbook.cn</a><ul>\n<li>付费电子书。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.apachecn.org/\" target=\"_blank\" rel=\"noopener\">ApacheCN</a><ul>\n<li>AI、大数据方面系列中文文档。</li>\n</ul>\n</li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"http://www.quickcode.co/\" target=\"_blank\" rel=\"noopener\">Quick Code</a><ul>\n<li>免费在线技术教程。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.com\" target=\"_blank\" rel=\"noopener\">gitbook.com</a><ul>\n<li>有部分中文电子书。</li>\n</ul>\n</li>\n<li><a href=\"https://www.cheatography.com/\" target=\"_blank\" rel=\"noopener\">Cheatography</a><ul>\n<li>Cheat Sheets 大全，单页文档网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.tutorialspoint.com/index.htm\" target=\"_blank\" rel=\"noopener\">Tutorialspoint</a><ul>\n<li>知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在线课堂\"><a href=\"#在线课堂\" class=\"headerlink\" title=\"在线课堂\"></a>在线课堂</h2><ul>\n<li><a href=\"http://www.xuetuwuyou.com/\" target=\"_blank\" rel=\"noopener\">学徒无忧</a></li>\n<li><a href=\"https://time.geekbang.org/\" target=\"_blank\" rel=\"noopener\">极客时间</a></li>\n<li><a href=\"https://segmentfault.com/lives\" target=\"_blank\" rel=\"noopener\">segmentfault</a></li>\n<li><a href=\"https://new.stuq.org/course/explore\" target=\"_blank\" rel=\"noopener\">斯达克学院</a></li>\n<li><a href=\"http://nowcoder.com\" target=\"_blank\" rel=\"noopener\">牛客网</a></li>\n<li><a href=\"https://www.jikexueyuan.com/\" target=\"_blank\" rel=\"noopener\">极客学院</a></li>\n<li><a href=\"http://edu.51cto.com/\" target=\"_blank\" rel=\"noopener\">51CTO学院</a></li>\n</ul>\n<h2 id=\"会议、活动\"><a href=\"#会议、活动\" class=\"headerlink\" title=\"会议、活动\"></a>会议、活动</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/qcon/\" target=\"_blank\" rel=\"noopener\">QCon</a></li>\n<li><a href=\"https://archsummit.com\" target=\"_blank\" rel=\"noopener\">ArchSummit</a></li>\n<li><a href=\"http://www.thegitc.com/\" target=\"_blank\" rel=\"noopener\">GITC全球互联网技术大会</a></li>\n</ul>\n<p><strong>活动发布平台:</strong> </p>\n<ul>\n<li><a href=\"http://www.huodongxing.com/\" target=\"_blank\" rel=\"noopener\">活动行</a></li>\n</ul>\n<h2 id=\"常用APP\"><a href=\"#常用APP\" class=\"headerlink\" title=\"常用APP\"></a>常用APP</h2><ul>\n<li><a href=\"https://time.geekbang.org\" target=\"_blank\" rel=\"noopener\">极客时间</a></li>\n<li><a href=\"https://www.igetget.com\" target=\"_blank\" rel=\"noopener\">得到</a></li>\n</ul>\n<h2 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h2><ul>\n<li><a href=\"https://www.zhipin.com\" target=\"_blank\" rel=\"noopener\">Boss直聘</a></li>\n<li><a href=\"https://www.lagou.com\" target=\"_blank\" rel=\"noopener\">拉勾网</a></li>\n<li><a href=\"https://www.liepin.com\" target=\"_blank\" rel=\"noopener\">猎聘</a></li>\n<li><a href=\"https://cn.100offer.com/\" target=\"_blank\" rel=\"noopener\">100Offer</a></li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><a href=\"https://s.geekbang.org/\" target=\"_blank\" rel=\"noopener\">极客搜索</a><ul>\n<li>技术文章搜索引擎。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码托管\"><a href=\"#代码托管\" class=\"headerlink\" title=\"代码托管\"></a>代码托管</h2><ul>\n<li><a href=\"https://coding.net\" target=\"_blank\" rel=\"noopener\">Coding</a></li>\n<li><a href=\"https://gitee.com/\" target=\"_blank\" rel=\"noopener\">码云</a></li>\n</ul>\n<h2 id=\"文件服务\"><a href=\"#文件服务\" class=\"headerlink\" title=\"文件服务\"></a>文件服务</h2><ul>\n<li>七牛</li>\n<li>又拍云</li>\n</ul>\n<h2 id=\"综合云服务商\"><a href=\"#综合云服务商\" class=\"headerlink\" title=\"综合云服务商\"></a>综合云服务商</h2><ul>\n<li>阿里云</li>\n<li><a href=\"https://cloud.tencent.com/redirect.php?redirect=1012&amp;cps_key=c2665015d90871c0cb20fef91b7afc3c\" target=\"_blank\" rel=\"noopener\">腾讯云</a></li>\n<li>百度云</li>\n<li>新浪云</li>\n<li>金山云</li>\n<li><a href=\"https://amazonaws-china.com/cn/\" target=\"_blank\" rel=\"noopener\">亚马逊云(AWS)</a></li>\n<li><a href=\"https://cloud.google.com/?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">谷歌云</a></li>\n<li><a href=\"https://azure.microsoft.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">微软云</a></li>\n</ul>\n<h3 id=\"VPS\"><a href=\"#VPS\" class=\"headerlink\" title=\"VPS\"></a>VPS</h3><ul>\n<li><a href=\"http://linode.com\" target=\"_blank\" rel=\"noopener\">Linode</a></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","post":"ckatvaq9k0001g4vaz2oig465","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/angular-start-quick/a-1.png","post":"ckatvaq9t0006g4vavv4o5ks2","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/apidoc-java/a.png","post":"ckatvaqaa000fg4va4bpcrxt0","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/distributed-id-snowflake/a.png","post":"ckatvaqat001hg4vambkq5x55","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-app-install/redis.conf","post":"ckatvaqaw001mg4vazotto437","slug":"redis.conf","modified":1,"renderable":1},{"_id":"source/_posts/docker-install-centos7/a.png","post":"ckatvaqb50027g4va8wcohl75","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-install-ubuntu16/a.png","post":"ckatvaqb60029g4vadltfsccg","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-maven-nexus/a-1.png","post":"ckatvaqbg002vg4varmbxurvm","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","post":"ckatvaqbx003vg4vanvou7d8n","slug":"favicon.ico","modified":1,"renderable":1},{"_id":"source/_posts/gitlab-start/a-1.png","post":"ckatvaqc10041g4vac2iz44aa","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/hashicorp-vault/a.png","post":"ckatvaqc40046g4vads0tvoyg","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-buffered/a-1.png","post":"ckatvaqcm0058g4va79tq6nbk","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/jwt-study/a-1.png","post":"ckatvaqdb006kg4vabwcuyf2d","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/microservice-think/a.png","post":"ckatvaqdq007fg4va030xfo13","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/rabbitmq-basic/a.png","post":"ckatvaqeb008kg4va2lphu7zb","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/redis-cluster-centos/a.png","post":"ckatvaqei008xg4vai0cl1rir","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/restful-api-dev/a.png","post":"ckatvaqew009qg4vawaed6p3r","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/sboot-change-contextpath/a.png","post":"ckatvaqez009wg4vaalptfvq1","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","post":"ckatvaqf200a1g4vafxagr6oz","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-exception/a.png","post":"ckatvaqfb00akg4vahskgtv6a","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-filters/a.png","post":"ckatvaqfc00amg4vaul9hhk4b","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-start/a.png","post":"ckatvaqfe00arg4vaw3585awf","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/spring-boot-dev-error-show/a.png","post":"ckatvaqft00bmg4vahjjdbqyr","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/website-high-performance/favicon.ico","post":"ckatvaqg900csg4va9hhw7y8y","slug":"favicon.ico","modified":1,"renderable":1},{"_id":"source/_posts/http-protocol-overview/a.png","post":"ckatvaqc50048g4vawkm4vtrh","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/http-protocol-overview/b.png","post":"ckatvaqc50048g4vawkm4vtrh","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/javapoet-apt-annotation/a.png","post":"ckatvaqd20061g4vazpfoai8i","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/javapoet-apt-annotation/b.png","post":"ckatvaqd20061g4vazpfoai8i","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/linux-command-use/a.png","post":"ckatvaqdf006tg4va8nkbua1j","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/linux-command-use/b.png","post":"ckatvaqdf006tg4va8nkbua1j","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/spring-boot-filter/a.png","post":"ckatvaqfv00brg4va51p27apg","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/spring-boot-filter/b.png","post":"ckatvaqfv00brg4va51p27apg","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/wkhtmltopdf/Arial.zip","slug":"Arial.zip","post":"ckatvaqga00cug4vaaquniemf","modified":1,"renderable":0},{"_id":"source/_posts/wkhtmltopdf/simsun.ttc","slug":"simsun.ttc","post":"ckatvaqga00cug4vaaquniemf","modified":1,"renderable":0},{"_id":"source/_posts/idea-good-plug/c-1.png","post":"ckatvaqca004kg4vahfq1obga","slug":"c-1.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-good-plug/c-2.png","post":"ckatvaqca004kg4vahfq1obga","slug":"c-2.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-good-plug/c-3.png","post":"ckatvaqca004kg4vahfq1obga","slug":"c-3.png","modified":1,"renderable":1},{"_id":"source/_posts/maven-ofen/a-1.png","post":"ckatvaqdi006zg4vac2klwwc3","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/maven-ofen/a.jpg","post":"ckatvaqdi006zg4vac2klwwc3","slug":"a.jpg","modified":1,"renderable":1},{"_id":"source/_posts/maven-ofen/b.jpg","post":"ckatvaqdi006zg4vac2klwwc3","slug":"b.jpg","modified":1,"renderable":1},{"_id":"source/_posts/mysql-copy/a-1.png","post":"ckatvaqds007ig4vae8s6qi2w","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/mysql-copy/a-2.png","post":"ckatvaqds007ig4vae8s6qi2w","slug":"a-2.png","modified":1,"renderable":1},{"_id":"source/_posts/mysql-copy/a-3.png","post":"ckatvaqds007ig4vae8s6qi2w","slug":"a-3.png","modified":1,"renderable":1},{"_id":"source/_posts/rabbitmq-exchange/a-1.png","post":"ckatvaqed008mg4vaj5djmm47","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/rabbitmq-exchange/a-2.png","post":"ckatvaqed008mg4vaj5djmm47","slug":"a-2.png","modified":1,"renderable":1},{"_id":"source/_posts/rabbitmq-exchange/a-3.png","post":"ckatvaqed008mg4vaj5djmm47","slug":"a-3.png","modified":1,"renderable":1},{"_id":"source/_posts/redmine-plugins/a-1.png","post":"ckatvaqes009ig4vairjkr83k","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/redmine-plugins/a.png","post":"ckatvaqes009ig4vairjkr83k","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/redmine-plugins/b-1.png","post":"ckatvaqes009ig4vairjkr83k","slug":"b-1.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-elk/kibana1.png","slug":"kibana1.png","post":"ckatvaqf300a5g4vas3usybfq","modified":1,"renderable":0},{"_id":"source/_posts/scloud-elk/kibana2.png","slug":"kibana2.png","post":"ckatvaqf300a5g4vas3usybfq","modified":1,"renderable":0},{"_id":"source/_posts/scloud-elk/kibana3.png","slug":"kibana3.png","post":"ckatvaqf300a5g4vas3usybfq","modified":1,"renderable":0},{"_id":"source/_posts/scloud-properties-refresh/a-1.png","post":"ckatvaqfe00aqg4vaozvqrni2","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-properties-refresh/a-2.png","post":"ckatvaqfe00aqg4vaozvqrni2","slug":"a-2.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-properties-refresh/b-1.png","post":"ckatvaqfe00aqg4vaozvqrni2","slug":"b-1.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-register-nexus/a-1.png","post":"ckatvaqbh002xg4va633cpy56","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-register-nexus/a-2.png","post":"ckatvaqbh002xg4va633cpy56","slug":"a-2.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-register-nexus/a-3.png","post":"ckatvaqbh002xg4va633cpy56","slug":"a-3.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-register-nexus/j-1.png","post":"ckatvaqbh002xg4va633cpy56","slug":"j-1.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/a.png","post":"ckatvaqe8008bg4vawu8gx8xl","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/b.png","slug":"b.png","post":"ckatvaqe8008bg4vawu8gx8xl","modified":1,"renderable":0},{"_id":"source/_posts/pivotal-web-service-start/c.png","post":"ckatvaqe8008bg4vawu8gx8xl","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/d.png","post":"ckatvaqe8008bg4vawu8gx8xl","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/redmine-start/a.png","post":"ckatvaqet009kg4vaeyfojoki","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/redmine-start/b.png","post":"ckatvaqet009kg4vaeyfojoki","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/redmine-start/c.png","post":"ckatvaqet009kg4vaeyfojoki","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/redmine-start/d.png","post":"ckatvaqet009kg4vaeyfojoki","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/a.png","post":"ckatvaqad000ig4va2mq4o4ph","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/b.png","post":"ckatvaqad000ig4va2mq4o4ph","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/c.png","post":"ckatvaqad000ig4va2mq4o4ph","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/d.png","post":"ckatvaqad000ig4va2mq4o4ph","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/e.png","post":"ckatvaqad000ig4va2mq4o4ph","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-byte-stream/a-1.png","post":"ckatvaqco005cg4vab6a02j23","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-byte-stream/b-1.png","post":"ckatvaqco005cg4vab6a02j23","slug":"b-1.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-byte-stream/b-2.png","post":"ckatvaqco005cg4vab6a02j23","slug":"b-2.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-byte-stream/c-1.png","post":"ckatvaqco005cg4vab6a02j23","slug":"c-1.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-byte-stream/c-2.png","post":"ckatvaqco005cg4vab6a02j23","slug":"c-2.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-start/a-1.png","post":"ckatvaqct005pg4vazuj8loud","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-start/a-2.png","post":"ckatvaqct005pg4vazuj8loud","slug":"a-2.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-start/a-3.png","post":"ckatvaqct005pg4vazuj8loud","slug":"a-3.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-start/b-1.png","post":"ckatvaqct005pg4vazuj8loud","slug":"b-1.png","modified":1,"renderable":1},{"_id":"source/_posts/java-core-io-start/b-2.png","post":"ckatvaqct005pg4vazuj8loud","slug":"b-2.png","modified":1,"renderable":1},{"_id":"source/_posts/rabbitmq-messages/b-1.png","post":"ckatvaqef008rg4vaohamr8op","slug":"b-1.png","modified":1,"renderable":1},{"_id":"source/_posts/rabbitmq-messages/b-2.png","post":"ckatvaqef008rg4vaohamr8op","slug":"b-2.png","modified":1,"renderable":1},{"_id":"source/_posts/rabbitmq-messages/b-3.png","post":"ckatvaqef008rg4vaohamr8op","slug":"b-3.png","modified":1,"renderable":1},{"_id":"source/_posts/rabbitmq-messages/b-4.png","post":"ckatvaqef008rg4vaohamr8op","slug":"b-4.png","modified":1,"renderable":1},{"_id":"source/_posts/rabbitmq-messages/b-5.png","post":"ckatvaqef008rg4vaohamr8op","slug":"b-5.png","modified":1,"renderable":1},{"_id":"source/_posts/shiro-start/shiro-01.png","post":"ckatvaqfn00b7g4va35p1pudn","slug":"shiro-01.png","modified":1,"renderable":1},{"_id":"source/_posts/shiro-start/shiro-02.png","post":"ckatvaqfn00b7g4va35p1pudn","slug":"shiro-02.png","modified":1,"renderable":1},{"_id":"source/_posts/shiro-start/shiro-03.png","post":"ckatvaqfn00b7g4va35p1pudn","slug":"shiro-03.png","modified":1,"renderable":1},{"_id":"source/_posts/shiro-start/shiro-04.png","post":"ckatvaqfn00b7g4va35p1pudn","slug":"shiro-04.png","modified":1,"renderable":1},{"_id":"source/_posts/shiro-start/shiro-05.png","post":"ckatvaqfn00b7g4va35p1pudn","slug":"shiro-05.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-Xshell/a-1.png","post":"ckatvaqg500cgg4vasjgog9pp","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-Xshell/a-2.png","post":"ckatvaqg500cgg4vasjgog9pp","slug":"a-2.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-Xshell/a-3.png","post":"ckatvaqg500cgg4vasjgog9pp","slug":"a-3.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-Xshell/b-1.png","post":"ckatvaqg500cgg4vasjgog9pp","slug":"b-1.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-Xshell/b-2.png","post":"ckatvaqg500cgg4vasjgog9pp","slug":"b-2.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-start/a.png","post":"ckatvaqg600cig4vaw386n5qt","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-start/b.png","post":"ckatvaqg600cig4vaw386n5qt","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-start/c.png","post":"ckatvaqg600cig4vaw386n5qt","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-start/d.png","post":"ckatvaqg600cig4vaw386n5qt","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/vagrant-start/e.png","post":"ckatvaqg600cig4vaw386n5qt","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-lesson3-images/a.png","post":"ckatvaqba002hg4vayb6tads7","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-lesson3-images/b-1.png","post":"ckatvaqba002hg4vayb6tads7","slug":"b-1.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-lesson3-images/b-2.png","post":"ckatvaqba002hg4vayb6tads7","slug":"b-2.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-lesson3-images/b.png","post":"ckatvaqba002hg4vayb6tads7","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-lesson3-images/c.png","post":"ckatvaqba002hg4vayb6tads7","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-lesson3-images/yy.png","post":"ckatvaqba002hg4vayb6tads7","slug":"yy.png","modified":1,"renderable":1},{"_id":"source/_posts/maven-nexus-jar/a-1.png","post":"ckatvaqdh006xg4vapmm8f2e1","slug":"a-1.png","modified":1,"renderable":1},{"_id":"source/_posts/maven-nexus-jar/a-2.png","post":"ckatvaqdh006xg4vapmm8f2e1","slug":"a-2.png","modified":1,"renderable":1},{"_id":"source/_posts/maven-nexus-jar/a-3.png","post":"ckatvaqdh006xg4vapmm8f2e1","slug":"a-3.png","modified":1,"renderable":1},{"_id":"source/_posts/maven-nexus-jar/a-4.png","post":"ckatvaqdh006xg4vapmm8f2e1","slug":"a-4.png","modified":1,"renderable":1},{"_id":"source/_posts/maven-nexus-jar/a-5.png","post":"ckatvaqdh006xg4vapmm8f2e1","slug":"a-5.png","modified":1,"renderable":1},{"_id":"source/_posts/maven-nexus-jar/a-6.png","post":"ckatvaqdh006xg4vapmm8f2e1","slug":"a-6.png","modified":1,"renderable":1},{"_id":"source/_posts/shadowsocks-go/Shadowsocks-4.0.6.zip","slug":"Shadowsocks-4.0.6.zip","post":"ckatvaqfj00axg4vaentm0358","modified":1,"renderable":0},{"_id":"source/_posts/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk","slug":"Shadowsocks_v4.2.5_apkpure.com.apk","post":"ckatvaqfj00axg4vaentm0358","modified":1,"renderable":0},{"_id":"source/_posts/shadowsocks-go/a.png","post":"ckatvaqfj00axg4vaentm0358","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/shadowsocks-go/b.png","post":"ckatvaqfj00axg4vaentm0358","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/shadowsocks-go/client.tar.gz","slug":"client.tar.gz","post":"ckatvaqfj00axg4vaentm0358","modified":1,"renderable":0},{"_id":"source/_posts/shadowsocks-go/go1.9.2.linux-amd64.tar.gz","slug":"go1.9.2.linux-amd64.tar.gz","post":"ckatvaqfj00axg4vaentm0358","modified":1,"renderable":0},{"_id":"source/_posts/shadowsocks-go/server.tar.gz","slug":"server.tar.gz","post":"ckatvaqfj00axg4vaentm0358","modified":1,"renderable":0},{"_id":"source/_posts/idea-file-template/a.png","post":"ckatvaqc8004eg4va2tswtcmi","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/b.png","post":"ckatvaqc8004eg4va2tswtcmi","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/c.png","post":"ckatvaqc8004eg4va2tswtcmi","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/d.png","post":"ckatvaqc8004eg4va2tswtcmi","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/e.png","post":"ckatvaqc8004eg4va2tswtcmi","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/f.png","post":"ckatvaqc8004eg4va2tswtcmi","slug":"f.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/g.png","post":"ckatvaqc8004eg4va2tswtcmi","slug":"g.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/j.png","post":"ckatvaqc8004eg4va2tswtcmi","slug":"j.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/a.png","post":"ckatvaqak000xg4vab8wfpway","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/b.png","post":"ckatvaqak000xg4vab8wfpway","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/c.png","post":"ckatvaqak000xg4vab8wfpway","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/d.png","post":"ckatvaqak000xg4vab8wfpway","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/e.png","post":"ckatvaqak000xg4vab8wfpway","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/f.png","post":"ckatvaqak000xg4vab8wfpway","slug":"f.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/g.png","post":"ckatvaqak000xg4vab8wfpway","slug":"g.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/h.png","post":"ckatvaqak000xg4vab8wfpway","slug":"h.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/i.png","post":"ckatvaqak000xg4vab8wfpway","slug":"i.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/j.png","post":"ckatvaqak000xg4vab8wfpway","slug":"j.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/1.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/10.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/11.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/12.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/13.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/14.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/15.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"15.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/2.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/3.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/4.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/5.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/6.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"6.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/7.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/8.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/8_1.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"8_1.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/9.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"9.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/a.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/b.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/c.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/e.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/f.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"f.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/g.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"g.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/h.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"h.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/i.png","post":"ckatvaqd40065g4vah0vx23qw","slug":"i.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckatvaq9k0001g4vaz2oig465","category_id":"ckatvaq9q0003g4vak9r2bz69","_id":"ckatvaqa5000cg4vacwd49qfn"},{"post_id":"ckatvaqa0000ag4vawkq4ylqg","category_id":"ckatvaq9x0008g4va26qzylq2","_id":"ckatvaqaa000gg4vairiqvnog"},{"post_id":"ckatvaq9o0002g4vaphnfw9ei","category_id":"ckatvaq9x0008g4va26qzylq2","_id":"ckatvaqad000jg4vakncittjg"},{"post_id":"ckatvaqa4000bg4vazs5cqr9j","category_id":"ckatvaq9x0008g4va26qzylq2","_id":"ckatvaqag000mg4va00unbdfg"},{"post_id":"ckatvaqa7000eg4vanaodg0ew","category_id":"ckatvaq9x0008g4va26qzylq2","_id":"ckatvaqah000pg4vanjdilg1g"},{"post_id":"ckatvaq9s0005g4vayw1npwtj","category_id":"ckatvaq9x0008g4va26qzylq2","_id":"ckatvaqaj000sg4vam23mfgku"},{"post_id":"ckatvaq9t0006g4vavv4o5ks2","category_id":"ckatvaq9x0008g4va26qzylq2","_id":"ckatvaqak000wg4vabrfuxb1w"},{"post_id":"ckatvaq9w0007g4vaxaxv2kro","category_id":"ckatvaq9x0008g4va26qzylq2","_id":"ckatvaqal000zg4vao5holwtf"},{"post_id":"ckatvaqaa000fg4va4bpcrxt0","category_id":"ckatvaqaj000tg4vatp0wzgha","_id":"ckatvaqao0016g4vah01ehinf"},{"post_id":"ckatvaqad000ig4va2mq4o4ph","category_id":"ckatvaqaj000tg4vatp0wzgha","_id":"ckatvaqaq001ag4va2fgponin"},{"post_id":"ckatvaqaf000lg4vawfirv1wq","category_id":"ckatvaqao0015g4vas5z2vqvi","_id":"ckatvaqat001gg4vanl8gpw80"},{"post_id":"ckatvaqah000og4vai4yghsf8","category_id":"ckatvaqar001cg4va7q9t2w8f","_id":"ckatvaqax001og4vap0rnff7j"},{"post_id":"ckatvaqai000qg4va0xq4hjzc","category_id":"ckatvaqar001cg4va7q9t2w8f","_id":"ckatvaqaz001tg4vab21hcd6q"},{"post_id":"ckatvaqaj000vg4vagai0n5e0","category_id":"ckatvaqaw001ng4vae7arq0ry","_id":"ckatvaqb2001zg4va4jvrlm81"},{"post_id":"ckatvaqak000xg4vab8wfpway","category_id":"ckatvaqb0001ug4varoihxjif","_id":"ckatvaqb50026g4vaae1afyrc"},{"post_id":"ckatvaqam0011g4vax5ztk8xw","category_id":"ckatvaqaw001ng4vae7arq0ry","_id":"ckatvaqb7002bg4va0eljgqoq"},{"post_id":"ckatvaqan0013g4va7fig6dbd","category_id":"ckatvaqaw001ng4vae7arq0ry","_id":"ckatvaqb9002fg4va28omtwcn"},{"post_id":"ckatvaqao0017g4val9uj25jo","category_id":"ckatvaqb7002ag4va8u586yh1","_id":"ckatvaqbc002mg4vazq060hhu"},{"post_id":"ckatvaqaq0019g4vavkekd1xe","category_id":"ckatvaqaw001ng4vae7arq0ry","_id":"ckatvaqbe002rg4va7dkopfnz"},{"post_id":"ckatvaqar001dg4va14t85gpf","category_id":"ckatvaqbc002lg4va4gz0gl3i","_id":"ckatvaqbi002yg4vam3x090px"},{"post_id":"ckatvaqas001fg4vaaz23w0c4","category_id":"ckatvaqbf002tg4vaka18w9uu","_id":"ckatvaqbk0035g4vav4kyatsm"},{"post_id":"ckatvaqat001hg4vambkq5x55","category_id":"ckatvaqbf002tg4vaka18w9uu","_id":"ckatvaqbo003bg4var08b5vfq"},{"post_id":"ckatvaqbl0036g4vazss5u9cs","category_id":"ckatvaqbf002tg4vaka18w9uu","_id":"ckatvaqbq003fg4vapmmtfxmz"},{"post_id":"ckatvaqav001lg4vaxa64leng","category_id":"ckatvaqbf002tg4vaka18w9uu","_id":"ckatvaqbs003jg4va1lcmleey"},{"post_id":"ckatvaqaw001mg4vazotto437","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqbt003og4vaumfkeku0"},{"post_id":"ckatvaqax001qg4va8ok85sqt","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqbx003ug4va2ju95fsh"},{"post_id":"ckatvaqaz001sg4vaoaj3fwnw","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqc0003zg4varpcj7f0p"},{"post_id":"ckatvaqb0001wg4vavgte12zs","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqc30045g4vafpujk1tc"},{"post_id":"ckatvaqb1001yg4vap3y91c0s","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqc6004bg4vau8vqh7ap"},{"post_id":"ckatvaqb30022g4vab7pebexl","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqc9004gg4vaxuv0zyxy"},{"post_id":"ckatvaqb40024g4vazm934k1o","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqcb004mg4vacqrnk6ez"},{"post_id":"ckatvaqb50027g4va8wcohl75","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqce004sg4vadpe0igb9"},{"post_id":"ckatvaqb60029g4vadltfsccg","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqch004yg4va6z2x3ehn"},{"post_id":"ckatvaqb8002dg4vavj7bs9uu","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqck0054g4vah3r6h5vu"},{"post_id":"ckatvaqcf004vg4va0yvbervm","category_id":"ckatvaqbc002lg4va4gz0gl3i","_id":"ckatvaqcm0056g4vaz5gpnot6"},{"post_id":"ckatvaqch004zg4vadmr6289q","category_id":"ckatvaqbc002lg4va4gz0gl3i","_id":"ckatvaqcn005bg4vampjyaknb"},{"post_id":"ckatvaqb8002eg4vabjf0of5w","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqcp005dg4vagfyboa17"},{"post_id":"ckatvaqci0051g4vai3vr0fi5","category_id":"ckatvaqbc002lg4va4gz0gl3i","_id":"ckatvaqcq005hg4vayj82bhj3"},{"post_id":"ckatvaqcl0055g4va84p158zo","category_id":"ckatvaqbc002lg4va4gz0gl3i","_id":"ckatvaqcr005kg4vaciadmsth"},{"post_id":"ckatvaqba002hg4vayb6tads7","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqct005og4vab2tysibt"},{"post_id":"ckatvaqbb002kg4vanebkpvnv","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqcu005rg4var4rk4cam"},{"post_id":"ckatvaqbc002ng4vaiykok555","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqcv005ug4vaojwqgg35"},{"post_id":"ckatvaqbd002pg4vabiksl0e3","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqcz005zg4vak7dnbpsn"},{"post_id":"ckatvaqbf002sg4varsj1t52p","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqd30063g4vat7h4ysny"},{"post_id":"ckatvaqcx005xg4vanlniqb4u","category_id":"ckatvaqbc002lg4va4gz0gl3i","_id":"ckatvaqd50066g4va1jlncu9i"},{"post_id":"ckatvaqcz0060g4vaaf6o7m52","category_id":"ckatvaqbc002lg4va4gz0gl3i","_id":"ckatvaqd60069g4vafpzhah2b"},{"post_id":"ckatvaqbg002vg4varmbxurvm","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqd8006cg4vaypjcrzx4"},{"post_id":"ckatvaqd40065g4vah0vx23qw","category_id":"ckatvaqb7002ag4va8u586yh1","_id":"ckatvaqd9006fg4vafbauriuc"},{"post_id":"ckatvaqbh002xg4va633cpy56","category_id":"ckatvaqbo003ag4va6jg9rcaz","_id":"ckatvaqdb006jg4va6cex6vzl"},{"post_id":"ckatvaqbk0033g4vafl0mi3ah","category_id":"ckatvaqd60068g4vavopu0xos","_id":"ckatvaqdc006mg4va7p69f7uj"},{"post_id":"ckatvaqda006hg4varkqvsaue","category_id":"ckatvaqaw001ng4vae7arq0ry","_id":"ckatvaqdf006rg4vanift6xjd"},{"post_id":"ckatvaqbn0039g4vaav5gbsls","category_id":"ckatvaqda006gg4vaih6s9ysx","_id":"ckatvaqdg006vg4vax59py8jf"},{"post_id":"ckatvaqbo003cg4valloa58j1","category_id":"ckatvaqd60068g4vavopu0xos","_id":"ckatvaqdj0070g4va7ozowusg"},{"post_id":"ckatvaqdh006xg4vapmm8f2e1","category_id":"ckatvaqb0001ug4varoihxjif","_id":"ckatvaqdm0076g4var0f5maqn"},{"post_id":"ckatvaqbp003eg4vaoqg9t61l","category_id":"ckatvaqdg006ug4vargqm4978","_id":"ckatvaqdn0079g4va2j8si3aw"},{"post_id":"ckatvaqdi006zg4vac2klwwc3","category_id":"ckatvaqb0001ug4varoihxjif","_id":"ckatvaqdp007cg4va43eswh6r"},{"post_id":"ckatvaqdk0072g4vaqnql4cyr","category_id":"ckatvaqb0001ug4varoihxjif","_id":"ckatvaqds007gg4va4t2eopzg"},{"post_id":"ckatvaqbr003ig4va3lr2i5lf","category_id":"ckatvaqdg006ug4vargqm4978","_id":"ckatvaqdt007jg4vawi4mqkmv"},{"post_id":"ckatvaqdl0075g4vad9llfiaz","category_id":"ckatvaqb0001ug4varoihxjif","_id":"ckatvaqdx007ng4va2ib55300"},{"post_id":"ckatvaqbs003lg4vajmzqdgks","category_id":"ckatvaqdg006ug4vargqm4978","_id":"ckatvaqdy007qg4vaqi8gv1b5"},{"post_id":"ckatvaqbu003pg4vaj3cqrx8x","category_id":"ckatvaqdg006ug4vargqm4978","_id":"ckatvaqe0007ug4va71brpt9g"},{"post_id":"ckatvaqbv003rg4vaqg9t8gqt","category_id":"ckatvaqdg006ug4vargqm4978","_id":"ckatvaqe1007xg4vaafto3qab"},{"post_id":"ckatvaqbx003vg4vanvou7d8n","category_id":"ckatvaqdy007rg4vasl81mj8j","_id":"ckatvaqe40084g4va2c4cfknp"},{"post_id":"ckatvaqe20080g4vah68zgeep","category_id":"ckatvaq9q0003g4vak9r2bz69","_id":"ckatvaqe70088g4vac8lw5ftu"},{"post_id":"ckatvaqby003wg4vah4vfxwct","category_id":"ckatvaqdy007rg4vasl81mj8j","_id":"ckatvaqe8008cg4vayers539s"},{"post_id":"ckatvaqc10041g4vac2iz44aa","category_id":"ckatvaqe40083g4va8laeuht0","_id":"ckatvaqea008hg4va8qy7ib3o"},{"post_id":"ckatvaqc20042g4va7qqc9imp","category_id":"ckatvaqd60068g4vavopu0xos","_id":"ckatvaqec008lg4vai0sna8ok"},{"post_id":"ckatvaqc40046g4vads0tvoyg","category_id":"ckatvaqea008gg4vay7j265o9","_id":"ckatvaqeg008sg4va34kko1wv"},{"post_id":"ckatvaqc50048g4vawkm4vtrh","category_id":"ckatvaqee008og4vaayt33tzy","_id":"ckatvaqej008yg4va47etakpz"},{"post_id":"ckatvaqc6004cg4va9x145nfd","category_id":"ckatvaqeh008ug4va20l75opr","_id":"ckatvaqem0095g4va6xw7jwhv"},{"post_id":"ckatvaqc8004eg4va2tswtcmi","category_id":"ckatvaqeh008ug4va20l75opr","_id":"ckatvaqeo009ag4vai8e194gy"},{"post_id":"ckatvaqc9004ig4va6dj3xm1u","category_id":"ckatvaqel0094g4va0zi64xf8","_id":"ckatvaqes009hg4vap9imw2xz"},{"post_id":"ckatvaqca004kg4vahfq1obga","category_id":"ckatvaqeh008ug4va20l75opr","_id":"ckatvaqev009ng4va3lcja37l"},{"post_id":"ckatvaqcc004ng4vap97dr7j3","category_id":"ckatvaqeh008ug4va20l75opr","_id":"ckatvaqex009sg4vasrtr7cy0"},{"post_id":"ckatvaqew009qg4vawaed6p3r","category_id":"ckatvaqaj000tg4vatp0wzgha","_id":"ckatvaqf1009zg4vah3o3621r"},{"post_id":"ckatvaqcd004qg4van5g0eamk","category_id":"ckatvaqeu009mg4vahghvn82o","_id":"ckatvaqf200a2g4vak14roipu"},{"post_id":"ckatvaqce004tg4vaajbvolkr","category_id":"ckatvaqey009ug4vati8ilfih","_id":"ckatvaqf400a6g4vaqij35tfi"},{"post_id":"ckatvaqcm0058g4va79tq6nbk","category_id":"ckatvaqf100a0g4vadpssuttp","_id":"ckatvaqf700adg4vaokt3u8ww"},{"post_id":"ckatvaqco005cg4vab6a02j23","category_id":"ckatvaqf100a0g4vadpssuttp","_id":"ckatvaqfa00ajg4vafyakisvb"},{"post_id":"ckatvaqcp005eg4vaac62b27u","category_id":"ckatvaqf100a0g4vadpssuttp","_id":"ckatvaqfd00apg4va3oa71syf"},{"post_id":"ckatvaqcr005jg4vah8gttqge","category_id":"ckatvaqf100a0g4vadpssuttp","_id":"ckatvaqfg00aug4vas5p8a4hf"},{"post_id":"ckatvaqcs005lg4va6h5w05nl","category_id":"ckatvaqf100a0g4vadpssuttp","_id":"ckatvaqfk00b0g4vard944jwq"},{"post_id":"ckatvaqct005pg4vazuj8loud","category_id":"ckatvaqf100a0g4vadpssuttp","_id":"ckatvaqfn00b6g4vaanxfi2uk"},{"post_id":"ckatvaqcu005sg4va06pabfm2","category_id":"ckatvaqf100a0g4vadpssuttp","_id":"ckatvaqfp00bag4va87bbcpuv"},{"post_id":"ckatvaqfl00b3g4vamkps5k26","category_id":"ckatvaqb7002ag4va8u586yh1","_id":"ckatvaqfq00bfg4va4m2vmdlx"},{"post_id":"ckatvaqcw005vg4vaejjthsyv","category_id":"ckatvaqfm00b5g4vafkm2nzik","_id":"ckatvaqfr00bhg4vaeh82g5k0"},{"post_id":"ckatvaqd20061g4vazpfoai8i","category_id":"ckatvaqfp00bcg4varhywgit3","_id":"ckatvaqfu00bog4vaem64gz6d"},{"post_id":"ckatvaqd50067g4va6voqa5w5","category_id":"ckatvaqfs00bkg4vaqv5m0pau","_id":"ckatvaqfx00bvg4vaq77z8phe"},{"post_id":"ckatvaqd6006ag4valfpzal9q","category_id":"ckatvaqfs00bkg4vaqv5m0pau","_id":"ckatvaqfz00c0g4vam7k3wcwc"},{"post_id":"ckatvaqd9006eg4vatygda84v","category_id":"ckatvaqfw00bug4vavhplrdwf","_id":"ckatvaqg100c6g4vai5n8qe58"},{"post_id":"ckatvaqdb006kg4vabwcuyf2d","category_id":"ckatvaqfz00c1g4vaav6xq9vz","_id":"ckatvaqg300ccg4vav5l8s9tu"},{"post_id":"ckatvaqdd006ng4va1d1rhfgs","category_id":"ckatvaqg100c7g4va8sfrc6jt","_id":"ckatvaqg700ckg4vaj9j5hl5z"},{"post_id":"ckatvaqde006qg4vafmmer3fp","category_id":"ckatvaqg100c7g4va8sfrc6jt","_id":"ckatvaqg900cpg4vavpn5teri"},{"post_id":"ckatvaqdf006tg4va8nkbua1j","category_id":"ckatvaqg600cjg4va9lwxa60u","_id":"ckatvaqgb00cvg4va4v5h6eft"},{"post_id":"ckatvaqdn0078g4va1jrx6ph2","category_id":"ckatvaqg900cqg4vak5cs4n9u","_id":"ckatvaqgf00d2g4vaw4lkmtcp"},{"post_id":"ckatvaqdo007bg4vagkbhex5s","category_id":"ckatvaqg900cqg4vak5cs4n9u","_id":"ckatvaqgf00d5g4vauklldae4"},{"post_id":"ckatvaqdq007fg4va030xfo13","category_id":"ckatvaqge00d1g4va1y6hsdqv","_id":"ckatvaqgg00d9g4vattvgbh9a"},{"post_id":"ckatvaqds007ig4vae8s6qi2w","category_id":"ckatvaqgg00d6g4va2fsxit2l","_id":"ckatvaqgj00deg4vaow54vcvb"},{"post_id":"ckatvaqdw007mg4va2ytcxv00","category_id":"ckatvaqgg00d6g4va2fsxit2l","_id":"ckatvaqgk00dig4vawdv93axm"},{"post_id":"ckatvaqdy007pg4vaj9fbnrge","category_id":"ckatvaqgg00d6g4va2fsxit2l","_id":"ckatvaqgl00dmg4vamgyuolv1"},{"post_id":"ckatvaqdz007tg4vaxlxxsggv","category_id":"ckatvaqgg00d6g4va2fsxit2l","_id":"ckatvaqgm00dpg4vapppxrckf"},{"post_id":"ckatvaqe0007vg4vatgskgxyl","category_id":"ckatvaqgg00d6g4va2fsxit2l","_id":"ckatvaqgn00dsg4va6ajilaa9"},{"post_id":"ckatvaqe30081g4vazs3ubcer","category_id":"ckatvaqgm00dog4vapo84epkv","_id":"ckatvaqgo00dwg4vaec34fte2"},{"post_id":"ckatvaqe40085g4vaibwqoyuf","category_id":"ckatvaqgn00dtg4vatj5w040d","_id":"ckatvaqgp00e0g4va5tihsluj"},{"post_id":"ckatvaqe60087g4vaev2l7as8","category_id":"ckatvaqgo00dxg4vadi700su5","_id":"ckatvaqgq00e4g4va5ilv63y5"},{"post_id":"ckatvaqe8008bg4vawu8gx8xl","category_id":"ckatvaqgp00e1g4vabn66dydd","_id":"ckatvaqgr00e8g4va56nov0le"},{"post_id":"ckatvaqeb008ig4vah0wygwqy","category_id":"ckatvaqgq00e5g4valngb96ep","_id":"ckatvaqgt00edg4vabcpfl0pn"},{"post_id":"ckatvaqeb008kg4va2lphu7zb","category_id":"ckatvaqgq00e5g4valngb96ep","_id":"ckatvaqgu00ehg4vamsy6sb0j"},{"post_id":"ckatvaqed008mg4vaj5djmm47","category_id":"ckatvaqgq00e5g4valngb96ep","_id":"ckatvaqgv00ekg4va4avibw85"},{"post_id":"ckatvaqee008qg4va6el1zwqe","category_id":"ckatvaqgq00e5g4valngb96ep","_id":"ckatvaqgw00eog4va2sun6zno"},{"post_id":"ckatvaqef008rg4vaohamr8op","category_id":"ckatvaqgq00e5g4valngb96ep","_id":"ckatvaqgx00erg4vadz1hz9ac"},{"post_id":"ckatvaqeh008vg4var46wmpmz","category_id":"ckatvaqgw00eng4vap8ix9iju","_id":"ckatvaqgz00ewg4vaz5xear85"},{"post_id":"ckatvaqei008xg4vai0cl1rir","category_id":"ckatvaqgw00eng4vap8ix9iju","_id":"ckatvaqh000f0g4vamrirw6s9"},{"post_id":"ckatvaqej0091g4vavg0s8adr","category_id":"ckatvaqgw00eng4vap8ix9iju","_id":"ckatvaqh100f4g4vafidxk698"},{"post_id":"ckatvaqek0093g4vayydkmybd","category_id":"ckatvaqgw00eng4vap8ix9iju","_id":"ckatvaqh200f8g4va00maan5g"},{"post_id":"ckatvaqem0097g4vabentt5ll","category_id":"ckatvaqgw00eng4vap8ix9iju","_id":"ckatvaqh300fag4vah847oueq"},{"post_id":"ckatvaqen0099g4vau92x8j5w","category_id":"ckatvaqgw00eng4vap8ix9iju","_id":"ckatvaqh400fdg4vasrkjhwmm"},{"post_id":"ckatvaqep009cg4va8nt29kew","category_id":"ckatvaqgw00eng4vap8ix9iju","_id":"ckatvaqh400feg4vaqgfi6r8b"},{"post_id":"ckatvaqer009fg4vak3u7yg6p","category_id":"ckatvaqh300fcg4vavl4o1p5y","_id":"ckatvaqh500fhg4vaophqitnc"},{"post_id":"ckatvaqes009ig4vairjkr83k","category_id":"ckatvaqh300fcg4vavl4o1p5y","_id":"ckatvaqh500fjg4va9ayzahjd"},{"post_id":"ckatvaqet009kg4vaeyfojoki","category_id":"ckatvaqh300fcg4vavl4o1p5y","_id":"ckatvaqh600flg4vartmld5za"},{"post_id":"ckatvaqev009og4va499pwn17","category_id":"ckatvaqh300fcg4vavl4o1p5y","_id":"ckatvaqh600fmg4vaw7nfi98e"},{"post_id":"ckatvaqex009tg4vaxnqynjf0","category_id":"ckatvaqh600fkg4vagdh6z4b9","_id":"ckatvaqh700fog4vaq2m6hijp"},{"post_id":"ckatvaqez009wg4vaalptfvq1","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqh700fqg4vaatza0jgn"},{"post_id":"ckatvaqf1009yg4vavb7kv3jh","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqh800ftg4vaatgr4i11"},{"post_id":"ckatvaqf200a1g4vafxagr6oz","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqh900fvg4va8girdinj"},{"post_id":"ckatvaqf300a5g4vas3usybfq","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqha00fxg4vai1ij6fv4"},{"post_id":"ckatvaqf400a8g4va532dq1sa","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqha00fzg4vam12x2n3i"},{"post_id":"ckatvaqf500aag4va9og65zlz","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqhb00g1g4va84op7k5m"},{"post_id":"ckatvaqf800aeg4vai16ayno8","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqhc00g3g4vaaagdec0h"},{"post_id":"ckatvaqf900agg4va812rs2xg","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqhd00g5g4vascl6hqpz"},{"post_id":"ckatvaqfb00akg4vahskgtv6a","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqhd00g7g4vaz5d2mw3v"},{"post_id":"ckatvaqfc00amg4vaul9hhk4b","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqhe00g9g4vaud85gnd2"},{"post_id":"ckatvaqfe00aqg4vaozvqrni2","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqhf00gbg4vam973sl9e"},{"post_id":"ckatvaqfe00arg4vaw3585awf","category_id":"ckatvaqh700fpg4vagcx2qjae","_id":"ckatvaqhf00gcg4va9f8slw0n"},{"post_id":"ckatvaqfg00awg4vadd0h7gmx","category_id":"ckatvaqhe00gag4vacepbwbiu","_id":"ckatvaqhf00geg4vabmxu4bnp"},{"post_id":"ckatvaqfj00axg4vaentm0358","category_id":"ckatvaqhf00gdg4valyprt4dl","_id":"ckatvaqhg00ghg4vaeedbd0bk"},{"post_id":"ckatvaqfk00b1g4va8oqk0tet","category_id":"ckatvaqfz00c1g4vaav6xq9vz","_id":"ckatvaqhh00gig4vacbyz645b"},{"post_id":"ckatvaqfn00b7g4va35p1pudn","category_id":"ckatvaqhg00ggg4vabfeogxt6","_id":"ckatvaqhi00glg4vaafy4w93l"},{"post_id":"ckatvaqfo00b9g4vawmu6cjxd","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhi00gng4vaf3skcavl"},{"post_id":"ckatvaqfp00bdg4va4tqfp15r","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhj00gpg4va6zj2odob"},{"post_id":"ckatvaqfq00bgg4va18ae7zhl","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhk00grg4vardfn6s5x"},{"post_id":"ckatvaqfr00big4vafshdptfu","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhl00gtg4va0msoc113"},{"post_id":"ckatvaqft00bmg4vahjjdbqyr","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhl00gvg4va7knheqfh"},{"post_id":"ckatvaqft00bng4vauscik1q8","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhm00gxg4va6fmc99gv"},{"post_id":"ckatvaqfv00brg4va51p27apg","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhn00gzg4valq7pgest"},{"post_id":"ckatvaqfw00btg4va2keva0wb","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqho00h1g4vac74i9is6"},{"post_id":"ckatvaqfx00bxg4vadu7tgskw","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqho00h3g4vai2evxaa0"},{"post_id":"ckatvaqfy00bzg4vaxh2408tu","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhp00h5g4vastav0ocd"},{"post_id":"ckatvaqfz00c3g4vaqtw2umun","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhq00h7g4va0r2gco5e"},{"post_id":"ckatvaqg000c5g4vagjuzlbq6","category_id":"ckatvaqh700fng4vavxzoin6s","_id":"ckatvaqhq00h8g4va7ghqaoiu"},{"post_id":"ckatvaqg100c8g4vasdisi81i","category_id":"ckatvaqhq00h6g4vaave4y0f8","_id":"ckatvaqhr00hag4vabl7o4ssy"},{"post_id":"ckatvaqg300cbg4va2jmqcnai","category_id":"ckatvaqhq00h9g4vas6l6zvzv","_id":"ckatvaqhr00hcg4varzdyzzgs"},{"post_id":"ckatvaqg300cdg4vapvx204c2","category_id":"ckatvaqhr00hbg4vaod99a3pe","_id":"ckatvaqhs00hfg4va3gqxw83o"},{"post_id":"ckatvaqg500cgg4vasjgog9pp","category_id":"ckatvaqhr00hbg4vaod99a3pe","_id":"ckatvaqht00hhg4vajm5tzu5n"},{"post_id":"ckatvaqg600cig4vaw386n5qt","category_id":"ckatvaqhr00hbg4vaod99a3pe","_id":"ckatvaqht00hjg4vasci5ncwl"},{"post_id":"ckatvaqg700cmg4vas3tar4sg","category_id":"ckatvaqhr00hbg4vaod99a3pe","_id":"ckatvaqhu00hkg4vapfbyufl5"},{"post_id":"ckatvaqg800cog4vamjrjaxl5","category_id":"ckatvaqht00hig4vapqprpjae","_id":"ckatvaqhv00hmg4valldiw2u1"},{"post_id":"ckatvaqg900csg4va9hhw7y8y","category_id":"ckatvaqhv00hlg4va0fgzeohc","_id":"ckatvaqhv00hog4vamnd7lb5i"},{"post_id":"ckatvaqga00cug4vaaquniemf","category_id":"ckatvaqhv00hng4vadf4avb07","_id":"ckatvaqhw00hqg4va1fm1e43j"},{"post_id":"ckatvaqgc00cxg4valx75jhi9","category_id":"ckatvaqhw00hpg4va1jtxz3in","_id":"ckatvaqhx00hsg4vatxu0jl1c"},{"post_id":"ckatvaqge00d0g4vadfdf737w","category_id":"ckatvaqhw00hpg4va1jtxz3in","_id":"ckatvaqhy00htg4vazzguwrnl"},{"post_id":"ckatvaqwu00hug4vana04fsnd","category_id":"ckatvaqhv00hlg4va0fgzeohc","_id":"ckatvaqwv00hwg4vayekjih58"}],"PostTag":[{"post_id":"ckatvaq9k0001g4vaz2oig465","tag_id":"ckatvaq9r0004g4vaav4ejf3p","_id":"ckatvaq9z0009g4va22319vlk"},{"post_id":"ckatvaqaa000fg4va4bpcrxt0","tag_id":"ckatvaqaf000kg4va6sywwu03","_id":"ckatvaqaj000ug4var9nacvfp"},{"post_id":"ckatvaqad000ig4va2mq4o4ph","tag_id":"ckatvaqai000rg4va1cm5qhga","_id":"ckatvaqan0012g4va2q1dxcai"},{"post_id":"ckatvaqaf000lg4vawfirv1wq","tag_id":"ckatvaqal000yg4vai2740dux","_id":"ckatvaqap0018g4vaejyohhb6"},{"post_id":"ckatvaqaj000vg4vagai0n5e0","tag_id":"ckatvaqao0014g4va354gjmh2","_id":"ckatvaqas001eg4vavf0e2pp8"},{"post_id":"ckatvaqam0011g4vax5ztk8xw","tag_id":"ckatvaqar001bg4va0tq0bsz7","_id":"ckatvaqav001kg4va0upvfkfj"},{"post_id":"ckatvaqao0017g4val9uj25jo","tag_id":"ckatvaqau001ig4va3xnx5i25","_id":"ckatvaqay001rg4vaxn7w6xn5"},{"post_id":"ckatvaqaq0019g4vavkekd1xe","tag_id":"ckatvaqax001pg4va1f0riikk","_id":"ckatvaqb1001xg4va3pdtl4l9"},{"post_id":"ckatvaqar001dg4va14t85gpf","tag_id":"ckatvaqb0001vg4vam6l6krlk","_id":"ckatvaqb30023g4vabjefi07y"},{"post_id":"ckatvaqat001hg4vambkq5x55","tag_id":"ckatvaqb20021g4vag0sc7qmf","_id":"ckatvaqb60028g4va6r324jgu"},{"post_id":"ckatvaqb50027g4va8wcohl75","tag_id":"ckatvaqb7002cg4vahston3j0","_id":"ckatvaqbb002jg4vap4wmdeol"},{"post_id":"ckatvaqb60029g4vadltfsccg","tag_id":"ckatvaqba002ig4vayailabau","_id":"ckatvaqbe002qg4vazcnthbqf"},{"post_id":"ckatvaqb8002dg4vavj7bs9uu","tag_id":"ckatvaqbd002og4va1dcuhfvd","_id":"ckatvaqbh002wg4va0egsxz2j"},{"post_id":"ckatvaqb8002eg4vabjf0of5w","tag_id":"ckatvaqbg002ug4vao3xyz30b","_id":"ckatvaqbj0032g4vawqdfxcre"},{"post_id":"ckatvaqba002hg4vayb6tads7","tag_id":"ckatvaqbi0030g4vafl8ndemx","_id":"ckatvaqbm0038g4vaozn6kmqf"},{"post_id":"ckatvaqbb002kg4vanebkpvnv","tag_id":"ckatvaqbm0037g4vaen4zpeav","_id":"ckatvaqbq003gg4vafgw1j3yo"},{"post_id":"ckatvaqbc002ng4vaiykok555","tag_id":"ckatvaqbp003dg4va6g2zkiax","_id":"ckatvaqbt003mg4vaydgya4tc"},{"post_id":"ckatvaqbd002pg4vabiksl0e3","tag_id":"ckatvaqbs003kg4vasvsk6vcc","_id":"ckatvaqbx003sg4vah85t4ug8"},{"post_id":"ckatvaqbp003eg4vaoqg9t61l","tag_id":"ckatvaqbv003qg4vayhq592im","_id":"ckatvaqc10040g4va1bezjcqa"},{"post_id":"ckatvaqbr003ig4va3lr2i5lf","tag_id":"ckatvaqc0003xg4vab4sdpxd5","_id":"ckatvaqc40047g4vayd0io1nu"},{"post_id":"ckatvaqbs003lg4vajmzqdgks","tag_id":"ckatvaqc30043g4vat4kn3lj7","_id":"ckatvaqc7004dg4va9gj41e8m"},{"post_id":"ckatvaqbu003pg4vaj3cqrx8x","tag_id":"ckatvaqc60049g4vam361ypzq","_id":"ckatvaqca004jg4va21sdhj70"},{"post_id":"ckatvaqbv003rg4vaqg9t8gqt","tag_id":"ckatvaqc9004hg4vahezzicv7","_id":"ckatvaqcd004pg4vas9n3pl6b"},{"post_id":"ckatvaqbx003vg4vanvou7d8n","tag_id":"ckatvaqcc004og4va616bbg34","_id":"ckatvaqcg004wg4va4xxwg0gq"},{"post_id":"ckatvaqc40046g4vads0tvoyg","tag_id":"ckatvaqcf004ug4va40n9b5fm","_id":"ckatvaqck0052g4vak0612i7w"},{"post_id":"ckatvaqc50048g4vawkm4vtrh","tag_id":"ckatvaqci0050g4vafuhvzf0g","_id":"ckatvaqcn0059g4vaggslvi7z"},{"post_id":"ckatvaqc9004ig4va6dj3xm1u","tag_id":"ckatvaqcm0057g4vadhadkelv","_id":"ckatvaqcq005ig4vayy2l4pe5"},{"post_id":"ckatvaqcd004qg4van5g0eamk","tag_id":"ckatvaqcp005fg4vaw7o5kyoe","_id":"ckatvaqcu005qg4va34kn4y2n"},{"post_id":"ckatvaqce004tg4vaajbvolkr","tag_id":"ckatvaqcs005mg4vapi3kea7h","_id":"ckatvaqcx005wg4vaou3gag9t"},{"post_id":"ckatvaqcz0060g4vaaf6o7m52","tag_id":"ckatvaqd30064g4vap25ja7u8","_id":"ckatvaqd8006dg4van4w7zddf"},{"post_id":"ckatvaqd20061g4vazpfoai8i","tag_id":"ckatvaqd7006bg4va4dg3j8la","_id":"ckatvaqdc006lg4va4wtkhxu4"},{"post_id":"ckatvaqd40065g4vah0vx23qw","tag_id":"ckatvaqdb006ig4vagpaiav1m","_id":"ckatvaqdf006sg4va6rd8mctr"},{"post_id":"ckatvaqd50067g4va6voqa5w5","tag_id":"ckatvaqde006pg4va60655had","_id":"ckatvaqdi006yg4va61meerhv"},{"post_id":"ckatvaqd6006ag4valfpzal9q","tag_id":"ckatvaqdh006wg4va9146pag0","_id":"ckatvaqdl0074g4vapd4zp9k0"},{"post_id":"ckatvaqd9006eg4vatygda84v","tag_id":"ckatvaqdk0073g4vaueuq4k66","_id":"ckatvaqdp007dg4vag6eyn3tx"},{"post_id":"ckatvaqde006qg4vafmmer3fp","tag_id":"ckatvaqdo007ag4vaxvbdxctn","_id":"ckatvaqdt007kg4vawvr5ifcg"},{"post_id":"ckatvaqdf006tg4va8nkbua1j","tag_id":"ckatvaqds007hg4vaudkhao8m","_id":"ckatvaqdz007sg4vaawjtu9e1"},{"post_id":"ckatvaqdi006zg4vac2klwwc3","tag_id":"ckatvaqdx007og4vav0fx4ga1","_id":"ckatvaqe2007zg4va08eicl1s"},{"post_id":"ckatvaqdl0075g4vad9llfiaz","tag_id":"ckatvaqe1007wg4vao4tnptcn","_id":"ckatvaqe50086g4vadh8u87jm"},{"post_id":"ckatvaqdq007fg4va030xfo13","tag_id":"ckatvaqe40082g4vagm1s46bb","_id":"ckatvaqe9008dg4vawdw8qhv2"},{"post_id":"ckatvaqds007ig4vae8s6qi2w","tag_id":"ckatvaqe70089g4va9v1cavi8","_id":"ckatvaqeb008jg4vaashwmpnb"},{"post_id":"ckatvaqdy007pg4vaj9fbnrge","tag_id":"ckatvaqea008fg4vacyf3j9el","_id":"ckatvaqee008pg4va7bnh7l31"},{"post_id":"ckatvaqdz007tg4vaxlxxsggv","tag_id":"ckatvaqed008ng4vax6znxz3m","_id":"ckatvaqei008wg4vakrr7npeh"},{"post_id":"ckatvaqe0007vg4vatgskgxyl","tag_id":"ckatvaqeg008tg4va8cuvx301","_id":"ckatvaqek0092g4vaqmps8l39"},{"post_id":"ckatvaqe20080g4vah68zgeep","tag_id":"ckatvaqej008zg4vax5ytiy3t","_id":"ckatvaqen0098g4vazz5j4shj"},{"post_id":"ckatvaqe40085g4vaibwqoyuf","tag_id":"ckatvaqem0096g4vaogsdlcn4","_id":"ckatvaqer009eg4vazlx0udmi"},{"post_id":"ckatvaqe60087g4vaev2l7as8","tag_id":"ckatvaqeq009dg4vavz44c55f","_id":"ckatvaqeu009lg4va58pqivdi"},{"post_id":"ckatvaqe8008bg4vawu8gx8xl","tag_id":"ckatvaqet009jg4vaelce0rv2","_id":"ckatvaqex009rg4vac0iec3kr"},{"post_id":"ckatvaqee008qg4va6el1zwqe","tag_id":"ckatvaqew009pg4val773g296","_id":"ckatvaqf0009xg4vaervvfxxn"},{"post_id":"ckatvaqeh008vg4var46wmpmz","tag_id":"ckatvaqez009vg4vaal4s6ynp","_id":"ckatvaqf300a4g4va6g77lmul"},{"post_id":"ckatvaqei008xg4vai0cl1rir","tag_id":"ckatvaqf300a3g4vappcn5klj","_id":"ckatvaqf600abg4va76nfo192"},{"post_id":"ckatvaqej0091g4vavg0s8adr","tag_id":"ckatvaqf500a9g4va599g814f","_id":"ckatvaqfa00ahg4vakj4u36ce"},{"post_id":"ckatvaqek0093g4vayydkmybd","tag_id":"ckatvaqf900afg4vaufcrotvt","_id":"ckatvaqfd00ang4va9yuyctrj"},{"post_id":"ckatvaqem0097g4vabentt5ll","tag_id":"ckatvaqfc00alg4varrcxf5h5","_id":"ckatvaqfg00avg4vale1w0bwy"},{"post_id":"ckatvaqen0099g4vau92x8j5w","tag_id":"ckatvaqff00asg4va4drnplta","_id":"ckatvaqfl00b2g4vas3z1s15n"},{"post_id":"ckatvaqep009cg4va8nt29kew","tag_id":"ckatvaqfj00ayg4vaccon0ihg","_id":"ckatvaqfo00b8g4va5psjfboq"},{"post_id":"ckatvaqer009fg4vak3u7yg6p","tag_id":"ckatvaqfm00b4g4vaqzkts0qk","_id":"ckatvaqfq00beg4va9t88dne6"},{"post_id":"ckatvaqes009ig4vairjkr83k","tag_id":"ckatvaqfp00bbg4vab7k56stz","_id":"ckatvaqfs00blg4vagc1t2eb7"},{"post_id":"ckatvaqew009qg4vawaed6p3r","tag_id":"ckatvaqfs00bjg4vavcts74z2","_id":"ckatvaqfv00bsg4va1qkxmhx8"},{"post_id":"ckatvaqex009tg4vaxnqynjf0","tag_id":"ckatvaqfu00bpg4valc4008tz","_id":"ckatvaqfy00byg4vatht7k9l5"},{"post_id":"ckatvaqez009wg4vaalptfvq1","tag_id":"ckatvaqfx00bwg4vaemplr1ei","_id":"ckatvaqg000c4g4vaap9egyca"},{"post_id":"ckatvaqf1009yg4vavb7kv3jh","tag_id":"ckatvaqfz00c2g4vas1dvkdg2","_id":"ckatvaqg200cag4vawwv289p8"},{"post_id":"ckatvaqf200a1g4vafxagr6oz","tag_id":"ckatvaqg200c9g4vasex5fx8b","_id":"ckatvaqg500chg4vayqdumx90"},{"post_id":"ckatvaqf300a5g4vas3usybfq","tag_id":"ckatvaqg400cfg4vakn96lsr1","_id":"ckatvaqg800cng4vaqwynlw1f"},{"post_id":"ckatvaqf400a8g4va532dq1sa","tag_id":"ckatvaqg700clg4va9gk3lowm","_id":"ckatvaqga00ctg4vasqqa3lkn"},{"post_id":"ckatvaqf500aag4va9og65zlz","tag_id":"ckatvaqg900crg4vadn574jx3","_id":"ckatvaqgd00czg4vadk93rhw5"},{"post_id":"ckatvaqf800aeg4vai16ayno8","tag_id":"ckatvaqgd00cyg4vaj1af9zg4","_id":"ckatvaqgf00d4g4vaytzkdubq"},{"post_id":"ckatvaqfb00akg4vahskgtv6a","tag_id":"ckatvaqgf00d3g4va7w69rxs5","_id":"ckatvaqgg00d8g4va7l5y5ggp"},{"post_id":"ckatvaqfc00amg4vaul9hhk4b","tag_id":"ckatvaqgg00d7g4va0tfwafut","_id":"ckatvaqgi00dcg4vat91nv6yd"},{"post_id":"ckatvaqfe00arg4vaw3585awf","tag_id":"ckatvaqgh00dbg4varuozla5y","_id":"ckatvaqgk00dgg4vazvtu7nfa"},{"post_id":"ckatvaqfj00axg4vaentm0358","tag_id":"ckatvaqgj00dfg4vadw4atvi4","_id":"ckatvaqgl00dkg4va5vy2tsac"},{"post_id":"ckatvaqfl00b3g4vamkps5k26","tag_id":"ckatvaqgl00djg4va0icwltux","_id":"ckatvaqgm00dqg4va2etfoygm"},{"post_id":"ckatvaqfn00b7g4va35p1pudn","tag_id":"ckatvaqgm00dng4va8jzttx97","_id":"ckatvaqgn00dug4va04do761g"},{"post_id":"ckatvaqfo00b9g4vawmu6cjxd","tag_id":"ckatvaqgn00drg4val1xmfy0a","_id":"ckatvaqgo00dyg4vausdw4fj2"},{"post_id":"ckatvaqfp00bdg4va4tqfp15r","tag_id":"ckatvaqgo00dvg4va96ygh499","_id":"ckatvaqgp00e2g4vakmnwpu2d"},{"post_id":"ckatvaqfq00bgg4va18ae7zhl","tag_id":"ckatvaqgo00dzg4vaa6c4vcg4","_id":"ckatvaqgq00e6g4vaoyvn488c"},{"post_id":"ckatvaqfv00brg4va51p27apg","tag_id":"ckatvaqgp00e3g4vabjbp3xpt","_id":"ckatvaqgr00eag4vagk6err15"},{"post_id":"ckatvaqfx00bxg4vadu7tgskw","tag_id":"ckatvaqgq00e7g4va5hvf5jgp","_id":"ckatvaqgt00eeg4vatbgpnq67"},{"post_id":"ckatvaqfy00bzg4vaxh2408tu","tag_id":"ckatvaqgs00ebg4vaeg700rw2","_id":"ckatvaqgu00eig4vab60226zw"},{"post_id":"ckatvaqg000c5g4vagjuzlbq6","tag_id":"ckatvaqgt00efg4va6tbvh31g","_id":"ckatvaqgv00emg4vatgjre4se"},{"post_id":"ckatvaqg100c8g4vasdisi81i","tag_id":"ckatvaqgv00elg4vafffo094r","_id":"ckatvaqgx00eqg4vaairu1kt3"},{"post_id":"ckatvaqg600cig4vaw386n5qt","tag_id":"ckatvaqgw00epg4vaey3e5ihl","_id":"ckatvaqgy00eug4vawtc2pwmr"},{"post_id":"ckatvaqg800cog4vamjrjaxl5","tag_id":"ckatvaqgy00etg4vads10yow6","_id":"ckatvaqgz00eyg4va760ljn0o"},{"post_id":"ckatvaqg900csg4va9hhw7y8y","tag_id":"ckatvaqgz00exg4vabv3a1e9j","_id":"ckatvaqh000f2g4vaw1ah7zck"},{"post_id":"ckatvaqga00cug4vaaquniemf","tag_id":"ckatvaqh000f1g4vauuyoxnj3","_id":"ckatvaqh200f6g4va7hapiege"},{"post_id":"ckatvaqgc00cxg4valx75jhi9","tag_id":"ckatvaqh100f5g4vaznhxt6xc","_id":"ckatvaqh300fbg4va8eo3lmb0"},{"post_id":"ckatvaqwu00hug4vana04fsnd","tag_id":"ckatvaqwv00hvg4vabz5xf1qx","_id":"ckatvaqwv00hxg4vakv8z7xtk"}],"Tag":[{"name":"nginx负载均衡","_id":"ckatvaq9r0004g4vaav4ejf3p"},{"name":"apidoc","_id":"ckatvaqaf000kg4va6sywwu03"},{"name":"api-version-manage,spring-boot中API版本迭代管理","_id":"ckatvaqai000rg4va1cm5qhga"},{"name":"aws云服务器","_id":"ckatvaqal000yg4vai2740dux"},{"name":"centos-jdk8-install","_id":"ckatvaqao0014g4va354gjmh2"},{"name":"centos登录","_id":"ckatvaqar001bg4va0tq0bsz7"},{"name":"concourse","_id":"ckatvaqau001ig4va3xnx5i25"},{"name":"mysql mysql8","_id":"ckatvaqax001pg4va1f0riikk"},{"name":"cron-grammar","_id":"ckatvaqb0001vg4vam6l6krlk"},{"name":"snowflake算法","_id":"ckatvaqb20021g4vag0sc7qmf"},{"name":"centos-docker-install","_id":"ckatvaqb7002cg4vahston3j0"},{"name":"docker ce安装","_id":"ckatvaqba002ig4vayailabau"},{"name":"docker镜像创建、docker容器启动、docker发布web应用","_id":"ckatvaqbd002og4va1dcuhfvd"},{"name":"基础概念","_id":"ckatvaqbg002ug4vao3xyz30b"},{"name":"docker镜像","_id":"ckatvaqbi0030g4vafl8ndemx"},{"name":"docker数据管理","_id":"ckatvaqbm0037g4vaen4zpeav"},{"name":"docker 容器","_id":"ckatvaqbp003dg4va6g2zkiax"},{"name":"docker网络","_id":"ckatvaqbs003kg4vasvsk6vcc"},{"name":"git分支、github分支","_id":"ckatvaqbv003qg4vayhq592im"},{"name":"git-server-build","_id":"ckatvaqc0003xg4vab4sdpxd5"},{"name":"git-install-in-centos","_id":"ckatvaqc30043g4vat4kn3lj7"},{"name":"git问题","_id":"ckatvaqc60049g4vam361ypzq"},{"name":"git-tag","_id":"ckatvaqc9004hg4vahezzicv7"},{"name":"github-fork-repo-update","_id":"ckatvaqcc004og4va616bbg34"},{"name":"hashicorp-vault","_id":"ckatvaqcf004ug4va40n9b5fm"},{"name":"http-overview","_id":"ckatvaqci0050g4vafuhvzf0g"},{"name":"hibernate-relation","_id":"ckatvaqcm0057g4vadhadkelv"},{"name":"jackson","_id":"ckatvaqcp005fg4vaw7o5kyoe"},{"name":"istio","_id":"ckatvaqcs005mg4vapi3kea7h"},{"name":"cglib","_id":"ckatvaqd30064g4vap25ja7u8"},{"name":"javapoet-apt-annotation","_id":"ckatvaqd7006bg4va4dg3j8la"},{"name":"jenkins-java-maven","_id":"ckatvaqdb006ig4vagpaiav1m"},{"name":"gc垃圾回收","_id":"ckatvaqde006pg4va60655had"},{"name":"jvm监控工具","_id":"ckatvaqdh006wg4va9146pag0"},{"name":"k8s","_id":"ckatvaqdk0073g4vaueuq4k66"},{"name":"ubuntu-navicat","_id":"ckatvaqdo007ag4vaxvbdxctn"},{"name":"linux-command","_id":"ckatvaqds007hg4vaudkhao8m"},{"name":"maven常用功能","_id":"ckatvaqdx007og4vav0fx4ga1"},{"name":"maven-error","_id":"ckatvaqe1007wg4vao4tnptcn"},{"name":"微服务实践总结","_id":"ckatvaqe40082g4vagm1s46bb"},{"name":"mysql一主多从配置","_id":"ckatvaqe70089g4va9v1cavi8"},{"name":"mysql建表规范","_id":"ckatvaqea008fg4vacyf3j9el"},{"name":"mysql-expain","_id":"ckatvaqed008ng4vax6znxz3m"},{"name":"mysql使用问题收藏","_id":"ckatvaqeg008tg4va8cuvx301"},{"name":"nginx能做什么","_id":"ckatvaqej008zg4vax5ytiy3t"},{"name":"npm使用问题","_id":"ckatvaqem0096g4vaogsdlcn4"},{"name":"ngrok使用","_id":"ckatvaqeq009dg4vavz44c55f"},{"name":"pws-push","_id":"ckatvaqet009jg4vaelce0rv2"},{"name":"rabbitmq-install","_id":"ckatvaqew009pg4val773g296"},{"name":"redis命令","_id":"ckatvaqez009vg4vaal4s6ynp"},{"name":"redis,主从,集群","_id":"ckatvaqf300a3g4vappcn5klj"},{"name":"redis分布式锁","_id":"ckatvaqf500a9g4va599g814f"},{"name":"redis,密码,安全","_id":"ckatvaqf900afg4vaufcrotvt"},{"name":"redis-install","_id":"ckatvaqfc00alg4varrcxf5h5"},{"name":"redis发布订阅","_id":"ckatvaqff00asg4va4drnplta"},{"name":"redis哨兵模式","_id":"ckatvaqfj00ayg4vaccon0ihg"},{"name":"redmine-mongrel-nginx","_id":"ckatvaqfm00b4g4vaqzkts0qk"},{"name":"redmine插件","_id":"ckatvaqfp00bbg4vab7k56stz"},{"name":"restful-api","_id":"ckatvaqfs00bjg4vavcts74z2"},{"name":"rocketmq入门","_id":"ckatvaqfu00bpg4valc4008tz"},{"name":"change-contextpath-way","_id":"ckatvaqfx00bwg4vaemplr1ei"},{"name":"spring-cloud(配置中心加解密)","_id":"ckatvaqfz00c2g4vas1dvkdg2"},{"name":"feign使用常见问题","_id":"ckatvaqg200c9g4vasex5fx8b"},{"name":"ELK","_id":"ckatvaqg400cfg4vakn96lsr1"},{"name":"feign","_id":"ckatvaqg700clg4va9gk3lowm"},{"name":"hystrix,dashboard","_id":"ckatvaqg900crg4vadn574jx3"},{"name":"hystrix","_id":"ckatvaqgd00cyg4vaj1af9zg4"},{"name":"zuul-exception","_id":"ckatvaqgf00d3g4va7w69rxs5"},{"name":"zuul-filters","_id":"ckatvaqgg00d7g4va0tfwafut"},{"name":"zuul-start","_id":"ckatvaqgh00dbg4varuozla5y"},{"name":"shadowsocks-go","_id":"ckatvaqgj00dfg4vadw4atvi4"},{"name":"spinnaker-start","_id":"ckatvaqgl00djg4va0icwltux"},{"name":"shiro入门","_id":"ckatvaqgm00dng4va8jzttx97"},{"name":"spring-boot-async","_id":"ckatvaqgn00drg4val1xmfy0a"},{"name":"spring-cors","_id":"ckatvaqgo00dvg4va96ygh499"},{"name":"spring cache","_id":"ckatvaqgo00dzg4vaa6c4vcg4"},{"name":"spring-boot-filter","_id":"ckatvaqgp00e3g4vabjbp3xpt"},{"name":"spring-boot-jar","_id":"ckatvaqgq00e7g4va5hvf5jgp"},{"name":"spring mvc国际化","_id":"ckatvaqgs00ebg4vaeg700rw2"},{"name":"jpa读写分离配置","_id":"ckatvaqgt00efg4va6tbvh31g"},{"name":"teamcity-start","_id":"ckatvaqgv00elg4vafffo094r"},{"name":"vagrant-start","_id":"ckatvaqgw00epg4vaey3e5ihl"},{"name":"vault","_id":"ckatvaqgy00etg4vads10yow6"},{"name":"website-high-performance","_id":"ckatvaqgz00exg4vabv3a1e9j"},{"name":"wkhtmltopdf","_id":"ckatvaqh000f1g4vauuyoxnj3"},{"name":"apache curator","_id":"ckatvaqh100f5g4vaznhxt6xc"},{"name":"后端架构师技术图谱","_id":"ckatvaqwv00hvg4vabz5xf1qx"}]}}